use reqwest::Body;
use serde::{de::DeserializeOwned, Serialize};

use crate::types::bulk::BulkResponse;
use super::types;
#[allow(unused_imports)]
use super::{
  encode_path, encode_path_option_vec_string, ByteStream, Error, HeaderMap, HeaderValue, RequestBuilderExt,
  ResponseValue,
};
///Builder for [`Client::info`]
///
///[`Client::info`]: super::Client::info
#[derive(Debug, Clone)]
pub struct Info<'a> {
  client: &'a super::Client,
}

impl<'a> Info<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self { client }
  }

  ///Sends a `GET` request to `/`
  pub async fn send(self) -> Result<ResponseValue<types::InfoResponseContent>, Error<()>> {
    let Self { client } = self;
    let url = format!("{}/", client.baseurl,);
    let request = client
      .client
      .get(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::ping`]
///
///[`Client::ping`]: super::Client::ping
#[derive(Debug, Clone)]
pub struct Ping<'a> {
  client: &'a super::Client,
}

impl<'a> Ping<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self { client }
  }

  ///Sends a `HEAD` request to `/`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self { client } = self;
    let url = format!("{}/", client.baseurl,);
    let request = client.client.head(url).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_get_alias`]
///
///[`Client::indices_get_alias`]: super::Client::indices_get_alias
#[derive(Debug, Clone)]
pub struct IndicesGetAlias<'a> {
  client: &'a super::Client,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
}

impl<'a> IndicesGetAlias<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      ignore_unavailable: Ok(None),
      local: Ok(None),
    }
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_alias`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      allow_no_indices,
      expand_wildcards,
      ignore_unavailable,
      local,
    } = self;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_alias", client.baseurl,);
    let mut query = Vec::with_capacity(4usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_get_alias_with_name`]
///
///[`Client::indices_get_alias_with_name`]: super::Client::indices_get_alias_with_name
#[derive(Debug, Clone)]
pub struct IndicesGetAliasWithName<'a> {
  client: &'a super::Client,
  name: Result<types::IndicesGetAliasWithNameName, String>,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
}

impl<'a> IndicesGetAliasWithName<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      name: Err("name was not initialized".to_string()),
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      ignore_unavailable: Ok(None),
      local: Ok(None),
    }
  }

  pub fn name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesGetAliasWithNameName>, {
    self.name = value
      .try_into()
      .map_err(|_| "conversion to `IndicesGetAliasWithNameName` for name failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_alias/{name}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      name,
      allow_no_indices,
      expand_wildcards,
      ignore_unavailable,
      local,
    } = self;
    let name = name.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_alias/{}", client.baseurl, encode_path(&name.to_string()),);
    let mut query = Vec::with_capacity(4usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_exists_alias`]
///
///[`Client::indices_exists_alias`]: super::Client::indices_exists_alias
#[derive(Debug, Clone)]
pub struct IndicesExistsAlias<'a> {
  client: &'a super::Client,
  name: Result<types::IndicesExistsAliasName, String>,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
}

impl<'a> IndicesExistsAlias<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      name: Err("name was not initialized".to_string()),
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      ignore_unavailable: Ok(None),
      local: Ok(None),
    }
  }

  pub fn name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesExistsAliasName>, {
    self.name = value
      .try_into()
      .map_err(|_| "conversion to `IndicesExistsAliasName` for name failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  ///Sends a `HEAD` request to `/_alias/{name}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      name,
      allow_no_indices,
      expand_wildcards,
      ignore_unavailable,
      local,
    } = self;
    let name = name.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_alias/{}", client.baseurl, encode_path(&name.to_string()),);
    let mut query = Vec::with_capacity(4usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    let request = client.client.head(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_update_aliases`]
///
///[`Client::indices_update_aliases`]: super::Client::indices_update_aliases
#[derive(Debug, Clone)]
pub struct IndicesUpdateAliases<'a> {
  client: &'a super::Client,
  cluster_manager_timeout: Result<Option<types::IndicesUpdateAliasesClusterManagerTimeout>, String>,
  master_timeout: Result<Option<types::IndicesUpdateAliasesMasterTimeout>, String>,
  timeout: Result<Option<types::IndicesUpdateAliasesTimeout>, String>,
  body: Result<types::builder::IndicesUpdateAliasesBodyParams, String>,
}

impl<'a> IndicesUpdateAliases<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      cluster_manager_timeout: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
      body: Ok(types::builder::IndicesUpdateAliasesBodyParams::default()),
    }
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesUpdateAliasesClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesUpdateAliasesClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesUpdateAliasesMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesUpdateAliasesMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesUpdateAliasesTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesUpdateAliasesTimeout` for timeout failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesUpdateAliasesBodyParams>, {
    self.body = value
      .try_into()
      .map(From::from)
      .map_err(|_| "conversion to `IndicesUpdateAliasesBodyParams` for body failed".to_string());
    self
  }

  pub fn body_map<F>(mut self, f: F) -> Self
  where
    F: std::ops::FnOnce(
      types::builder::IndicesUpdateAliasesBodyParams,
    ) -> types::builder::IndicesUpdateAliasesBodyParams, {
    self.body = self.body.map(f);
    self
  }

  ///Sends a `POST` request to `/_aliases`
  pub async fn send(self) -> Result<ResponseValue<types::IndicesUpdateAliasesResponseContent>, Error<()>> {
    let Self {
      client,
      cluster_manager_timeout,
      master_timeout,
      timeout,
      body,
    } = self;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let body = body
      .and_then(std::convert::TryInto::<types::IndicesUpdateAliasesBodyParams>::try_into)
      .map_err(Error::InvalidRequest)?;
    let url = format!("{}/_aliases", client.baseurl,);
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client
      .client
      .post(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .json(&body)
      .query(&query)
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_analyze_get`]
///
///[`Client::indices_analyze_get`]: super::Client::indices_analyze_get
#[derive(Debug, Clone)]
pub struct IndicesAnalyzeGet<'a> {
  client: &'a super::Client,
  index: Result<Option<String>, String>,
}

impl<'a> IndicesAnalyzeGet<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.index = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for index failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_analyze`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self { client, index } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_analyze", client.baseurl,);
    let mut query = Vec::with_capacity(1usize);
    if let Some(v) = &index {
      query.push(("index", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_analyze_post`]
///
///[`Client::indices_analyze_post`]: super::Client::indices_analyze_post
#[derive(Debug, Clone)]
pub struct IndicesAnalyzePost<'a> {
  client: &'a super::Client,
  index: Result<Option<String>, String>,
  body: Result<types::IndicesAnalyzeBodyParams, String>,
}

impl<'a> IndicesAnalyzePost<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.index = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for index failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesAnalyzeBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `IndicesAnalyzeBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_analyze`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self { client, index, body } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_analyze", client.baseurl,);
    let mut query = Vec::with_capacity(1usize);
    if let Some(v) = &index {
      query.push(("index", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::bulk_post`]
///
///[`Client::bulk_post`]: super::Client::bulk_post
#[derive(Debug, Clone)]
pub struct BulkPost<'a> {
  client: &'a super::Client,
  source: Result<Option<String>, String>,
  source_excludes: Result<Option<Vec<String>>, String>,
  source_includes: Result<Option<Vec<String>>, String>,
  pipeline: Result<Option<String>, String>,
  refresh: Result<Option<types::RefreshEnum>, String>,
  require_alias: Result<Option<bool>, String>,
  routing: Result<Option<String>, String>,
  timeout: Result<Option<types::BulkPostTimeout>, String>,
  type_: Result<Option<String>, String>,
  wait_for_active_shards: Result<Option<String>, String>,
  body: Result<String, String>,
}

impl<'a> BulkPost<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      source: Ok(None),
      source_excludes: Ok(None),
      source_includes: Ok(None),
      pipeline: Ok(None),
      refresh: Ok(None),
      require_alias: Ok(None),
      routing: Ok(None),
      timeout: Ok(None),
      type_: Ok(None),
      wait_for_active_shards: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn source<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.source = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source failed".to_string());
    self
  }

  pub fn source_excludes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source_excludes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source_excludes failed".to_string());
    self
  }

  pub fn source_includes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source_includes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source_includes failed".to_string());
    self
  }

  pub fn pipeline<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.pipeline = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for pipeline failed".to_string());
    self
  }

  pub fn refresh<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::RefreshEnum>, {
    self.refresh = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `RefreshEnum` for refresh failed".to_string());
    self
  }

  pub fn require_alias<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.require_alias = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for require_alias failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for routing failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::BulkPostTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `BulkPostTimeout` for timeout failed".to_string());
    self
  }

  pub fn type_<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.type_ = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for type_ failed".to_string());
    self
  }

  pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.wait_for_active_shards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for wait_for_active_shards failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `BulkBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_bulk`
  pub async fn send(self) -> Result<ResponseValue<BulkResponse>, Error<()>> {
    let Self {
      client,
      source,
      source_excludes,
      source_includes,
      pipeline,
      refresh,
      require_alias,
      routing,
      timeout,
      type_,
      wait_for_active_shards,
      body,
    } = self;
    let source = source.map_err(Error::InvalidRequest)?;
    let source_excludes = source_excludes.map_err(Error::InvalidRequest)?;
    let source_includes = source_includes.map_err(Error::InvalidRequest)?;
    let pipeline = pipeline.map_err(Error::InvalidRequest)?;
    let refresh = refresh.map_err(Error::InvalidRequest)?;
    let require_alias = require_alias.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let type_ = type_.map_err(Error::InvalidRequest)?;
    let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_bulk", client.baseurl,);
    let mut query = Vec::with_capacity(10usize);
    if let Some(v) = &source_excludes {
      query.push(("_source_excludes", v.join(",")));
    }
    if let Some(v) = &source_includes {
      query.push(("_source_includes", v.join(",")));
    }
    if let Some(v) = &pipeline {
      query.push(("pipeline", v.to_string()));
    }
    if let Some(v) = &refresh {
      query.push(("refresh", v.to_string()));
    }
    if let Some(v) = &require_alias {
      query.push(("require_alias", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &type_ {
      query.push(("type", v.to_string()));
    }
    if let Some(v) = &wait_for_active_shards {
      query.push(("wait_for_active_shards", v.to_string()));
    }
    let request = client
      .client
      .post(url)
      .body(Body::from(body))
      .header("Content-Type", "application/x-ndjson")
      .query(&query)
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_clear_cache`]
///
///[`Client::indices_clear_cache`]: super::Client::indices_clear_cache
#[derive(Debug, Clone)]
pub struct IndicesClearCache<'a> {
  client: &'a super::Client,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  fielddata: Result<Option<bool>, String>,
  fields: Result<Option<Vec<String>>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  index: Result<Option<Vec<String>>, String>,
  query: Result<Option<bool>, String>,
  request: Result<Option<bool>, String>,
}

impl<'a> IndicesClearCache<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      fielddata: Ok(None),
      fields: Ok(None),
      ignore_unavailable: Ok(None),
      index: Ok(None),
      query: Ok(None),
      request: Ok(None),
    }
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn fielddata<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.fielddata = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for fielddata failed".to_string());
    self
  }

  pub fn fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.index = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for index failed".to_string());
    self
  }

  pub fn query<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.query = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for query failed".to_string());
    self
  }

  pub fn request<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.request = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for request failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_cache/clear`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      allow_no_indices,
      expand_wildcards,
      fielddata,
      fields,
      ignore_unavailable,
      index,
      query,
      request,
    } = self;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let fielddata = fielddata.map_err(Error::InvalidRequest)?;
    let fields = fields.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let index = index.map_err(Error::InvalidRequest)?;
    let query_opt = query.map_err(Error::InvalidRequest)?;
    let request = request.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cache/clear", client.baseurl,);
    let mut query = Vec::with_capacity(8usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &fielddata {
      query.push(("fielddata", v.to_string()));
    }
    if let Some(v) = &fields {
      query.push(("fields", v.join(",")));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &index {
      query.push(("index", v.join(",")));
    }
    if let Some(v) = &query_opt {
      query.push(("query", v.to_string()));
    }
    if let Some(v) = &request {
      query.push(("request", v.to_string()));
    }
    let request = client.client.post(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cat_help`]
///
///[`Client::cat_help`]: super::Client::cat_help
#[derive(Debug, Clone)]
pub struct CatHelp<'a> {
  client: &'a super::Client,
  help: Result<Option<bool>, String>,
  s: Result<Option<Vec<String>>, String>,
}

impl<'a> CatHelp<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      help: Ok(None),
      s: Ok(None),
    }
  }

  pub fn help<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.help = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for help failed".to_string());
    self
  }

  pub fn s<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.s = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cat`
  pub async fn send(self) -> Result<ResponseValue<String>, Error<()>> {
    let Self { client, help, s } = self;
    let help = help.map_err(Error::InvalidRequest)?;
    let s = s.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cat", client.baseurl,);
    let mut query = Vec::with_capacity(2usize);
    if let Some(v) = &help {
      query.push(("help", v.to_string()));
    }
    if let Some(v) = &s {
      query.push(("s", v.join(",")));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::text(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cat_aliases`]
///
///[`Client::cat_aliases`]: super::Client::cat_aliases
#[derive(Debug, Clone)]
pub struct CatAliases<'a> {
  client: &'a super::Client,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  format: Result<Option<String>, String>,
  h: Result<Option<Vec<String>>, String>,
  help: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
  s: Result<Option<Vec<String>>, String>,
  v: Result<Option<bool>, String>,
}

impl<'a> CatAliases<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      expand_wildcards: Ok(None),
      format: Ok(None),
      h: Ok(None),
      help: Ok(None),
      local: Ok(None),
      s: Ok(None),
      v: Ok(None),
    }
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn format<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.format = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for format failed".to_string());
    self
  }

  pub fn h<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.h = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
    self
  }

  pub fn help<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.help = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for help failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn s<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.s = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
    self
  }

  pub fn v<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.v = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for v failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cat/aliases`
  pub async fn send(self) -> Result<ResponseValue<String>, Error<()>> {
    let Self {
      client,
      expand_wildcards,
      format,
      h,
      help,
      local,
      s,
      v,
    } = self;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let format = format.map_err(Error::InvalidRequest)?;
    let h = h.map_err(Error::InvalidRequest)?;
    let help = help.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let s = s.map_err(Error::InvalidRequest)?;
    let v = v.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cat/aliases", client.baseurl,);
    let mut query = Vec::with_capacity(7usize);
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &format {
      query.push(("format", v.to_string()));
    }
    if let Some(v) = &h {
      query.push(("h", v.join(",")));
    }
    if let Some(v) = &help {
      query.push(("help", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &s {
      query.push(("s", v.join(",")));
    }
    if let Some(v) = &v {
      query.push(("v", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::text(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cat_aliases_with_name`]
///
///[`Client::cat_aliases_with_name`]: super::Client::cat_aliases_with_name
#[derive(Debug, Clone)]
pub struct CatAliasesWithName<'a> {
  client: &'a super::Client,
  name: Result<types::CatAliasesWithNameName, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  format: Result<Option<String>, String>,
  h: Result<Option<Vec<String>>, String>,
  help: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
  s: Result<Option<Vec<String>>, String>,
  v: Result<Option<bool>, String>,
}

impl<'a> CatAliasesWithName<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      name: Err("name was not initialized".to_string()),
      expand_wildcards: Ok(None),
      format: Ok(None),
      h: Ok(None),
      help: Ok(None),
      local: Ok(None),
      s: Ok(None),
      v: Ok(None),
    }
  }

  pub fn name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatAliasesWithNameName>, {
    self.name = value
      .try_into()
      .map_err(|_| "conversion to `CatAliasesWithNameName` for name failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn format<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.format = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for format failed".to_string());
    self
  }

  pub fn h<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.h = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
    self
  }

  pub fn help<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.help = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for help failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn s<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.s = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
    self
  }

  pub fn v<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.v = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for v failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cat/aliases/{name}`
  pub async fn send(self) -> Result<ResponseValue<String>, Error<()>> {
    let Self {
      client,
      name,
      expand_wildcards,
      format,
      h,
      help,
      local,
      s,
      v,
    } = self;
    let name = name.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let format = format.map_err(Error::InvalidRequest)?;
    let h = h.map_err(Error::InvalidRequest)?;
    let help = help.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let s = s.map_err(Error::InvalidRequest)?;
    let v = v.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cat/aliases/{}", client.baseurl, encode_path(&name.to_string()),);
    let mut query = Vec::with_capacity(7usize);
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &format {
      query.push(("format", v.to_string()));
    }
    if let Some(v) = &h {
      query.push(("h", v.join(",")));
    }
    if let Some(v) = &help {
      query.push(("help", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &s {
      query.push(("s", v.join(",")));
    }
    if let Some(v) = &v {
      query.push(("v", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::text(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cat_allocation`]
///
///[`Client::cat_allocation`]: super::Client::cat_allocation
#[derive(Debug, Clone)]
pub struct CatAllocation<'a> {
  client: &'a super::Client,
  bytes: Result<Option<types::Bytes>, String>,
  cluster_manager_timeout: Result<Option<types::CatAllocationClusterManagerTimeout>, String>,
  format: Result<Option<String>, String>,
  h: Result<Option<Vec<String>>, String>,
  help: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::CatAllocationMasterTimeout>, String>,
  s: Result<Option<Vec<String>>, String>,
  v: Result<Option<bool>, String>,
}

impl<'a> CatAllocation<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      bytes: Ok(None),
      cluster_manager_timeout: Ok(None),
      format: Ok(None),
      h: Ok(None),
      help: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
      s: Ok(None),
      v: Ok(None),
    }
  }

  pub fn bytes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::Bytes>, {
    self.bytes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Bytes` for bytes failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatAllocationClusterManagerTimeout>, {
    self.cluster_manager_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `CatAllocationClusterManagerTimeout` for cluster_manager_timeout failed".to_string());
    self
  }

  pub fn format<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.format = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for format failed".to_string());
    self
  }

  pub fn h<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.h = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
    self
  }

  pub fn help<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.help = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for help failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatAllocationMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `CatAllocationMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn s<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.s = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
    self
  }

  pub fn v<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.v = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for v failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cat/allocation`
  pub async fn send(self) -> Result<ResponseValue<String>, Error<()>> {
    let Self {
      client,
      bytes,
      cluster_manager_timeout,
      format,
      h,
      help,
      local,
      master_timeout,
      s,
      v,
    } = self;
    let bytes = bytes.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let format = format.map_err(Error::InvalidRequest)?;
    let h = h.map_err(Error::InvalidRequest)?;
    let help = help.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let s = s.map_err(Error::InvalidRequest)?;
    let v = v.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cat/allocation", client.baseurl,);
    let mut query = Vec::with_capacity(9usize);
    if let Some(v) = &bytes {
      query.push(("bytes", v.to_string()));
    }
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &format {
      query.push(("format", v.to_string()));
    }
    if let Some(v) = &h {
      query.push(("h", v.join(",")));
    }
    if let Some(v) = &help {
      query.push(("help", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &s {
      query.push(("s", v.join(",")));
    }
    if let Some(v) = &v {
      query.push(("v", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::text(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cat_allocation_with_node_id`]
///
///[`Client::cat_allocation_with_node_id`]: super::Client::cat_allocation_with_node_id
#[derive(Debug, Clone)]
pub struct CatAllocationWithNodeId<'a> {
  client: &'a super::Client,
  node_id: Result<types::CatAllocationWithNodeIdNodeId, String>,
  bytes: Result<Option<types::Bytes>, String>,
  cluster_manager_timeout: Result<Option<types::CatAllocationWithNodeIdClusterManagerTimeout>, String>,
  format: Result<Option<String>, String>,
  h: Result<Option<Vec<String>>, String>,
  help: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::CatAllocationWithNodeIdMasterTimeout>, String>,
  s: Result<Option<Vec<String>>, String>,
  v: Result<Option<bool>, String>,
}

impl<'a> CatAllocationWithNodeId<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      node_id: Err("node_id was not initialized".to_string()),
      bytes: Ok(None),
      cluster_manager_timeout: Ok(None),
      format: Ok(None),
      h: Ok(None),
      help: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
      s: Ok(None),
      v: Ok(None),
    }
  }

  pub fn node_id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatAllocationWithNodeIdNodeId>, {
    self.node_id = value
      .try_into()
      .map_err(|_| "conversion to `CatAllocationWithNodeIdNodeId` for node_id failed".to_string());
    self
  }

  pub fn bytes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::Bytes>, {
    self.bytes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Bytes` for bytes failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatAllocationWithNodeIdClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `CatAllocationWithNodeIdClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn format<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.format = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for format failed".to_string());
    self
  }

  pub fn h<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.h = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
    self
  }

  pub fn help<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.help = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for help failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatAllocationWithNodeIdMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `CatAllocationWithNodeIdMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn s<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.s = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
    self
  }

  pub fn v<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.v = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for v failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cat/allocation/{node_id}`
  pub async fn send(self) -> Result<ResponseValue<String>, Error<()>> {
    let Self {
      client,
      node_id,
      bytes,
      cluster_manager_timeout,
      format,
      h,
      help,
      local,
      master_timeout,
      s,
      v,
    } = self;
    let node_id = node_id.map_err(Error::InvalidRequest)?;
    let bytes = bytes.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let format = format.map_err(Error::InvalidRequest)?;
    let h = h.map_err(Error::InvalidRequest)?;
    let help = help.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let s = s.map_err(Error::InvalidRequest)?;
    let v = v.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_cat/allocation/{}",
      client.baseurl,
      encode_path(&node_id.to_string()),
    );
    let mut query = Vec::with_capacity(9usize);
    if let Some(v) = &bytes {
      query.push(("bytes", v.to_string()));
    }
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &format {
      query.push(("format", v.to_string()));
    }
    if let Some(v) = &h {
      query.push(("h", v.join(",")));
    }
    if let Some(v) = &help {
      query.push(("help", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &s {
      query.push(("s", v.join(",")));
    }
    if let Some(v) = &v {
      query.push(("v", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::text(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cat_cluster_manager`]
///
///[`Client::cat_cluster_manager`]: super::Client::cat_cluster_manager
#[derive(Debug, Clone)]
pub struct CatClusterManager<'a> {
  client: &'a super::Client,
  cluster_manager_timeout: Result<Option<types::CatClusterManagerClusterManagerTimeout>, String>,
  format: Result<Option<String>, String>,
  h: Result<Option<Vec<String>>, String>,
  help: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::CatClusterManagerMasterTimeout>, String>,
  s: Result<Option<Vec<String>>, String>,
  v: Result<Option<bool>, String>,
}

impl<'a> CatClusterManager<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      cluster_manager_timeout: Ok(None),
      format: Ok(None),
      h: Ok(None),
      help: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
      s: Ok(None),
      v: Ok(None),
    }
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatClusterManagerClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `CatClusterManagerClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn format<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.format = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for format failed".to_string());
    self
  }

  pub fn h<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.h = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
    self
  }

  pub fn help<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.help = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for help failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatClusterManagerMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `CatClusterManagerMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn s<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.s = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
    self
  }

  pub fn v<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.v = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for v failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cat/cluster_manager`
  pub async fn send(self) -> Result<ResponseValue<String>, Error<()>> {
    let Self {
      client,
      cluster_manager_timeout,
      format,
      h,
      help,
      local,
      master_timeout,
      s,
      v,
    } = self;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let format = format.map_err(Error::InvalidRequest)?;
    let h = h.map_err(Error::InvalidRequest)?;
    let help = help.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let s = s.map_err(Error::InvalidRequest)?;
    let v = v.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cat/cluster_manager", client.baseurl,);
    let mut query = Vec::with_capacity(8usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &format {
      query.push(("format", v.to_string()));
    }
    if let Some(v) = &h {
      query.push(("h", v.join(",")));
    }
    if let Some(v) = &help {
      query.push(("help", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &s {
      query.push(("s", v.join(",")));
    }
    if let Some(v) = &v {
      query.push(("v", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::text(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cat_count`]
///
///[`Client::cat_count`]: super::Client::cat_count
#[derive(Debug, Clone)]
pub struct CatCount<'a> {
  client: &'a super::Client,
  format: Result<Option<String>, String>,
  h: Result<Option<Vec<String>>, String>,
  help: Result<Option<bool>, String>,
  s: Result<Option<Vec<String>>, String>,
  v: Result<Option<bool>, String>,
}

impl<'a> CatCount<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      format: Ok(None),
      h: Ok(None),
      help: Ok(None),
      s: Ok(None),
      v: Ok(None),
    }
  }

  pub fn format<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.format = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for format failed".to_string());
    self
  }

  pub fn h<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.h = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
    self
  }

  pub fn help<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.help = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for help failed".to_string());
    self
  }

  pub fn s<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.s = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
    self
  }

  pub fn v<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.v = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for v failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cat/count`
  pub async fn send(self) -> Result<ResponseValue<String>, Error<()>> {
    let Self {
      client,
      format,
      h,
      help,
      s,
      v,
    } = self;
    let format = format.map_err(Error::InvalidRequest)?;
    let h = h.map_err(Error::InvalidRequest)?;
    let help = help.map_err(Error::InvalidRequest)?;
    let s = s.map_err(Error::InvalidRequest)?;
    let v = v.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cat/count", client.baseurl,);
    let mut query = Vec::with_capacity(5usize);
    if let Some(v) = &format {
      query.push(("format", v.to_string()));
    }
    if let Some(v) = &h {
      query.push(("h", v.join(",")));
    }
    if let Some(v) = &help {
      query.push(("help", v.to_string()));
    }
    if let Some(v) = &s {
      query.push(("s", v.join(",")));
    }
    if let Some(v) = &v {
      query.push(("v", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::text(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cat_count_with_index`]
///
///[`Client::cat_count_with_index`]: super::Client::cat_count_with_index
#[derive(Debug, Clone)]
pub struct CatCountWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::CatCountWithIndexIndex, String>,
  format: Result<Option<String>, String>,
  h: Result<Option<Vec<String>>, String>,
  help: Result<Option<bool>, String>,
  s: Result<Option<Vec<String>>, String>,
  v: Result<Option<bool>, String>,
}

impl<'a> CatCountWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      format: Ok(None),
      h: Ok(None),
      help: Ok(None),
      s: Ok(None),
      v: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatCountWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `CatCountWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn format<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.format = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for format failed".to_string());
    self
  }

  pub fn h<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.h = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
    self
  }

  pub fn help<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.help = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for help failed".to_string());
    self
  }

  pub fn s<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.s = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
    self
  }

  pub fn v<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.v = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for v failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cat/count/{index}`
  pub async fn send(self) -> Result<ResponseValue<String>, Error<()>> {
    let Self {
      client,
      index,
      format,
      h,
      help,
      s,
      v,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let format = format.map_err(Error::InvalidRequest)?;
    let h = h.map_err(Error::InvalidRequest)?;
    let help = help.map_err(Error::InvalidRequest)?;
    let s = s.map_err(Error::InvalidRequest)?;
    let v = v.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cat/count/{}", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(5usize);
    if let Some(v) = &format {
      query.push(("format", v.to_string()));
    }
    if let Some(v) = &h {
      query.push(("h", v.join(",")));
    }
    if let Some(v) = &help {
      query.push(("help", v.to_string()));
    }
    if let Some(v) = &s {
      query.push(("s", v.join(",")));
    }
    if let Some(v) = &v {
      query.push(("v", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::text(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cat_fielddata`]
///
///[`Client::cat_fielddata`]: super::Client::cat_fielddata
#[derive(Debug, Clone)]
pub struct CatFielddata<'a> {
  client: &'a super::Client,
  bytes: Result<Option<types::Bytes>, String>,
  fields: Result<Option<Vec<String>>, String>,
  format: Result<Option<String>, String>,
  h: Result<Option<Vec<String>>, String>,
  help: Result<Option<bool>, String>,
  s: Result<Option<Vec<String>>, String>,
  v: Result<Option<bool>, String>,
}

impl<'a> CatFielddata<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      bytes: Ok(None),
      fields: Ok(None),
      format: Ok(None),
      h: Ok(None),
      help: Ok(None),
      s: Ok(None),
      v: Ok(None),
    }
  }

  pub fn bytes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::Bytes>, {
    self.bytes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Bytes` for bytes failed".to_string());
    self
  }

  pub fn fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
    self
  }

  pub fn format<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.format = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for format failed".to_string());
    self
  }

  pub fn h<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.h = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
    self
  }

  pub fn help<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.help = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for help failed".to_string());
    self
  }

  pub fn s<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.s = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
    self
  }

  pub fn v<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.v = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for v failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cat/fielddata`
  pub async fn send(self) -> Result<ResponseValue<String>, Error<()>> {
    let Self {
      client,
      bytes,
      fields,
      format,
      h,
      help,
      s,
      v,
    } = self;
    let bytes = bytes.map_err(Error::InvalidRequest)?;
    let fields = fields.map_err(Error::InvalidRequest)?;
    let format = format.map_err(Error::InvalidRequest)?;
    let h = h.map_err(Error::InvalidRequest)?;
    let help = help.map_err(Error::InvalidRequest)?;
    let s = s.map_err(Error::InvalidRequest)?;
    let v = v.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cat/fielddata", client.baseurl,);
    let mut query = Vec::with_capacity(7usize);
    if let Some(v) = &bytes {
      query.push(("bytes", v.to_string()));
    }
    if let Some(v) = &fields {
      query.push(("fields", v.join(",")));
    }
    if let Some(v) = &format {
      query.push(("format", v.to_string()));
    }
    if let Some(v) = &h {
      query.push(("h", v.join(",")));
    }
    if let Some(v) = &help {
      query.push(("help", v.to_string()));
    }
    if let Some(v) = &s {
      query.push(("s", v.join(",")));
    }
    if let Some(v) = &v {
      query.push(("v", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::text(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cat_fielddata_with_fields`]
///
///[`Client::cat_fielddata_with_fields`]: super::Client::cat_fielddata_with_fields
#[derive(Debug, Clone)]
pub struct CatFielddataWithFields<'a> {
  client: &'a super::Client,
  bytes: Result<Option<types::Bytes>, String>,
  fields: Result<Option<Vec<String>>, String>,
  format: Result<Option<String>, String>,
  h: Result<Option<Vec<String>>, String>,
  help: Result<Option<bool>, String>,
  s: Result<Option<Vec<String>>, String>,
  v: Result<Option<bool>, String>,
}

impl<'a> CatFielddataWithFields<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      bytes: Ok(None),
      fields: Ok(None),
      format: Ok(None),
      h: Ok(None),
      help: Ok(None),
      s: Ok(None),
      v: Ok(None),
    }
  }

  pub fn bytes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::Bytes>, {
    self.bytes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Bytes` for bytes failed".to_string());
    self
  }

  pub fn fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
    self
  }

  pub fn format<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.format = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for format failed".to_string());
    self
  }

  pub fn h<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.h = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
    self
  }

  pub fn help<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.help = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for help failed".to_string());
    self
  }

  pub fn s<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.s = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
    self
  }

  pub fn v<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.v = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for v failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cat/fielddata/{fields}`
  pub async fn send(self) -> Result<ResponseValue<String>, Error<()>> {
    let Self {
      client,
      bytes,
      fields,
      format,
      h,
      help,
      s,
      v,
    } = self;
    let bytes = bytes.map_err(Error::InvalidRequest)?;
    let fields = fields.map_err(Error::InvalidRequest)?;
    let format = format.map_err(Error::InvalidRequest)?;
    let h = h.map_err(Error::InvalidRequest)?;
    let help = help.map_err(Error::InvalidRequest)?;
    let s = s.map_err(Error::InvalidRequest)?;
    let v = v.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_cat/fielddata/{}",
      client.baseurl,
      encode_path_option_vec_string(&fields),
    );
    let mut query = Vec::with_capacity(7usize);
    if let Some(v) = &bytes {
      query.push(("bytes", v.to_string()));
    }
    if let Some(v) = &fields {
      query.push(("fields", v.join(",")));
    }
    if let Some(v) = &format {
      query.push(("format", v.to_string()));
    }
    if let Some(v) = &h {
      query.push(("h", v.join(",")));
    }
    if let Some(v) = &help {
      query.push(("help", v.to_string()));
    }
    if let Some(v) = &s {
      query.push(("s", v.join(",")));
    }
    if let Some(v) = &v {
      query.push(("v", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::text(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cat_health`]
///
///[`Client::cat_health`]: super::Client::cat_health
#[derive(Debug, Clone)]
pub struct CatHealth<'a> {
  client: &'a super::Client,
  format: Result<Option<String>, String>,
  h: Result<Option<Vec<String>>, String>,
  help: Result<Option<bool>, String>,
  s: Result<Option<Vec<String>>, String>,
  time: Result<Option<types::Time>, String>,
  ts: Result<Option<bool>, String>,
  v: Result<Option<bool>, String>,
}

impl<'a> CatHealth<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      format: Ok(None),
      h: Ok(None),
      help: Ok(None),
      s: Ok(None),
      time: Ok(None),
      ts: Ok(None),
      v: Ok(None),
    }
  }

  pub fn format<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.format = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for format failed".to_string());
    self
  }

  pub fn h<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.h = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
    self
  }

  pub fn help<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.help = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for help failed".to_string());
    self
  }

  pub fn s<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.s = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
    self
  }

  pub fn time<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::Time>, {
    self.time = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Time` for time failed".to_string());
    self
  }

  pub fn ts<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ts = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ts failed".to_string());
    self
  }

  pub fn v<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.v = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for v failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cat/health`
  pub async fn send(self) -> Result<ResponseValue<String>, Error<()>> {
    let Self {
      client,
      format,
      h,
      help,
      s,
      time,
      ts,
      v,
    } = self;
    let format = format.map_err(Error::InvalidRequest)?;
    let h = h.map_err(Error::InvalidRequest)?;
    let help = help.map_err(Error::InvalidRequest)?;
    let s = s.map_err(Error::InvalidRequest)?;
    let time = time.map_err(Error::InvalidRequest)?;
    let ts = ts.map_err(Error::InvalidRequest)?;
    let v = v.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cat/health", client.baseurl,);
    let mut query = Vec::with_capacity(7usize);
    if let Some(v) = &format {
      query.push(("format", v.to_string()));
    }
    if let Some(v) = &h {
      query.push(("h", v.join(",")));
    }
    if let Some(v) = &help {
      query.push(("help", v.to_string()));
    }
    if let Some(v) = &s {
      query.push(("s", v.join(",")));
    }
    if let Some(v) = &time {
      query.push(("time", v.to_string()));
    }
    if let Some(v) = &ts {
      query.push(("ts", v.to_string()));
    }
    if let Some(v) = &v {
      query.push(("v", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::text(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cat_indices`]
///
///[`Client::cat_indices`]: super::Client::cat_indices
#[derive(Debug, Clone)]
pub struct CatIndices<'a> {
  client: &'a super::Client,
  bytes: Result<Option<types::Bytes>, String>,
  cluster_manager_timeout: Result<Option<types::CatIndicesClusterManagerTimeout>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  format: Result<Option<String>, String>,
  h: Result<Option<Vec<String>>, String>,
  health: Result<Option<types::Health>, String>,
  help: Result<Option<bool>, String>,
  include_unloaded_segments: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::CatIndicesMasterTimeout>, String>,
  pri: Result<Option<bool>, String>,
  s: Result<Option<Vec<String>>, String>,
  time: Result<Option<types::Time>, String>,
  v: Result<Option<bool>, String>,
}

impl<'a> CatIndices<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      bytes: Ok(None),
      cluster_manager_timeout: Ok(None),
      expand_wildcards: Ok(None),
      format: Ok(None),
      h: Ok(None),
      health: Ok(None),
      help: Ok(None),
      include_unloaded_segments: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
      pri: Ok(None),
      s: Ok(None),
      time: Ok(None),
      v: Ok(None),
    }
  }

  pub fn bytes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::Bytes>, {
    self.bytes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Bytes` for bytes failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatIndicesClusterManagerTimeout>, {
    self.cluster_manager_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `CatIndicesClusterManagerTimeout` for cluster_manager_timeout failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn format<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.format = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for format failed".to_string());
    self
  }

  pub fn h<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.h = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
    self
  }

  pub fn health<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::Health>, {
    self.health = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Health` for health failed".to_string());
    self
  }

  pub fn help<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.help = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for help failed".to_string());
    self
  }

  pub fn include_unloaded_segments<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.include_unloaded_segments = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for include_unloaded_segments failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatIndicesMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `CatIndicesMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn pri<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.pri = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for pri failed".to_string());
    self
  }

  pub fn s<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.s = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
    self
  }

  pub fn time<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::Time>, {
    self.time = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Time` for time failed".to_string());
    self
  }

  pub fn v<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.v = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for v failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cat/indices`
  pub async fn send(self) -> Result<ResponseValue<String>, Error<()>> {
    let Self {
      client,
      bytes,
      cluster_manager_timeout,
      expand_wildcards,
      format,
      h,
      health,
      help,
      include_unloaded_segments,
      local,
      master_timeout,
      pri,
      s,
      time,
      v,
    } = self;
    let bytes = bytes.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let format = format.map_err(Error::InvalidRequest)?;
    let h = h.map_err(Error::InvalidRequest)?;
    let health = health.map_err(Error::InvalidRequest)?;
    let help = help.map_err(Error::InvalidRequest)?;
    let include_unloaded_segments = include_unloaded_segments.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let pri = pri.map_err(Error::InvalidRequest)?;
    let s = s.map_err(Error::InvalidRequest)?;
    let time = time.map_err(Error::InvalidRequest)?;
    let v = v.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cat/indices", client.baseurl,);
    let mut query = Vec::with_capacity(14usize);
    if let Some(v) = &bytes {
      query.push(("bytes", v.to_string()));
    }
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &format {
      query.push(("format", v.to_string()));
    }
    if let Some(v) = &h {
      query.push(("h", v.join(",")));
    }
    if let Some(v) = &health {
      query.push(("health", v.to_string()));
    }
    if let Some(v) = &help {
      query.push(("help", v.to_string()));
    }
    if let Some(v) = &include_unloaded_segments {
      query.push(("include_unloaded_segments", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &pri {
      query.push(("pri", v.to_string()));
    }
    if let Some(v) = &s {
      query.push(("s", v.join(",")));
    }
    if let Some(v) = &time {
      query.push(("time", v.to_string()));
    }
    if let Some(v) = &v {
      query.push(("v", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::text(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cat_indices_with_index`]
///
///[`Client::cat_indices_with_index`]: super::Client::cat_indices_with_index
#[derive(Debug, Clone)]
pub struct CatIndicesWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::CatIndicesWithIndexIndex, String>,
  bytes: Result<Option<types::Bytes>, String>,
  cluster_manager_timeout: Result<Option<types::CatIndicesWithIndexClusterManagerTimeout>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  format: Result<Option<String>, String>,
  h: Result<Option<Vec<String>>, String>,
  health: Result<Option<types::Health>, String>,
  help: Result<Option<bool>, String>,
  include_unloaded_segments: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::CatIndicesWithIndexMasterTimeout>, String>,
  pri: Result<Option<bool>, String>,
  s: Result<Option<Vec<String>>, String>,
  time: Result<Option<types::Time>, String>,
  v: Result<Option<bool>, String>,
}

impl<'a> CatIndicesWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      bytes: Ok(None),
      cluster_manager_timeout: Ok(None),
      expand_wildcards: Ok(None),
      format: Ok(None),
      h: Ok(None),
      health: Ok(None),
      help: Ok(None),
      include_unloaded_segments: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
      pri: Ok(None),
      s: Ok(None),
      time: Ok(None),
      v: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatIndicesWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `CatIndicesWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn bytes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::Bytes>, {
    self.bytes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Bytes` for bytes failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatIndicesWithIndexClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `CatIndicesWithIndexClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn format<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.format = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for format failed".to_string());
    self
  }

  pub fn h<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.h = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
    self
  }

  pub fn health<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::Health>, {
    self.health = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Health` for health failed".to_string());
    self
  }

  pub fn help<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.help = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for help failed".to_string());
    self
  }

  pub fn include_unloaded_segments<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.include_unloaded_segments = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for include_unloaded_segments failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatIndicesWithIndexMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `CatIndicesWithIndexMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn pri<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.pri = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for pri failed".to_string());
    self
  }

  pub fn s<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.s = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
    self
  }

  pub fn time<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::Time>, {
    self.time = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Time` for time failed".to_string());
    self
  }

  pub fn v<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.v = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for v failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cat/indices/{index}`
  pub async fn send(self) -> Result<ResponseValue<String>, Error<()>> {
    let Self {
      client,
      index,
      bytes,
      cluster_manager_timeout,
      expand_wildcards,
      format,
      h,
      health,
      help,
      include_unloaded_segments,
      local,
      master_timeout,
      pri,
      s,
      time,
      v,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let bytes = bytes.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let format = format.map_err(Error::InvalidRequest)?;
    let h = h.map_err(Error::InvalidRequest)?;
    let health = health.map_err(Error::InvalidRequest)?;
    let help = help.map_err(Error::InvalidRequest)?;
    let include_unloaded_segments = include_unloaded_segments.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let pri = pri.map_err(Error::InvalidRequest)?;
    let s = s.map_err(Error::InvalidRequest)?;
    let time = time.map_err(Error::InvalidRequest)?;
    let v = v.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cat/indices/{}", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(14usize);
    if let Some(v) = &bytes {
      query.push(("bytes", v.to_string()));
    }
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &format {
      query.push(("format", v.to_string()));
    }
    if let Some(v) = &h {
      query.push(("h", v.join(",")));
    }
    if let Some(v) = &health {
      query.push(("health", v.to_string()));
    }
    if let Some(v) = &help {
      query.push(("help", v.to_string()));
    }
    if let Some(v) = &include_unloaded_segments {
      query.push(("include_unloaded_segments", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &pri {
      query.push(("pri", v.to_string()));
    }
    if let Some(v) = &s {
      query.push(("s", v.join(",")));
    }
    if let Some(v) = &time {
      query.push(("time", v.to_string()));
    }
    if let Some(v) = &v {
      query.push(("v", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::text(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cat_master`]
///
///[`Client::cat_master`]: super::Client::cat_master
#[derive(Debug, Clone)]
pub struct CatMaster<'a> {
  client: &'a super::Client,
  cluster_manager_timeout: Result<Option<types::CatMasterClusterManagerTimeout>, String>,
  format: Result<Option<String>, String>,
  h: Result<Option<Vec<String>>, String>,
  help: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::CatMasterMasterTimeout>, String>,
  s: Result<Option<Vec<String>>, String>,
  v: Result<Option<bool>, String>,
}

impl<'a> CatMaster<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      cluster_manager_timeout: Ok(None),
      format: Ok(None),
      h: Ok(None),
      help: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
      s: Ok(None),
      v: Ok(None),
    }
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatMasterClusterManagerTimeout>, {
    self.cluster_manager_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `CatMasterClusterManagerTimeout` for cluster_manager_timeout failed".to_string());
    self
  }

  pub fn format<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.format = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for format failed".to_string());
    self
  }

  pub fn h<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.h = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
    self
  }

  pub fn help<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.help = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for help failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatMasterMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `CatMasterMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn s<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.s = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
    self
  }

  pub fn v<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.v = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for v failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cat/master`
  pub async fn send(self) -> Result<ResponseValue<String>, Error<()>> {
    let Self {
      client,
      cluster_manager_timeout,
      format,
      h,
      help,
      local,
      master_timeout,
      s,
      v,
    } = self;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let format = format.map_err(Error::InvalidRequest)?;
    let h = h.map_err(Error::InvalidRequest)?;
    let help = help.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let s = s.map_err(Error::InvalidRequest)?;
    let v = v.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cat/master", client.baseurl,);
    let mut query = Vec::with_capacity(8usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &format {
      query.push(("format", v.to_string()));
    }
    if let Some(v) = &h {
      query.push(("h", v.join(",")));
    }
    if let Some(v) = &help {
      query.push(("help", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &s {
      query.push(("s", v.join(",")));
    }
    if let Some(v) = &v {
      query.push(("v", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::text(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cat_nodeattrs`]
///
///[`Client::cat_nodeattrs`]: super::Client::cat_nodeattrs
#[derive(Debug, Clone)]
pub struct CatNodeattrs<'a> {
  client: &'a super::Client,
  cluster_manager_timeout: Result<Option<types::CatNodeattrsClusterManagerTimeout>, String>,
  format: Result<Option<String>, String>,
  h: Result<Option<Vec<String>>, String>,
  help: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::CatNodeattrsMasterTimeout>, String>,
  s: Result<Option<Vec<String>>, String>,
  v: Result<Option<bool>, String>,
}

impl<'a> CatNodeattrs<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      cluster_manager_timeout: Ok(None),
      format: Ok(None),
      h: Ok(None),
      help: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
      s: Ok(None),
      v: Ok(None),
    }
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatNodeattrsClusterManagerTimeout>, {
    self.cluster_manager_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `CatNodeattrsClusterManagerTimeout` for cluster_manager_timeout failed".to_string());
    self
  }

  pub fn format<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.format = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for format failed".to_string());
    self
  }

  pub fn h<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.h = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
    self
  }

  pub fn help<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.help = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for help failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatNodeattrsMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `CatNodeattrsMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn s<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.s = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
    self
  }

  pub fn v<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.v = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for v failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cat/nodeattrs`
  pub async fn send(self) -> Result<ResponseValue<String>, Error<()>> {
    let Self {
      client,
      cluster_manager_timeout,
      format,
      h,
      help,
      local,
      master_timeout,
      s,
      v,
    } = self;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let format = format.map_err(Error::InvalidRequest)?;
    let h = h.map_err(Error::InvalidRequest)?;
    let help = help.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let s = s.map_err(Error::InvalidRequest)?;
    let v = v.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cat/nodeattrs", client.baseurl,);
    let mut query = Vec::with_capacity(8usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &format {
      query.push(("format", v.to_string()));
    }
    if let Some(v) = &h {
      query.push(("h", v.join(",")));
    }
    if let Some(v) = &help {
      query.push(("help", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &s {
      query.push(("s", v.join(",")));
    }
    if let Some(v) = &v {
      query.push(("v", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::text(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cat_nodes`]
///
///[`Client::cat_nodes`]: super::Client::cat_nodes
#[derive(Debug, Clone)]
pub struct CatNodes<'a> {
  client: &'a super::Client,
  bytes: Result<Option<types::Bytes>, String>,
  cluster_manager_timeout: Result<Option<types::CatNodesClusterManagerTimeout>, String>,
  format: Result<Option<String>, String>,
  full_id: Result<Option<bool>, String>,
  h: Result<Option<Vec<String>>, String>,
  help: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::CatNodesMasterTimeout>, String>,
  s: Result<Option<Vec<String>>, String>,
  time: Result<Option<types::Time>, String>,
  v: Result<Option<bool>, String>,
}

impl<'a> CatNodes<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      bytes: Ok(None),
      cluster_manager_timeout: Ok(None),
      format: Ok(None),
      full_id: Ok(None),
      h: Ok(None),
      help: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
      s: Ok(None),
      time: Ok(None),
      v: Ok(None),
    }
  }

  pub fn bytes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::Bytes>, {
    self.bytes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Bytes` for bytes failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatNodesClusterManagerTimeout>, {
    self.cluster_manager_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `CatNodesClusterManagerTimeout` for cluster_manager_timeout failed".to_string());
    self
  }

  pub fn format<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.format = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for format failed".to_string());
    self
  }

  pub fn full_id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.full_id = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for full_id failed".to_string());
    self
  }

  pub fn h<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.h = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
    self
  }

  pub fn help<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.help = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for help failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatNodesMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `CatNodesMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn s<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.s = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
    self
  }

  pub fn time<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::Time>, {
    self.time = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Time` for time failed".to_string());
    self
  }

  pub fn v<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.v = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for v failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cat/nodes`
  pub async fn send(self) -> Result<ResponseValue<String>, Error<()>> {
    let Self {
      client,
      bytes,
      cluster_manager_timeout,
      format,
      full_id,
      h,
      help,
      local,
      master_timeout,
      s,
      time,
      v,
    } = self;
    let bytes = bytes.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let format = format.map_err(Error::InvalidRequest)?;
    let full_id = full_id.map_err(Error::InvalidRequest)?;
    let h = h.map_err(Error::InvalidRequest)?;
    let help = help.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let s = s.map_err(Error::InvalidRequest)?;
    let time = time.map_err(Error::InvalidRequest)?;
    let v = v.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cat/nodes", client.baseurl,);
    let mut query = Vec::with_capacity(11usize);
    if let Some(v) = &bytes {
      query.push(("bytes", v.to_string()));
    }
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &format {
      query.push(("format", v.to_string()));
    }
    if let Some(v) = &full_id {
      query.push(("full_id", v.to_string()));
    }
    if let Some(v) = &h {
      query.push(("h", v.join(",")));
    }
    if let Some(v) = &help {
      query.push(("help", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &s {
      query.push(("s", v.join(",")));
    }
    if let Some(v) = &time {
      query.push(("time", v.to_string()));
    }
    if let Some(v) = &v {
      query.push(("v", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::text(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cat_pending_tasks`]
///
///[`Client::cat_pending_tasks`]: super::Client::cat_pending_tasks
#[derive(Debug, Clone)]
pub struct CatPendingTasks<'a> {
  client: &'a super::Client,
  cluster_manager_timeout: Result<Option<types::CatPendingTasksClusterManagerTimeout>, String>,
  format: Result<Option<String>, String>,
  h: Result<Option<Vec<String>>, String>,
  help: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::CatPendingTasksMasterTimeout>, String>,
  s: Result<Option<Vec<String>>, String>,
  time: Result<Option<types::Time>, String>,
  v: Result<Option<bool>, String>,
}

impl<'a> CatPendingTasks<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      cluster_manager_timeout: Ok(None),
      format: Ok(None),
      h: Ok(None),
      help: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
      s: Ok(None),
      time: Ok(None),
      v: Ok(None),
    }
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatPendingTasksClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `CatPendingTasksClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn format<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.format = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for format failed".to_string());
    self
  }

  pub fn h<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.h = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
    self
  }

  pub fn help<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.help = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for help failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatPendingTasksMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `CatPendingTasksMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn s<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.s = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
    self
  }

  pub fn time<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::Time>, {
    self.time = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Time` for time failed".to_string());
    self
  }

  pub fn v<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.v = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for v failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cat/pending_tasks`
  pub async fn send(self) -> Result<ResponseValue<String>, Error<()>> {
    let Self {
      client,
      cluster_manager_timeout,
      format,
      h,
      help,
      local,
      master_timeout,
      s,
      time,
      v,
    } = self;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let format = format.map_err(Error::InvalidRequest)?;
    let h = h.map_err(Error::InvalidRequest)?;
    let help = help.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let s = s.map_err(Error::InvalidRequest)?;
    let time = time.map_err(Error::InvalidRequest)?;
    let v = v.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cat/pending_tasks", client.baseurl,);
    let mut query = Vec::with_capacity(9usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &format {
      query.push(("format", v.to_string()));
    }
    if let Some(v) = &h {
      query.push(("h", v.join(",")));
    }
    if let Some(v) = &help {
      query.push(("help", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &s {
      query.push(("s", v.join(",")));
    }
    if let Some(v) = &time {
      query.push(("time", v.to_string()));
    }
    if let Some(v) = &v {
      query.push(("v", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::text(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cat_pit_segments`]
///
///[`Client::cat_pit_segments`]: super::Client::cat_pit_segments
#[derive(Debug, Clone)]
pub struct CatPitSegments<'a> {
  client: &'a super::Client,
  body: Result<types::builder::CatPitSegmentsBodyParams, String>,
}

impl<'a> CatPitSegments<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      body: Ok(types::builder::CatPitSegmentsBodyParams::default()),
    }
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatPitSegmentsBodyParams>, {
    self.body = value
      .try_into()
      .map(From::from)
      .map_err(|_| "conversion to `CatPitSegmentsBodyParams` for body failed".to_string());
    self
  }

  pub fn body_map<F>(mut self, f: F) -> Self
  where
    F: std::ops::FnOnce(types::builder::CatPitSegmentsBodyParams) -> types::builder::CatPitSegmentsBodyParams, {
    self.body = self.body.map(f);
    self
  }

  ///Sends a `GET` request to `/_cat/pit_segments`
  pub async fn send(self) -> Result<ResponseValue<types::CatPitSegmentsResponseContent>, Error<()>> {
    let Self { client, body } = self;
    let body = body
      .and_then(std::convert::TryInto::<types::CatPitSegmentsBodyParams>::try_into)
      .map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cat/pit_segments", client.baseurl,);
    let request = client
      .client
      .get(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .json(&body)
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cat_all_pit_segments`]
///
///[`Client::cat_all_pit_segments`]: super::Client::cat_all_pit_segments
#[derive(Debug, Clone)]
pub struct CatAllPitSegments<'a> {
  client: &'a super::Client,
}

impl<'a> CatAllPitSegments<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self { client }
  }

  ///Sends a `GET` request to `/_cat/pit_segments/_all`
  pub async fn send(self) -> Result<ResponseValue<types::CatAllPitSegmentsResponseContent>, Error<()>> {
    let Self { client } = self;
    let url = format!("{}/_cat/pit_segments/_all", client.baseurl,);
    let request = client
      .client
      .get(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cat_plugins`]
///
///[`Client::cat_plugins`]: super::Client::cat_plugins
#[derive(Debug, Clone)]
pub struct CatPlugins<'a> {
  client: &'a super::Client,
  cluster_manager_timeout: Result<Option<types::CatPluginsClusterManagerTimeout>, String>,
  format: Result<Option<String>, String>,
  h: Result<Option<Vec<String>>, String>,
  help: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::CatPluginsMasterTimeout>, String>,
  s: Result<Option<Vec<String>>, String>,
  v: Result<Option<bool>, String>,
}

impl<'a> CatPlugins<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      cluster_manager_timeout: Ok(None),
      format: Ok(None),
      h: Ok(None),
      help: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
      s: Ok(None),
      v: Ok(None),
    }
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatPluginsClusterManagerTimeout>, {
    self.cluster_manager_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `CatPluginsClusterManagerTimeout` for cluster_manager_timeout failed".to_string());
    self
  }

  pub fn format<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.format = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for format failed".to_string());
    self
  }

  pub fn h<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.h = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
    self
  }

  pub fn help<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.help = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for help failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatPluginsMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `CatPluginsMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn s<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.s = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
    self
  }

  pub fn v<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.v = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for v failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cat/plugins`
  pub async fn send(self) -> Result<ResponseValue<String>, Error<()>> {
    let Self {
      client,
      cluster_manager_timeout,
      format,
      h,
      help,
      local,
      master_timeout,
      s,
      v,
    } = self;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let format = format.map_err(Error::InvalidRequest)?;
    let h = h.map_err(Error::InvalidRequest)?;
    let help = help.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let s = s.map_err(Error::InvalidRequest)?;
    let v = v.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cat/plugins", client.baseurl,);
    let mut query = Vec::with_capacity(8usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &format {
      query.push(("format", v.to_string()));
    }
    if let Some(v) = &h {
      query.push(("h", v.join(",")));
    }
    if let Some(v) = &help {
      query.push(("help", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &s {
      query.push(("s", v.join(",")));
    }
    if let Some(v) = &v {
      query.push(("v", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::text(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cat_recovery`]
///
///[`Client::cat_recovery`]: super::Client::cat_recovery
#[derive(Debug, Clone)]
pub struct CatRecovery<'a> {
  client: &'a super::Client,
  active_only: Result<Option<bool>, String>,
  bytes: Result<Option<types::Bytes>, String>,
  detailed: Result<Option<bool>, String>,
  format: Result<Option<String>, String>,
  h: Result<Option<Vec<String>>, String>,
  help: Result<Option<bool>, String>,
  index: Result<Option<Vec<String>>, String>,
  s: Result<Option<Vec<String>>, String>,
  time: Result<Option<types::Time>, String>,
  v: Result<Option<bool>, String>,
}

impl<'a> CatRecovery<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      active_only: Ok(None),
      bytes: Ok(None),
      detailed: Ok(None),
      format: Ok(None),
      h: Ok(None),
      help: Ok(None),
      index: Ok(None),
      s: Ok(None),
      time: Ok(None),
      v: Ok(None),
    }
  }

  pub fn active_only<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.active_only = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for active_only failed".to_string());
    self
  }

  pub fn bytes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::Bytes>, {
    self.bytes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Bytes` for bytes failed".to_string());
    self
  }

  pub fn detailed<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.detailed = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for detailed failed".to_string());
    self
  }

  pub fn format<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.format = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for format failed".to_string());
    self
  }

  pub fn h<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.h = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
    self
  }

  pub fn help<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.help = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for help failed".to_string());
    self
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.index = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for index failed".to_string());
    self
  }

  pub fn s<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.s = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
    self
  }

  pub fn time<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::Time>, {
    self.time = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Time` for time failed".to_string());
    self
  }

  pub fn v<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.v = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for v failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cat/recovery`
  pub async fn send(self) -> Result<ResponseValue<String>, Error<()>> {
    let Self {
      client,
      active_only,
      bytes,
      detailed,
      format,
      h,
      help,
      index,
      s,
      time,
      v,
    } = self;
    let active_only = active_only.map_err(Error::InvalidRequest)?;
    let bytes = bytes.map_err(Error::InvalidRequest)?;
    let detailed = detailed.map_err(Error::InvalidRequest)?;
    let format = format.map_err(Error::InvalidRequest)?;
    let h = h.map_err(Error::InvalidRequest)?;
    let help = help.map_err(Error::InvalidRequest)?;
    let index = index.map_err(Error::InvalidRequest)?;
    let s = s.map_err(Error::InvalidRequest)?;
    let time = time.map_err(Error::InvalidRequest)?;
    let v = v.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cat/recovery", client.baseurl,);
    let mut query = Vec::with_capacity(10usize);
    if let Some(v) = &active_only {
      query.push(("active_only", v.to_string()));
    }
    if let Some(v) = &bytes {
      query.push(("bytes", v.to_string()));
    }
    if let Some(v) = &detailed {
      query.push(("detailed", v.to_string()));
    }
    if let Some(v) = &format {
      query.push(("format", v.to_string()));
    }
    if let Some(v) = &h {
      query.push(("h", v.join(",")));
    }
    if let Some(v) = &help {
      query.push(("help", v.to_string()));
    }
    if let Some(v) = &index {
      query.push(("index", v.join(",")));
    }
    if let Some(v) = &s {
      query.push(("s", v.join(",")));
    }
    if let Some(v) = &time {
      query.push(("time", v.to_string()));
    }
    if let Some(v) = &v {
      query.push(("v", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::text(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cat_recovery_with_index`]
///
///[`Client::cat_recovery_with_index`]: super::Client::cat_recovery_with_index
#[derive(Debug, Clone)]
pub struct CatRecoveryWithIndex<'a> {
  client: &'a super::Client,
  active_only: Result<Option<bool>, String>,
  bytes: Result<Option<types::Bytes>, String>,
  detailed: Result<Option<bool>, String>,
  format: Result<Option<String>, String>,
  h: Result<Option<Vec<String>>, String>,
  help: Result<Option<bool>, String>,
  index: Result<Option<Vec<String>>, String>,
  s: Result<Option<Vec<String>>, String>,
  time: Result<Option<types::Time>, String>,
  v: Result<Option<bool>, String>,
}

impl<'a> CatRecoveryWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      active_only: Ok(None),
      bytes: Ok(None),
      detailed: Ok(None),
      format: Ok(None),
      h: Ok(None),
      help: Ok(None),
      index: Ok(None),
      s: Ok(None),
      time: Ok(None),
      v: Ok(None),
    }
  }

  pub fn active_only<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.active_only = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for active_only failed".to_string());
    self
  }

  pub fn bytes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::Bytes>, {
    self.bytes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Bytes` for bytes failed".to_string());
    self
  }

  pub fn detailed<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.detailed = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for detailed failed".to_string());
    self
  }

  pub fn format<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.format = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for format failed".to_string());
    self
  }

  pub fn h<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.h = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
    self
  }

  pub fn help<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.help = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for help failed".to_string());
    self
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.index = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for index failed".to_string());
    self
  }

  pub fn s<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.s = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
    self
  }

  pub fn time<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::Time>, {
    self.time = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Time` for time failed".to_string());
    self
  }

  pub fn v<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.v = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for v failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cat/recovery/{index}`
  pub async fn send(self) -> Result<ResponseValue<String>, Error<()>> {
    let Self {
      client,
      active_only,
      bytes,
      detailed,
      format,
      h,
      help,
      index,
      s,
      time,
      v,
    } = self;
    let active_only = active_only.map_err(Error::InvalidRequest)?;
    let bytes = bytes.map_err(Error::InvalidRequest)?;
    let detailed = detailed.map_err(Error::InvalidRequest)?;
    let format = format.map_err(Error::InvalidRequest)?;
    let h = h.map_err(Error::InvalidRequest)?;
    let help = help.map_err(Error::InvalidRequest)?;
    let index = index.map_err(Error::InvalidRequest)?;
    let s = s.map_err(Error::InvalidRequest)?;
    let time = time.map_err(Error::InvalidRequest)?;
    let v = v.map_err(Error::InvalidRequest)?;
    let url = match index {
      Some(_) => {
        format!(
          "{}/_cat/recovery/{}",
          client.baseurl,
          encode_path(&index.clone().unwrap().join(",")),
        )
      }
      None => format!("{}/_cat/recovery", client.baseurl),
    };
    let mut query = Vec::with_capacity(10usize);
    if let Some(v) = &active_only {
      query.push(("active_only", v.to_string()));
    }
    if let Some(v) = &bytes {
      query.push(("bytes", v.to_string()));
    }
    if let Some(v) = &detailed {
      query.push(("detailed", v.to_string()));
    }
    if let Some(v) = &format {
      query.push(("format", v.to_string()));
    }
    if let Some(v) = &h {
      query.push(("h", v.join(",")));
    }
    if let Some(v) = &help {
      query.push(("help", v.to_string()));
    }
    if let Some(v) = &index {
      query.push(("index", v.join(",")));
    }
    if let Some(v) = &s {
      query.push(("s", v.join(",")));
    }
    if let Some(v) = &time {
      query.push(("time", v.to_string()));
    }
    if let Some(v) = &v {
      query.push(("v", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::text(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cat_repositories`]
///
///[`Client::cat_repositories`]: super::Client::cat_repositories
#[derive(Debug, Clone)]
pub struct CatRepositories<'a> {
  client: &'a super::Client,
  cluster_manager_timeout: Result<Option<types::CatRepositoriesClusterManagerTimeout>, String>,
  format: Result<Option<String>, String>,
  h: Result<Option<Vec<String>>, String>,
  help: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::CatRepositoriesMasterTimeout>, String>,
  s: Result<Option<Vec<String>>, String>,
  v: Result<Option<bool>, String>,
}

impl<'a> CatRepositories<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      cluster_manager_timeout: Ok(None),
      format: Ok(None),
      h: Ok(None),
      help: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
      s: Ok(None),
      v: Ok(None),
    }
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatRepositoriesClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `CatRepositoriesClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn format<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.format = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for format failed".to_string());
    self
  }

  pub fn h<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.h = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
    self
  }

  pub fn help<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.help = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for help failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatRepositoriesMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `CatRepositoriesMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn s<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.s = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
    self
  }

  pub fn v<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.v = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for v failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cat/repositories`
  pub async fn send(self) -> Result<ResponseValue<String>, Error<()>> {
    let Self {
      client,
      cluster_manager_timeout,
      format,
      h,
      help,
      local,
      master_timeout,
      s,
      v,
    } = self;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let format = format.map_err(Error::InvalidRequest)?;
    let h = h.map_err(Error::InvalidRequest)?;
    let help = help.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let s = s.map_err(Error::InvalidRequest)?;
    let v = v.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cat/repositories", client.baseurl,);
    let mut query = Vec::with_capacity(8usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &format {
      query.push(("format", v.to_string()));
    }
    if let Some(v) = &h {
      query.push(("h", v.join(",")));
    }
    if let Some(v) = &help {
      query.push(("help", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &s {
      query.push(("s", v.join(",")));
    }
    if let Some(v) = &v {
      query.push(("v", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::text(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cat_segment_replication`]
///
///[`Client::cat_segment_replication`]: super::Client::cat_segment_replication
#[derive(Debug, Clone)]
pub struct CatSegmentReplication<'a> {
  client: &'a super::Client,
  active_only: Result<Option<bool>, String>,
  bytes: Result<Option<types::Bytes>, String>,
  completed_only: Result<Option<bool>, String>,
  detailed: Result<Option<bool>, String>,
  format: Result<Option<String>, String>,
  h: Result<Option<Vec<String>>, String>,
  help: Result<Option<bool>, String>,
  index: Result<Option<Vec<String>>, String>,
  s: Result<Option<Vec<String>>, String>,
  shards: Result<Option<Vec<String>>, String>,
  time: Result<Option<types::Time>, String>,
  v: Result<Option<bool>, String>,
}

impl<'a> CatSegmentReplication<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      active_only: Ok(None),
      bytes: Ok(None),
      completed_only: Ok(None),
      detailed: Ok(None),
      format: Ok(None),
      h: Ok(None),
      help: Ok(None),
      index: Ok(None),
      s: Ok(None),
      shards: Ok(None),
      time: Ok(None),
      v: Ok(None),
    }
  }

  pub fn active_only<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.active_only = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for active_only failed".to_string());
    self
  }

  pub fn bytes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::Bytes>, {
    self.bytes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Bytes` for bytes failed".to_string());
    self
  }

  pub fn completed_only<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.completed_only = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for completed_only failed".to_string());
    self
  }

  pub fn detailed<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.detailed = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for detailed failed".to_string());
    self
  }

  pub fn format<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.format = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for format failed".to_string());
    self
  }

  pub fn h<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.h = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
    self
  }

  pub fn help<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.help = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for help failed".to_string());
    self
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.index = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for index failed".to_string());
    self
  }

  pub fn s<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.s = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
    self
  }

  pub fn shards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.shards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for shards failed".to_string());
    self
  }

  pub fn time<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::Time>, {
    self.time = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Time` for time failed".to_string());
    self
  }

  pub fn v<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.v = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for v failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cat/segment_replication`
  pub async fn send(self) -> Result<ResponseValue<String>, Error<()>> {
    let Self {
      client,
      active_only,
      bytes,
      completed_only,
      detailed,
      format,
      h,
      help,
      index,
      s,
      shards,
      time,
      v,
    } = self;
    let active_only = active_only.map_err(Error::InvalidRequest)?;
    let bytes = bytes.map_err(Error::InvalidRequest)?;
    let completed_only = completed_only.map_err(Error::InvalidRequest)?;
    let detailed = detailed.map_err(Error::InvalidRequest)?;
    let format = format.map_err(Error::InvalidRequest)?;
    let h = h.map_err(Error::InvalidRequest)?;
    let help = help.map_err(Error::InvalidRequest)?;
    let index = index.map_err(Error::InvalidRequest)?;
    let s = s.map_err(Error::InvalidRequest)?;
    let shards = shards.map_err(Error::InvalidRequest)?;
    let time = time.map_err(Error::InvalidRequest)?;
    let v = v.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cat/segment_replication", client.baseurl,);
    let mut query = Vec::with_capacity(12usize);
    if let Some(v) = &active_only {
      query.push(("active_only", v.to_string()));
    }
    if let Some(v) = &bytes {
      query.push(("bytes", v.to_string()));
    }
    if let Some(v) = &completed_only {
      query.push(("completed_only", v.to_string()));
    }
    if let Some(v) = &detailed {
      query.push(("detailed", v.to_string()));
    }
    if let Some(v) = &format {
      query.push(("format", v.to_string()));
    }
    if let Some(v) = &h {
      query.push(("h", v.join(",")));
    }
    if let Some(v) = &help {
      query.push(("help", v.to_string()));
    }
    if let Some(v) = &index {
      query.push(("index", v.join(",")));
    }
    if let Some(v) = &s {
      query.push(("s", v.join(",")));
    }
    if let Some(v) = &shards {
      query.push(("shards", v.join(",")));
    }
    if let Some(v) = &time {
      query.push(("time", v.to_string()));
    }
    if let Some(v) = &v {
      query.push(("v", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::text(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cat_segment_replication_with_index`]
///
///[`Client::cat_segment_replication_with_index`]: super::Client::cat_segment_replication_with_index
#[derive(Debug, Clone)]
pub struct CatSegmentReplicationWithIndex<'a> {
  client: &'a super::Client,
  active_only: Result<Option<bool>, String>,
  bytes: Result<Option<types::Bytes>, String>,
  completed_only: Result<Option<bool>, String>,
  detailed: Result<Option<bool>, String>,
  format: Result<Option<String>, String>,
  h: Result<Option<Vec<String>>, String>,
  help: Result<Option<bool>, String>,
  index: Result<Option<Vec<String>>, String>,
  s: Result<Option<Vec<String>>, String>,
  shards: Result<Option<Vec<String>>, String>,
  time: Result<Option<types::Time>, String>,
  v: Result<Option<bool>, String>,
}

impl<'a> CatSegmentReplicationWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      active_only: Ok(None),
      bytes: Ok(None),
      completed_only: Ok(None),
      detailed: Ok(None),
      format: Ok(None),
      h: Ok(None),
      help: Ok(None),
      index: Ok(None),
      s: Ok(None),
      shards: Ok(None),
      time: Ok(None),
      v: Ok(None),
    }
  }

  pub fn active_only<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.active_only = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for active_only failed".to_string());
    self
  }

  pub fn bytes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::Bytes>, {
    self.bytes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Bytes` for bytes failed".to_string());
    self
  }

  pub fn completed_only<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.completed_only = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for completed_only failed".to_string());
    self
  }

  pub fn detailed<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.detailed = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for detailed failed".to_string());
    self
  }

  pub fn format<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.format = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for format failed".to_string());
    self
  }

  pub fn h<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.h = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
    self
  }

  pub fn help<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.help = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for help failed".to_string());
    self
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.index = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for index failed".to_string());
    self
  }

  pub fn s<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.s = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
    self
  }

  pub fn shards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.shards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for shards failed".to_string());
    self
  }

  pub fn time<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::Time>, {
    self.time = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Time` for time failed".to_string());
    self
  }

  pub fn v<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.v = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for v failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cat/segment_replication/{index}`
  pub async fn send(self) -> Result<ResponseValue<String>, Error<()>> {
    let Self {
      client,
      active_only,
      bytes,
      completed_only,
      detailed,
      format,
      h,
      help,
      index,
      s,
      shards,
      time,
      v,
    } = self;
    let active_only = active_only.map_err(Error::InvalidRequest)?;
    let bytes = bytes.map_err(Error::InvalidRequest)?;
    let completed_only = completed_only.map_err(Error::InvalidRequest)?;
    let detailed = detailed.map_err(Error::InvalidRequest)?;
    let format = format.map_err(Error::InvalidRequest)?;
    let h = h.map_err(Error::InvalidRequest)?;
    let help = help.map_err(Error::InvalidRequest)?;
    let index = index.map_err(Error::InvalidRequest)?;
    let s = s.map_err(Error::InvalidRequest)?;
    let shards = shards.map_err(Error::InvalidRequest)?;
    let time = time.map_err(Error::InvalidRequest)?;
    let v = v.map_err(Error::InvalidRequest)?;
    let url = match index {
      Some(_) => {
        format!(
          "{}/_cat/segment_replication/{}",
          client.baseurl,
          encode_path(&index.clone().unwrap().join(",")),
        )
      }
      None => format!("{}/_cat/segment_replication", client.baseurl),
    };

    let mut query = Vec::with_capacity(12usize);
    if let Some(v) = &active_only {
      query.push(("active_only", v.to_string()));
    }
    if let Some(v) = &bytes {
      query.push(("bytes", v.to_string()));
    }
    if let Some(v) = &completed_only {
      query.push(("completed_only", v.to_string()));
    }
    if let Some(v) = &detailed {
      query.push(("detailed", v.to_string()));
    }
    if let Some(v) = &format {
      query.push(("format", v.to_string()));
    }
    if let Some(v) = &h {
      query.push(("h", v.join(",")));
    }
    if let Some(v) = &help {
      query.push(("help", v.to_string()));
    }
    if let Some(v) = &index {
      query.push(("index", v.join(",")));
    }
    if let Some(v) = &s {
      query.push(("s", v.join(",")));
    }
    if let Some(v) = &shards {
      query.push(("shards", v.join(",")));
    }
    if let Some(v) = &time {
      query.push(("time", v.to_string()));
    }
    if let Some(v) = &v {
      query.push(("v", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::text(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cat_segments`]
///
///[`Client::cat_segments`]: super::Client::cat_segments
#[derive(Debug, Clone)]
pub struct CatSegments<'a> {
  client: &'a super::Client,
  bytes: Result<Option<types::Bytes>, String>,
  cluster_manager_timeout: Result<Option<types::CatSegmentsClusterManagerTimeout>, String>,
  format: Result<Option<String>, String>,
  h: Result<Option<Vec<String>>, String>,
  help: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::CatSegmentsMasterTimeout>, String>,
  s: Result<Option<Vec<String>>, String>,
  v: Result<Option<bool>, String>,
}

impl<'a> CatSegments<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      bytes: Ok(None),
      cluster_manager_timeout: Ok(None),
      format: Ok(None),
      h: Ok(None),
      help: Ok(None),
      master_timeout: Ok(None),
      s: Ok(None),
      v: Ok(None),
    }
  }

  pub fn bytes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::Bytes>, {
    self.bytes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Bytes` for bytes failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatSegmentsClusterManagerTimeout>, {
    self.cluster_manager_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `CatSegmentsClusterManagerTimeout` for cluster_manager_timeout failed".to_string());
    self
  }

  pub fn format<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.format = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for format failed".to_string());
    self
  }

  pub fn h<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.h = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
    self
  }

  pub fn help<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.help = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for help failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatSegmentsMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `CatSegmentsMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn s<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.s = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
    self
  }

  pub fn v<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.v = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for v failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cat/segments`
  pub async fn send(self) -> Result<ResponseValue<String>, Error<()>> {
    let Self {
      client,
      bytes,
      cluster_manager_timeout,
      format,
      h,
      help,
      master_timeout,
      s,
      v,
    } = self;
    let bytes = bytes.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let format = format.map_err(Error::InvalidRequest)?;
    let h = h.map_err(Error::InvalidRequest)?;
    let help = help.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let s = s.map_err(Error::InvalidRequest)?;
    let v = v.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cat/segments", client.baseurl,);
    let mut query = Vec::with_capacity(8usize);
    if let Some(v) = &bytes {
      query.push(("bytes", v.to_string()));
    }
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &format {
      query.push(("format", v.to_string()));
    }
    if let Some(v) = &h {
      query.push(("h", v.join(",")));
    }
    if let Some(v) = &help {
      query.push(("help", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &s {
      query.push(("s", v.join(",")));
    }
    if let Some(v) = &v {
      query.push(("v", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::text(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cat_segments_with_index`]
///
///[`Client::cat_segments_with_index`]: super::Client::cat_segments_with_index
#[derive(Debug, Clone)]
pub struct CatSegmentsWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::CatSegmentsWithIndexIndex, String>,
  bytes: Result<Option<types::Bytes>, String>,
  cluster_manager_timeout: Result<Option<types::CatSegmentsWithIndexClusterManagerTimeout>, String>,
  format: Result<Option<String>, String>,
  h: Result<Option<Vec<String>>, String>,
  help: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::CatSegmentsWithIndexMasterTimeout>, String>,
  s: Result<Option<Vec<String>>, String>,
  v: Result<Option<bool>, String>,
}

impl<'a> CatSegmentsWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      bytes: Ok(None),
      cluster_manager_timeout: Ok(None),
      format: Ok(None),
      h: Ok(None),
      help: Ok(None),
      master_timeout: Ok(None),
      s: Ok(None),
      v: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatSegmentsWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `CatSegmentsWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn bytes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::Bytes>, {
    self.bytes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Bytes` for bytes failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatSegmentsWithIndexClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `CatSegmentsWithIndexClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn format<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.format = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for format failed".to_string());
    self
  }

  pub fn h<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.h = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
    self
  }

  pub fn help<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.help = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for help failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatSegmentsWithIndexMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `CatSegmentsWithIndexMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn s<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.s = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
    self
  }

  pub fn v<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.v = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for v failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cat/segments/{index}`
  pub async fn send(self) -> Result<ResponseValue<String>, Error<()>> {
    let Self {
      client,
      index,
      bytes,
      cluster_manager_timeout,
      format,
      h,
      help,
      master_timeout,
      s,
      v,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let bytes = bytes.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let format = format.map_err(Error::InvalidRequest)?;
    let h = h.map_err(Error::InvalidRequest)?;
    let help = help.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let s = s.map_err(Error::InvalidRequest)?;
    let v = v.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cat/segments/{}", client.baseurl, encode_path(&index.to_string()),);

    let mut query = Vec::with_capacity(8usize);
    if let Some(v) = &bytes {
      query.push(("bytes", v.to_string()));
    }
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &format {
      query.push(("format", v.to_string()));
    }
    if let Some(v) = &h {
      query.push(("h", v.join(",")));
    }
    if let Some(v) = &help {
      query.push(("help", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &s {
      query.push(("s", v.join(",")));
    }
    if let Some(v) = &v {
      query.push(("v", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::text(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cat_shards`]
///
///[`Client::cat_shards`]: super::Client::cat_shards
#[derive(Debug, Clone)]
pub struct CatShards<'a> {
  client: &'a super::Client,
  bytes: Result<Option<types::Bytes>, String>,
  cluster_manager_timeout: Result<Option<types::CatShardsClusterManagerTimeout>, String>,
  format: Result<Option<String>, String>,
  h: Result<Option<Vec<String>>, String>,
  help: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::CatShardsMasterTimeout>, String>,
  s: Result<Option<Vec<String>>, String>,
  time: Result<Option<types::Time>, String>,
  v: Result<Option<bool>, String>,
}

impl<'a> CatShards<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      bytes: Ok(None),
      cluster_manager_timeout: Ok(None),
      format: Ok(None),
      h: Ok(None),
      help: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
      s: Ok(None),
      time: Ok(None),
      v: Ok(None),
    }
  }

  pub fn bytes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::Bytes>, {
    self.bytes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Bytes` for bytes failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatShardsClusterManagerTimeout>, {
    self.cluster_manager_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `CatShardsClusterManagerTimeout` for cluster_manager_timeout failed".to_string());
    self
  }

  pub fn format<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.format = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for format failed".to_string());
    self
  }

  pub fn h<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.h = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
    self
  }

  pub fn help<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.help = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for help failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatShardsMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `CatShardsMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn s<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.s = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
    self
  }

  pub fn time<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::Time>, {
    self.time = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Time` for time failed".to_string());
    self
  }

  pub fn v<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.v = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for v failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cat/shards`
  pub async fn send(self) -> Result<ResponseValue<String>, Error<()>> {
    let Self {
      client,
      bytes,
      cluster_manager_timeout,
      format,
      h,
      help,
      local,
      master_timeout,
      s,
      time,
      v,
    } = self;
    let bytes = bytes.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let format = format.map_err(Error::InvalidRequest)?;
    let h = h.map_err(Error::InvalidRequest)?;
    let help = help.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let s = s.map_err(Error::InvalidRequest)?;
    let time = time.map_err(Error::InvalidRequest)?;
    let v = v.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cat/shards", client.baseurl,);
    let mut query = Vec::with_capacity(10usize);
    if let Some(v) = &bytes {
      query.push(("bytes", v.to_string()));
    }
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &format {
      query.push(("format", v.to_string()));
    }
    if let Some(v) = &h {
      query.push(("h", v.join(",")));
    }
    if let Some(v) = &help {
      query.push(("help", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &s {
      query.push(("s", v.join(",")));
    }
    if let Some(v) = &time {
      query.push(("time", v.to_string()));
    }
    if let Some(v) = &v {
      query.push(("v", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::text(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cat_shards_with_index`]
///
///[`Client::cat_shards_with_index`]: super::Client::cat_shards_with_index
#[derive(Debug, Clone)]
pub struct CatShardsWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::CatShardsWithIndexIndex, String>,
  bytes: Result<Option<types::Bytes>, String>,
  cluster_manager_timeout: Result<Option<types::CatShardsWithIndexClusterManagerTimeout>, String>,
  format: Result<Option<String>, String>,
  h: Result<Option<Vec<String>>, String>,
  help: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::CatShardsWithIndexMasterTimeout>, String>,
  s: Result<Option<Vec<String>>, String>,
  time: Result<Option<types::Time>, String>,
  v: Result<Option<bool>, String>,
}

impl<'a> CatShardsWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      bytes: Ok(None),
      cluster_manager_timeout: Ok(None),
      format: Ok(None),
      h: Ok(None),
      help: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
      s: Ok(None),
      time: Ok(None),
      v: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatShardsWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `CatShardsWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn bytes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::Bytes>, {
    self.bytes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Bytes` for bytes failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatShardsWithIndexClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `CatShardsWithIndexClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn format<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.format = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for format failed".to_string());
    self
  }

  pub fn h<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.h = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
    self
  }

  pub fn help<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.help = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for help failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatShardsWithIndexMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `CatShardsWithIndexMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn s<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.s = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
    self
  }

  pub fn time<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::Time>, {
    self.time = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Time` for time failed".to_string());
    self
  }

  pub fn v<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.v = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for v failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cat/shards/{index}`
  pub async fn send(self) -> Result<ResponseValue<String>, Error<()>> {
    let Self {
      client,
      index,
      bytes,
      cluster_manager_timeout,
      format,
      h,
      help,
      local,
      master_timeout,
      s,
      time,
      v,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let bytes = bytes.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let format = format.map_err(Error::InvalidRequest)?;
    let h = h.map_err(Error::InvalidRequest)?;
    let help = help.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let s = s.map_err(Error::InvalidRequest)?;
    let time = time.map_err(Error::InvalidRequest)?;
    let v = v.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cat/shards/{}", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(10usize);
    if let Some(v) = &bytes {
      query.push(("bytes", v.to_string()));
    }
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &format {
      query.push(("format", v.to_string()));
    }
    if let Some(v) = &h {
      query.push(("h", v.join(",")));
    }
    if let Some(v) = &help {
      query.push(("help", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &s {
      query.push(("s", v.join(",")));
    }
    if let Some(v) = &time {
      query.push(("time", v.to_string()));
    }
    if let Some(v) = &v {
      query.push(("v", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::text(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cat_snapshots`]
///
///[`Client::cat_snapshots`]: super::Client::cat_snapshots
#[derive(Debug, Clone)]
pub struct CatSnapshots<'a> {
  client: &'a super::Client,
  cluster_manager_timeout: Result<Option<types::CatSnapshotsClusterManagerTimeout>, String>,
  format: Result<Option<String>, String>,
  h: Result<Option<Vec<String>>, String>,
  help: Result<Option<bool>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::CatSnapshotsMasterTimeout>, String>,
  s: Result<Option<Vec<String>>, String>,
  time: Result<Option<types::Time>, String>,
  v: Result<Option<bool>, String>,
}

impl<'a> CatSnapshots<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      cluster_manager_timeout: Ok(None),
      format: Ok(None),
      h: Ok(None),
      help: Ok(None),
      ignore_unavailable: Ok(None),
      master_timeout: Ok(None),
      s: Ok(None),
      time: Ok(None),
      v: Ok(None),
    }
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatSnapshotsClusterManagerTimeout>, {
    self.cluster_manager_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `CatSnapshotsClusterManagerTimeout` for cluster_manager_timeout failed".to_string());
    self
  }

  pub fn format<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.format = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for format failed".to_string());
    self
  }

  pub fn h<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.h = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
    self
  }

  pub fn help<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.help = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for help failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatSnapshotsMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `CatSnapshotsMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn s<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.s = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
    self
  }

  pub fn time<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::Time>, {
    self.time = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Time` for time failed".to_string());
    self
  }

  pub fn v<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.v = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for v failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cat/snapshots`
  pub async fn send(self) -> Result<ResponseValue<String>, Error<()>> {
    let Self {
      client,
      cluster_manager_timeout,
      format,
      h,
      help,
      ignore_unavailable,
      master_timeout,
      s,
      time,
      v,
    } = self;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let format = format.map_err(Error::InvalidRequest)?;
    let h = h.map_err(Error::InvalidRequest)?;
    let help = help.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let s = s.map_err(Error::InvalidRequest)?;
    let time = time.map_err(Error::InvalidRequest)?;
    let v = v.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cat/snapshots", client.baseurl,);
    let mut query = Vec::with_capacity(9usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &format {
      query.push(("format", v.to_string()));
    }
    if let Some(v) = &h {
      query.push(("h", v.join(",")));
    }
    if let Some(v) = &help {
      query.push(("help", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &s {
      query.push(("s", v.join(",")));
    }
    if let Some(v) = &time {
      query.push(("time", v.to_string()));
    }
    if let Some(v) = &v {
      query.push(("v", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::text(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cat_snapshots_with_repository`]
///
///[`Client::cat_snapshots_with_repository`]: super::Client::cat_snapshots_with_repository
#[derive(Debug, Clone)]
pub struct CatSnapshotsWithRepository<'a> {
  client: &'a super::Client,
  repository: Result<types::CatSnapshotsWithRepositoryRepository, String>,
  cluster_manager_timeout: Result<Option<types::CatSnapshotsWithRepositoryClusterManagerTimeout>, String>,
  format: Result<Option<String>, String>,
  h: Result<Option<Vec<String>>, String>,
  help: Result<Option<bool>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::CatSnapshotsWithRepositoryMasterTimeout>, String>,
  s: Result<Option<Vec<String>>, String>,
  time: Result<Option<types::Time>, String>,
  v: Result<Option<bool>, String>,
}

impl<'a> CatSnapshotsWithRepository<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      repository: Err("repository was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      format: Ok(None),
      h: Ok(None),
      help: Ok(None),
      ignore_unavailable: Ok(None),
      master_timeout: Ok(None),
      s: Ok(None),
      time: Ok(None),
      v: Ok(None),
    }
  }

  pub fn repository<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatSnapshotsWithRepositoryRepository>, {
    self.repository = value
      .try_into()
      .map_err(|_| "conversion to `CatSnapshotsWithRepositoryRepository` for repository failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatSnapshotsWithRepositoryClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `CatSnapshotsWithRepositoryClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn format<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.format = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for format failed".to_string());
    self
  }

  pub fn h<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.h = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
    self
  }

  pub fn help<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.help = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for help failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatSnapshotsWithRepositoryMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `CatSnapshotsWithRepositoryMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn s<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.s = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
    self
  }

  pub fn time<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::Time>, {
    self.time = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Time` for time failed".to_string());
    self
  }

  pub fn v<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.v = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for v failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cat/snapshots/{repository}`
  pub async fn send(self) -> Result<ResponseValue<String>, Error<()>> {
    let Self {
      client,
      repository,
      cluster_manager_timeout,
      format,
      h,
      help,
      ignore_unavailable,
      master_timeout,
      s,
      time,
      v,
    } = self;
    let repository = repository.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let format = format.map_err(Error::InvalidRequest)?;
    let h = h.map_err(Error::InvalidRequest)?;
    let help = help.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let s = s.map_err(Error::InvalidRequest)?;
    let time = time.map_err(Error::InvalidRequest)?;
    let v = v.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_cat/snapshots/{}",
      client.baseurl,
      encode_path(&repository.to_string()),
    );
    let mut query = Vec::with_capacity(9usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &format {
      query.push(("format", v.to_string()));
    }
    if let Some(v) = &h {
      query.push(("h", v.join(",")));
    }
    if let Some(v) = &help {
      query.push(("help", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &s {
      query.push(("s", v.join(",")));
    }
    if let Some(v) = &time {
      query.push(("time", v.to_string()));
    }
    if let Some(v) = &v {
      query.push(("v", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::text(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cat_tasks`]
///
///[`Client::cat_tasks`]: super::Client::cat_tasks
#[derive(Debug, Clone)]
pub struct CatTasks<'a> {
  client: &'a super::Client,
  actions: Result<Option<Vec<String>>, String>,
  detailed: Result<Option<bool>, String>,
  format: Result<Option<String>, String>,
  h: Result<Option<Vec<String>>, String>,
  help: Result<Option<bool>, String>,
  nodes: Result<Option<Vec<String>>, String>,
  parent_task_id: Result<Option<String>, String>,
  s: Result<Option<Vec<String>>, String>,
  time: Result<Option<types::Time>, String>,
  v: Result<Option<bool>, String>,
}

impl<'a> CatTasks<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      actions: Ok(None),
      detailed: Ok(None),
      format: Ok(None),
      h: Ok(None),
      help: Ok(None),
      nodes: Ok(None),
      parent_task_id: Ok(None),
      s: Ok(None),
      time: Ok(None),
      v: Ok(None),
    }
  }

  pub fn actions<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.actions = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for actions failed".to_string());
    self
  }

  pub fn detailed<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.detailed = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for detailed failed".to_string());
    self
  }

  pub fn format<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.format = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for format failed".to_string());
    self
  }

  pub fn h<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.h = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
    self
  }

  pub fn help<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.help = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for help failed".to_string());
    self
  }

  pub fn nodes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.nodes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for nodes failed".to_string());
    self
  }

  pub fn parent_task_id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.parent_task_id = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for parent_task_id failed".to_string());
    self
  }

  pub fn s<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.s = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
    self
  }

  pub fn time<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::Time>, {
    self.time = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Time` for time failed".to_string());
    self
  }

  pub fn v<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.v = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for v failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cat/tasks`
  pub async fn send(self) -> Result<ResponseValue<String>, Error<()>> {
    let Self {
      client,
      actions,
      detailed,
      format,
      h,
      help,
      nodes,
      parent_task_id,
      s,
      time,
      v,
    } = self;
    let actions = actions.map_err(Error::InvalidRequest)?;
    let detailed = detailed.map_err(Error::InvalidRequest)?;
    let format = format.map_err(Error::InvalidRequest)?;
    let h = h.map_err(Error::InvalidRequest)?;
    let help = help.map_err(Error::InvalidRequest)?;
    let nodes = nodes.map_err(Error::InvalidRequest)?;
    let parent_task_id = parent_task_id.map_err(Error::InvalidRequest)?;
    let s = s.map_err(Error::InvalidRequest)?;
    let time = time.map_err(Error::InvalidRequest)?;
    let v = v.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cat/tasks", client.baseurl,);
    let mut query = Vec::with_capacity(10usize);
    if let Some(v) = &actions {
      query.push(("actions", v.join(",")));
    }
    if let Some(v) = &detailed {
      query.push(("detailed", v.to_string()));
    }
    if let Some(v) = &format {
      query.push(("format", v.to_string()));
    }
    if let Some(v) = &h {
      query.push(("h", v.join(",")));
    }
    if let Some(v) = &help {
      query.push(("help", v.to_string()));
    }
    if let Some(v) = &nodes {
      query.push(("nodes", v.join(",")));
    }
    if let Some(v) = &parent_task_id {
      query.push(("parent_task_id", v.to_string()));
    }
    if let Some(v) = &s {
      query.push(("s", v.join(",")));
    }
    if let Some(v) = &time {
      query.push(("time", v.to_string()));
    }
    if let Some(v) = &v {
      query.push(("v", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::text(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cat_templates`]
///
///[`Client::cat_templates`]: super::Client::cat_templates
#[derive(Debug, Clone)]
pub struct CatTemplates<'a> {
  client: &'a super::Client,
  cluster_manager_timeout: Result<Option<types::CatTemplatesClusterManagerTimeout>, String>,
  format: Result<Option<String>, String>,
  h: Result<Option<Vec<String>>, String>,
  help: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::CatTemplatesMasterTimeout>, String>,
  s: Result<Option<Vec<String>>, String>,
  v: Result<Option<bool>, String>,
}

impl<'a> CatTemplates<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      cluster_manager_timeout: Ok(None),
      format: Ok(None),
      h: Ok(None),
      help: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
      s: Ok(None),
      v: Ok(None),
    }
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatTemplatesClusterManagerTimeout>, {
    self.cluster_manager_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `CatTemplatesClusterManagerTimeout` for cluster_manager_timeout failed".to_string());
    self
  }

  pub fn format<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.format = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for format failed".to_string());
    self
  }

  pub fn h<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.h = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
    self
  }

  pub fn help<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.help = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for help failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatTemplatesMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `CatTemplatesMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn s<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.s = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
    self
  }

  pub fn v<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.v = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for v failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cat/templates`
  pub async fn send(self) -> Result<ResponseValue<String>, Error<()>> {
    let Self {
      client,
      cluster_manager_timeout,
      format,
      h,
      help,
      local,
      master_timeout,
      s,
      v,
    } = self;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let format = format.map_err(Error::InvalidRequest)?;
    let h = h.map_err(Error::InvalidRequest)?;
    let help = help.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let s = s.map_err(Error::InvalidRequest)?;
    let v = v.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cat/templates", client.baseurl,);
    let mut query = Vec::with_capacity(8usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &format {
      query.push(("format", v.to_string()));
    }
    if let Some(v) = &h {
      query.push(("h", v.join(",")));
    }
    if let Some(v) = &help {
      query.push(("help", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &s {
      query.push(("s", v.join(",")));
    }
    if let Some(v) = &v {
      query.push(("v", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::text(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cat_templates_with_name`]
///
///[`Client::cat_templates_with_name`]: super::Client::cat_templates_with_name
#[derive(Debug, Clone)]
pub struct CatTemplatesWithName<'a> {
  client: &'a super::Client,
  name: Result<types::CatTemplatesWithNameName, String>,
  cluster_manager_timeout: Result<Option<types::CatTemplatesWithNameClusterManagerTimeout>, String>,
  format: Result<Option<String>, String>,
  h: Result<Option<Vec<String>>, String>,
  help: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::CatTemplatesWithNameMasterTimeout>, String>,
  s: Result<Option<Vec<String>>, String>,
  v: Result<Option<bool>, String>,
}

impl<'a> CatTemplatesWithName<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      name: Err("name was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      format: Ok(None),
      h: Ok(None),
      help: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
      s: Ok(None),
      v: Ok(None),
    }
  }

  pub fn name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatTemplatesWithNameName>, {
    self.name = value
      .try_into()
      .map_err(|_| "conversion to `CatTemplatesWithNameName` for name failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatTemplatesWithNameClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `CatTemplatesWithNameClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn format<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.format = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for format failed".to_string());
    self
  }

  pub fn h<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.h = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
    self
  }

  pub fn help<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.help = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for help failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatTemplatesWithNameMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `CatTemplatesWithNameMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn s<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.s = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
    self
  }

  pub fn v<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.v = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for v failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cat/templates/{name}`
  pub async fn send(self) -> Result<ResponseValue<String>, Error<()>> {
    let Self {
      client,
      name,
      cluster_manager_timeout,
      format,
      h,
      help,
      local,
      master_timeout,
      s,
      v,
    } = self;
    let name = name.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let format = format.map_err(Error::InvalidRequest)?;
    let h = h.map_err(Error::InvalidRequest)?;
    let help = help.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let s = s.map_err(Error::InvalidRequest)?;
    let v = v.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cat/templates/{}", client.baseurl, encode_path(&name.to_string()),);
    let mut query = Vec::with_capacity(8usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &format {
      query.push(("format", v.to_string()));
    }
    if let Some(v) = &h {
      query.push(("h", v.join(",")));
    }
    if let Some(v) = &help {
      query.push(("help", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &s {
      query.push(("s", v.join(",")));
    }
    if let Some(v) = &v {
      query.push(("v", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::text(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cat_thread_pool`]
///
///[`Client::cat_thread_pool`]: super::Client::cat_thread_pool
#[derive(Debug, Clone)]
pub struct CatThreadPool<'a> {
  client: &'a super::Client,
  cluster_manager_timeout: Result<Option<types::CatThreadPoolClusterManagerTimeout>, String>,
  format: Result<Option<String>, String>,
  h: Result<Option<Vec<String>>, String>,
  help: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::CatThreadPoolMasterTimeout>, String>,
  s: Result<Option<Vec<String>>, String>,
  size: Result<Option<i32>, String>,
  v: Result<Option<bool>, String>,
}

impl<'a> CatThreadPool<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      cluster_manager_timeout: Ok(None),
      format: Ok(None),
      h: Ok(None),
      help: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
      s: Ok(None),
      size: Ok(None),
      v: Ok(None),
    }
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatThreadPoolClusterManagerTimeout>, {
    self.cluster_manager_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `CatThreadPoolClusterManagerTimeout` for cluster_manager_timeout failed".to_string());
    self
  }

  pub fn format<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.format = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for format failed".to_string());
    self
  }

  pub fn h<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.h = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
    self
  }

  pub fn help<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.help = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for help failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatThreadPoolMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `CatThreadPoolMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn s<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.s = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
    self
  }

  pub fn size<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.size = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for size failed".to_string());
    self
  }

  pub fn v<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.v = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for v failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cat/thread_pool`
  pub async fn send(self) -> Result<ResponseValue<String>, Error<()>> {
    let Self {
      client,
      cluster_manager_timeout,
      format,
      h,
      help,
      local,
      master_timeout,
      s,
      size,
      v,
    } = self;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let format = format.map_err(Error::InvalidRequest)?;
    let h = h.map_err(Error::InvalidRequest)?;
    let help = help.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let s = s.map_err(Error::InvalidRequest)?;
    let size = size.map_err(Error::InvalidRequest)?;
    let v = v.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cat/thread_pool", client.baseurl,);
    let mut query = Vec::with_capacity(9usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &format {
      query.push(("format", v.to_string()));
    }
    if let Some(v) = &h {
      query.push(("h", v.join(",")));
    }
    if let Some(v) = &help {
      query.push(("help", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &s {
      query.push(("s", v.join(",")));
    }
    if let Some(v) = &size {
      query.push(("size", v.to_string()));
    }
    if let Some(v) = &v {
      query.push(("v", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::text(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cat_thread_pool_with_thread_pool_patterns`]
///
///[`Client::cat_thread_pool_with_thread_pool_patterns`]: super::Client::cat_thread_pool_with_thread_pool_patterns
#[derive(Debug, Clone)]
pub struct CatThreadPoolWithThreadPoolPatterns<'a> {
  client: &'a super::Client,
  thread_pool_patterns: Result<types::CatThreadPoolWithThreadPoolPatternsThreadPoolPatterns, String>,
  cluster_manager_timeout: Result<Option<types::CatThreadPoolWithThreadPoolPatternsClusterManagerTimeout>, String>,
  format: Result<Option<String>, String>,
  h: Result<Option<Vec<String>>, String>,
  help: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::CatThreadPoolWithThreadPoolPatternsMasterTimeout>, String>,
  s: Result<Option<Vec<String>>, String>,
  size: Result<Option<i32>, String>,
  v: Result<Option<bool>, String>,
}

impl<'a> CatThreadPoolWithThreadPoolPatterns<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      thread_pool_patterns: Err("thread_pool_patterns was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      format: Ok(None),
      h: Ok(None),
      help: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
      s: Ok(None),
      size: Ok(None),
      v: Ok(None),
    }
  }

  pub fn thread_pool_patterns<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatThreadPoolWithThreadPoolPatternsThreadPoolPatterns>, {
    self.thread_pool_patterns = value.try_into().map_err(|_| {
      "conversion to `CatThreadPoolWithThreadPoolPatternsThreadPoolPatterns` for thread_pool_patterns failed"
        .to_string()
    });
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatThreadPoolWithThreadPoolPatternsClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `CatThreadPoolWithThreadPoolPatternsClusterManagerTimeout` for cluster_manager_timeout failed"
        .to_string()
    });
    self
  }

  pub fn format<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.format = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for format failed".to_string());
    self
  }

  pub fn h<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.h = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
    self
  }

  pub fn help<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.help = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for help failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CatThreadPoolWithThreadPoolPatternsMasterTimeout>, {
    self.master_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `CatThreadPoolWithThreadPoolPatternsMasterTimeout` for master_timeout failed".to_string()
    });
    self
  }

  pub fn s<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.s = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
    self
  }

  pub fn size<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.size = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for size failed".to_string());
    self
  }

  pub fn v<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.v = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for v failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cat/thread_pool/{thread_pool_patterns}`
  pub async fn send(self) -> Result<ResponseValue<String>, Error<()>> {
    let Self {
      client,
      thread_pool_patterns,
      cluster_manager_timeout,
      format,
      h,
      help,
      local,
      master_timeout,
      s,
      size,
      v,
    } = self;
    let thread_pool_patterns = thread_pool_patterns.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let format = format.map_err(Error::InvalidRequest)?;
    let h = h.map_err(Error::InvalidRequest)?;
    let help = help.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let s = s.map_err(Error::InvalidRequest)?;
    let size = size.map_err(Error::InvalidRequest)?;
    let v = v.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_cat/thread_pool/{}",
      client.baseurl,
      encode_path(&thread_pool_patterns.to_string()),
    );
    let mut query = Vec::with_capacity(9usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &format {
      query.push(("format", v.to_string()));
    }
    if let Some(v) = &h {
      query.push(("h", v.join(",")));
    }
    if let Some(v) = &help {
      query.push(("help", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &s {
      query.push(("s", v.join(",")));
    }
    if let Some(v) = &size {
      query.push(("size", v.to_string()));
    }
    if let Some(v) = &v {
      query.push(("v", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::text(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cluster_allocation_explain_get`]
///
///[`Client::cluster_allocation_explain_get`]: super::Client::cluster_allocation_explain_get
#[derive(Debug, Clone)]
pub struct ClusterAllocationExplainGet<'a> {
  client: &'a super::Client,
  include_disk_info: Result<Option<bool>, String>,
  include_yes_decisions: Result<Option<bool>, String>,
}

impl<'a> ClusterAllocationExplainGet<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      include_disk_info: Ok(None),
      include_yes_decisions: Ok(None),
    }
  }

  pub fn include_disk_info<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.include_disk_info = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for include_disk_info failed".to_string());
    self
  }

  pub fn include_yes_decisions<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.include_yes_decisions = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for include_yes_decisions failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cluster/allocation/explain`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      include_disk_info,
      include_yes_decisions,
    } = self;
    let include_disk_info = include_disk_info.map_err(Error::InvalidRequest)?;
    let include_yes_decisions = include_yes_decisions.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cluster/allocation/explain", client.baseurl,);
    let mut query = Vec::with_capacity(2usize);
    if let Some(v) = &include_disk_info {
      query.push(("include_disk_info", v.to_string()));
    }
    if let Some(v) = &include_yes_decisions {
      query.push(("include_yes_decisions", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cluster_allocation_explain_post`]
///
///[`Client::cluster_allocation_explain_post`]: super::Client::cluster_allocation_explain_post
#[derive(Debug, Clone)]
pub struct ClusterAllocationExplainPost<'a> {
  client: &'a super::Client,
  include_disk_info: Result<Option<bool>, String>,
  include_yes_decisions: Result<Option<bool>, String>,
  body: Result<types::ClusterAllocationExplainBodyParams, String>,
}

impl<'a> ClusterAllocationExplainPost<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      include_disk_info: Ok(None),
      include_yes_decisions: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn include_disk_info<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.include_disk_info = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for include_disk_info failed".to_string());
    self
  }

  pub fn include_yes_decisions<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.include_yes_decisions = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for include_yes_decisions failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterAllocationExplainBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `ClusterAllocationExplainBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_cluster/allocation/explain`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      include_disk_info,
      include_yes_decisions,
      body,
    } = self;
    let include_disk_info = include_disk_info.map_err(Error::InvalidRequest)?;
    let include_yes_decisions = include_yes_decisions.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cluster/allocation/explain", client.baseurl,);
    let mut query = Vec::with_capacity(2usize);
    if let Some(v) = &include_disk_info {
      query.push(("include_disk_info", v.to_string()));
    }
    if let Some(v) = &include_yes_decisions {
      query.push(("include_yes_decisions", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cluster_delete_decommission_awareness`]
///
///[`Client::cluster_delete_decommission_awareness`]: super::Client::cluster_delete_decommission_awareness
#[derive(Debug, Clone)]
pub struct ClusterDeleteDecommissionAwareness<'a> {
  client: &'a super::Client,
}

impl<'a> ClusterDeleteDecommissionAwareness<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self { client }
  }

  ///Sends a `DELETE` request to `/_cluster/decommission/awareness/`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self { client } = self;
    let url = format!("{}/_cluster/decommission/awareness/", client.baseurl,);
    let request = client.client.delete(url).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cluster_get_decommission_awareness`]
///
///[`Client::cluster_get_decommission_awareness`]: super::Client::cluster_get_decommission_awareness
#[derive(Debug, Clone)]
pub struct ClusterGetDecommissionAwareness<'a> {
  client: &'a super::Client,
  awareness_attribute_name: Result<types::ClusterGetDecommissionAwarenessAwarenessAttributeName, String>,
}

impl<'a> ClusterGetDecommissionAwareness<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      awareness_attribute_name: Err("awareness_attribute_name was not initialized".to_string()),
    }
  }

  pub fn awareness_attribute_name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterGetDecommissionAwarenessAwarenessAttributeName>, {
    self.awareness_attribute_name = value.try_into().map_err(|_| {
      "conversion to `ClusterGetDecommissionAwarenessAwarenessAttributeName` for awareness_attribute_name failed"
        .to_string()
    });
    self
  }

  ///Sends a `GET` request to
  /// `/_cluster/decommission/awareness/{awareness_attribute_name}/
  /// _status`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      awareness_attribute_name,
    } = self;
    let awareness_attribute_name = awareness_attribute_name.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_cluster/decommission/awareness/{}/_status",
      client.baseurl,
      encode_path(&awareness_attribute_name.to_string()),
    );
    let request = client.client.get(url).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cluster_put_decommission_awareness`]
///
///[`Client::cluster_put_decommission_awareness`]: super::Client::cluster_put_decommission_awareness
#[derive(Debug, Clone)]
pub struct ClusterPutDecommissionAwareness<'a> {
  client: &'a super::Client,
  awareness_attribute_name: Result<types::ClusterPutDecommissionAwarenessAwarenessAttributeName, String>,
  awareness_attribute_value: Result<types::ClusterPutDecommissionAwarenessAwarenessAttributeValue, String>,
}

impl<'a> ClusterPutDecommissionAwareness<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      awareness_attribute_name: Err("awareness_attribute_name was not initialized".to_string()),
      awareness_attribute_value: Err("awareness_attribute_value was not initialized".to_string()),
    }
  }

  pub fn awareness_attribute_name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterPutDecommissionAwarenessAwarenessAttributeName>, {
    self.awareness_attribute_name = value.try_into().map_err(|_| {
      "conversion to `ClusterPutDecommissionAwarenessAwarenessAttributeName` for awareness_attribute_name failed"
        .to_string()
    });
    self
  }

  pub fn awareness_attribute_value<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterPutDecommissionAwarenessAwarenessAttributeValue>, {
    self.awareness_attribute_value = value.try_into().map_err(|_| {
      "conversion to `ClusterPutDecommissionAwarenessAwarenessAttributeValue` for awareness_attribute_value failed"
        .to_string()
    });
    self
  }

  ///Sends a `PUT` request to
  /// `/_cluster/decommission/awareness/{awareness_attribute_name}/
  /// {awareness_attribute_value}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      awareness_attribute_name,
      awareness_attribute_value,
    } = self;
    let awareness_attribute_name = awareness_attribute_name.map_err(Error::InvalidRequest)?;
    let awareness_attribute_value = awareness_attribute_value.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_cluster/decommission/awareness/{}/{}",
      client.baseurl,
      encode_path(&awareness_attribute_name.to_string()),
      encode_path(&awareness_attribute_value.to_string()),
    );
    let request = client.client.put(url).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cluster_health`]
///
///[`Client::cluster_health`]: super::Client::cluster_health
#[derive(Debug, Clone)]
pub struct ClusterHealth<'a> {
  client: &'a super::Client,
  awareness_attribute: Result<Option<String>, String>,
  cluster_manager_timeout: Result<Option<types::ClusterHealthClusterManagerTimeout>, String>,
  ensure_node_commissioned: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  level: Result<Option<types::ClusterHealthLevel>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::ClusterHealthMasterTimeout>, String>,
  timeout: Result<Option<types::ClusterHealthTimeout>, String>,
  wait_for_active_shards: Result<Option<String>, String>,
  wait_for_events: Result<Option<types::WaitForEvents>, String>,
  wait_for_no_initializing_shards: Result<Option<bool>, String>,
  wait_for_no_relocating_shards: Result<Option<bool>, String>,
  wait_for_nodes: Result<Option<String>, String>,
  wait_for_status: Result<Option<types::WaitForStatus>, String>,
}

impl<'a> ClusterHealth<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      awareness_attribute: Ok(None),
      cluster_manager_timeout: Ok(None),
      ensure_node_commissioned: Ok(None),
      expand_wildcards: Ok(None),
      level: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
      wait_for_active_shards: Ok(None),
      wait_for_events: Ok(None),
      wait_for_no_initializing_shards: Ok(None),
      wait_for_no_relocating_shards: Ok(None),
      wait_for_nodes: Ok(None),
      wait_for_status: Ok(None),
    }
  }

  pub fn awareness_attribute<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.awareness_attribute = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for awareness_attribute failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterHealthClusterManagerTimeout>, {
    self.cluster_manager_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ClusterHealthClusterManagerTimeout` for cluster_manager_timeout failed".to_string());
    self
  }

  pub fn ensure_node_commissioned<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ensure_node_commissioned = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ensure_node_commissioned failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn level<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterHealthLevel>, {
    self.level = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ClusterHealthLevel` for level failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterHealthMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ClusterHealthMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterHealthTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ClusterHealthTimeout` for timeout failed".to_string());
    self
  }

  pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.wait_for_active_shards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for wait_for_active_shards failed".to_string());
    self
  }

  pub fn wait_for_events<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::WaitForEvents>, {
    self.wait_for_events = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `WaitForEvents` for wait_for_events failed".to_string());
    self
  }

  pub fn wait_for_no_initializing_shards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.wait_for_no_initializing_shards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for wait_for_no_initializing_shards failed".to_string());
    self
  }

  pub fn wait_for_no_relocating_shards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.wait_for_no_relocating_shards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for wait_for_no_relocating_shards failed".to_string());
    self
  }

  pub fn wait_for_nodes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.wait_for_nodes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for wait_for_nodes failed".to_string());
    self
  }

  pub fn wait_for_status<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::WaitForStatus>, {
    self.wait_for_status = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `WaitForStatus` for wait_for_status failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cluster/health`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      awareness_attribute,
      cluster_manager_timeout,
      ensure_node_commissioned,
      expand_wildcards,
      level,
      local,
      master_timeout,
      timeout,
      wait_for_active_shards,
      wait_for_events,
      wait_for_no_initializing_shards,
      wait_for_no_relocating_shards,
      wait_for_nodes,
      wait_for_status,
    } = self;
    let awareness_attribute = awareness_attribute.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let ensure_node_commissioned = ensure_node_commissioned.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let level = level.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
    let wait_for_events = wait_for_events.map_err(Error::InvalidRequest)?;
    let wait_for_no_initializing_shards = wait_for_no_initializing_shards.map_err(Error::InvalidRequest)?;
    let wait_for_no_relocating_shards = wait_for_no_relocating_shards.map_err(Error::InvalidRequest)?;
    let wait_for_nodes = wait_for_nodes.map_err(Error::InvalidRequest)?;
    let wait_for_status = wait_for_status.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cluster/health", client.baseurl,);
    let mut query = Vec::with_capacity(14usize);
    if let Some(v) = &awareness_attribute {
      query.push(("awareness_attribute", v.to_string()));
    }
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &ensure_node_commissioned {
      query.push(("ensure_node_commissioned", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &level {
      query.push(("level", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &wait_for_active_shards {
      query.push(("wait_for_active_shards", v.to_string()));
    }
    if let Some(v) = &wait_for_events {
      query.push(("wait_for_events", v.to_string()));
    }
    if let Some(v) = &wait_for_no_initializing_shards {
      query.push(("wait_for_no_initializing_shards", v.to_string()));
    }
    if let Some(v) = &wait_for_no_relocating_shards {
      query.push(("wait_for_no_relocating_shards", v.to_string()));
    }
    if let Some(v) = &wait_for_nodes {
      query.push(("wait_for_nodes", v.to_string()));
    }
    if let Some(v) = &wait_for_status {
      query.push(("wait_for_status", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cluster_health_with_index`]
///
///[`Client::cluster_health_with_index`]: super::Client::cluster_health_with_index
#[derive(Debug, Clone)]
pub struct ClusterHealthWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::ClusterHealthWithIndexIndex, String>,
  awareness_attribute: Result<Option<String>, String>,
  cluster_manager_timeout: Result<Option<types::ClusterHealthWithIndexClusterManagerTimeout>, String>,
  ensure_node_commissioned: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  level: Result<Option<types::ClusterHealthLevel>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::ClusterHealthWithIndexMasterTimeout>, String>,
  timeout: Result<Option<types::ClusterHealthWithIndexTimeout>, String>,
  wait_for_active_shards: Result<Option<String>, String>,
  wait_for_events: Result<Option<types::WaitForEvents>, String>,
  wait_for_no_initializing_shards: Result<Option<bool>, String>,
  wait_for_no_relocating_shards: Result<Option<bool>, String>,
  wait_for_nodes: Result<Option<String>, String>,
  wait_for_status: Result<Option<types::WaitForStatus>, String>,
}

impl<'a> ClusterHealthWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      awareness_attribute: Ok(None),
      cluster_manager_timeout: Ok(None),
      ensure_node_commissioned: Ok(None),
      expand_wildcards: Ok(None),
      level: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
      wait_for_active_shards: Ok(None),
      wait_for_events: Ok(None),
      wait_for_no_initializing_shards: Ok(None),
      wait_for_no_relocating_shards: Ok(None),
      wait_for_nodes: Ok(None),
      wait_for_status: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterHealthWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `ClusterHealthWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn awareness_attribute<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.awareness_attribute = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for awareness_attribute failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterHealthWithIndexClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `ClusterHealthWithIndexClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn ensure_node_commissioned<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ensure_node_commissioned = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ensure_node_commissioned failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn level<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterHealthLevel>, {
    self.level = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ClusterHealthLevel` for level failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterHealthWithIndexMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ClusterHealthWithIndexMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterHealthWithIndexTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ClusterHealthWithIndexTimeout` for timeout failed".to_string());
    self
  }

  pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.wait_for_active_shards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for wait_for_active_shards failed".to_string());
    self
  }

  pub fn wait_for_events<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::WaitForEvents>, {
    self.wait_for_events = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `WaitForEvents` for wait_for_events failed".to_string());
    self
  }

  pub fn wait_for_no_initializing_shards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.wait_for_no_initializing_shards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for wait_for_no_initializing_shards failed".to_string());
    self
  }

  pub fn wait_for_no_relocating_shards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.wait_for_no_relocating_shards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for wait_for_no_relocating_shards failed".to_string());
    self
  }

  pub fn wait_for_nodes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.wait_for_nodes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for wait_for_nodes failed".to_string());
    self
  }

  pub fn wait_for_status<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::WaitForStatus>, {
    self.wait_for_status = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `WaitForStatus` for wait_for_status failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cluster/health/{index}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      awareness_attribute,
      cluster_manager_timeout,
      ensure_node_commissioned,
      expand_wildcards,
      level,
      local,
      master_timeout,
      timeout,
      wait_for_active_shards,
      wait_for_events,
      wait_for_no_initializing_shards,
      wait_for_no_relocating_shards,
      wait_for_nodes,
      wait_for_status,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let awareness_attribute = awareness_attribute.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let ensure_node_commissioned = ensure_node_commissioned.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let level = level.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
    let wait_for_events = wait_for_events.map_err(Error::InvalidRequest)?;
    let wait_for_no_initializing_shards = wait_for_no_initializing_shards.map_err(Error::InvalidRequest)?;
    let wait_for_no_relocating_shards = wait_for_no_relocating_shards.map_err(Error::InvalidRequest)?;
    let wait_for_nodes = wait_for_nodes.map_err(Error::InvalidRequest)?;
    let wait_for_status = wait_for_status.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cluster/health/{}", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(14usize);
    if let Some(v) = &awareness_attribute {
      query.push(("awareness_attribute", v.to_string()));
    }
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &ensure_node_commissioned {
      query.push(("ensure_node_commissioned", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &level {
      query.push(("level", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &wait_for_active_shards {
      query.push(("wait_for_active_shards", v.to_string()));
    }
    if let Some(v) = &wait_for_events {
      query.push(("wait_for_events", v.to_string()));
    }
    if let Some(v) = &wait_for_no_initializing_shards {
      query.push(("wait_for_no_initializing_shards", v.to_string()));
    }
    if let Some(v) = &wait_for_no_relocating_shards {
      query.push(("wait_for_no_relocating_shards", v.to_string()));
    }
    if let Some(v) = &wait_for_nodes {
      query.push(("wait_for_nodes", v.to_string()));
    }
    if let Some(v) = &wait_for_status {
      query.push(("wait_for_status", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::nodes_hot_threads_deprecated_dash`]
///
///[`Client::nodes_hot_threads_deprecated_dash`]: super::Client::nodes_hot_threads_deprecated_dash
#[derive(Debug, Clone)]
pub struct NodesHotThreadsDeprecatedDash<'a> {
  client: &'a super::Client,
  ignore_idle_threads: Result<Option<bool>, String>,
  interval: Result<Option<types::NodesHotThreadsDeprecatedDashInterval>, String>,
  snapshots: Result<Option<i32>, String>,
  threads: Result<Option<i32>, String>,
  timeout: Result<Option<types::NodesHotThreadsDeprecatedDashTimeout>, String>,
  type_: Result<Option<types::SampleType>, String>,
}

impl<'a> NodesHotThreadsDeprecatedDash<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      ignore_idle_threads: Ok(None),
      interval: Ok(None),
      snapshots: Ok(None),
      threads: Ok(None),
      timeout: Ok(None),
      type_: Ok(None),
    }
  }

  pub fn ignore_idle_threads<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_idle_threads = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_idle_threads failed".to_string());
    self
  }

  pub fn interval<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesHotThreadsDeprecatedDashInterval>, {
    self.interval = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `NodesHotThreadsDeprecatedDashInterval` for interval failed".to_string());
    self
  }

  pub fn snapshots<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.snapshots = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for snapshots failed".to_string());
    self
  }

  pub fn threads<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.threads = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for threads failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesHotThreadsDeprecatedDashTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `NodesHotThreadsDeprecatedDashTimeout` for timeout failed".to_string());
    self
  }

  pub fn type_<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SampleType>, {
    self.type_ = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SampleType` for type_ failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cluster/nodes/hot_threads`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      ignore_idle_threads,
      interval,
      snapshots,
      threads,
      timeout,
      type_,
    } = self;
    let ignore_idle_threads = ignore_idle_threads.map_err(Error::InvalidRequest)?;
    let interval = interval.map_err(Error::InvalidRequest)?;
    let snapshots = snapshots.map_err(Error::InvalidRequest)?;
    let threads = threads.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let type_ = type_.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cluster/nodes/hot_threads", client.baseurl,);
    let mut query = Vec::with_capacity(6usize);
    if let Some(v) = &ignore_idle_threads {
      query.push(("ignore_idle_threads", v.to_string()));
    }
    if let Some(v) = &interval {
      query.push(("interval", v.to_string()));
    }
    if let Some(v) = &snapshots {
      query.push(("snapshots", v.to_string()));
    }
    if let Some(v) = &threads {
      query.push(("threads", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &type_ {
      query.push(("type", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::nodes_hot_threads_deprecated_cluster`]
///
///[`Client::nodes_hot_threads_deprecated_cluster`]: super::Client::nodes_hot_threads_deprecated_cluster
#[derive(Debug, Clone)]
pub struct NodesHotThreadsDeprecatedCluster<'a> {
  client: &'a super::Client,
  ignore_idle_threads: Result<Option<bool>, String>,
  interval: Result<Option<types::NodesHotThreadsDeprecatedClusterInterval>, String>,
  snapshots: Result<Option<i32>, String>,
  threads: Result<Option<i32>, String>,
  timeout: Result<Option<types::NodesHotThreadsDeprecatedClusterTimeout>, String>,
  type_: Result<Option<types::SampleType>, String>,
}

impl<'a> NodesHotThreadsDeprecatedCluster<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      ignore_idle_threads: Ok(None),
      interval: Ok(None),
      snapshots: Ok(None),
      threads: Ok(None),
      timeout: Ok(None),
      type_: Ok(None),
    }
  }

  pub fn ignore_idle_threads<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_idle_threads = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_idle_threads failed".to_string());
    self
  }

  pub fn interval<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesHotThreadsDeprecatedClusterInterval>, {
    self.interval = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `NodesHotThreadsDeprecatedClusterInterval` for interval failed".to_string());
    self
  }

  pub fn snapshots<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.snapshots = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for snapshots failed".to_string());
    self
  }

  pub fn threads<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.threads = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for threads failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesHotThreadsDeprecatedClusterTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `NodesHotThreadsDeprecatedClusterTimeout` for timeout failed".to_string());
    self
  }

  pub fn type_<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SampleType>, {
    self.type_ = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SampleType` for type_ failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cluster/nodes/hotthreads`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      ignore_idle_threads,
      interval,
      snapshots,
      threads,
      timeout,
      type_,
    } = self;
    let ignore_idle_threads = ignore_idle_threads.map_err(Error::InvalidRequest)?;
    let interval = interval.map_err(Error::InvalidRequest)?;
    let snapshots = snapshots.map_err(Error::InvalidRequest)?;
    let threads = threads.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let type_ = type_.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cluster/nodes/hotthreads", client.baseurl,);
    let mut query = Vec::with_capacity(6usize);
    if let Some(v) = &ignore_idle_threads {
      query.push(("ignore_idle_threads", v.to_string()));
    }
    if let Some(v) = &interval {
      query.push(("interval", v.to_string()));
    }
    if let Some(v) = &snapshots {
      query.push(("snapshots", v.to_string()));
    }
    if let Some(v) = &threads {
      query.push(("threads", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &type_ {
      query.push(("type", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::nodes_hot_threads_with_node_id_deprecated_dash`]
///
///[`Client::nodes_hot_threads_with_node_id_deprecated_dash`]: super::Client::nodes_hot_threads_with_node_id_deprecated_dash
#[derive(Debug, Clone)]
pub struct NodesHotThreadsWithNodeIdDeprecatedDash<'a> {
  client: &'a super::Client,
  node_id: Result<types::NodesHotThreadsWithNodeIdDeprecatedDashNodeId, String>,
  ignore_idle_threads: Result<Option<bool>, String>,
  interval: Result<Option<types::NodesHotThreadsWithNodeIdDeprecatedDashInterval>, String>,
  snapshots: Result<Option<i32>, String>,
  threads: Result<Option<i32>, String>,
  timeout: Result<Option<types::NodesHotThreadsWithNodeIdDeprecatedDashTimeout>, String>,
  type_: Result<Option<types::SampleType>, String>,
}

impl<'a> NodesHotThreadsWithNodeIdDeprecatedDash<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      node_id: Err("node_id was not initialized".to_string()),
      ignore_idle_threads: Ok(None),
      interval: Ok(None),
      snapshots: Ok(None),
      threads: Ok(None),
      timeout: Ok(None),
      type_: Ok(None),
    }
  }

  pub fn node_id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesHotThreadsWithNodeIdDeprecatedDashNodeId>, {
    self.node_id = value
      .try_into()
      .map_err(|_| "conversion to `NodesHotThreadsWithNodeIdDeprecatedDashNodeId` for node_id failed".to_string());
    self
  }

  pub fn ignore_idle_threads<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_idle_threads = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_idle_threads failed".to_string());
    self
  }

  pub fn interval<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesHotThreadsWithNodeIdDeprecatedDashInterval>, {
    self.interval = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `NodesHotThreadsWithNodeIdDeprecatedDashInterval` for interval failed".to_string());
    self
  }

  pub fn snapshots<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.snapshots = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for snapshots failed".to_string());
    self
  }

  pub fn threads<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.threads = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for threads failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesHotThreadsWithNodeIdDeprecatedDashTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `NodesHotThreadsWithNodeIdDeprecatedDashTimeout` for timeout failed".to_string());
    self
  }

  pub fn type_<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SampleType>, {
    self.type_ = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SampleType` for type_ failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cluster/nodes/{node_id}/hot_threads`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      node_id,
      ignore_idle_threads,
      interval,
      snapshots,
      threads,
      timeout,
      type_,
    } = self;
    let node_id = node_id.map_err(Error::InvalidRequest)?;
    let ignore_idle_threads = ignore_idle_threads.map_err(Error::InvalidRequest)?;
    let interval = interval.map_err(Error::InvalidRequest)?;
    let snapshots = snapshots.map_err(Error::InvalidRequest)?;
    let threads = threads.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let type_ = type_.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_cluster/nodes/{}/hot_threads",
      client.baseurl,
      encode_path(&node_id.to_string()),
    );
    let mut query = Vec::with_capacity(6usize);
    if let Some(v) = &ignore_idle_threads {
      query.push(("ignore_idle_threads", v.to_string()));
    }
    if let Some(v) = &interval {
      query.push(("interval", v.to_string()));
    }
    if let Some(v) = &snapshots {
      query.push(("snapshots", v.to_string()));
    }
    if let Some(v) = &threads {
      query.push(("threads", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &type_ {
      query.push(("type", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for
/// [`Client::nodes_hot_threads_with_node_id_deprecated_cluster`]
///
///[`Client::nodes_hot_threads_with_node_id_deprecated_cluster`]: super::Client::nodes_hot_threads_with_node_id_deprecated_cluster
#[derive(Debug, Clone)]
pub struct NodesHotThreadsWithNodeIdDeprecatedCluster<'a> {
  client: &'a super::Client,
  node_id: Result<types::NodesHotThreadsWithNodeIdDeprecatedClusterNodeId, String>,
  ignore_idle_threads: Result<Option<bool>, String>,
  interval: Result<Option<types::NodesHotThreadsWithNodeIdDeprecatedClusterInterval>, String>,
  snapshots: Result<Option<i32>, String>,
  threads: Result<Option<i32>, String>,
  timeout: Result<Option<types::NodesHotThreadsWithNodeIdDeprecatedClusterTimeout>, String>,
  type_: Result<Option<types::SampleType>, String>,
}

impl<'a> NodesHotThreadsWithNodeIdDeprecatedCluster<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      node_id: Err("node_id was not initialized".to_string()),
      ignore_idle_threads: Ok(None),
      interval: Ok(None),
      snapshots: Ok(None),
      threads: Ok(None),
      timeout: Ok(None),
      type_: Ok(None),
    }
  }

  pub fn node_id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesHotThreadsWithNodeIdDeprecatedClusterNodeId>, {
    self.node_id = value
      .try_into()
      .map_err(|_| "conversion to `NodesHotThreadsWithNodeIdDeprecatedClusterNodeId` for node_id failed".to_string());
    self
  }

  pub fn ignore_idle_threads<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_idle_threads = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_idle_threads failed".to_string());
    self
  }

  pub fn interval<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesHotThreadsWithNodeIdDeprecatedClusterInterval>, {
    self.interval = value.try_into().map(Some).map_err(|_| {
      "conversion to `NodesHotThreadsWithNodeIdDeprecatedClusterInterval` for interval failed".to_string()
    });
    self
  }

  pub fn snapshots<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.snapshots = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for snapshots failed".to_string());
    self
  }

  pub fn threads<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.threads = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for threads failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesHotThreadsWithNodeIdDeprecatedClusterTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `NodesHotThreadsWithNodeIdDeprecatedClusterTimeout` for timeout failed".to_string());
    self
  }

  pub fn type_<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SampleType>, {
    self.type_ = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SampleType` for type_ failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cluster/nodes/{node_id}/hotthreads`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      node_id,
      ignore_idle_threads,
      interval,
      snapshots,
      threads,
      timeout,
      type_,
    } = self;
    let node_id = node_id.map_err(Error::InvalidRequest)?;
    let ignore_idle_threads = ignore_idle_threads.map_err(Error::InvalidRequest)?;
    let interval = interval.map_err(Error::InvalidRequest)?;
    let snapshots = snapshots.map_err(Error::InvalidRequest)?;
    let threads = threads.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let type_ = type_.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_cluster/nodes/{}/hotthreads",
      client.baseurl,
      encode_path(&node_id.to_string()),
    );
    let mut query = Vec::with_capacity(6usize);
    if let Some(v) = &ignore_idle_threads {
      query.push(("ignore_idle_threads", v.to_string()));
    }
    if let Some(v) = &interval {
      query.push(("interval", v.to_string()));
    }
    if let Some(v) = &snapshots {
      query.push(("snapshots", v.to_string()));
    }
    if let Some(v) = &threads {
      query.push(("threads", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &type_ {
      query.push(("type", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cluster_pending_tasks`]
///
///[`Client::cluster_pending_tasks`]: super::Client::cluster_pending_tasks
#[derive(Debug, Clone)]
pub struct ClusterPendingTasks<'a> {
  client: &'a super::Client,
  cluster_manager_timeout: Result<Option<types::ClusterPendingTasksClusterManagerTimeout>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::ClusterPendingTasksMasterTimeout>, String>,
}

impl<'a> ClusterPendingTasks<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      cluster_manager_timeout: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
    }
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterPendingTasksClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `ClusterPendingTasksClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterPendingTasksMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ClusterPendingTasksMasterTimeout` for master_timeout failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cluster/pending_tasks`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      cluster_manager_timeout,
      local,
      master_timeout,
    } = self;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cluster/pending_tasks", client.baseurl,);
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cluster_reroute`]
///
///[`Client::cluster_reroute`]: super::Client::cluster_reroute
#[derive(Debug, Clone)]
pub struct ClusterReroute<'a> {
  client: &'a super::Client,
  cluster_manager_timeout: Result<Option<types::ClusterRerouteClusterManagerTimeout>, String>,
  dry_run: Result<Option<bool>, String>,
  explain: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::ClusterRerouteMasterTimeout>, String>,
  metric: Result<Option<Vec<types::ClusterRerouteMetricMember>>, String>,
  retry_failed: Result<Option<bool>, String>,
  timeout: Result<Option<types::ClusterRerouteTimeout>, String>,
  body: Result<types::ClusterRerouteBodyParams, String>,
}

impl<'a> ClusterReroute<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      cluster_manager_timeout: Ok(None),
      dry_run: Ok(None),
      explain: Ok(None),
      master_timeout: Ok(None),
      metric: Ok(None),
      retry_failed: Ok(None),
      timeout: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterRerouteClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `ClusterRerouteClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn dry_run<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.dry_run = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for dry_run failed".to_string());
    self
  }

  pub fn explain<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.explain = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for explain failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterRerouteMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ClusterRerouteMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn metric<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<types::ClusterRerouteMetricMember>>, {
    self.metric = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < ClusterRerouteMetricMember >` for metric failed".to_string());
    self
  }

  pub fn retry_failed<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.retry_failed = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for retry_failed failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterRerouteTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ClusterRerouteTimeout` for timeout failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterRerouteBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `ClusterRerouteBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_cluster/reroute`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      cluster_manager_timeout,
      dry_run,
      explain,
      master_timeout,
      metric,
      retry_failed,
      timeout,
      body,
    } = self;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let dry_run = dry_run.map_err(Error::InvalidRequest)?;
    let explain = explain.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let metric = metric.map_err(Error::InvalidRequest)?;
    let retry_failed = retry_failed.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cluster/reroute", client.baseurl,);
    let mut query = Vec::with_capacity(7usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &dry_run {
      query.push(("dry_run", v.to_string()));
    }
    if let Some(v) = &explain {
      query.push(("explain", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    // if let Some(v) = &metric {
    //   query.push(("metric", v.into_iter().map(|p|
    // p.to_string()).collect().join(","))); }
    if let Some(v) = &retry_failed {
      query.push(("retry_failed", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cluster_delete_weighted_routing`]
///
///[`Client::cluster_delete_weighted_routing`]: super::Client::cluster_delete_weighted_routing
#[derive(Debug, Clone)]
pub struct ClusterDeleteWeightedRouting<'a> {
  client: &'a super::Client,
}

impl<'a> ClusterDeleteWeightedRouting<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self { client }
  }

  ///Sends a `DELETE` request to `/_cluster/routing/awareness/weights`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self { client } = self;
    let url = format!("{}/_cluster/routing/awareness/weights", client.baseurl,);
    let request = client.client.delete(url).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cluster_get_weighted_routing`]
///
///[`Client::cluster_get_weighted_routing`]: super::Client::cluster_get_weighted_routing
#[derive(Debug, Clone)]
pub struct ClusterGetWeightedRouting<'a> {
  client: &'a super::Client,
  attribute: Result<types::ClusterGetWeightedRoutingAttribute, String>,
}

impl<'a> ClusterGetWeightedRouting<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      attribute: Err("attribute was not initialized".to_string()),
    }
  }

  pub fn attribute<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterGetWeightedRoutingAttribute>, {
    self.attribute = value
      .try_into()
      .map_err(|_| "conversion to `ClusterGetWeightedRoutingAttribute` for attribute failed".to_string());
    self
  }

  ///Sends a `GET` request to
  /// `/_cluster/routing/awareness/{attribute}/weights`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self { client, attribute } = self;
    let attribute = attribute.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_cluster/routing/awareness/{}/weights",
      client.baseurl,
      encode_path(&attribute.to_string()),
    );
    let request = client.client.get(url).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cluster_put_weighted_routing`]
///
///[`Client::cluster_put_weighted_routing`]: super::Client::cluster_put_weighted_routing
#[derive(Debug, Clone)]
pub struct ClusterPutWeightedRouting<'a> {
  client: &'a super::Client,
  attribute: Result<types::ClusterPutWeightedRoutingAttribute, String>,
}

impl<'a> ClusterPutWeightedRouting<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      attribute: Err("attribute was not initialized".to_string()),
    }
  }

  pub fn attribute<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterPutWeightedRoutingAttribute>, {
    self.attribute = value
      .try_into()
      .map_err(|_| "conversion to `ClusterPutWeightedRoutingAttribute` for attribute failed".to_string());
    self
  }

  ///Sends a `PUT` request to
  /// `/_cluster/routing/awareness/{attribute}/weights`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self { client, attribute } = self;
    let attribute = attribute.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_cluster/routing/awareness/{}/weights",
      client.baseurl,
      encode_path(&attribute.to_string()),
    );
    let request = client.client.put(url).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cluster_get_settings`]
///
///[`Client::cluster_get_settings`]: super::Client::cluster_get_settings
#[derive(Debug, Clone)]
pub struct ClusterGetSettings<'a> {
  client: &'a super::Client,
  cluster_manager_timeout: Result<Option<types::ClusterGetSettingsClusterManagerTimeout>, String>,
  flat_settings: Result<Option<bool>, String>,
  include_defaults: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::ClusterGetSettingsMasterTimeout>, String>,
  timeout: Result<Option<types::ClusterGetSettingsTimeout>, String>,
}

impl<'a> ClusterGetSettings<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      cluster_manager_timeout: Ok(None),
      flat_settings: Ok(None),
      include_defaults: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
    }
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterGetSettingsClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `ClusterGetSettingsClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn flat_settings<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.flat_settings = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
    self
  }

  pub fn include_defaults<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.include_defaults = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for include_defaults failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterGetSettingsMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ClusterGetSettingsMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterGetSettingsTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ClusterGetSettingsTimeout` for timeout failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cluster/settings`
  pub async fn send(self) -> Result<ResponseValue<types::ClusterGetSettingsResponseContent>, Error<()>> {
    let Self {
      client,
      cluster_manager_timeout,
      flat_settings,
      include_defaults,
      master_timeout,
      timeout,
    } = self;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
    let include_defaults = include_defaults.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cluster/settings", client.baseurl,);
    let mut query = Vec::with_capacity(5usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &flat_settings {
      query.push(("flat_settings", v.to_string()));
    }
    if let Some(v) = &include_defaults {
      query.push(("include_defaults", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client
      .client
      .get(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .query(&query)
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cluster_put_settings`]
///
///[`Client::cluster_put_settings`]: super::Client::cluster_put_settings
#[derive(Debug, Clone)]
pub struct ClusterPutSettings<'a> {
  client: &'a super::Client,
  cluster_manager_timeout: Result<Option<types::ClusterPutSettingsClusterManagerTimeout>, String>,
  flat_settings: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::ClusterPutSettingsMasterTimeout>, String>,
  timeout: Result<Option<types::ClusterPutSettingsTimeout>, String>,
  body: Result<types::builder::ClusterPutSettingsBodyParams, String>,
}

impl<'a> ClusterPutSettings<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      cluster_manager_timeout: Ok(None),
      flat_settings: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
      body: Ok(types::builder::ClusterPutSettingsBodyParams::default()),
    }
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterPutSettingsClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `ClusterPutSettingsClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn flat_settings<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.flat_settings = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterPutSettingsMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ClusterPutSettingsMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterPutSettingsTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ClusterPutSettingsTimeout` for timeout failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterPutSettingsBodyParams>, {
    self.body = value
      .try_into()
      .map(From::from)
      .map_err(|_| "conversion to `ClusterPutSettingsBodyParams` for body failed".to_string());
    self
  }

  pub fn body_map<F>(mut self, f: F) -> Self
  where
    F: std::ops::FnOnce(types::builder::ClusterPutSettingsBodyParams) -> types::builder::ClusterPutSettingsBodyParams,
  {
    self.body = self.body.map(f);
    self
  }

  ///Sends a `PUT` request to `/_cluster/settings`
  pub async fn send(self) -> Result<ResponseValue<types::ClusterPutSettingsResponseContent>, Error<()>> {
    let Self {
      client,
      cluster_manager_timeout,
      flat_settings,
      master_timeout,
      timeout,
      body,
    } = self;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let body = body
      .and_then(std::convert::TryInto::<types::ClusterPutSettingsBodyParams>::try_into)
      .map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cluster/settings", client.baseurl,);
    let mut query = Vec::with_capacity(4usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &flat_settings {
      query.push(("flat_settings", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client
      .client
      .put(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .json(&body)
      .query(&query)
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cluster_state`]
///
///[`Client::cluster_state`]: super::Client::cluster_state
#[derive(Debug, Clone)]
pub struct ClusterState<'a> {
  client: &'a super::Client,
  allow_no_indices: Result<Option<bool>, String>,
  cluster_manager_timeout: Result<Option<types::ClusterStateClusterManagerTimeout>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  flat_settings: Result<Option<bool>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::ClusterStateMasterTimeout>, String>,
  wait_for_metadata_version: Result<Option<i32>, String>,
  wait_for_timeout: Result<Option<types::ClusterStateWaitForTimeout>, String>,
}

impl<'a> ClusterState<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      allow_no_indices: Ok(None),
      cluster_manager_timeout: Ok(None),
      expand_wildcards: Ok(None),
      flat_settings: Ok(None),
      ignore_unavailable: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
      wait_for_metadata_version: Ok(None),
      wait_for_timeout: Ok(None),
    }
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterStateClusterManagerTimeout>, {
    self.cluster_manager_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ClusterStateClusterManagerTimeout` for cluster_manager_timeout failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn flat_settings<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.flat_settings = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterStateMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ClusterStateMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn wait_for_metadata_version<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.wait_for_metadata_version = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for wait_for_metadata_version failed".to_string());
    self
  }

  pub fn wait_for_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterStateWaitForTimeout>, {
    self.wait_for_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ClusterStateWaitForTimeout` for wait_for_timeout failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cluster/state`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      allow_no_indices,
      cluster_manager_timeout,
      expand_wildcards,
      flat_settings,
      ignore_unavailable,
      local,
      master_timeout,
      wait_for_metadata_version,
      wait_for_timeout,
    } = self;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let wait_for_metadata_version = wait_for_metadata_version.map_err(Error::InvalidRequest)?;
    let wait_for_timeout = wait_for_timeout.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cluster/state", client.baseurl,);
    let mut query = Vec::with_capacity(9usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &flat_settings {
      query.push(("flat_settings", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &wait_for_metadata_version {
      query.push(("wait_for_metadata_version", v.to_string()));
    }
    if let Some(v) = &wait_for_timeout {
      query.push(("wait_for_timeout", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cluster_state_with_metric`]
///
///[`Client::cluster_state_with_metric`]: super::Client::cluster_state_with_metric
#[derive(Debug, Clone)]
pub struct ClusterStateWithMetric<'a> {
  client: &'a super::Client,
  metric: Result<types::ClusterStateWithMetricMetric, String>,
  allow_no_indices: Result<Option<bool>, String>,
  cluster_manager_timeout: Result<Option<types::ClusterStateWithMetricClusterManagerTimeout>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  flat_settings: Result<Option<bool>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::ClusterStateWithMetricMasterTimeout>, String>,
  wait_for_metadata_version: Result<Option<i32>, String>,
  wait_for_timeout: Result<Option<types::ClusterStateWithMetricWaitForTimeout>, String>,
}

impl<'a> ClusterStateWithMetric<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      metric: Err("metric was not initialized".to_string()),
      allow_no_indices: Ok(None),
      cluster_manager_timeout: Ok(None),
      expand_wildcards: Ok(None),
      flat_settings: Ok(None),
      ignore_unavailable: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
      wait_for_metadata_version: Ok(None),
      wait_for_timeout: Ok(None),
    }
  }

  pub fn metric<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterStateWithMetricMetric>, {
    self.metric = value
      .try_into()
      .map_err(|_| "conversion to `ClusterStateWithMetricMetric` for metric failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterStateWithMetricClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `ClusterStateWithMetricClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn flat_settings<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.flat_settings = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterStateWithMetricMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ClusterStateWithMetricMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn wait_for_metadata_version<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.wait_for_metadata_version = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for wait_for_metadata_version failed".to_string());
    self
  }

  pub fn wait_for_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterStateWithMetricWaitForTimeout>, {
    self.wait_for_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ClusterStateWithMetricWaitForTimeout` for wait_for_timeout failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cluster/state/{metric}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      metric,
      allow_no_indices,
      cluster_manager_timeout,
      expand_wildcards,
      flat_settings,
      ignore_unavailable,
      local,
      master_timeout,
      wait_for_metadata_version,
      wait_for_timeout,
    } = self;
    let metric = metric.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let wait_for_metadata_version = wait_for_metadata_version.map_err(Error::InvalidRequest)?;
    let wait_for_timeout = wait_for_timeout.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cluster/state/{}", client.baseurl, encode_path(&metric.to_string()),);
    let mut query = Vec::with_capacity(9usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &flat_settings {
      query.push(("flat_settings", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &wait_for_metadata_version {
      query.push(("wait_for_metadata_version", v.to_string()));
    }
    if let Some(v) = &wait_for_timeout {
      query.push(("wait_for_timeout", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cluster_state_with_index_metric`]
///
///[`Client::cluster_state_with_index_metric`]: super::Client::cluster_state_with_index_metric
#[derive(Debug, Clone)]
pub struct ClusterStateWithIndexMetric<'a> {
  client: &'a super::Client,
  metric: Result<types::ClusterStateWithIndexMetricMetric, String>,
  index: Result<types::ClusterStateWithIndexMetricIndex, String>,
  allow_no_indices: Result<Option<bool>, String>,
  cluster_manager_timeout: Result<Option<types::ClusterStateWithIndexMetricClusterManagerTimeout>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  flat_settings: Result<Option<bool>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::ClusterStateWithIndexMetricMasterTimeout>, String>,
  wait_for_metadata_version: Result<Option<i32>, String>,
  wait_for_timeout: Result<Option<types::ClusterStateWithIndexMetricWaitForTimeout>, String>,
}

impl<'a> ClusterStateWithIndexMetric<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      metric: Err("metric was not initialized".to_string()),
      index: Err("index was not initialized".to_string()),
      allow_no_indices: Ok(None),
      cluster_manager_timeout: Ok(None),
      expand_wildcards: Ok(None),
      flat_settings: Ok(None),
      ignore_unavailable: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
      wait_for_metadata_version: Ok(None),
      wait_for_timeout: Ok(None),
    }
  }

  pub fn metric<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterStateWithIndexMetricMetric>, {
    self.metric = value
      .try_into()
      .map_err(|_| "conversion to `ClusterStateWithIndexMetricMetric` for metric failed".to_string());
    self
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterStateWithIndexMetricIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `ClusterStateWithIndexMetricIndex` for index failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterStateWithIndexMetricClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `ClusterStateWithIndexMetricClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn flat_settings<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.flat_settings = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterStateWithIndexMetricMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ClusterStateWithIndexMetricMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn wait_for_metadata_version<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.wait_for_metadata_version = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for wait_for_metadata_version failed".to_string());
    self
  }

  pub fn wait_for_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterStateWithIndexMetricWaitForTimeout>, {
    self.wait_for_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ClusterStateWithIndexMetricWaitForTimeout` for wait_for_timeout failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cluster/state/{metric}/{index}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      metric,
      index,
      allow_no_indices,
      cluster_manager_timeout,
      expand_wildcards,
      flat_settings,
      ignore_unavailable,
      local,
      master_timeout,
      wait_for_metadata_version,
      wait_for_timeout,
    } = self;
    let metric = metric.map_err(Error::InvalidRequest)?;
    let index = index.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let wait_for_metadata_version = wait_for_metadata_version.map_err(Error::InvalidRequest)?;
    let wait_for_timeout = wait_for_timeout.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_cluster/state/{}/{}",
      client.baseurl,
      encode_path(&metric.to_string()),
      encode_path(&index.to_string()),
    );
    let mut query = Vec::with_capacity(9usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &flat_settings {
      query.push(("flat_settings", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &wait_for_metadata_version {
      query.push(("wait_for_metadata_version", v.to_string()));
    }
    if let Some(v) = &wait_for_timeout {
      query.push(("wait_for_timeout", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cluster_stats`]
///
///[`Client::cluster_stats`]: super::Client::cluster_stats
#[derive(Debug, Clone)]
pub struct ClusterStats<'a> {
  client: &'a super::Client,
  flat_settings: Result<Option<bool>, String>,
  timeout: Result<Option<types::ClusterStatsTimeout>, String>,
}

impl<'a> ClusterStats<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      flat_settings: Ok(None),
      timeout: Ok(None),
    }
  }

  pub fn flat_settings<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.flat_settings = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterStatsTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ClusterStatsTimeout` for timeout failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cluster/stats`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      flat_settings,
      timeout,
    } = self;
    let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cluster/stats", client.baseurl,);
    let mut query = Vec::with_capacity(2usize);
    if let Some(v) = &flat_settings {
      query.push(("flat_settings", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cluster_stats_with_node_id`]
///
///[`Client::cluster_stats_with_node_id`]: super::Client::cluster_stats_with_node_id
#[derive(Debug, Clone)]
pub struct ClusterStatsWithNodeId<'a> {
  client: &'a super::Client,
  node_id: Result<types::ClusterStatsWithNodeIdNodeId, String>,
  flat_settings: Result<Option<bool>, String>,
  timeout: Result<Option<types::ClusterStatsWithNodeIdTimeout>, String>,
}

impl<'a> ClusterStatsWithNodeId<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      node_id: Err("node_id was not initialized".to_string()),
      flat_settings: Ok(None),
      timeout: Ok(None),
    }
  }

  pub fn node_id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterStatsWithNodeIdNodeId>, {
    self.node_id = value
      .try_into()
      .map_err(|_| "conversion to `ClusterStatsWithNodeIdNodeId` for node_id failed".to_string());
    self
  }

  pub fn flat_settings<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.flat_settings = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterStatsWithNodeIdTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ClusterStatsWithNodeIdTimeout` for timeout failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_cluster/stats/nodes/{node_id}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      node_id,
      flat_settings,
      timeout,
    } = self;
    let node_id = node_id.map_err(Error::InvalidRequest)?;
    let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_cluster/stats/nodes/{}",
      client.baseurl,
      encode_path(&node_id.to_string()),
    );
    let mut query = Vec::with_capacity(2usize);
    if let Some(v) = &flat_settings {
      query.push(("flat_settings", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cluster_post_voting_config_exclusions`]
///
///[`Client::cluster_post_voting_config_exclusions`]: super::Client::cluster_post_voting_config_exclusions
#[derive(Debug, Clone)]
pub struct ClusterPostVotingConfigExclusions<'a> {
  client: &'a super::Client,
  node_ids: Result<Option<String>, String>,
  node_names: Result<Option<String>, String>,
  timeout: Result<Option<types::ClusterPostVotingConfigExclusionsTimeout>, String>,
}

impl<'a> ClusterPostVotingConfigExclusions<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      node_ids: Ok(None),
      node_names: Ok(None),
      timeout: Ok(None),
    }
  }

  pub fn node_ids<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.node_ids = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for node_ids failed".to_string());
    self
  }

  pub fn node_names<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.node_names = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for node_names failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterPostVotingConfigExclusionsTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ClusterPostVotingConfigExclusionsTimeout` for timeout failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_cluster/voting_config_exclusions`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      node_ids,
      node_names,
      timeout,
    } = self;
    let node_ids = node_ids.map_err(Error::InvalidRequest)?;
    let node_names = node_names.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cluster/voting_config_exclusions", client.baseurl,);
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &node_ids {
      query.push(("node_ids", v.to_string()));
    }
    if let Some(v) = &node_names {
      query.push(("node_names", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client.client.post(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cluster_delete_voting_config_exclusions`]
///
///[`Client::cluster_delete_voting_config_exclusions`]: super::Client::cluster_delete_voting_config_exclusions
#[derive(Debug, Clone)]
pub struct ClusterDeleteVotingConfigExclusions<'a> {
  client: &'a super::Client,
  wait_for_removal: Result<Option<bool>, String>,
}

impl<'a> ClusterDeleteVotingConfigExclusions<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      wait_for_removal: Ok(None),
    }
  }

  pub fn wait_for_removal<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.wait_for_removal = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for wait_for_removal failed".to_string());
    self
  }

  ///Sends a `DELETE` request to `/_cluster/voting_config_exclusions`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      wait_for_removal,
    } = self;
    let wait_for_removal = wait_for_removal.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_cluster/voting_config_exclusions", client.baseurl,);
    let mut query = Vec::with_capacity(1usize);
    if let Some(v) = &wait_for_removal {
      query.push(("wait_for_removal", v.to_string()));
    }
    let request = client.client.delete(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cluster_get_component_template`]
///
///[`Client::cluster_get_component_template`]: super::Client::cluster_get_component_template
#[derive(Debug, Clone)]
pub struct ClusterGetComponentTemplate<'a> {
  client: &'a super::Client,
  cluster_manager_timeout: Result<Option<types::ClusterGetComponentTemplateClusterManagerTimeout>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::ClusterGetComponentTemplateMasterTimeout>, String>,
}

impl<'a> ClusterGetComponentTemplate<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      cluster_manager_timeout: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
    }
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterGetComponentTemplateClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `ClusterGetComponentTemplateClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterGetComponentTemplateMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ClusterGetComponentTemplateMasterTimeout` for master_timeout failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_component_template`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      cluster_manager_timeout,
      local,
      master_timeout,
    } = self;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_component_template", client.baseurl,);
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cluster_get_component_template_with_name`]
///
///[`Client::cluster_get_component_template_with_name`]: super::Client::cluster_get_component_template_with_name
#[derive(Debug, Clone)]
pub struct ClusterGetComponentTemplateWithName<'a> {
  client: &'a super::Client,
  name: Result<types::ClusterGetComponentTemplateWithNameName, String>,
  cluster_manager_timeout: Result<Option<types::ClusterGetComponentTemplateWithNameClusterManagerTimeout>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::ClusterGetComponentTemplateWithNameMasterTimeout>, String>,
}

impl<'a> ClusterGetComponentTemplateWithName<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      name: Err("name was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
    }
  }

  pub fn name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterGetComponentTemplateWithNameName>, {
    self.name = value
      .try_into()
      .map_err(|_| "conversion to `ClusterGetComponentTemplateWithNameName` for name failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterGetComponentTemplateWithNameClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `ClusterGetComponentTemplateWithNameClusterManagerTimeout` for cluster_manager_timeout failed"
        .to_string()
    });
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterGetComponentTemplateWithNameMasterTimeout>, {
    self.master_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `ClusterGetComponentTemplateWithNameMasterTimeout` for master_timeout failed".to_string()
    });
    self
  }

  ///Sends a `GET` request to `/_component_template/{name}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      name,
      cluster_manager_timeout,
      local,
      master_timeout,
    } = self;
    let name = name.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_component_template/{}",
      client.baseurl,
      encode_path(&name.to_string()),
    );
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cluster_put_component_template_put`]
///
///[`Client::cluster_put_component_template_put`]: super::Client::cluster_put_component_template_put
#[derive(Debug, Clone)]
pub struct ClusterPutComponentTemplatePut<'a> {
  client: &'a super::Client,
  name: Result<types::ClusterPutComponentTemplatePutName, String>,
  cluster_manager_timeout: Result<Option<types::ClusterPutComponentTemplatePutClusterManagerTimeout>, String>,
  create: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::ClusterPutComponentTemplatePutMasterTimeout>, String>,
  timeout: Result<Option<types::ClusterPutComponentTemplatePutTimeout>, String>,
  body: Result<types::ClusterPutComponentTemplateBodyParams, String>,
}

impl<'a> ClusterPutComponentTemplatePut<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      name: Err("name was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      create: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterPutComponentTemplatePutName>, {
    self.name = value
      .try_into()
      .map_err(|_| "conversion to `ClusterPutComponentTemplatePutName` for name failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterPutComponentTemplatePutClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `ClusterPutComponentTemplatePutClusterManagerTimeout` for cluster_manager_timeout failed"
        .to_string()
    });
    self
  }

  pub fn create<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.create = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for create failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterPutComponentTemplatePutMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ClusterPutComponentTemplatePutMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterPutComponentTemplatePutTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ClusterPutComponentTemplatePutTimeout` for timeout failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterPutComponentTemplateBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `ClusterPutComponentTemplateBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `PUT` request to `/_component_template/{name}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      name,
      cluster_manager_timeout,
      create,
      master_timeout,
      timeout,
      body,
    } = self;
    let name = name.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let create = create.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_component_template/{}",
      client.baseurl,
      encode_path(&name.to_string()),
    );
    let mut query = Vec::with_capacity(4usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &create {
      query.push(("create", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client.client.put(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cluster_put_component_template_post`]
///
///[`Client::cluster_put_component_template_post`]: super::Client::cluster_put_component_template_post
#[derive(Debug, Clone)]
pub struct ClusterPutComponentTemplatePost<'a> {
  client: &'a super::Client,
  name: Result<types::ClusterPutComponentTemplatePostName, String>,
  cluster_manager_timeout: Result<Option<types::ClusterPutComponentTemplatePostClusterManagerTimeout>, String>,
  create: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::ClusterPutComponentTemplatePostMasterTimeout>, String>,
  timeout: Result<Option<types::ClusterPutComponentTemplatePostTimeout>, String>,
  body: Result<types::ClusterPutComponentTemplateBodyParams, String>,
}

impl<'a> ClusterPutComponentTemplatePost<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      name: Err("name was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      create: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterPutComponentTemplatePostName>, {
    self.name = value
      .try_into()
      .map_err(|_| "conversion to `ClusterPutComponentTemplatePostName` for name failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterPutComponentTemplatePostClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `ClusterPutComponentTemplatePostClusterManagerTimeout` for cluster_manager_timeout failed"
        .to_string()
    });
    self
  }

  pub fn create<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.create = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for create failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterPutComponentTemplatePostMasterTimeout>, {
    self.master_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `ClusterPutComponentTemplatePostMasterTimeout` for master_timeout failed".to_string()
    });
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterPutComponentTemplatePostTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ClusterPutComponentTemplatePostTimeout` for timeout failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterPutComponentTemplateBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `ClusterPutComponentTemplateBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_component_template/{name}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      name,
      cluster_manager_timeout,
      create,
      master_timeout,
      timeout,
      body,
    } = self;
    let name = name.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let create = create.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_component_template/{}",
      client.baseurl,
      encode_path(&name.to_string()),
    );
    let mut query = Vec::with_capacity(4usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &create {
      query.push(("create", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cluster_delete_component_template`]
///
///[`Client::cluster_delete_component_template`]: super::Client::cluster_delete_component_template
#[derive(Debug, Clone)]
pub struct ClusterDeleteComponentTemplate<'a> {
  client: &'a super::Client,
  name: Result<types::ClusterDeleteComponentTemplateName, String>,
  cluster_manager_timeout: Result<Option<types::ClusterDeleteComponentTemplateClusterManagerTimeout>, String>,
  master_timeout: Result<Option<types::ClusterDeleteComponentTemplateMasterTimeout>, String>,
  timeout: Result<Option<types::ClusterDeleteComponentTemplateTimeout>, String>,
}

impl<'a> ClusterDeleteComponentTemplate<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      name: Err("name was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
    }
  }

  pub fn name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterDeleteComponentTemplateName>, {
    self.name = value
      .try_into()
      .map_err(|_| "conversion to `ClusterDeleteComponentTemplateName` for name failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterDeleteComponentTemplateClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `ClusterDeleteComponentTemplateClusterManagerTimeout` for cluster_manager_timeout failed"
        .to_string()
    });
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterDeleteComponentTemplateMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ClusterDeleteComponentTemplateMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterDeleteComponentTemplateTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ClusterDeleteComponentTemplateTimeout` for timeout failed".to_string());
    self
  }

  ///Sends a `DELETE` request to `/_component_template/{name}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      name,
      cluster_manager_timeout,
      master_timeout,
      timeout,
    } = self;
    let name = name.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_component_template/{}",
      client.baseurl,
      encode_path(&name.to_string()),
    );
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client.client.delete(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cluster_exists_component_template`]
///
///[`Client::cluster_exists_component_template`]: super::Client::cluster_exists_component_template
#[derive(Debug, Clone)]
pub struct ClusterExistsComponentTemplate<'a> {
  client: &'a super::Client,
  name: Result<types::ClusterExistsComponentTemplateName, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::ClusterExistsComponentTemplateMasterTimeout>, String>,
}

impl<'a> ClusterExistsComponentTemplate<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      name: Err("name was not initialized".to_string()),
      local: Ok(None),
      master_timeout: Ok(None),
    }
  }

  pub fn name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterExistsComponentTemplateName>, {
    self.name = value
      .try_into()
      .map_err(|_| "conversion to `ClusterExistsComponentTemplateName` for name failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClusterExistsComponentTemplateMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ClusterExistsComponentTemplateMasterTimeout` for master_timeout failed".to_string());
    self
  }

  ///Sends a `HEAD` request to `/_component_template/{name}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      name,
      local,
      master_timeout,
    } = self;
    let name = name.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_component_template/{}",
      client.baseurl,
      encode_path(&name.to_string()),
    );
    let mut query = Vec::with_capacity(2usize);
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    let request = client.client.head(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::count_get`]
///
///[`Client::count_get`]: super::Client::count_get
#[derive(Debug, Clone)]
pub struct CountGet<'a> {
  client: &'a super::Client,
  allow_no_indices: Result<Option<bool>, String>,
  analyze_wildcard: Result<Option<bool>, String>,
  analyzer: Result<Option<String>, String>,
  default_operator: Result<Option<types::DefaultOperator>, String>,
  df: Result<Option<String>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_throttled: Result<Option<bool>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  lenient: Result<Option<bool>, String>,
  min_score: Result<Option<i32>, String>,
  preference: Result<Option<String>, String>,
  q: Result<Option<String>, String>,
  routing: Result<Option<Vec<String>>, String>,
  terminate_after: Result<Option<i32>, String>,
}

impl<'a> CountGet<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      allow_no_indices: Ok(None),
      analyze_wildcard: Ok(None),
      analyzer: Ok(None),
      default_operator: Ok(None),
      df: Ok(None),
      expand_wildcards: Ok(None),
      ignore_throttled: Ok(None),
      ignore_unavailable: Ok(None),
      lenient: Ok(None),
      min_score: Ok(None),
      preference: Ok(None),
      q: Ok(None),
      routing: Ok(None),
      terminate_after: Ok(None),
    }
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn analyze_wildcard<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.analyze_wildcard = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for analyze_wildcard failed".to_string());
    self
  }

  pub fn analyzer<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.analyzer = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for analyzer failed".to_string());
    self
  }

  pub fn default_operator<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::DefaultOperator>, {
    self.default_operator = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `DefaultOperator` for default_operator failed".to_string());
    self
  }

  pub fn df<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.df = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for df failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_throttled<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_throttled = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_throttled failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn lenient<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.lenient = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for lenient failed".to_string());
    self
  }

  pub fn min_score<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.min_score = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for min_score failed".to_string());
    self
  }

  pub fn preference<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.preference = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for preference failed".to_string());
    self
  }

  pub fn q<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.q = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for q failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for routing failed".to_string());
    self
  }

  pub fn terminate_after<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.terminate_after = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for terminate_after failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_count`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      allow_no_indices,
      analyze_wildcard,
      analyzer,
      default_operator,
      df,
      expand_wildcards,
      ignore_throttled,
      ignore_unavailable,
      lenient,
      min_score,
      preference,
      q,
      routing,
      terminate_after,
    } = self;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let analyze_wildcard = analyze_wildcard.map_err(Error::InvalidRequest)?;
    let analyzer = analyzer.map_err(Error::InvalidRequest)?;
    let default_operator = default_operator.map_err(Error::InvalidRequest)?;
    let df = df.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_throttled = ignore_throttled.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let lenient = lenient.map_err(Error::InvalidRequest)?;
    let min_score = min_score.map_err(Error::InvalidRequest)?;
    let preference = preference.map_err(Error::InvalidRequest)?;
    let q = q.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let terminate_after = terminate_after.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_count", client.baseurl,);
    let mut query = Vec::with_capacity(14usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &analyze_wildcard {
      query.push(("analyze_wildcard", v.to_string()));
    }
    if let Some(v) = &analyzer {
      query.push(("analyzer", v.to_string()));
    }
    if let Some(v) = &default_operator {
      query.push(("default_operator", v.to_string()));
    }
    if let Some(v) = &df {
      query.push(("df", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_throttled {
      query.push(("ignore_throttled", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &lenient {
      query.push(("lenient", v.to_string()));
    }
    if let Some(v) = &min_score {
      query.push(("min_score", v.to_string()));
    }
    if let Some(v) = &preference {
      query.push(("preference", v.to_string()));
    }
    if let Some(v) = &q {
      query.push(("q", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.join(",")));
    }
    if let Some(v) = &terminate_after {
      query.push(("terminate_after", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::count_post`]
///
///[`Client::count_post`]: super::Client::count_post
#[derive(Debug, Clone)]
pub struct CountPost<'a> {
  client: &'a super::Client,
  allow_no_indices: Result<Option<bool>, String>,
  analyze_wildcard: Result<Option<bool>, String>,
  analyzer: Result<Option<String>, String>,
  default_operator: Result<Option<types::DefaultOperator>, String>,
  df: Result<Option<String>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_throttled: Result<Option<bool>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  lenient: Result<Option<bool>, String>,
  min_score: Result<Option<i32>, String>,
  preference: Result<Option<String>, String>,
  q: Result<Option<String>, String>,
  routing: Result<Option<Vec<String>>, String>,
  terminate_after: Result<Option<i32>, String>,
  body: Result<types::CountBodyParams, String>,
}

impl<'a> CountPost<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      allow_no_indices: Ok(None),
      analyze_wildcard: Ok(None),
      analyzer: Ok(None),
      default_operator: Ok(None),
      df: Ok(None),
      expand_wildcards: Ok(None),
      ignore_throttled: Ok(None),
      ignore_unavailable: Ok(None),
      lenient: Ok(None),
      min_score: Ok(None),
      preference: Ok(None),
      q: Ok(None),
      routing: Ok(None),
      terminate_after: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn analyze_wildcard<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.analyze_wildcard = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for analyze_wildcard failed".to_string());
    self
  }

  pub fn analyzer<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.analyzer = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for analyzer failed".to_string());
    self
  }

  pub fn default_operator<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::DefaultOperator>, {
    self.default_operator = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `DefaultOperator` for default_operator failed".to_string());
    self
  }

  pub fn df<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.df = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for df failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_throttled<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_throttled = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_throttled failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn lenient<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.lenient = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for lenient failed".to_string());
    self
  }

  pub fn min_score<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.min_score = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for min_score failed".to_string());
    self
  }

  pub fn preference<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.preference = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for preference failed".to_string());
    self
  }

  pub fn q<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.q = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for q failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for routing failed".to_string());
    self
  }

  pub fn terminate_after<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.terminate_after = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for terminate_after failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CountBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `CountBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_count`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      allow_no_indices,
      analyze_wildcard,
      analyzer,
      default_operator,
      df,
      expand_wildcards,
      ignore_throttled,
      ignore_unavailable,
      lenient,
      min_score,
      preference,
      q,
      routing,
      terminate_after,
      body,
    } = self;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let analyze_wildcard = analyze_wildcard.map_err(Error::InvalidRequest)?;
    let analyzer = analyzer.map_err(Error::InvalidRequest)?;
    let default_operator = default_operator.map_err(Error::InvalidRequest)?;
    let df = df.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_throttled = ignore_throttled.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let lenient = lenient.map_err(Error::InvalidRequest)?;
    let min_score = min_score.map_err(Error::InvalidRequest)?;
    let preference = preference.map_err(Error::InvalidRequest)?;
    let q = q.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let terminate_after = terminate_after.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_count", client.baseurl,);
    let mut query = Vec::with_capacity(14usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &analyze_wildcard {
      query.push(("analyze_wildcard", v.to_string()));
    }
    if let Some(v) = &analyzer {
      query.push(("analyzer", v.to_string()));
    }
    if let Some(v) = &default_operator {
      query.push(("default_operator", v.to_string()));
    }
    if let Some(v) = &df {
      query.push(("df", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_throttled {
      query.push(("ignore_throttled", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &lenient {
      query.push(("lenient", v.to_string()));
    }
    if let Some(v) = &min_score {
      query.push(("min_score", v.to_string()));
    }
    if let Some(v) = &preference {
      query.push(("preference", v.to_string()));
    }
    if let Some(v) = &q {
      query.push(("q", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.join(",")));
    }
    if let Some(v) = &terminate_after {
      query.push(("terminate_after", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::dangling_indices_list_dangling_indices`]
///
///[`Client::dangling_indices_list_dangling_indices`]: super::Client::dangling_indices_list_dangling_indices
#[derive(Debug, Clone)]
pub struct DanglingIndicesListDanglingIndices<'a> {
  client: &'a super::Client,
}

impl<'a> DanglingIndicesListDanglingIndices<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self { client }
  }

  ///Sends a `GET` request to `/_dangling`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self { client } = self;
    let url = format!("{}/_dangling", client.baseurl,);
    let request = client.client.get(url).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::dangling_indices_import_dangling_index`]
///
///[`Client::dangling_indices_import_dangling_index`]: super::Client::dangling_indices_import_dangling_index
#[derive(Debug, Clone)]
pub struct DanglingIndicesImportDanglingIndex<'a> {
  client: &'a super::Client,
  index_uuid: Result<types::DanglingIndicesImportDanglingIndexIndexUuid, String>,
  accept_data_loss: Result<Option<bool>, String>,
  cluster_manager_timeout: Result<Option<types::DanglingIndicesImportDanglingIndexClusterManagerTimeout>, String>,
  master_timeout: Result<Option<types::DanglingIndicesImportDanglingIndexMasterTimeout>, String>,
  timeout: Result<Option<types::DanglingIndicesImportDanglingIndexTimeout>, String>,
}

impl<'a> DanglingIndicesImportDanglingIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index_uuid: Err("index_uuid was not initialized".to_string()),
      accept_data_loss: Ok(None),
      cluster_manager_timeout: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
    }
  }

  pub fn index_uuid<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::DanglingIndicesImportDanglingIndexIndexUuid>, {
    self.index_uuid = value
      .try_into()
      .map_err(|_| "conversion to `DanglingIndicesImportDanglingIndexIndexUuid` for index_uuid failed".to_string());
    self
  }

  pub fn accept_data_loss<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.accept_data_loss = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for accept_data_loss failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::DanglingIndicesImportDanglingIndexClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `DanglingIndicesImportDanglingIndexClusterManagerTimeout` for cluster_manager_timeout failed"
        .to_string()
    });
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::DanglingIndicesImportDanglingIndexMasterTimeout>, {
    self.master_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `DanglingIndicesImportDanglingIndexMasterTimeout` for master_timeout failed".to_string()
    });
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::DanglingIndicesImportDanglingIndexTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `DanglingIndicesImportDanglingIndexTimeout` for timeout failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_dangling/{index_uuid}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index_uuid,
      accept_data_loss,
      cluster_manager_timeout,
      master_timeout,
      timeout,
    } = self;
    let index_uuid = index_uuid.map_err(Error::InvalidRequest)?;
    let accept_data_loss = accept_data_loss.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_dangling/{}", client.baseurl, encode_path(&index_uuid.to_string()),);
    let mut query = Vec::with_capacity(4usize);
    if let Some(v) = &accept_data_loss {
      query.push(("accept_data_loss", v.to_string()));
    }
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client.client.post(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::dangling_indices_delete_dangling_index`]
///
///[`Client::dangling_indices_delete_dangling_index`]: super::Client::dangling_indices_delete_dangling_index
#[derive(Debug, Clone)]
pub struct DanglingIndicesDeleteDanglingIndex<'a> {
  client: &'a super::Client,
  index_uuid: Result<types::DanglingIndicesDeleteDanglingIndexIndexUuid, String>,
  accept_data_loss: Result<Option<bool>, String>,
  cluster_manager_timeout: Result<Option<types::DanglingIndicesDeleteDanglingIndexClusterManagerTimeout>, String>,
  master_timeout: Result<Option<types::DanglingIndicesDeleteDanglingIndexMasterTimeout>, String>,
  timeout: Result<Option<types::DanglingIndicesDeleteDanglingIndexTimeout>, String>,
}

impl<'a> DanglingIndicesDeleteDanglingIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index_uuid: Err("index_uuid was not initialized".to_string()),
      accept_data_loss: Ok(None),
      cluster_manager_timeout: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
    }
  }

  pub fn index_uuid<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::DanglingIndicesDeleteDanglingIndexIndexUuid>, {
    self.index_uuid = value
      .try_into()
      .map_err(|_| "conversion to `DanglingIndicesDeleteDanglingIndexIndexUuid` for index_uuid failed".to_string());
    self
  }

  pub fn accept_data_loss<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.accept_data_loss = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for accept_data_loss failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::DanglingIndicesDeleteDanglingIndexClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `DanglingIndicesDeleteDanglingIndexClusterManagerTimeout` for cluster_manager_timeout failed"
        .to_string()
    });
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::DanglingIndicesDeleteDanglingIndexMasterTimeout>, {
    self.master_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `DanglingIndicesDeleteDanglingIndexMasterTimeout` for master_timeout failed".to_string()
    });
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::DanglingIndicesDeleteDanglingIndexTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `DanglingIndicesDeleteDanglingIndexTimeout` for timeout failed".to_string());
    self
  }

  ///Sends a `DELETE` request to `/_dangling/{index_uuid}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index_uuid,
      accept_data_loss,
      cluster_manager_timeout,
      master_timeout,
      timeout,
    } = self;
    let index_uuid = index_uuid.map_err(Error::InvalidRequest)?;
    let accept_data_loss = accept_data_loss.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_dangling/{}", client.baseurl, encode_path(&index_uuid.to_string()),);
    let mut query = Vec::with_capacity(4usize);
    if let Some(v) = &accept_data_loss {
      query.push(("accept_data_loss", v.to_string()));
    }
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client.client.delete(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_get_data_stream`]
///
///[`Client::indices_get_data_stream`]: super::Client::indices_get_data_stream
#[derive(Debug, Clone)]
pub struct IndicesGetDataStream<'a> {
  client: &'a super::Client,
}

impl<'a> IndicesGetDataStream<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self { client }
  }

  ///Sends a `GET` request to `/_data_stream`
  pub async fn send(self) -> Result<ResponseValue<types::IndicesGetDataStreamResponseContent>, Error<()>> {
    let Self { client } = self;
    let url = format!("{}/_data_stream", client.baseurl,);
    let request = client
      .client
      .get(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_data_streams_stats`]
///
///[`Client::indices_data_streams_stats`]: super::Client::indices_data_streams_stats
#[derive(Debug, Clone)]
pub struct IndicesDataStreamsStats<'a> {
  client: &'a super::Client,
}

impl<'a> IndicesDataStreamsStats<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self { client }
  }

  ///Sends a `GET` request to `/_data_stream/_stats`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self { client } = self;
    let url = format!("{}/_data_stream/_stats", client.baseurl,);
    let request = client.client.get(url).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_get_data_stream_with_name`]
///
///[`Client::indices_get_data_stream_with_name`]: super::Client::indices_get_data_stream_with_name
#[derive(Debug, Clone)]
pub struct IndicesGetDataStreamWithName<'a> {
  client: &'a super::Client,
  name: Result<types::IndicesGetDataStreamWithNameName, String>,
}

impl<'a> IndicesGetDataStreamWithName<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      name: Err("name was not initialized".to_string()),
    }
  }

  pub fn name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesGetDataStreamWithNameName>, {
    self.name = value
      .try_into()
      .map_err(|_| "conversion to `IndicesGetDataStreamWithNameName` for name failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_data_stream/{name}`
  pub async fn send(self) -> Result<ResponseValue<types::IndicesGetDataStreamWithNameResponseContent>, Error<()>> {
    let Self { client, name } = self;
    let name = name.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_data_stream/{}", client.baseurl, encode_path(&name.to_string()),);
    let request = client
      .client
      .get(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_create_data_stream`]
///
///[`Client::indices_create_data_stream`]: super::Client::indices_create_data_stream
#[derive(Debug, Clone)]
pub struct IndicesCreateDataStream<'a> {
  client: &'a super::Client,
  name: Result<types::IndicesCreateDataStreamName, String>,
  body: Result<types::IndicesCreateDataStreamBodyParams, String>,
}

impl<'a> IndicesCreateDataStream<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      name: Err("name was not initialized".to_string()),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesCreateDataStreamName>, {
    self.name = value
      .try_into()
      .map_err(|_| "conversion to `IndicesCreateDataStreamName` for name failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesCreateDataStreamBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `IndicesCreateDataStreamBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `PUT` request to `/_data_stream/{name}`
  pub async fn send(self) -> Result<ResponseValue<types::IndicesCreateDataStreamResponseContent>, Error<()>> {
    let Self { client, name, body } = self;
    let name = name.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_data_stream/{}", client.baseurl, encode_path(&name.to_string()),);
    let request = client
      .client
      .put(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .json(&body)
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_delete_data_stream`]
///
///[`Client::indices_delete_data_stream`]: super::Client::indices_delete_data_stream
#[derive(Debug, Clone)]
pub struct IndicesDeleteDataStream<'a> {
  client: &'a super::Client,
  name: Result<types::IndicesDeleteDataStreamName, String>,
}

impl<'a> IndicesDeleteDataStream<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      name: Err("name was not initialized".to_string()),
    }
  }

  pub fn name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesDeleteDataStreamName>, {
    self.name = value
      .try_into()
      .map_err(|_| "conversion to `IndicesDeleteDataStreamName` for name failed".to_string());
    self
  }

  ///Sends a `DELETE` request to `/_data_stream/{name}`
  pub async fn send(self) -> Result<ResponseValue<types::IndicesDeleteDataStreamResponseContent>, Error<()>> {
    let Self { client, name } = self;
    let name = name.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_data_stream/{}", client.baseurl, encode_path(&name.to_string()),);
    let request = client
      .client
      .delete(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_data_streams_stats_with_name`]
///
///[`Client::indices_data_streams_stats_with_name`]: super::Client::indices_data_streams_stats_with_name
#[derive(Debug, Clone)]
pub struct IndicesDataStreamsStatsWithName<'a> {
  client: &'a super::Client,
  name: Result<types::IndicesDataStreamsStatsWithNameName, String>,
}

impl<'a> IndicesDataStreamsStatsWithName<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      name: Err("name was not initialized".to_string()),
    }
  }

  pub fn name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesDataStreamsStatsWithNameName>, {
    self.name = value
      .try_into()
      .map_err(|_| "conversion to `IndicesDataStreamsStatsWithNameName` for name failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_data_stream/{name}/_stats`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self { client, name } = self;
    let name = name.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_data_stream/{}/_stats",
      client.baseurl,
      encode_path(&name.to_string()),
    );
    let request = client.client.get(url).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::delete_by_query_rethrottle`]
///
///[`Client::delete_by_query_rethrottle`]: super::Client::delete_by_query_rethrottle
#[derive(Debug, Clone)]
pub struct DeleteByQueryRethrottle<'a> {
  client: &'a super::Client,
  task_id: Result<types::DeleteByQueryRethrottleTaskId, String>,
  requests_per_second: Result<i32, String>,
}

impl<'a> DeleteByQueryRethrottle<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      task_id: Err("task_id was not initialized".to_string()),
      requests_per_second: Err("requests_per_second was not initialized".to_string()),
    }
  }

  pub fn task_id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::DeleteByQueryRethrottleTaskId>, {
    self.task_id = value
      .try_into()
      .map_err(|_| "conversion to `DeleteByQueryRethrottleTaskId` for task_id failed".to_string());
    self
  }

  pub fn requests_per_second<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.requests_per_second = value
      .try_into()
      .map_err(|_| "conversion to `i32` for requests_per_second failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_delete_by_query/{task_id}/_rethrottle`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      task_id,
      requests_per_second,
    } = self;
    let task_id = task_id.map_err(Error::InvalidRequest)?;
    let requests_per_second = requests_per_second.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_delete_by_query/{}/_rethrottle",
      client.baseurl,
      encode_path(&task_id.to_string()),
    );
    let mut query = Vec::with_capacity(1usize);
    query.push(("requests_per_second", requests_per_second.to_string()));
    let request = client.client.post(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::field_caps_get`]
///
///[`Client::field_caps_get`]: super::Client::field_caps_get
#[derive(Debug, Clone)]
pub struct FieldCapsGet<'a> {
  client: &'a super::Client,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  fields: Result<Option<Vec<String>>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  include_unmapped: Result<Option<bool>, String>,
}

impl<'a> FieldCapsGet<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      fields: Ok(None),
      ignore_unavailable: Ok(None),
      include_unmapped: Ok(None),
    }
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn include_unmapped<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.include_unmapped = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for include_unmapped failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_field_caps`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      allow_no_indices,
      expand_wildcards,
      fields,
      ignore_unavailable,
      include_unmapped,
    } = self;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let fields = fields.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let include_unmapped = include_unmapped.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_field_caps", client.baseurl,);
    let mut query = Vec::with_capacity(5usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &fields {
      query.push(("fields", v.join(",")));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &include_unmapped {
      query.push(("include_unmapped", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::field_caps_post`]
///
///[`Client::field_caps_post`]: super::Client::field_caps_post
#[derive(Debug, Clone)]
pub struct FieldCapsPost<'a> {
  client: &'a super::Client,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  fields: Result<Option<Vec<String>>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  include_unmapped: Result<Option<bool>, String>,
  body: Result<types::FieldCapsBodyParams, String>,
}

impl<'a> FieldCapsPost<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      fields: Ok(None),
      ignore_unavailable: Ok(None),
      include_unmapped: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn include_unmapped<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.include_unmapped = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for include_unmapped failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::FieldCapsBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `FieldCapsBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_field_caps`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      allow_no_indices,
      expand_wildcards,
      fields,
      ignore_unavailable,
      include_unmapped,
      body,
    } = self;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let fields = fields.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let include_unmapped = include_unmapped.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_field_caps", client.baseurl,);
    let mut query = Vec::with_capacity(5usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &fields {
      query.push(("fields", v.join(",")));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &include_unmapped {
      query.push(("include_unmapped", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_flush_get`]
///
///[`Client::indices_flush_get`]: super::Client::indices_flush_get
#[derive(Debug, Clone)]
pub struct IndicesFlushGet<'a> {
  client: &'a super::Client,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  force: Result<Option<bool>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  wait_if_ongoing: Result<Option<bool>, String>,
}

impl<'a> IndicesFlushGet<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      force: Ok(None),
      ignore_unavailable: Ok(None),
      wait_if_ongoing: Ok(None),
    }
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn force<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.force = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for force failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn wait_if_ongoing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.wait_if_ongoing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for wait_if_ongoing failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_flush`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      allow_no_indices,
      expand_wildcards,
      force,
      ignore_unavailable,
      wait_if_ongoing,
    } = self;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let force = force.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let wait_if_ongoing = wait_if_ongoing.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_flush", client.baseurl,);
    let mut query = Vec::with_capacity(5usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &force {
      query.push(("force", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &wait_if_ongoing {
      query.push(("wait_if_ongoing", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_flush_post`]
///
///[`Client::indices_flush_post`]: super::Client::indices_flush_post
#[derive(Debug, Clone)]
pub struct IndicesFlushPost<'a> {
  client: &'a super::Client,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  force: Result<Option<bool>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  wait_if_ongoing: Result<Option<bool>, String>,
}

impl<'a> IndicesFlushPost<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      force: Ok(None),
      ignore_unavailable: Ok(None),
      wait_if_ongoing: Ok(None),
    }
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn force<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.force = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for force failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn wait_if_ongoing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.wait_if_ongoing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for wait_if_ongoing failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_flush`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      allow_no_indices,
      expand_wildcards,
      force,
      ignore_unavailable,
      wait_if_ongoing,
    } = self;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let force = force.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let wait_if_ongoing = wait_if_ongoing.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_flush", client.baseurl,);
    let mut query = Vec::with_capacity(5usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &force {
      query.push(("force", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &wait_if_ongoing {
      query.push(("wait_if_ongoing", v.to_string()));
    }
    let request = client.client.post(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_forcemerge`]
///
///[`Client::indices_forcemerge`]: super::Client::indices_forcemerge
#[derive(Debug, Clone)]
pub struct IndicesForcemerge<'a> {
  client: &'a super::Client,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  flush: Result<Option<bool>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  max_num_segments: Result<Option<i32>, String>,
  only_expunge_deletes: Result<Option<bool>, String>,
}

impl<'a> IndicesForcemerge<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      flush: Ok(None),
      ignore_unavailable: Ok(None),
      max_num_segments: Ok(None),
      only_expunge_deletes: Ok(None),
    }
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn flush<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.flush = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for flush failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn max_num_segments<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.max_num_segments = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for max_num_segments failed".to_string());
    self
  }

  pub fn only_expunge_deletes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.only_expunge_deletes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for only_expunge_deletes failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_forcemerge`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      allow_no_indices,
      expand_wildcards,
      flush,
      ignore_unavailable,
      max_num_segments,
      only_expunge_deletes,
    } = self;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let flush = flush.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let max_num_segments = max_num_segments.map_err(Error::InvalidRequest)?;
    let only_expunge_deletes = only_expunge_deletes.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_forcemerge", client.baseurl,);
    let mut query = Vec::with_capacity(6usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &flush {
      query.push(("flush", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &max_num_segments {
      query.push(("max_num_segments", v.to_string()));
    }
    if let Some(v) = &only_expunge_deletes {
      query.push(("only_expunge_deletes", v.to_string()));
    }
    let request = client.client.post(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_get_index_template`]
///
///[`Client::indices_get_index_template`]: super::Client::indices_get_index_template
#[derive(Debug, Clone)]
pub struct IndicesGetIndexTemplate<'a> {
  client: &'a super::Client,
  cluster_manager_timeout: Result<Option<types::IndicesGetIndexTemplateClusterManagerTimeout>, String>,
  flat_settings: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::IndicesGetIndexTemplateMasterTimeout>, String>,
}

impl<'a> IndicesGetIndexTemplate<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      cluster_manager_timeout: Ok(None),
      flat_settings: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
    }
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesGetIndexTemplateClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesGetIndexTemplateClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn flat_settings<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.flat_settings = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesGetIndexTemplateMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesGetIndexTemplateMasterTimeout` for master_timeout failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_index_template`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      cluster_manager_timeout,
      flat_settings,
      local,
      master_timeout,
    } = self;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_index_template", client.baseurl,);
    let mut query = Vec::with_capacity(4usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &flat_settings {
      query.push(("flat_settings", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_simulate_template`]
///
///[`Client::indices_simulate_template`]: super::Client::indices_simulate_template
#[derive(Debug, Clone)]
pub struct IndicesSimulateTemplate<'a> {
  client: &'a super::Client,
  cause: Result<Option<String>, String>,
  cluster_manager_timeout: Result<Option<types::IndicesSimulateTemplateClusterManagerTimeout>, String>,
  create: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::IndicesSimulateTemplateMasterTimeout>, String>,
  body: Result<types::IndicesSimulateTemplateBodyParams, String>,
}

impl<'a> IndicesSimulateTemplate<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      cause: Ok(None),
      cluster_manager_timeout: Ok(None),
      create: Ok(None),
      master_timeout: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn cause<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.cause = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for cause failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesSimulateTemplateClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesSimulateTemplateClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn create<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.create = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for create failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesSimulateTemplateMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesSimulateTemplateMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesSimulateTemplateBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `IndicesSimulateTemplateBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_index_template/_simulate`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      cause,
      cluster_manager_timeout,
      create,
      master_timeout,
      body,
    } = self;
    let cause = cause.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let create = create.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_index_template/_simulate", client.baseurl,);
    let mut query = Vec::with_capacity(4usize);
    if let Some(v) = &cause {
      query.push(("cause", v.to_string()));
    }
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &create {
      query.push(("create", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_simulate_template_with_name`]
///
///[`Client::indices_simulate_template_with_name`]: super::Client::indices_simulate_template_with_name
#[derive(Debug, Clone)]
pub struct IndicesSimulateTemplateWithName<'a> {
  client: &'a super::Client,
  name: Result<types::IndicesSimulateTemplateWithNameName, String>,
  cause: Result<Option<String>, String>,
  cluster_manager_timeout: Result<Option<types::IndicesSimulateTemplateWithNameClusterManagerTimeout>, String>,
  create: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::IndicesSimulateTemplateWithNameMasterTimeout>, String>,
  body: Result<types::IndicesSimulateTemplateBodyParams, String>,
}

impl<'a> IndicesSimulateTemplateWithName<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      name: Err("name was not initialized".to_string()),
      cause: Ok(None),
      cluster_manager_timeout: Ok(None),
      create: Ok(None),
      master_timeout: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesSimulateTemplateWithNameName>, {
    self.name = value
      .try_into()
      .map_err(|_| "conversion to `IndicesSimulateTemplateWithNameName` for name failed".to_string());
    self
  }

  pub fn cause<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.cause = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for cause failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesSimulateTemplateWithNameClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesSimulateTemplateWithNameClusterManagerTimeout` for cluster_manager_timeout failed"
        .to_string()
    });
    self
  }

  pub fn create<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.create = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for create failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesSimulateTemplateWithNameMasterTimeout>, {
    self.master_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesSimulateTemplateWithNameMasterTimeout` for master_timeout failed".to_string()
    });
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesSimulateTemplateBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `IndicesSimulateTemplateBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_index_template/_simulate/{name}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      name,
      cause,
      cluster_manager_timeout,
      create,
      master_timeout,
      body,
    } = self;
    let name = name.map_err(Error::InvalidRequest)?;
    let cause = cause.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let create = create.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_index_template/_simulate/{}",
      client.baseurl,
      encode_path(&name.to_string()),
    );
    let mut query = Vec::with_capacity(4usize);
    if let Some(v) = &cause {
      query.push(("cause", v.to_string()));
    }
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &create {
      query.push(("create", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_simulate_index_template`]
///
///[`Client::indices_simulate_index_template`]: super::Client::indices_simulate_index_template
#[derive(Debug, Clone)]
pub struct IndicesSimulateIndexTemplate<'a> {
  client: &'a super::Client,
  name: Result<types::IndicesSimulateIndexTemplateName, String>,
  cause: Result<Option<String>, String>,
  cluster_manager_timeout: Result<Option<types::IndicesSimulateIndexTemplateClusterManagerTimeout>, String>,
  create: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::IndicesSimulateIndexTemplateMasterTimeout>, String>,
  body: Result<types::IndicesSimulateIndexTemplateBodyParams, String>,
}

impl<'a> IndicesSimulateIndexTemplate<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      name: Err("name was not initialized".to_string()),
      cause: Ok(None),
      cluster_manager_timeout: Ok(None),
      create: Ok(None),
      master_timeout: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesSimulateIndexTemplateName>, {
    self.name = value
      .try_into()
      .map_err(|_| "conversion to `IndicesSimulateIndexTemplateName` for name failed".to_string());
    self
  }

  pub fn cause<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.cause = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for cause failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesSimulateIndexTemplateClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesSimulateIndexTemplateClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn create<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.create = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for create failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesSimulateIndexTemplateMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesSimulateIndexTemplateMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesSimulateIndexTemplateBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `IndicesSimulateIndexTemplateBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_index_template/_simulate_index/{name}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      name,
      cause,
      cluster_manager_timeout,
      create,
      master_timeout,
      body,
    } = self;
    let name = name.map_err(Error::InvalidRequest)?;
    let cause = cause.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let create = create.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_index_template/_simulate_index/{}",
      client.baseurl,
      encode_path(&name.to_string()),
    );
    let mut query = Vec::with_capacity(4usize);
    if let Some(v) = &cause {
      query.push(("cause", v.to_string()));
    }
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &create {
      query.push(("create", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_get_index_template_with_name`]
///
///[`Client::indices_get_index_template_with_name`]: super::Client::indices_get_index_template_with_name
#[derive(Debug, Clone)]
pub struct IndicesGetIndexTemplateWithName<'a> {
  client: &'a super::Client,
  name: Result<types::IndicesGetIndexTemplateWithNameName, String>,
  cluster_manager_timeout: Result<Option<types::IndicesGetIndexTemplateWithNameClusterManagerTimeout>, String>,
  flat_settings: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::IndicesGetIndexTemplateWithNameMasterTimeout>, String>,
}

impl<'a> IndicesGetIndexTemplateWithName<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      name: Err("name was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      flat_settings: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
    }
  }

  pub fn name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesGetIndexTemplateWithNameName>, {
    self.name = value
      .try_into()
      .map_err(|_| "conversion to `IndicesGetIndexTemplateWithNameName` for name failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesGetIndexTemplateWithNameClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesGetIndexTemplateWithNameClusterManagerTimeout` for cluster_manager_timeout failed"
        .to_string()
    });
    self
  }

  pub fn flat_settings<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.flat_settings = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesGetIndexTemplateWithNameMasterTimeout>, {
    self.master_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesGetIndexTemplateWithNameMasterTimeout` for master_timeout failed".to_string()
    });
    self
  }

  ///Sends a `GET` request to `/_index_template/{name}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      name,
      cluster_manager_timeout,
      flat_settings,
      local,
      master_timeout,
    } = self;
    let name = name.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_index_template/{}", client.baseurl, encode_path(&name.to_string()),);
    let mut query = Vec::with_capacity(4usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &flat_settings {
      query.push(("flat_settings", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_put_index_template_put`]
///
///[`Client::indices_put_index_template_put`]: super::Client::indices_put_index_template_put
#[derive(Debug, Clone)]
pub struct IndicesPutIndexTemplatePut<'a> {
  client: &'a super::Client,
  name: Result<types::IndicesPutIndexTemplatePutName, String>,
  cause: Result<Option<String>, String>,
  cluster_manager_timeout: Result<Option<types::IndicesPutIndexTemplatePutClusterManagerTimeout>, String>,
  create: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::IndicesPutIndexTemplatePutMasterTimeout>, String>,
  body: Result<types::IndicesPutIndexTemplateBodyParams, String>,
}

impl<'a> IndicesPutIndexTemplatePut<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      name: Err("name was not initialized".to_string()),
      cause: Ok(None),
      cluster_manager_timeout: Ok(None),
      create: Ok(None),
      master_timeout: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutIndexTemplatePutName>, {
    self.name = value
      .try_into()
      .map_err(|_| "conversion to `IndicesPutIndexTemplatePutName` for name failed".to_string());
    self
  }

  pub fn cause<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.cause = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for cause failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutIndexTemplatePutClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesPutIndexTemplatePutClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn create<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.create = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for create failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutIndexTemplatePutMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesPutIndexTemplatePutMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutIndexTemplateBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `IndicesPutIndexTemplateBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `PUT` request to `/_index_template/{name}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      name,
      cause,
      cluster_manager_timeout,
      create,
      master_timeout,
      body,
    } = self;
    let name = name.map_err(Error::InvalidRequest)?;
    let cause = cause.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let create = create.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_index_template/{}", client.baseurl, encode_path(&name.to_string()),);
    let mut query = Vec::with_capacity(4usize);
    if let Some(v) = &cause {
      query.push(("cause", v.to_string()));
    }
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &create {
      query.push(("create", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    let request = client.client.put(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_put_index_template_post`]
///
///[`Client::indices_put_index_template_post`]: super::Client::indices_put_index_template_post
#[derive(Debug, Clone)]
pub struct IndicesPutIndexTemplatePost<'a> {
  client: &'a super::Client,
  name: Result<types::IndicesPutIndexTemplatePostName, String>,
  cause: Result<Option<String>, String>,
  cluster_manager_timeout: Result<Option<types::IndicesPutIndexTemplatePostClusterManagerTimeout>, String>,
  create: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::IndicesPutIndexTemplatePostMasterTimeout>, String>,
  body: Result<types::IndicesPutIndexTemplateBodyParams, String>,
}

impl<'a> IndicesPutIndexTemplatePost<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      name: Err("name was not initialized".to_string()),
      cause: Ok(None),
      cluster_manager_timeout: Ok(None),
      create: Ok(None),
      master_timeout: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutIndexTemplatePostName>, {
    self.name = value
      .try_into()
      .map_err(|_| "conversion to `IndicesPutIndexTemplatePostName` for name failed".to_string());
    self
  }

  pub fn cause<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.cause = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for cause failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutIndexTemplatePostClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesPutIndexTemplatePostClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn create<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.create = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for create failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutIndexTemplatePostMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesPutIndexTemplatePostMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutIndexTemplateBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `IndicesPutIndexTemplateBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_index_template/{name}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      name,
      cause,
      cluster_manager_timeout,
      create,
      master_timeout,
      body,
    } = self;
    let name = name.map_err(Error::InvalidRequest)?;
    let cause = cause.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let create = create.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_index_template/{}", client.baseurl, encode_path(&name.to_string()),);
    let mut query = Vec::with_capacity(4usize);
    if let Some(v) = &cause {
      query.push(("cause", v.to_string()));
    }
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &create {
      query.push(("create", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_delete_index_template`]
///
///[`Client::indices_delete_index_template`]: super::Client::indices_delete_index_template
#[derive(Debug, Clone)]
pub struct IndicesDeleteIndexTemplate<'a> {
  client: &'a super::Client,
  name: Result<types::IndicesDeleteIndexTemplateName, String>,
  cluster_manager_timeout: Result<Option<types::IndicesDeleteIndexTemplateClusterManagerTimeout>, String>,
  master_timeout: Result<Option<types::IndicesDeleteIndexTemplateMasterTimeout>, String>,
  timeout: Result<Option<types::IndicesDeleteIndexTemplateTimeout>, String>,
}

impl<'a> IndicesDeleteIndexTemplate<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      name: Err("name was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
    }
  }

  pub fn name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesDeleteIndexTemplateName>, {
    self.name = value
      .try_into()
      .map_err(|_| "conversion to `IndicesDeleteIndexTemplateName` for name failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesDeleteIndexTemplateClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesDeleteIndexTemplateClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesDeleteIndexTemplateMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesDeleteIndexTemplateMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesDeleteIndexTemplateTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesDeleteIndexTemplateTimeout` for timeout failed".to_string());
    self
  }

  ///Sends a `DELETE` request to `/_index_template/{name}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      name,
      cluster_manager_timeout,
      master_timeout,
      timeout,
    } = self;
    let name = name.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_index_template/{}", client.baseurl, encode_path(&name.to_string()),);
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client.client.delete(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_exists_index_template`]
///
///[`Client::indices_exists_index_template`]: super::Client::indices_exists_index_template
#[derive(Debug, Clone)]
pub struct IndicesExistsIndexTemplate<'a> {
  client: &'a super::Client,
  name: Result<types::IndicesExistsIndexTemplateName, String>,
  flat_settings: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::IndicesExistsIndexTemplateMasterTimeout>, String>,
}

impl<'a> IndicesExistsIndexTemplate<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      name: Err("name was not initialized".to_string()),
      flat_settings: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
    }
  }

  pub fn name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesExistsIndexTemplateName>, {
    self.name = value
      .try_into()
      .map_err(|_| "conversion to `IndicesExistsIndexTemplateName` for name failed".to_string());
    self
  }

  pub fn flat_settings<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.flat_settings = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesExistsIndexTemplateMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesExistsIndexTemplateMasterTimeout` for master_timeout failed".to_string());
    self
  }

  ///Sends a `HEAD` request to `/_index_template/{name}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      name,
      flat_settings,
      local,
      master_timeout,
    } = self;
    let name = name.map_err(Error::InvalidRequest)?;
    let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_index_template/{}", client.baseurl, encode_path(&name.to_string()),);
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &flat_settings {
      query.push(("flat_settings", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    let request = client.client.head(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::ingest_get_pipeline`]
///
///[`Client::ingest_get_pipeline`]: super::Client::ingest_get_pipeline
#[derive(Debug, Clone)]
pub struct IngestGetPipeline<'a> {
  client: &'a super::Client,
  cluster_manager_timeout: Result<Option<types::IngestGetPipelineClusterManagerTimeout>, String>,
  master_timeout: Result<Option<types::IngestGetPipelineMasterTimeout>, String>,
}

impl<'a> IngestGetPipeline<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      cluster_manager_timeout: Ok(None),
      master_timeout: Ok(None),
    }
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IngestGetPipelineClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IngestGetPipelineClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IngestGetPipelineMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IngestGetPipelineMasterTimeout` for master_timeout failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_ingest/pipeline`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      cluster_manager_timeout,
      master_timeout,
    } = self;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_ingest/pipeline", client.baseurl,);
    let mut query = Vec::with_capacity(2usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::ingest_simulate_get`]
///
///[`Client::ingest_simulate_get`]: super::Client::ingest_simulate_get
#[derive(Debug, Clone)]
pub struct IngestSimulateGet<'a> {
  client: &'a super::Client,
  verbose: Result<Option<bool>, String>,
}

impl<'a> IngestSimulateGet<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      verbose: Ok(None),
    }
  }

  pub fn verbose<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.verbose = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for verbose failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_ingest/pipeline/_simulate`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self { client, verbose } = self;
    let verbose = verbose.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_ingest/pipeline/_simulate", client.baseurl,);
    let mut query = Vec::with_capacity(1usize);
    if let Some(v) = &verbose {
      query.push(("verbose", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::ingest_simulate_post`]
///
///[`Client::ingest_simulate_post`]: super::Client::ingest_simulate_post
#[derive(Debug, Clone)]
pub struct IngestSimulatePost<'a> {
  client: &'a super::Client,
  verbose: Result<Option<bool>, String>,
  body: Result<types::IngestSimulateBodyParams, String>,
}

impl<'a> IngestSimulatePost<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      verbose: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn verbose<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.verbose = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for verbose failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IngestSimulateBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `IngestSimulateBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_ingest/pipeline/_simulate`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self { client, verbose, body } = self;
    let verbose = verbose.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_ingest/pipeline/_simulate", client.baseurl,);
    let mut query = Vec::with_capacity(1usize);
    if let Some(v) = &verbose {
      query.push(("verbose", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::ingest_get_pipeline_with_id`]
///
///[`Client::ingest_get_pipeline_with_id`]: super::Client::ingest_get_pipeline_with_id
#[derive(Debug, Clone)]
pub struct IngestGetPipelineWithId<'a> {
  client: &'a super::Client,
  id: Result<types::IngestGetPipelineWithIdId, String>,
  cluster_manager_timeout: Result<Option<types::IngestGetPipelineWithIdClusterManagerTimeout>, String>,
  master_timeout: Result<Option<types::IngestGetPipelineWithIdMasterTimeout>, String>,
}

impl<'a> IngestGetPipelineWithId<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      id: Err("id was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      master_timeout: Ok(None),
    }
  }

  pub fn id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IngestGetPipelineWithIdId>, {
    self.id = value
      .try_into()
      .map_err(|_| "conversion to `IngestGetPipelineWithIdId` for id failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IngestGetPipelineWithIdClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IngestGetPipelineWithIdClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IngestGetPipelineWithIdMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IngestGetPipelineWithIdMasterTimeout` for master_timeout failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_ingest/pipeline/{id}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      id,
      cluster_manager_timeout,
      master_timeout,
    } = self;
    let id = id.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_ingest/pipeline/{}", client.baseurl, encode_path(&id.to_string()),);
    let mut query = Vec::with_capacity(2usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::ingest_put_pipeline`]
///
///[`Client::ingest_put_pipeline`]: super::Client::ingest_put_pipeline
#[derive(Debug, Clone)]
pub struct IngestPutPipeline<'a> {
  client: &'a super::Client,
  id: Result<types::IngestPutPipelineId, String>,
  cluster_manager_timeout: Result<Option<types::IngestPutPipelineClusterManagerTimeout>, String>,
  master_timeout: Result<Option<types::IngestPutPipelineMasterTimeout>, String>,
  timeout: Result<Option<types::IngestPutPipelineTimeout>, String>,
  body: Result<types::IngestPutPipelineBodyParams, String>,
}

impl<'a> IngestPutPipeline<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      id: Err("id was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IngestPutPipelineId>, {
    self.id = value
      .try_into()
      .map_err(|_| "conversion to `IngestPutPipelineId` for id failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IngestPutPipelineClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IngestPutPipelineClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IngestPutPipelineMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IngestPutPipelineMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IngestPutPipelineTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IngestPutPipelineTimeout` for timeout failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IngestPutPipelineBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `IngestPutPipelineBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `PUT` request to `/_ingest/pipeline/{id}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      id,
      cluster_manager_timeout,
      master_timeout,
      timeout,
      body,
    } = self;
    let id = id.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_ingest/pipeline/{}", client.baseurl, encode_path(&id.to_string()),);
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client.client.put(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::ingest_delete_pipeline`]
///
///[`Client::ingest_delete_pipeline`]: super::Client::ingest_delete_pipeline
#[derive(Debug, Clone)]
pub struct IngestDeletePipeline<'a> {
  client: &'a super::Client,
  id: Result<types::IngestDeletePipelineId, String>,
  cluster_manager_timeout: Result<Option<types::IngestDeletePipelineClusterManagerTimeout>, String>,
  master_timeout: Result<Option<types::IngestDeletePipelineMasterTimeout>, String>,
  timeout: Result<Option<types::IngestDeletePipelineTimeout>, String>,
}

impl<'a> IngestDeletePipeline<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      id: Err("id was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
    }
  }

  pub fn id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IngestDeletePipelineId>, {
    self.id = value
      .try_into()
      .map_err(|_| "conversion to `IngestDeletePipelineId` for id failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IngestDeletePipelineClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IngestDeletePipelineClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IngestDeletePipelineMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IngestDeletePipelineMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IngestDeletePipelineTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IngestDeletePipelineTimeout` for timeout failed".to_string());
    self
  }

  ///Sends a `DELETE` request to `/_ingest/pipeline/{id}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      id,
      cluster_manager_timeout,
      master_timeout,
      timeout,
    } = self;
    let id = id.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_ingest/pipeline/{}", client.baseurl, encode_path(&id.to_string()),);
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client.client.delete(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::ingest_simulate_get_with_id`]
///
///[`Client::ingest_simulate_get_with_id`]: super::Client::ingest_simulate_get_with_id
#[derive(Debug, Clone)]
pub struct IngestSimulateGetWithId<'a> {
  client: &'a super::Client,
  id: Result<types::IngestSimulateGetWithIdId, String>,
  verbose: Result<Option<bool>, String>,
}

impl<'a> IngestSimulateGetWithId<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      id: Err("id was not initialized".to_string()),
      verbose: Ok(None),
    }
  }

  pub fn id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IngestSimulateGetWithIdId>, {
    self.id = value
      .try_into()
      .map_err(|_| "conversion to `IngestSimulateGetWithIdId` for id failed".to_string());
    self
  }

  pub fn verbose<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.verbose = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for verbose failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_ingest/pipeline/{id}/_simulate`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self { client, id, verbose } = self;
    let id = id.map_err(Error::InvalidRequest)?;
    let verbose = verbose.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_ingest/pipeline/{}/_simulate",
      client.baseurl,
      encode_path(&id.to_string()),
    );
    let mut query = Vec::with_capacity(1usize);
    if let Some(v) = &verbose {
      query.push(("verbose", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::ingest_simulate_post_with_id`]
///
///[`Client::ingest_simulate_post_with_id`]: super::Client::ingest_simulate_post_with_id
#[derive(Debug, Clone)]
pub struct IngestSimulatePostWithId<'a> {
  client: &'a super::Client,
  id: Result<types::IngestSimulatePostWithIdId, String>,
  verbose: Result<Option<bool>, String>,
  body: Result<types::IngestSimulateBodyParams, String>,
}

impl<'a> IngestSimulatePostWithId<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      id: Err("id was not initialized".to_string()),
      verbose: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IngestSimulatePostWithIdId>, {
    self.id = value
      .try_into()
      .map_err(|_| "conversion to `IngestSimulatePostWithIdId` for id failed".to_string());
    self
  }

  pub fn verbose<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.verbose = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for verbose failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IngestSimulateBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `IngestSimulateBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_ingest/pipeline/{id}/_simulate`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      id,
      verbose,
      body,
    } = self;
    let id = id.map_err(Error::InvalidRequest)?;
    let verbose = verbose.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_ingest/pipeline/{}/_simulate",
      client.baseurl,
      encode_path(&id.to_string()),
    );
    let mut query = Vec::with_capacity(1usize);
    if let Some(v) = &verbose {
      query.push(("verbose", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::ingest_processor_grok`]
///
///[`Client::ingest_processor_grok`]: super::Client::ingest_processor_grok
#[derive(Debug, Clone)]
pub struct IngestProcessorGrok<'a> {
  client: &'a super::Client,
}

impl<'a> IngestProcessorGrok<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self { client }
  }

  ///Sends a `GET` request to `/_ingest/processor/grok`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self { client } = self;
    let url = format!("{}/_ingest/processor/grok", client.baseurl,);
    let request = client.client.get(url).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_get_mapping`]
///
///[`Client::indices_get_mapping`]: super::Client::indices_get_mapping
#[derive(Debug, Clone)]
pub struct IndicesGetMapping<'a> {
  client: &'a super::Client,
  allow_no_indices: Result<Option<bool>, String>,
  cluster_manager_timeout: Result<Option<types::IndicesGetMappingClusterManagerTimeout>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::IndicesGetMappingMasterTimeout>, String>,
}

impl<'a> IndicesGetMapping<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      allow_no_indices: Ok(None),
      cluster_manager_timeout: Ok(None),
      expand_wildcards: Ok(None),
      ignore_unavailable: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
    }
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesGetMappingClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesGetMappingClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesGetMappingMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesGetMappingMasterTimeout` for master_timeout failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_mapping`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      allow_no_indices,
      cluster_manager_timeout,
      expand_wildcards,
      ignore_unavailable,
      local,
      master_timeout,
    } = self;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_mapping", client.baseurl,);
    let mut query = Vec::with_capacity(6usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_get_field_mapping`]
///
///[`Client::indices_get_field_mapping`]: super::Client::indices_get_field_mapping
#[derive(Debug, Clone)]
pub struct IndicesGetFieldMapping<'a> {
  client: &'a super::Client,
  fields: Result<types::IndicesGetFieldMappingFields, String>,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  include_defaults: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
}

impl<'a> IndicesGetFieldMapping<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      fields: Err("fields was not initialized".to_string()),
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      ignore_unavailable: Ok(None),
      include_defaults: Ok(None),
      local: Ok(None),
    }
  }

  pub fn fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesGetFieldMappingFields>, {
    self.fields = value
      .try_into()
      .map_err(|_| "conversion to `IndicesGetFieldMappingFields` for fields failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn include_defaults<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.include_defaults = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for include_defaults failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_mapping/field/{fields}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      fields,
      allow_no_indices,
      expand_wildcards,
      ignore_unavailable,
      include_defaults,
      local,
    } = self;
    let fields = fields.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let include_defaults = include_defaults.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_mapping/field/{}", client.baseurl, encode_path(&fields.to_string()),);
    let mut query = Vec::with_capacity(5usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &include_defaults {
      query.push(("include_defaults", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::mget_get`]
///
///[`Client::mget_get`]: super::Client::mget_get
#[derive(Debug, Clone)]
pub struct MgetGet<'a> {
  client: &'a super::Client,
  source: Result<Option<Vec<String>>, String>,
  source_excludes: Result<Option<Vec<String>>, String>,
  source_includes: Result<Option<Vec<String>>, String>,
  preference: Result<Option<String>, String>,
  realtime: Result<Option<bool>, String>,
  refresh: Result<Option<bool>, String>,
  routing: Result<Option<String>, String>,
  stored_fields: Result<Option<Vec<String>>, String>,
}

impl<'a> MgetGet<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      source: Ok(None),
      source_excludes: Ok(None),
      source_includes: Ok(None),
      preference: Ok(None),
      realtime: Ok(None),
      refresh: Ok(None),
      routing: Ok(None),
      stored_fields: Ok(None),
    }
  }

  pub fn source<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source failed".to_string());
    self
  }

  pub fn source_excludes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source_excludes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source_excludes failed".to_string());
    self
  }

  pub fn source_includes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source_includes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source_includes failed".to_string());
    self
  }

  pub fn preference<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.preference = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for preference failed".to_string());
    self
  }

  pub fn realtime<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.realtime = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for realtime failed".to_string());
    self
  }

  pub fn refresh<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.refresh = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for refresh failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for routing failed".to_string());
    self
  }

  pub fn stored_fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.stored_fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for stored_fields failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_mget`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      source,
      source_excludes,
      source_includes,
      preference,
      realtime,
      refresh,
      routing,
      stored_fields,
    } = self;
    let source = source.map_err(Error::InvalidRequest)?;
    let source_excludes = source_excludes.map_err(Error::InvalidRequest)?;
    let source_includes = source_includes.map_err(Error::InvalidRequest)?;
    let preference = preference.map_err(Error::InvalidRequest)?;
    let realtime = realtime.map_err(Error::InvalidRequest)?;
    let refresh = refresh.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let stored_fields = stored_fields.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_mget", client.baseurl,);
    let mut query = Vec::with_capacity(8usize);
    if let Some(v) = &source {
      query.push(("_source", v.join(",")));
    }
    if let Some(v) = &source_excludes {
      query.push(("_source_excludes", v.join(",")));
    }
    if let Some(v) = &source_includes {
      query.push(("_source_includes", v.join(",")));
    }
    if let Some(v) = &preference {
      query.push(("preference", v.to_string()));
    }
    if let Some(v) = &realtime {
      query.push(("realtime", v.to_string()));
    }
    if let Some(v) = &refresh {
      query.push(("refresh", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.to_string()));
    }
    if let Some(v) = &stored_fields {
      query.push(("stored_fields", v.join(",")));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::mget_post`]
///
///[`Client::mget_post`]: super::Client::mget_post
#[derive(Debug, Clone)]
pub struct MgetPost<'a> {
  client: &'a super::Client,
  source: Result<Option<Vec<String>>, String>,
  source_excludes: Result<Option<Vec<String>>, String>,
  source_includes: Result<Option<Vec<String>>, String>,
  preference: Result<Option<String>, String>,
  realtime: Result<Option<bool>, String>,
  refresh: Result<Option<bool>, String>,
  routing: Result<Option<String>, String>,
  stored_fields: Result<Option<Vec<String>>, String>,
  body: Result<types::MgetBodyParams, String>,
}

impl<'a> MgetPost<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      source: Ok(None),
      source_excludes: Ok(None),
      source_includes: Ok(None),
      preference: Ok(None),
      realtime: Ok(None),
      refresh: Ok(None),
      routing: Ok(None),
      stored_fields: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn source<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source failed".to_string());
    self
  }

  pub fn source_excludes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source_excludes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source_excludes failed".to_string());
    self
  }

  pub fn source_includes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source_includes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source_includes failed".to_string());
    self
  }

  pub fn preference<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.preference = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for preference failed".to_string());
    self
  }

  pub fn realtime<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.realtime = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for realtime failed".to_string());
    self
  }

  pub fn refresh<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.refresh = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for refresh failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for routing failed".to_string());
    self
  }

  pub fn stored_fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.stored_fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for stored_fields failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::MgetBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `MgetBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_mget`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      source,
      source_excludes,
      source_includes,
      preference,
      realtime,
      refresh,
      routing,
      stored_fields,
      body,
    } = self;
    let source = source.map_err(Error::InvalidRequest)?;
    let source_excludes = source_excludes.map_err(Error::InvalidRequest)?;
    let source_includes = source_includes.map_err(Error::InvalidRequest)?;
    let preference = preference.map_err(Error::InvalidRequest)?;
    let realtime = realtime.map_err(Error::InvalidRequest)?;
    let refresh = refresh.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let stored_fields = stored_fields.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_mget", client.baseurl,);
    let mut query = Vec::with_capacity(8usize);
    if let Some(v) = &source {
      query.push(("_source", v.join(",")));
    }
    if let Some(v) = &source_excludes {
      query.push(("_source_excludes", v.join(",")));
    }
    if let Some(v) = &source_includes {
      query.push(("_source_includes", v.join(",")));
    }
    if let Some(v) = &preference {
      query.push(("preference", v.to_string()));
    }
    if let Some(v) = &realtime {
      query.push(("realtime", v.to_string()));
    }
    if let Some(v) = &refresh {
      query.push(("refresh", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.to_string()));
    }
    if let Some(v) = &stored_fields {
      query.push(("stored_fields", v.join(",")));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::msearch_get`]
///
///[`Client::msearch_get`]: super::Client::msearch_get
#[derive(Debug, Clone)]
pub struct MsearchGet<'a> {
  client: &'a super::Client,
  ccs_minimize_roundtrips: Result<Option<bool>, String>,
  max_concurrent_searches: Result<Option<i32>, String>,
  max_concurrent_shard_requests: Result<Option<i32>, String>,
  pre_filter_shard_size: Result<Option<i32>, String>,
  rest_total_hits_as_int: Result<Option<bool>, String>,
  search_type: Result<Option<types::SearchTypeMulti>, String>,
  typed_keys: Result<Option<bool>, String>,
}

impl<'a> MsearchGet<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      ccs_minimize_roundtrips: Ok(None),
      max_concurrent_searches: Ok(None),
      max_concurrent_shard_requests: Ok(None),
      pre_filter_shard_size: Ok(None),
      rest_total_hits_as_int: Ok(None),
      search_type: Ok(None),
      typed_keys: Ok(None),
    }
  }

  pub fn ccs_minimize_roundtrips<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ccs_minimize_roundtrips = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ccs_minimize_roundtrips failed".to_string());
    self
  }

  pub fn max_concurrent_searches<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.max_concurrent_searches = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for max_concurrent_searches failed".to_string());
    self
  }

  pub fn max_concurrent_shard_requests<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.max_concurrent_shard_requests = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for max_concurrent_shard_requests failed".to_string());
    self
  }

  pub fn pre_filter_shard_size<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.pre_filter_shard_size = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for pre_filter_shard_size failed".to_string());
    self
  }

  pub fn rest_total_hits_as_int<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.rest_total_hits_as_int = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for rest_total_hits_as_int failed".to_string());
    self
  }

  pub fn search_type<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SearchTypeMulti>, {
    self.search_type = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SearchTypeMulti` for search_type failed".to_string());
    self
  }

  pub fn typed_keys<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.typed_keys = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for typed_keys failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_msearch`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      ccs_minimize_roundtrips,
      max_concurrent_searches,
      max_concurrent_shard_requests,
      pre_filter_shard_size,
      rest_total_hits_as_int,
      search_type,
      typed_keys,
    } = self;
    let ccs_minimize_roundtrips = ccs_minimize_roundtrips.map_err(Error::InvalidRequest)?;
    let max_concurrent_searches = max_concurrent_searches.map_err(Error::InvalidRequest)?;
    let max_concurrent_shard_requests = max_concurrent_shard_requests.map_err(Error::InvalidRequest)?;
    let pre_filter_shard_size = pre_filter_shard_size.map_err(Error::InvalidRequest)?;
    let rest_total_hits_as_int = rest_total_hits_as_int.map_err(Error::InvalidRequest)?;
    let search_type = search_type.map_err(Error::InvalidRequest)?;
    let typed_keys = typed_keys.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_msearch", client.baseurl,);
    let mut query = Vec::with_capacity(7usize);
    if let Some(v) = &ccs_minimize_roundtrips {
      query.push(("ccs_minimize_roundtrips", v.to_string()));
    }
    if let Some(v) = &max_concurrent_searches {
      query.push(("max_concurrent_searches", v.to_string()));
    }
    if let Some(v) = &max_concurrent_shard_requests {
      query.push(("max_concurrent_shard_requests", v.to_string()));
    }
    if let Some(v) = &pre_filter_shard_size {
      query.push(("pre_filter_shard_size", v.to_string()));
    }
    if let Some(v) = &rest_total_hits_as_int {
      query.push(("rest_total_hits_as_int", v.to_string()));
    }
    if let Some(v) = &search_type {
      query.push(("search_type", v.to_string()));
    }
    if let Some(v) = &typed_keys {
      query.push(("typed_keys", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::msearch_post`]
///
///[`Client::msearch_post`]: super::Client::msearch_post
#[derive(Debug, Clone)]
pub struct MsearchPost<'a> {
  client: &'a super::Client,
  ccs_minimize_roundtrips: Result<Option<bool>, String>,
  max_concurrent_searches: Result<Option<i32>, String>,
  max_concurrent_shard_requests: Result<Option<i32>, String>,
  pre_filter_shard_size: Result<Option<i32>, String>,
  rest_total_hits_as_int: Result<Option<bool>, String>,
  search_type: Result<Option<types::SearchTypeMulti>, String>,
  typed_keys: Result<Option<bool>, String>,
  body: Result<types::MsearchBodyParams, String>,
}

impl<'a> MsearchPost<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      ccs_minimize_roundtrips: Ok(None),
      max_concurrent_searches: Ok(None),
      max_concurrent_shard_requests: Ok(None),
      pre_filter_shard_size: Ok(None),
      rest_total_hits_as_int: Ok(None),
      search_type: Ok(None),
      typed_keys: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn ccs_minimize_roundtrips<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ccs_minimize_roundtrips = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ccs_minimize_roundtrips failed".to_string());
    self
  }

  pub fn max_concurrent_searches<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.max_concurrent_searches = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for max_concurrent_searches failed".to_string());
    self
  }

  pub fn max_concurrent_shard_requests<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.max_concurrent_shard_requests = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for max_concurrent_shard_requests failed".to_string());
    self
  }

  pub fn pre_filter_shard_size<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.pre_filter_shard_size = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for pre_filter_shard_size failed".to_string());
    self
  }

  pub fn rest_total_hits_as_int<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.rest_total_hits_as_int = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for rest_total_hits_as_int failed".to_string());
    self
  }

  pub fn search_type<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SearchTypeMulti>, {
    self.search_type = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SearchTypeMulti` for search_type failed".to_string());
    self
  }

  pub fn typed_keys<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.typed_keys = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for typed_keys failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::MsearchBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `MsearchBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_msearch`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      ccs_minimize_roundtrips,
      max_concurrent_searches,
      max_concurrent_shard_requests,
      pre_filter_shard_size,
      rest_total_hits_as_int,
      search_type,
      typed_keys,
      body,
    } = self;
    let ccs_minimize_roundtrips = ccs_minimize_roundtrips.map_err(Error::InvalidRequest)?;
    let max_concurrent_searches = max_concurrent_searches.map_err(Error::InvalidRequest)?;
    let max_concurrent_shard_requests = max_concurrent_shard_requests.map_err(Error::InvalidRequest)?;
    let pre_filter_shard_size = pre_filter_shard_size.map_err(Error::InvalidRequest)?;
    let rest_total_hits_as_int = rest_total_hits_as_int.map_err(Error::InvalidRequest)?;
    let search_type = search_type.map_err(Error::InvalidRequest)?;
    let typed_keys = typed_keys.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_msearch", client.baseurl,);
    let mut query = Vec::with_capacity(7usize);
    if let Some(v) = &ccs_minimize_roundtrips {
      query.push(("ccs_minimize_roundtrips", v.to_string()));
    }
    if let Some(v) = &max_concurrent_searches {
      query.push(("max_concurrent_searches", v.to_string()));
    }
    if let Some(v) = &max_concurrent_shard_requests {
      query.push(("max_concurrent_shard_requests", v.to_string()));
    }
    if let Some(v) = &pre_filter_shard_size {
      query.push(("pre_filter_shard_size", v.to_string()));
    }
    if let Some(v) = &rest_total_hits_as_int {
      query.push(("rest_total_hits_as_int", v.to_string()));
    }
    if let Some(v) = &search_type {
      query.push(("search_type", v.to_string()));
    }
    if let Some(v) = &typed_keys {
      query.push(("typed_keys", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::msearch_template_get`]
///
///[`Client::msearch_template_get`]: super::Client::msearch_template_get
#[derive(Debug, Clone)]
pub struct MsearchTemplateGet<'a> {
  client: &'a super::Client,
  ccs_minimize_roundtrips: Result<Option<bool>, String>,
  max_concurrent_searches: Result<Option<i32>, String>,
  rest_total_hits_as_int: Result<Option<bool>, String>,
  search_type: Result<Option<types::SearchTypeMulti>, String>,
  typed_keys: Result<Option<bool>, String>,
}

impl<'a> MsearchTemplateGet<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      ccs_minimize_roundtrips: Ok(None),
      max_concurrent_searches: Ok(None),
      rest_total_hits_as_int: Ok(None),
      search_type: Ok(None),
      typed_keys: Ok(None),
    }
  }

  pub fn ccs_minimize_roundtrips<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ccs_minimize_roundtrips = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ccs_minimize_roundtrips failed".to_string());
    self
  }

  pub fn max_concurrent_searches<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.max_concurrent_searches = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for max_concurrent_searches failed".to_string());
    self
  }

  pub fn rest_total_hits_as_int<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.rest_total_hits_as_int = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for rest_total_hits_as_int failed".to_string());
    self
  }

  pub fn search_type<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SearchTypeMulti>, {
    self.search_type = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SearchTypeMulti` for search_type failed".to_string());
    self
  }

  pub fn typed_keys<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.typed_keys = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for typed_keys failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_msearch/template`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      ccs_minimize_roundtrips,
      max_concurrent_searches,
      rest_total_hits_as_int,
      search_type,
      typed_keys,
    } = self;
    let ccs_minimize_roundtrips = ccs_minimize_roundtrips.map_err(Error::InvalidRequest)?;
    let max_concurrent_searches = max_concurrent_searches.map_err(Error::InvalidRequest)?;
    let rest_total_hits_as_int = rest_total_hits_as_int.map_err(Error::InvalidRequest)?;
    let search_type = search_type.map_err(Error::InvalidRequest)?;
    let typed_keys = typed_keys.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_msearch/template", client.baseurl,);
    let mut query = Vec::with_capacity(5usize);
    if let Some(v) = &ccs_minimize_roundtrips {
      query.push(("ccs_minimize_roundtrips", v.to_string()));
    }
    if let Some(v) = &max_concurrent_searches {
      query.push(("max_concurrent_searches", v.to_string()));
    }
    if let Some(v) = &rest_total_hits_as_int {
      query.push(("rest_total_hits_as_int", v.to_string()));
    }
    if let Some(v) = &search_type {
      query.push(("search_type", v.to_string()));
    }
    if let Some(v) = &typed_keys {
      query.push(("typed_keys", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::msearch_template_post`]
///
///[`Client::msearch_template_post`]: super::Client::msearch_template_post
#[derive(Debug, Clone)]
pub struct MsearchTemplatePost<'a> {
  client: &'a super::Client,
  ccs_minimize_roundtrips: Result<Option<bool>, String>,
  max_concurrent_searches: Result<Option<i32>, String>,
  rest_total_hits_as_int: Result<Option<bool>, String>,
  search_type: Result<Option<types::SearchTypeMulti>, String>,
  typed_keys: Result<Option<bool>, String>,
  body: Result<types::MsearchTemplateBodyParams, String>,
}

impl<'a> MsearchTemplatePost<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      ccs_minimize_roundtrips: Ok(None),
      max_concurrent_searches: Ok(None),
      rest_total_hits_as_int: Ok(None),
      search_type: Ok(None),
      typed_keys: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn ccs_minimize_roundtrips<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ccs_minimize_roundtrips = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ccs_minimize_roundtrips failed".to_string());
    self
  }

  pub fn max_concurrent_searches<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.max_concurrent_searches = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for max_concurrent_searches failed".to_string());
    self
  }

  pub fn rest_total_hits_as_int<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.rest_total_hits_as_int = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for rest_total_hits_as_int failed".to_string());
    self
  }

  pub fn search_type<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SearchTypeMulti>, {
    self.search_type = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SearchTypeMulti` for search_type failed".to_string());
    self
  }

  pub fn typed_keys<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.typed_keys = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for typed_keys failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::MsearchTemplateBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `MsearchTemplateBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_msearch/template`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      ccs_minimize_roundtrips,
      max_concurrent_searches,
      rest_total_hits_as_int,
      search_type,
      typed_keys,
      body,
    } = self;
    let ccs_minimize_roundtrips = ccs_minimize_roundtrips.map_err(Error::InvalidRequest)?;
    let max_concurrent_searches = max_concurrent_searches.map_err(Error::InvalidRequest)?;
    let rest_total_hits_as_int = rest_total_hits_as_int.map_err(Error::InvalidRequest)?;
    let search_type = search_type.map_err(Error::InvalidRequest)?;
    let typed_keys = typed_keys.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_msearch/template", client.baseurl,);
    let mut query = Vec::with_capacity(5usize);
    if let Some(v) = &ccs_minimize_roundtrips {
      query.push(("ccs_minimize_roundtrips", v.to_string()));
    }
    if let Some(v) = &max_concurrent_searches {
      query.push(("max_concurrent_searches", v.to_string()));
    }
    if let Some(v) = &rest_total_hits_as_int {
      query.push(("rest_total_hits_as_int", v.to_string()));
    }
    if let Some(v) = &search_type {
      query.push(("search_type", v.to_string()));
    }
    if let Some(v) = &typed_keys {
      query.push(("typed_keys", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::mtermvectors_get`]
///
///[`Client::mtermvectors_get`]: super::Client::mtermvectors_get
#[derive(Debug, Clone)]
pub struct MtermvectorsGet<'a> {
  client: &'a super::Client,
  field_statistics: Result<Option<bool>, String>,
  fields: Result<Option<Vec<String>>, String>,
  ids: Result<Option<Vec<String>>, String>,
  offsets: Result<Option<bool>, String>,
  payloads: Result<Option<bool>, String>,
  positions: Result<Option<bool>, String>,
  preference: Result<Option<String>, String>,
  realtime: Result<Option<bool>, String>,
  routing: Result<Option<String>, String>,
  term_statistics: Result<Option<bool>, String>,
  version: Result<Option<i32>, String>,
  version_type: Result<Option<types::VersionType>, String>,
}

impl<'a> MtermvectorsGet<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      field_statistics: Ok(None),
      fields: Ok(None),
      ids: Ok(None),
      offsets: Ok(None),
      payloads: Ok(None),
      positions: Ok(None),
      preference: Ok(None),
      realtime: Ok(None),
      routing: Ok(None),
      term_statistics: Ok(None),
      version: Ok(None),
      version_type: Ok(None),
    }
  }

  pub fn field_statistics<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.field_statistics = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for field_statistics failed".to_string());
    self
  }

  pub fn fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
    self
  }

  pub fn ids<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.ids = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for ids failed".to_string());
    self
  }

  pub fn offsets<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.offsets = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for offsets failed".to_string());
    self
  }

  pub fn payloads<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.payloads = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for payloads failed".to_string());
    self
  }

  pub fn positions<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.positions = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for positions failed".to_string());
    self
  }

  pub fn preference<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.preference = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for preference failed".to_string());
    self
  }

  pub fn realtime<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.realtime = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for realtime failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for routing failed".to_string());
    self
  }

  pub fn term_statistics<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.term_statistics = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for term_statistics failed".to_string());
    self
  }

  pub fn version<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.version = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for version failed".to_string());
    self
  }

  pub fn version_type<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::VersionType>, {
    self.version_type = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `VersionType` for version_type failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_mtermvectors`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      field_statistics,
      fields,
      ids,
      offsets,
      payloads,
      positions,
      preference,
      realtime,
      routing,
      term_statistics,
      version,
      version_type,
    } = self;
    let field_statistics = field_statistics.map_err(Error::InvalidRequest)?;
    let fields = fields.map_err(Error::InvalidRequest)?;
    let ids = ids.map_err(Error::InvalidRequest)?;
    let offsets = offsets.map_err(Error::InvalidRequest)?;
    let payloads = payloads.map_err(Error::InvalidRequest)?;
    let positions = positions.map_err(Error::InvalidRequest)?;
    let preference = preference.map_err(Error::InvalidRequest)?;
    let realtime = realtime.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let term_statistics = term_statistics.map_err(Error::InvalidRequest)?;
    let version = version.map_err(Error::InvalidRequest)?;
    let version_type = version_type.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_mtermvectors", client.baseurl,);
    let mut query = Vec::with_capacity(12usize);
    if let Some(v) = &field_statistics {
      query.push(("field_statistics", v.to_string()));
    }
    if let Some(v) = &fields {
      query.push(("fields", v.join(",")));
    }
    if let Some(v) = &ids {
      query.push(("ids", v.join(",")));
    }
    if let Some(v) = &offsets {
      query.push(("offsets", v.to_string()));
    }
    if let Some(v) = &payloads {
      query.push(("payloads", v.to_string()));
    }
    if let Some(v) = &positions {
      query.push(("positions", v.to_string()));
    }
    if let Some(v) = &preference {
      query.push(("preference", v.to_string()));
    }
    if let Some(v) = &realtime {
      query.push(("realtime", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.to_string()));
    }
    if let Some(v) = &term_statistics {
      query.push(("term_statistics", v.to_string()));
    }
    if let Some(v) = &version {
      query.push(("version", v.to_string()));
    }
    if let Some(v) = &version_type {
      query.push(("version_type", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::mtermvectors_post`]
///
///[`Client::mtermvectors_post`]: super::Client::mtermvectors_post
#[derive(Debug, Clone)]
pub struct MtermvectorsPost<'a> {
  client: &'a super::Client,
  field_statistics: Result<Option<bool>, String>,
  fields: Result<Option<Vec<String>>, String>,
  ids: Result<Option<Vec<String>>, String>,
  offsets: Result<Option<bool>, String>,
  payloads: Result<Option<bool>, String>,
  positions: Result<Option<bool>, String>,
  preference: Result<Option<String>, String>,
  realtime: Result<Option<bool>, String>,
  routing: Result<Option<String>, String>,
  term_statistics: Result<Option<bool>, String>,
  version: Result<Option<i32>, String>,
  version_type: Result<Option<types::VersionType>, String>,
  body: Result<types::MtermvectorsBodyParams, String>,
}

impl<'a> MtermvectorsPost<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      field_statistics: Ok(None),
      fields: Ok(None),
      ids: Ok(None),
      offsets: Ok(None),
      payloads: Ok(None),
      positions: Ok(None),
      preference: Ok(None),
      realtime: Ok(None),
      routing: Ok(None),
      term_statistics: Ok(None),
      version: Ok(None),
      version_type: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn field_statistics<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.field_statistics = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for field_statistics failed".to_string());
    self
  }

  pub fn fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
    self
  }

  pub fn ids<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.ids = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for ids failed".to_string());
    self
  }

  pub fn offsets<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.offsets = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for offsets failed".to_string());
    self
  }

  pub fn payloads<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.payloads = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for payloads failed".to_string());
    self
  }

  pub fn positions<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.positions = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for positions failed".to_string());
    self
  }

  pub fn preference<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.preference = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for preference failed".to_string());
    self
  }

  pub fn realtime<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.realtime = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for realtime failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for routing failed".to_string());
    self
  }

  pub fn term_statistics<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.term_statistics = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for term_statistics failed".to_string());
    self
  }

  pub fn version<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.version = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for version failed".to_string());
    self
  }

  pub fn version_type<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::VersionType>, {
    self.version_type = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `VersionType` for version_type failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::MtermvectorsBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `MtermvectorsBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_mtermvectors`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      field_statistics,
      fields,
      ids,
      offsets,
      payloads,
      positions,
      preference,
      realtime,
      routing,
      term_statistics,
      version,
      version_type,
      body,
    } = self;
    let field_statistics = field_statistics.map_err(Error::InvalidRequest)?;
    let fields = fields.map_err(Error::InvalidRequest)?;
    let ids = ids.map_err(Error::InvalidRequest)?;
    let offsets = offsets.map_err(Error::InvalidRequest)?;
    let payloads = payloads.map_err(Error::InvalidRequest)?;
    let positions = positions.map_err(Error::InvalidRequest)?;
    let preference = preference.map_err(Error::InvalidRequest)?;
    let realtime = realtime.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let term_statistics = term_statistics.map_err(Error::InvalidRequest)?;
    let version = version.map_err(Error::InvalidRequest)?;
    let version_type = version_type.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_mtermvectors", client.baseurl,);
    let mut query = Vec::with_capacity(12usize);
    if let Some(v) = &field_statistics {
      query.push(("field_statistics", v.to_string()));
    }
    if let Some(v) = &fields {
      query.push(("fields", v.join(",")));
    }
    if let Some(v) = &ids {
      query.push(("ids", v.join(",")));
    }
    if let Some(v) = &offsets {
      query.push(("offsets", v.to_string()));
    }
    if let Some(v) = &payloads {
      query.push(("payloads", v.to_string()));
    }
    if let Some(v) = &positions {
      query.push(("positions", v.to_string()));
    }
    if let Some(v) = &preference {
      query.push(("preference", v.to_string()));
    }
    if let Some(v) = &realtime {
      query.push(("realtime", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.to_string()));
    }
    if let Some(v) = &term_statistics {
      query.push(("term_statistics", v.to_string()));
    }
    if let Some(v) = &version {
      query.push(("version", v.to_string()));
    }
    if let Some(v) = &version_type {
      query.push(("version_type", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::nodes_info`]
///
///[`Client::nodes_info`]: super::Client::nodes_info
#[derive(Debug, Clone)]
pub struct NodesInfo<'a> {
  client: &'a super::Client,
  flat_settings: Result<Option<bool>, String>,
  timeout: Result<Option<types::NodesInfoTimeout>, String>,
}

impl<'a> NodesInfo<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      flat_settings: Ok(None),
      timeout: Ok(None),
    }
  }

  pub fn flat_settings<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.flat_settings = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesInfoTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `NodesInfoTimeout` for timeout failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_nodes`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      flat_settings,
      timeout,
    } = self;
    let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_nodes", client.baseurl,);
    let mut query = Vec::with_capacity(2usize);
    if let Some(v) = &flat_settings {
      query.push(("flat_settings", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::nodes_hot_threads`]
///
///[`Client::nodes_hot_threads`]: super::Client::nodes_hot_threads
#[derive(Debug, Clone)]
pub struct NodesHotThreads<'a> {
  client: &'a super::Client,
  ignore_idle_threads: Result<Option<bool>, String>,
  interval: Result<Option<types::NodesHotThreadsInterval>, String>,
  snapshots: Result<Option<i32>, String>,
  threads: Result<Option<i32>, String>,
  timeout: Result<Option<types::NodesHotThreadsTimeout>, String>,
  type_: Result<Option<types::SampleType>, String>,
}

impl<'a> NodesHotThreads<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      ignore_idle_threads: Ok(None),
      interval: Ok(None),
      snapshots: Ok(None),
      threads: Ok(None),
      timeout: Ok(None),
      type_: Ok(None),
    }
  }

  pub fn ignore_idle_threads<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_idle_threads = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_idle_threads failed".to_string());
    self
  }

  pub fn interval<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesHotThreadsInterval>, {
    self.interval = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `NodesHotThreadsInterval` for interval failed".to_string());
    self
  }

  pub fn snapshots<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.snapshots = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for snapshots failed".to_string());
    self
  }

  pub fn threads<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.threads = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for threads failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesHotThreadsTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `NodesHotThreadsTimeout` for timeout failed".to_string());
    self
  }

  pub fn type_<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SampleType>, {
    self.type_ = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SampleType` for type_ failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_nodes/hot_threads`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      ignore_idle_threads,
      interval,
      snapshots,
      threads,
      timeout,
      type_,
    } = self;
    let ignore_idle_threads = ignore_idle_threads.map_err(Error::InvalidRequest)?;
    let interval = interval.map_err(Error::InvalidRequest)?;
    let snapshots = snapshots.map_err(Error::InvalidRequest)?;
    let threads = threads.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let type_ = type_.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_nodes/hot_threads", client.baseurl,);
    let mut query = Vec::with_capacity(6usize);
    if let Some(v) = &ignore_idle_threads {
      query.push(("ignore_idle_threads", v.to_string()));
    }
    if let Some(v) = &interval {
      query.push(("interval", v.to_string()));
    }
    if let Some(v) = &snapshots {
      query.push(("snapshots", v.to_string()));
    }
    if let Some(v) = &threads {
      query.push(("threads", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &type_ {
      query.push(("type", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::nodes_hot_threads_deprecated`]
///
///[`Client::nodes_hot_threads_deprecated`]: super::Client::nodes_hot_threads_deprecated
#[derive(Debug, Clone)]
pub struct NodesHotThreadsDeprecated<'a> {
  client: &'a super::Client,
  ignore_idle_threads: Result<Option<bool>, String>,
  interval: Result<Option<types::NodesHotThreadsDeprecatedInterval>, String>,
  snapshots: Result<Option<i32>, String>,
  threads: Result<Option<i32>, String>,
  timeout: Result<Option<types::NodesHotThreadsDeprecatedTimeout>, String>,
  type_: Result<Option<types::SampleType>, String>,
}

impl<'a> NodesHotThreadsDeprecated<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      ignore_idle_threads: Ok(None),
      interval: Ok(None),
      snapshots: Ok(None),
      threads: Ok(None),
      timeout: Ok(None),
      type_: Ok(None),
    }
  }

  pub fn ignore_idle_threads<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_idle_threads = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_idle_threads failed".to_string());
    self
  }

  pub fn interval<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesHotThreadsDeprecatedInterval>, {
    self.interval = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `NodesHotThreadsDeprecatedInterval` for interval failed".to_string());
    self
  }

  pub fn snapshots<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.snapshots = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for snapshots failed".to_string());
    self
  }

  pub fn threads<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.threads = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for threads failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesHotThreadsDeprecatedTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `NodesHotThreadsDeprecatedTimeout` for timeout failed".to_string());
    self
  }

  pub fn type_<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SampleType>, {
    self.type_ = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SampleType` for type_ failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_nodes/hotthreads`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      ignore_idle_threads,
      interval,
      snapshots,
      threads,
      timeout,
      type_,
    } = self;
    let ignore_idle_threads = ignore_idle_threads.map_err(Error::InvalidRequest)?;
    let interval = interval.map_err(Error::InvalidRequest)?;
    let snapshots = snapshots.map_err(Error::InvalidRequest)?;
    let threads = threads.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let type_ = type_.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_nodes/hotthreads", client.baseurl,);
    let mut query = Vec::with_capacity(6usize);
    if let Some(v) = &ignore_idle_threads {
      query.push(("ignore_idle_threads", v.to_string()));
    }
    if let Some(v) = &interval {
      query.push(("interval", v.to_string()));
    }
    if let Some(v) = &snapshots {
      query.push(("snapshots", v.to_string()));
    }
    if let Some(v) = &threads {
      query.push(("threads", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &type_ {
      query.push(("type", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::nodes_reload_secure_settings`]
///
///[`Client::nodes_reload_secure_settings`]: super::Client::nodes_reload_secure_settings
#[derive(Debug, Clone)]
pub struct NodesReloadSecureSettings<'a> {
  client: &'a super::Client,
  timeout: Result<Option<types::NodesReloadSecureSettingsTimeout>, String>,
  body: Result<types::NodesReloadSecureSettingsBodyParams, String>,
}

impl<'a> NodesReloadSecureSettings<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      timeout: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesReloadSecureSettingsTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `NodesReloadSecureSettingsTimeout` for timeout failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesReloadSecureSettingsBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `NodesReloadSecureSettingsBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_nodes/reload_secure_settings`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self { client, timeout, body } = self;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_nodes/reload_secure_settings", client.baseurl,);
    let mut query = Vec::with_capacity(1usize);
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::nodes_stats`]
///
///[`Client::nodes_stats`]: super::Client::nodes_stats
#[derive(Debug, Clone)]
pub struct NodesStats<'a> {
  client: &'a super::Client,
  completion_fields: Result<Option<Vec<String>>, String>,
  fielddata_fields: Result<Option<Vec<String>>, String>,
  fields: Result<Option<Vec<String>>, String>,
  groups: Result<Option<Vec<String>>, String>,
  include_segment_file_sizes: Result<Option<bool>, String>,
  level: Result<Option<types::NodesStatLevel>, String>,
  timeout: Result<Option<types::NodesStatsTimeout>, String>,
  types: Result<Option<Vec<String>>, String>,
}

impl<'a> NodesStats<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      completion_fields: Ok(None),
      fielddata_fields: Ok(None),
      fields: Ok(None),
      groups: Ok(None),
      include_segment_file_sizes: Ok(None),
      level: Ok(None),
      timeout: Ok(None),
      types: Ok(None),
    }
  }

  pub fn completion_fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.completion_fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for completion_fields failed".to_string());
    self
  }

  pub fn fielddata_fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.fielddata_fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for fielddata_fields failed".to_string());
    self
  }

  pub fn fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
    self
  }

  pub fn groups<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.groups = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for groups failed".to_string());
    self
  }

  pub fn include_segment_file_sizes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.include_segment_file_sizes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for include_segment_file_sizes failed".to_string());
    self
  }

  pub fn level<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesStatLevel>, {
    self.level = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `NodesStatLevel` for level failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesStatsTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `NodesStatsTimeout` for timeout failed".to_string());
    self
  }

  pub fn types<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.types = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for types failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_nodes/stats`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      completion_fields,
      fielddata_fields,
      fields,
      groups,
      include_segment_file_sizes,
      level,
      timeout,
      types,
    } = self;
    let completion_fields = completion_fields.map_err(Error::InvalidRequest)?;
    let fielddata_fields = fielddata_fields.map_err(Error::InvalidRequest)?;
    let fields = fields.map_err(Error::InvalidRequest)?;
    let groups = groups.map_err(Error::InvalidRequest)?;
    let include_segment_file_sizes = include_segment_file_sizes.map_err(Error::InvalidRequest)?;
    let level = level.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let types = types.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_nodes/stats", client.baseurl,);
    let mut query = Vec::with_capacity(8usize);
    if let Some(v) = &completion_fields {
      query.push(("completion_fields", v.join(",")));
    }
    if let Some(v) = &fielddata_fields {
      query.push(("fielddata_fields", v.join(",")));
    }
    if let Some(v) = &fields {
      query.push(("fields", v.join(",")));
    }
    if let Some(v) = &groups {
      query.push(("groups", v.join(",")));
    }
    if let Some(v) = &include_segment_file_sizes {
      query.push(("include_segment_file_sizes", v.to_string()));
    }
    if let Some(v) = &level {
      query.push(("level", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &types {
      query.push(("types", v.join(",")));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::nodes_stats_with_metric`]
///
///[`Client::nodes_stats_with_metric`]: super::Client::nodes_stats_with_metric
#[derive(Debug, Clone)]
pub struct NodesStatsWithMetric<'a> {
  client: &'a super::Client,
  metric: Result<types::NodesStatsWithMetricMetric, String>,
  completion_fields: Result<Option<Vec<String>>, String>,
  fielddata_fields: Result<Option<Vec<String>>, String>,
  fields: Result<Option<Vec<String>>, String>,
  groups: Result<Option<Vec<String>>, String>,
  include_segment_file_sizes: Result<Option<bool>, String>,
  level: Result<Option<types::NodesStatLevel>, String>,
  timeout: Result<Option<types::NodesStatsWithMetricTimeout>, String>,
  types: Result<Option<Vec<String>>, String>,
}

impl<'a> NodesStatsWithMetric<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      metric: Err("metric was not initialized".to_string()),
      completion_fields: Ok(None),
      fielddata_fields: Ok(None),
      fields: Ok(None),
      groups: Ok(None),
      include_segment_file_sizes: Ok(None),
      level: Ok(None),
      timeout: Ok(None),
      types: Ok(None),
    }
  }

  pub fn metric<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesStatsWithMetricMetric>, {
    self.metric = value
      .try_into()
      .map_err(|_| "conversion to `NodesStatsWithMetricMetric` for metric failed".to_string());
    self
  }

  pub fn completion_fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.completion_fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for completion_fields failed".to_string());
    self
  }

  pub fn fielddata_fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.fielddata_fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for fielddata_fields failed".to_string());
    self
  }

  pub fn fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
    self
  }

  pub fn groups<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.groups = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for groups failed".to_string());
    self
  }

  pub fn include_segment_file_sizes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.include_segment_file_sizes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for include_segment_file_sizes failed".to_string());
    self
  }

  pub fn level<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesStatLevel>, {
    self.level = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `NodesStatLevel` for level failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesStatsWithMetricTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `NodesStatsWithMetricTimeout` for timeout failed".to_string());
    self
  }

  pub fn types<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.types = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for types failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_nodes/stats/{metric}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      metric,
      completion_fields,
      fielddata_fields,
      fields,
      groups,
      include_segment_file_sizes,
      level,
      timeout,
      types,
    } = self;
    let metric = metric.map_err(Error::InvalidRequest)?;
    let completion_fields = completion_fields.map_err(Error::InvalidRequest)?;
    let fielddata_fields = fielddata_fields.map_err(Error::InvalidRequest)?;
    let fields = fields.map_err(Error::InvalidRequest)?;
    let groups = groups.map_err(Error::InvalidRequest)?;
    let include_segment_file_sizes = include_segment_file_sizes.map_err(Error::InvalidRequest)?;
    let level = level.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let types = types.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_nodes/stats/{}", client.baseurl, encode_path(&metric.to_string()),);
    let mut query = Vec::with_capacity(8usize);
    if let Some(v) = &completion_fields {
      query.push(("completion_fields", v.join(",")));
    }
    if let Some(v) = &fielddata_fields {
      query.push(("fielddata_fields", v.join(",")));
    }
    if let Some(v) = &fields {
      query.push(("fields", v.join(",")));
    }
    if let Some(v) = &groups {
      query.push(("groups", v.join(",")));
    }
    if let Some(v) = &include_segment_file_sizes {
      query.push(("include_segment_file_sizes", v.to_string()));
    }
    if let Some(v) = &level {
      query.push(("level", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &types {
      query.push(("types", v.join(",")));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::nodes_stats_with_index_metric_metric`]
///
///[`Client::nodes_stats_with_index_metric_metric`]: super::Client::nodes_stats_with_index_metric_metric
#[derive(Debug, Clone)]
pub struct NodesStatsWithIndexMetricMetric<'a> {
  client: &'a super::Client,
  metric: Result<types::NodesStatsWithIndexMetricMetricMetric, String>,
  index_metric: Result<types::NodesStatsWithIndexMetricMetricIndexMetric, String>,
  completion_fields: Result<Option<Vec<String>>, String>,
  fielddata_fields: Result<Option<Vec<String>>, String>,
  fields: Result<Option<Vec<String>>, String>,
  groups: Result<Option<Vec<String>>, String>,
  include_segment_file_sizes: Result<Option<bool>, String>,
  level: Result<Option<types::NodesStatLevel>, String>,
  timeout: Result<Option<types::NodesStatsWithIndexMetricMetricTimeout>, String>,
  types: Result<Option<Vec<String>>, String>,
}

impl<'a> NodesStatsWithIndexMetricMetric<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      metric: Err("metric was not initialized".to_string()),
      index_metric: Err("index_metric was not initialized".to_string()),
      completion_fields: Ok(None),
      fielddata_fields: Ok(None),
      fields: Ok(None),
      groups: Ok(None),
      include_segment_file_sizes: Ok(None),
      level: Ok(None),
      timeout: Ok(None),
      types: Ok(None),
    }
  }

  pub fn metric<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesStatsWithIndexMetricMetricMetric>, {
    self.metric = value
      .try_into()
      .map_err(|_| "conversion to `NodesStatsWithIndexMetricMetricMetric` for metric failed".to_string());
    self
  }

  pub fn index_metric<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesStatsWithIndexMetricMetricIndexMetric>, {
    self.index_metric = value
      .try_into()
      .map_err(|_| "conversion to `NodesStatsWithIndexMetricMetricIndexMetric` for index_metric failed".to_string());
    self
  }

  pub fn completion_fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.completion_fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for completion_fields failed".to_string());
    self
  }

  pub fn fielddata_fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.fielddata_fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for fielddata_fields failed".to_string());
    self
  }

  pub fn fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
    self
  }

  pub fn groups<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.groups = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for groups failed".to_string());
    self
  }

  pub fn include_segment_file_sizes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.include_segment_file_sizes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for include_segment_file_sizes failed".to_string());
    self
  }

  pub fn level<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesStatLevel>, {
    self.level = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `NodesStatLevel` for level failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesStatsWithIndexMetricMetricTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `NodesStatsWithIndexMetricMetricTimeout` for timeout failed".to_string());
    self
  }

  pub fn types<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.types = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for types failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_nodes/stats/{metric}/{index_metric}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      metric,
      index_metric,
      completion_fields,
      fielddata_fields,
      fields,
      groups,
      include_segment_file_sizes,
      level,
      timeout,
      types,
    } = self;
    let metric = metric.map_err(Error::InvalidRequest)?;
    let index_metric = index_metric.map_err(Error::InvalidRequest)?;
    let completion_fields = completion_fields.map_err(Error::InvalidRequest)?;
    let fielddata_fields = fielddata_fields.map_err(Error::InvalidRequest)?;
    let fields = fields.map_err(Error::InvalidRequest)?;
    let groups = groups.map_err(Error::InvalidRequest)?;
    let include_segment_file_sizes = include_segment_file_sizes.map_err(Error::InvalidRequest)?;
    let level = level.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let types = types.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_nodes/stats/{}/{}",
      client.baseurl,
      encode_path(&metric.to_string()),
      encode_path(&index_metric.to_string()),
    );
    let mut query = Vec::with_capacity(8usize);
    if let Some(v) = &completion_fields {
      query.push(("completion_fields", v.join(",")));
    }
    if let Some(v) = &fielddata_fields {
      query.push(("fielddata_fields", v.join(",")));
    }
    if let Some(v) = &fields {
      query.push(("fields", v.join(",")));
    }
    if let Some(v) = &groups {
      query.push(("groups", v.join(",")));
    }
    if let Some(v) = &include_segment_file_sizes {
      query.push(("include_segment_file_sizes", v.to_string()));
    }
    if let Some(v) = &level {
      query.push(("level", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &types {
      query.push(("types", v.join(",")));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::nodes_usage`]
///
///[`Client::nodes_usage`]: super::Client::nodes_usage
#[derive(Debug, Clone)]
pub struct NodesUsage<'a> {
  client: &'a super::Client,
  timeout: Result<Option<types::NodesUsageTimeout>, String>,
}

impl<'a> NodesUsage<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      timeout: Ok(None),
    }
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesUsageTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `NodesUsageTimeout` for timeout failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_nodes/usage`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self { client, timeout } = self;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_nodes/usage", client.baseurl,);
    let mut query = Vec::with_capacity(1usize);
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::nodes_usage_with_metric`]
///
///[`Client::nodes_usage_with_metric`]: super::Client::nodes_usage_with_metric
#[derive(Debug, Clone)]
pub struct NodesUsageWithMetric<'a> {
  client: &'a super::Client,
  metric: Result<types::NodesUsageWithMetricMetric, String>,
  timeout: Result<Option<types::NodesUsageWithMetricTimeout>, String>,
}

impl<'a> NodesUsageWithMetric<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      metric: Err("metric was not initialized".to_string()),
      timeout: Ok(None),
    }
  }

  pub fn metric<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesUsageWithMetricMetric>, {
    self.metric = value
      .try_into()
      .map_err(|_| "conversion to `NodesUsageWithMetricMetric` for metric failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesUsageWithMetricTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `NodesUsageWithMetricTimeout` for timeout failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_nodes/usage/{metric}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      metric,
      timeout,
    } = self;
    let metric = metric.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_nodes/usage/{}", client.baseurl, encode_path(&metric.to_string()),);
    let mut query = Vec::with_capacity(1usize);
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::nodes_info_with_node_id`]
///
///[`Client::nodes_info_with_node_id`]: super::Client::nodes_info_with_node_id
#[derive(Debug, Clone)]
pub struct NodesInfoWithNodeId<'a> {
  client: &'a super::Client,
  node_id: Result<types::NodesInfoWithNodeIdNodeId, String>,
  flat_settings: Result<Option<bool>, String>,
  timeout: Result<Option<types::NodesInfoWithNodeIdTimeout>, String>,
}

impl<'a> NodesInfoWithNodeId<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      node_id: Err("node_id was not initialized".to_string()),
      flat_settings: Ok(None),
      timeout: Ok(None),
    }
  }

  pub fn node_id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesInfoWithNodeIdNodeId>, {
    self.node_id = value
      .try_into()
      .map_err(|_| "conversion to `NodesInfoWithNodeIdNodeId` for node_id failed".to_string());
    self
  }

  pub fn flat_settings<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.flat_settings = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesInfoWithNodeIdTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `NodesInfoWithNodeIdTimeout` for timeout failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_nodes/{node_id}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      node_id,
      flat_settings,
      timeout,
    } = self;
    let node_id = node_id.map_err(Error::InvalidRequest)?;
    let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_nodes/{}", client.baseurl, encode_path(&node_id.to_string()),);
    let mut query = Vec::with_capacity(2usize);
    if let Some(v) = &flat_settings {
      query.push(("flat_settings", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::nodes_hot_threads_with_node_id`]
///
///[`Client::nodes_hot_threads_with_node_id`]: super::Client::nodes_hot_threads_with_node_id
#[derive(Debug, Clone)]
pub struct NodesHotThreadsWithNodeId<'a> {
  client: &'a super::Client,
  node_id: Result<types::NodesHotThreadsWithNodeIdNodeId, String>,
  ignore_idle_threads: Result<Option<bool>, String>,
  interval: Result<Option<types::NodesHotThreadsWithNodeIdInterval>, String>,
  snapshots: Result<Option<i32>, String>,
  threads: Result<Option<i32>, String>,
  timeout: Result<Option<types::NodesHotThreadsWithNodeIdTimeout>, String>,
  type_: Result<Option<types::SampleType>, String>,
}

impl<'a> NodesHotThreadsWithNodeId<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      node_id: Err("node_id was not initialized".to_string()),
      ignore_idle_threads: Ok(None),
      interval: Ok(None),
      snapshots: Ok(None),
      threads: Ok(None),
      timeout: Ok(None),
      type_: Ok(None),
    }
  }

  pub fn node_id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesHotThreadsWithNodeIdNodeId>, {
    self.node_id = value
      .try_into()
      .map_err(|_| "conversion to `NodesHotThreadsWithNodeIdNodeId` for node_id failed".to_string());
    self
  }

  pub fn ignore_idle_threads<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_idle_threads = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_idle_threads failed".to_string());
    self
  }

  pub fn interval<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesHotThreadsWithNodeIdInterval>, {
    self.interval = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `NodesHotThreadsWithNodeIdInterval` for interval failed".to_string());
    self
  }

  pub fn snapshots<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.snapshots = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for snapshots failed".to_string());
    self
  }

  pub fn threads<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.threads = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for threads failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesHotThreadsWithNodeIdTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `NodesHotThreadsWithNodeIdTimeout` for timeout failed".to_string());
    self
  }

  pub fn type_<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SampleType>, {
    self.type_ = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SampleType` for type_ failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_nodes/{node_id}/hot_threads`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      node_id,
      ignore_idle_threads,
      interval,
      snapshots,
      threads,
      timeout,
      type_,
    } = self;
    let node_id = node_id.map_err(Error::InvalidRequest)?;
    let ignore_idle_threads = ignore_idle_threads.map_err(Error::InvalidRequest)?;
    let interval = interval.map_err(Error::InvalidRequest)?;
    let snapshots = snapshots.map_err(Error::InvalidRequest)?;
    let threads = threads.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let type_ = type_.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_nodes/{}/hot_threads",
      client.baseurl,
      encode_path(&node_id.to_string()),
    );
    let mut query = Vec::with_capacity(6usize);
    if let Some(v) = &ignore_idle_threads {
      query.push(("ignore_idle_threads", v.to_string()));
    }
    if let Some(v) = &interval {
      query.push(("interval", v.to_string()));
    }
    if let Some(v) = &snapshots {
      query.push(("snapshots", v.to_string()));
    }
    if let Some(v) = &threads {
      query.push(("threads", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &type_ {
      query.push(("type", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::nodes_hot_threads_with_node_id_deprecated`]
///
///[`Client::nodes_hot_threads_with_node_id_deprecated`]: super::Client::nodes_hot_threads_with_node_id_deprecated
#[derive(Debug, Clone)]
pub struct NodesHotThreadsWithNodeIdDeprecated<'a> {
  client: &'a super::Client,
  node_id: Result<types::NodesHotThreadsWithNodeIdDeprecatedNodeId, String>,
  ignore_idle_threads: Result<Option<bool>, String>,
  interval: Result<Option<types::NodesHotThreadsWithNodeIdDeprecatedInterval>, String>,
  snapshots: Result<Option<i32>, String>,
  threads: Result<Option<i32>, String>,
  timeout: Result<Option<types::NodesHotThreadsWithNodeIdDeprecatedTimeout>, String>,
  type_: Result<Option<types::SampleType>, String>,
}

impl<'a> NodesHotThreadsWithNodeIdDeprecated<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      node_id: Err("node_id was not initialized".to_string()),
      ignore_idle_threads: Ok(None),
      interval: Ok(None),
      snapshots: Ok(None),
      threads: Ok(None),
      timeout: Ok(None),
      type_: Ok(None),
    }
  }

  pub fn node_id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesHotThreadsWithNodeIdDeprecatedNodeId>, {
    self.node_id = value
      .try_into()
      .map_err(|_| "conversion to `NodesHotThreadsWithNodeIdDeprecatedNodeId` for node_id failed".to_string());
    self
  }

  pub fn ignore_idle_threads<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_idle_threads = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_idle_threads failed".to_string());
    self
  }

  pub fn interval<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesHotThreadsWithNodeIdDeprecatedInterval>, {
    self.interval = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `NodesHotThreadsWithNodeIdDeprecatedInterval` for interval failed".to_string());
    self
  }

  pub fn snapshots<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.snapshots = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for snapshots failed".to_string());
    self
  }

  pub fn threads<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.threads = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for threads failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesHotThreadsWithNodeIdDeprecatedTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `NodesHotThreadsWithNodeIdDeprecatedTimeout` for timeout failed".to_string());
    self
  }

  pub fn type_<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SampleType>, {
    self.type_ = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SampleType` for type_ failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_nodes/{node_id}/hotthreads`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      node_id,
      ignore_idle_threads,
      interval,
      snapshots,
      threads,
      timeout,
      type_,
    } = self;
    let node_id = node_id.map_err(Error::InvalidRequest)?;
    let ignore_idle_threads = ignore_idle_threads.map_err(Error::InvalidRequest)?;
    let interval = interval.map_err(Error::InvalidRequest)?;
    let snapshots = snapshots.map_err(Error::InvalidRequest)?;
    let threads = threads.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let type_ = type_.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_nodes/{}/hotthreads",
      client.baseurl,
      encode_path(&node_id.to_string()),
    );
    let mut query = Vec::with_capacity(6usize);
    if let Some(v) = &ignore_idle_threads {
      query.push(("ignore_idle_threads", v.to_string()));
    }
    if let Some(v) = &interval {
      query.push(("interval", v.to_string()));
    }
    if let Some(v) = &snapshots {
      query.push(("snapshots", v.to_string()));
    }
    if let Some(v) = &threads {
      query.push(("threads", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &type_ {
      query.push(("type", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::nodes_reload_secure_settings_with_node_id`]
///
///[`Client::nodes_reload_secure_settings_with_node_id`]: super::Client::nodes_reload_secure_settings_with_node_id
#[derive(Debug, Clone)]
pub struct NodesReloadSecureSettingsWithNodeId<'a> {
  client: &'a super::Client,
  node_id: Result<types::NodesReloadSecureSettingsWithNodeIdNodeId, String>,
  timeout: Result<Option<types::NodesReloadSecureSettingsWithNodeIdTimeout>, String>,
  body: Result<types::NodesReloadSecureSettingsBodyParams, String>,
}

impl<'a> NodesReloadSecureSettingsWithNodeId<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      node_id: Err("node_id was not initialized".to_string()),
      timeout: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn node_id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesReloadSecureSettingsWithNodeIdNodeId>, {
    self.node_id = value
      .try_into()
      .map_err(|_| "conversion to `NodesReloadSecureSettingsWithNodeIdNodeId` for node_id failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesReloadSecureSettingsWithNodeIdTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `NodesReloadSecureSettingsWithNodeIdTimeout` for timeout failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesReloadSecureSettingsBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `NodesReloadSecureSettingsBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_nodes/{node_id}/reload_secure_settings`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      node_id,
      timeout,
      body,
    } = self;
    let node_id = node_id.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_nodes/{}/reload_secure_settings",
      client.baseurl,
      encode_path(&node_id.to_string()),
    );
    let mut query = Vec::with_capacity(1usize);
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::nodes_stats_with_node_id`]
///
///[`Client::nodes_stats_with_node_id`]: super::Client::nodes_stats_with_node_id
#[derive(Debug, Clone)]
pub struct NodesStatsWithNodeId<'a> {
  client: &'a super::Client,
  node_id: Result<types::NodesStatsWithNodeIdNodeId, String>,
  completion_fields: Result<Option<Vec<String>>, String>,
  fielddata_fields: Result<Option<Vec<String>>, String>,
  fields: Result<Option<Vec<String>>, String>,
  groups: Result<Option<Vec<String>>, String>,
  include_segment_file_sizes: Result<Option<bool>, String>,
  level: Result<Option<types::NodesStatLevel>, String>,
  timeout: Result<Option<types::NodesStatsWithNodeIdTimeout>, String>,
  types: Result<Option<Vec<String>>, String>,
}

impl<'a> NodesStatsWithNodeId<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      node_id: Err("node_id was not initialized".to_string()),
      completion_fields: Ok(None),
      fielddata_fields: Ok(None),
      fields: Ok(None),
      groups: Ok(None),
      include_segment_file_sizes: Ok(None),
      level: Ok(None),
      timeout: Ok(None),
      types: Ok(None),
    }
  }

  pub fn node_id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesStatsWithNodeIdNodeId>, {
    self.node_id = value
      .try_into()
      .map_err(|_| "conversion to `NodesStatsWithNodeIdNodeId` for node_id failed".to_string());
    self
  }

  pub fn completion_fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.completion_fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for completion_fields failed".to_string());
    self
  }

  pub fn fielddata_fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.fielddata_fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for fielddata_fields failed".to_string());
    self
  }

  pub fn fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
    self
  }

  pub fn groups<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.groups = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for groups failed".to_string());
    self
  }

  pub fn include_segment_file_sizes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.include_segment_file_sizes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for include_segment_file_sizes failed".to_string());
    self
  }

  pub fn level<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesStatLevel>, {
    self.level = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `NodesStatLevel` for level failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesStatsWithNodeIdTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `NodesStatsWithNodeIdTimeout` for timeout failed".to_string());
    self
  }

  pub fn types<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.types = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for types failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_nodes/{node_id}/stats`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      node_id,
      completion_fields,
      fielddata_fields,
      fields,
      groups,
      include_segment_file_sizes,
      level,
      timeout,
      types,
    } = self;
    let node_id = node_id.map_err(Error::InvalidRequest)?;
    let completion_fields = completion_fields.map_err(Error::InvalidRequest)?;
    let fielddata_fields = fielddata_fields.map_err(Error::InvalidRequest)?;
    let fields = fields.map_err(Error::InvalidRequest)?;
    let groups = groups.map_err(Error::InvalidRequest)?;
    let include_segment_file_sizes = include_segment_file_sizes.map_err(Error::InvalidRequest)?;
    let level = level.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let types = types.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_nodes/{}/stats", client.baseurl, encode_path(&node_id.to_string()),);
    let mut query = Vec::with_capacity(8usize);
    if let Some(v) = &completion_fields {
      query.push(("completion_fields", v.join(",")));
    }
    if let Some(v) = &fielddata_fields {
      query.push(("fielddata_fields", v.join(",")));
    }
    if let Some(v) = &fields {
      query.push(("fields", v.join(",")));
    }
    if let Some(v) = &groups {
      query.push(("groups", v.join(",")));
    }
    if let Some(v) = &include_segment_file_sizes {
      query.push(("include_segment_file_sizes", v.to_string()));
    }
    if let Some(v) = &level {
      query.push(("level", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &types {
      query.push(("types", v.join(",")));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::nodes_stats_with_metric_node_id`]
///
///[`Client::nodes_stats_with_metric_node_id`]: super::Client::nodes_stats_with_metric_node_id
#[derive(Debug, Clone)]
pub struct NodesStatsWithMetricNodeId<'a> {
  client: &'a super::Client,
  node_id: Result<types::NodesStatsWithMetricNodeIdNodeId, String>,
  metric: Result<types::NodesStatsWithMetricNodeIdMetric, String>,
  completion_fields: Result<Option<Vec<String>>, String>,
  fielddata_fields: Result<Option<Vec<String>>, String>,
  fields: Result<Option<Vec<String>>, String>,
  groups: Result<Option<Vec<String>>, String>,
  include_segment_file_sizes: Result<Option<bool>, String>,
  level: Result<Option<types::NodesStatLevel>, String>,
  timeout: Result<Option<types::NodesStatsWithMetricNodeIdTimeout>, String>,
  types: Result<Option<Vec<String>>, String>,
}

impl<'a> NodesStatsWithMetricNodeId<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      node_id: Err("node_id was not initialized".to_string()),
      metric: Err("metric was not initialized".to_string()),
      completion_fields: Ok(None),
      fielddata_fields: Ok(None),
      fields: Ok(None),
      groups: Ok(None),
      include_segment_file_sizes: Ok(None),
      level: Ok(None),
      timeout: Ok(None),
      types: Ok(None),
    }
  }

  pub fn node_id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesStatsWithMetricNodeIdNodeId>, {
    self.node_id = value
      .try_into()
      .map_err(|_| "conversion to `NodesStatsWithMetricNodeIdNodeId` for node_id failed".to_string());
    self
  }

  pub fn metric<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesStatsWithMetricNodeIdMetric>, {
    self.metric = value
      .try_into()
      .map_err(|_| "conversion to `NodesStatsWithMetricNodeIdMetric` for metric failed".to_string());
    self
  }

  pub fn completion_fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.completion_fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for completion_fields failed".to_string());
    self
  }

  pub fn fielddata_fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.fielddata_fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for fielddata_fields failed".to_string());
    self
  }

  pub fn fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
    self
  }

  pub fn groups<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.groups = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for groups failed".to_string());
    self
  }

  pub fn include_segment_file_sizes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.include_segment_file_sizes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for include_segment_file_sizes failed".to_string());
    self
  }

  pub fn level<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesStatLevel>, {
    self.level = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `NodesStatLevel` for level failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesStatsWithMetricNodeIdTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `NodesStatsWithMetricNodeIdTimeout` for timeout failed".to_string());
    self
  }

  pub fn types<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.types = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for types failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_nodes/{node_id}/stats/{metric}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      node_id,
      metric,
      completion_fields,
      fielddata_fields,
      fields,
      groups,
      include_segment_file_sizes,
      level,
      timeout,
      types,
    } = self;
    let node_id = node_id.map_err(Error::InvalidRequest)?;
    let metric = metric.map_err(Error::InvalidRequest)?;
    let completion_fields = completion_fields.map_err(Error::InvalidRequest)?;
    let fielddata_fields = fielddata_fields.map_err(Error::InvalidRequest)?;
    let fields = fields.map_err(Error::InvalidRequest)?;
    let groups = groups.map_err(Error::InvalidRequest)?;
    let include_segment_file_sizes = include_segment_file_sizes.map_err(Error::InvalidRequest)?;
    let level = level.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let types = types.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_nodes/{}/stats/{}",
      client.baseurl,
      encode_path(&node_id.to_string()),
      encode_path(&metric.to_string()),
    );
    let mut query = Vec::with_capacity(8usize);
    if let Some(v) = &completion_fields {
      query.push(("completion_fields", v.join(",")));
    }
    if let Some(v) = &fielddata_fields {
      query.push(("fielddata_fields", v.join(",")));
    }
    if let Some(v) = &fields {
      query.push(("fields", v.join(",")));
    }
    if let Some(v) = &groups {
      query.push(("groups", v.join(",")));
    }
    if let Some(v) = &include_segment_file_sizes {
      query.push(("include_segment_file_sizes", v.to_string()));
    }
    if let Some(v) = &level {
      query.push(("level", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &types {
      query.push(("types", v.join(",")));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::nodes_stats_with_index_metric_metric_node_id`]
///
///[`Client::nodes_stats_with_index_metric_metric_node_id`]: super::Client::nodes_stats_with_index_metric_metric_node_id
#[derive(Debug, Clone)]
pub struct NodesStatsWithIndexMetricMetricNodeId<'a> {
  client: &'a super::Client,
  node_id: Result<types::NodesStatsWithIndexMetricMetricNodeIdNodeId, String>,
  metric: Result<types::NodesStatsWithIndexMetricMetricNodeIdMetric, String>,
  index_metric: Result<types::NodesStatsWithIndexMetricMetricNodeIdIndexMetric, String>,
  completion_fields: Result<Option<Vec<String>>, String>,
  fielddata_fields: Result<Option<Vec<String>>, String>,
  fields: Result<Option<Vec<String>>, String>,
  groups: Result<Option<Vec<String>>, String>,
  include_segment_file_sizes: Result<Option<bool>, String>,
  level: Result<Option<types::NodesStatLevel>, String>,
  timeout: Result<Option<types::NodesStatsWithIndexMetricMetricNodeIdTimeout>, String>,
  types: Result<Option<Vec<String>>, String>,
}

impl<'a> NodesStatsWithIndexMetricMetricNodeId<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      node_id: Err("node_id was not initialized".to_string()),
      metric: Err("metric was not initialized".to_string()),
      index_metric: Err("index_metric was not initialized".to_string()),
      completion_fields: Ok(None),
      fielddata_fields: Ok(None),
      fields: Ok(None),
      groups: Ok(None),
      include_segment_file_sizes: Ok(None),
      level: Ok(None),
      timeout: Ok(None),
      types: Ok(None),
    }
  }

  pub fn node_id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesStatsWithIndexMetricMetricNodeIdNodeId>, {
    self.node_id = value
      .try_into()
      .map_err(|_| "conversion to `NodesStatsWithIndexMetricMetricNodeIdNodeId` for node_id failed".to_string());
    self
  }

  pub fn metric<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesStatsWithIndexMetricMetricNodeIdMetric>, {
    self.metric = value
      .try_into()
      .map_err(|_| "conversion to `NodesStatsWithIndexMetricMetricNodeIdMetric` for metric failed".to_string());
    self
  }

  pub fn index_metric<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesStatsWithIndexMetricMetricNodeIdIndexMetric>, {
    self.index_metric = value.try_into().map_err(|_| {
      "conversion to `NodesStatsWithIndexMetricMetricNodeIdIndexMetric` for index_metric failed".to_string()
    });
    self
  }

  pub fn completion_fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.completion_fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for completion_fields failed".to_string());
    self
  }

  pub fn fielddata_fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.fielddata_fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for fielddata_fields failed".to_string());
    self
  }

  pub fn fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
    self
  }

  pub fn groups<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.groups = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for groups failed".to_string());
    self
  }

  pub fn include_segment_file_sizes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.include_segment_file_sizes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for include_segment_file_sizes failed".to_string());
    self
  }

  pub fn level<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesStatLevel>, {
    self.level = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `NodesStatLevel` for level failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesStatsWithIndexMetricMetricNodeIdTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `NodesStatsWithIndexMetricMetricNodeIdTimeout` for timeout failed".to_string());
    self
  }

  pub fn types<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.types = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for types failed".to_string());
    self
  }

  ///Sends a `GET` request to
  /// `/_nodes/{node_id}/stats/{metric}/{index_metric}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      node_id,
      metric,
      index_metric,
      completion_fields,
      fielddata_fields,
      fields,
      groups,
      include_segment_file_sizes,
      level,
      timeout,
      types,
    } = self;
    let node_id = node_id.map_err(Error::InvalidRequest)?;
    let metric = metric.map_err(Error::InvalidRequest)?;
    let index_metric = index_metric.map_err(Error::InvalidRequest)?;
    let completion_fields = completion_fields.map_err(Error::InvalidRequest)?;
    let fielddata_fields = fielddata_fields.map_err(Error::InvalidRequest)?;
    let fields = fields.map_err(Error::InvalidRequest)?;
    let groups = groups.map_err(Error::InvalidRequest)?;
    let include_segment_file_sizes = include_segment_file_sizes.map_err(Error::InvalidRequest)?;
    let level = level.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let types = types.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_nodes/{}/stats/{}/{}",
      client.baseurl,
      encode_path(&node_id.to_string()),
      encode_path(&metric.to_string()),
      encode_path(&index_metric.to_string()),
    );
    let mut query = Vec::with_capacity(8usize);
    if let Some(v) = &completion_fields {
      query.push(("completion_fields", v.join(",")));
    }
    if let Some(v) = &fielddata_fields {
      query.push(("fielddata_fields", v.join(",")));
    }
    if let Some(v) = &fields {
      query.push(("fields", v.join(",")));
    }
    if let Some(v) = &groups {
      query.push(("groups", v.join(",")));
    }
    if let Some(v) = &include_segment_file_sizes {
      query.push(("include_segment_file_sizes", v.to_string()));
    }
    if let Some(v) = &level {
      query.push(("level", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &types {
      query.push(("types", v.join(",")));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::nodes_usage_with_node_id`]
///
///[`Client::nodes_usage_with_node_id`]: super::Client::nodes_usage_with_node_id
#[derive(Debug, Clone)]
pub struct NodesUsageWithNodeId<'a> {
  client: &'a super::Client,
  node_id: Result<types::NodesUsageWithNodeIdNodeId, String>,
  timeout: Result<Option<types::NodesUsageWithNodeIdTimeout>, String>,
}

impl<'a> NodesUsageWithNodeId<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      node_id: Err("node_id was not initialized".to_string()),
      timeout: Ok(None),
    }
  }

  pub fn node_id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesUsageWithNodeIdNodeId>, {
    self.node_id = value
      .try_into()
      .map_err(|_| "conversion to `NodesUsageWithNodeIdNodeId` for node_id failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesUsageWithNodeIdTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `NodesUsageWithNodeIdTimeout` for timeout failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_nodes/{node_id}/usage`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      node_id,
      timeout,
    } = self;
    let node_id = node_id.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_nodes/{}/usage", client.baseurl, encode_path(&node_id.to_string()),);
    let mut query = Vec::with_capacity(1usize);
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::nodes_usage_with_metric_node_id`]
///
///[`Client::nodes_usage_with_metric_node_id`]: super::Client::nodes_usage_with_metric_node_id
#[derive(Debug, Clone)]
pub struct NodesUsageWithMetricNodeId<'a> {
  client: &'a super::Client,
  node_id: Result<types::NodesUsageWithMetricNodeIdNodeId, String>,
  metric: Result<types::NodesUsageWithMetricNodeIdMetric, String>,
  timeout: Result<Option<types::NodesUsageWithMetricNodeIdTimeout>, String>,
}

impl<'a> NodesUsageWithMetricNodeId<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      node_id: Err("node_id was not initialized".to_string()),
      metric: Err("metric was not initialized".to_string()),
      timeout: Ok(None),
    }
  }

  pub fn node_id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesUsageWithMetricNodeIdNodeId>, {
    self.node_id = value
      .try_into()
      .map_err(|_| "conversion to `NodesUsageWithMetricNodeIdNodeId` for node_id failed".to_string());
    self
  }

  pub fn metric<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesUsageWithMetricNodeIdMetric>, {
    self.metric = value
      .try_into()
      .map_err(|_| "conversion to `NodesUsageWithMetricNodeIdMetric` for metric failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesUsageWithMetricNodeIdTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `NodesUsageWithMetricNodeIdTimeout` for timeout failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_nodes/{node_id}/usage/{metric}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      node_id,
      metric,
      timeout,
    } = self;
    let node_id = node_id.map_err(Error::InvalidRequest)?;
    let metric = metric.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_nodes/{}/usage/{}",
      client.baseurl,
      encode_path(&node_id.to_string()),
      encode_path(&metric.to_string()),
    );
    let mut query = Vec::with_capacity(1usize);
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::nodes_info_with_metric_node_id`]
///
///[`Client::nodes_info_with_metric_node_id`]: super::Client::nodes_info_with_metric_node_id
#[derive(Debug, Clone)]
pub struct NodesInfoWithMetricNodeId<'a> {
  client: &'a super::Client,
  node_id: Result<types::NodesInfoWithMetricNodeIdNodeId, String>,
  metric: Result<types::NodesInfoWithMetricNodeIdMetric, String>,
  flat_settings: Result<Option<bool>, String>,
  timeout: Result<Option<types::NodesInfoWithMetricNodeIdTimeout>, String>,
}

impl<'a> NodesInfoWithMetricNodeId<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      node_id: Err("node_id was not initialized".to_string()),
      metric: Err("metric was not initialized".to_string()),
      flat_settings: Ok(None),
      timeout: Ok(None),
    }
  }

  pub fn node_id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesInfoWithMetricNodeIdNodeId>, {
    self.node_id = value
      .try_into()
      .map_err(|_| "conversion to `NodesInfoWithMetricNodeIdNodeId` for node_id failed".to_string());
    self
  }

  pub fn metric<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesInfoWithMetricNodeIdMetric>, {
    self.metric = value
      .try_into()
      .map_err(|_| "conversion to `NodesInfoWithMetricNodeIdMetric` for metric failed".to_string());
    self
  }

  pub fn flat_settings<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.flat_settings = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::NodesInfoWithMetricNodeIdTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `NodesInfoWithMetricNodeIdTimeout` for timeout failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_nodes/{node_id}/{metric}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      node_id,
      metric,
      flat_settings,
      timeout,
    } = self;
    let node_id = node_id.map_err(Error::InvalidRequest)?;
    let metric = metric.map_err(Error::InvalidRequest)?;
    let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_nodes/{}/{}",
      client.baseurl,
      encode_path(&node_id.to_string()),
      encode_path(&metric.to_string()),
    );
    let mut query = Vec::with_capacity(2usize);
    if let Some(v) = &flat_settings {
      query.push(("flat_settings", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::get_account_details`]
///
///[`Client::get_account_details`]: super::Client::get_account_details
#[derive(Debug, Clone)]
pub struct GetAccountDetails<'a> {
  client: &'a super::Client,
}

impl<'a> GetAccountDetails<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self { client }
  }

  ///Sends a `GET` request to `/_plugins/_security/api/account`
  pub async fn send(self) -> Result<ResponseValue<types::AccountDetails>, Error<()>> {
    let Self { client } = self;
    let url = format!("{}/_plugins/_security/api/account", client.baseurl,);
    let request = client
      .client
      .get(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::change_password`]
///
///[`Client::change_password`]: super::Client::change_password
#[derive(Debug, Clone)]
pub struct ChangePassword<'a> {
  client: &'a super::Client,
  body: Result<types::builder::ChangePasswordRequestContent, String>,
}

impl<'a> ChangePassword<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      body: Ok(types::builder::ChangePasswordRequestContent::default()),
    }
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ChangePasswordRequestContent>, {
    self.body = value
      .try_into()
      .map(From::from)
      .map_err(|_| "conversion to `ChangePasswordRequestContent` for body failed".to_string());
    self
  }

  pub fn body_map<F>(mut self, f: F) -> Self
  where
    F: std::ops::FnOnce(types::builder::ChangePasswordRequestContent) -> types::builder::ChangePasswordRequestContent,
  {
    self.body = self.body.map(f);
    self
  }

  ///Sends a `PUT` request to `/_plugins/_security/api/account`
  pub async fn send(self) -> Result<ResponseValue<types::ChangePasswordResponseContent>, Error<()>> {
    let Self { client, body } = self;
    let body = body
      .and_then(std::convert::TryInto::<types::ChangePasswordRequestContent>::try_into)
      .map_err(Error::InvalidRequest)?;
    let url = format!("{}/_plugins/_security/api/account", client.baseurl,);
    let request = client
      .client
      .put(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .json(&body)
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::patch_action_groups`]
///
///[`Client::patch_action_groups`]: super::Client::patch_action_groups
#[derive(Debug, Clone)]
pub struct PatchActionGroups<'a> {
  client: &'a super::Client,
  body: Result<types::PatchActionGroupsInputPayload, String>,
}

impl<'a> PatchActionGroups<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::PatchActionGroupsInputPayload>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `PatchActionGroupsInputPayload` for body failed".to_string());
    self
  }

  ///Sends a `PATCH` request to `/_plugins/_security/api/actiongroups`
  pub async fn send(self) -> Result<ResponseValue<types::PatchActionGroupsResponseContent>, Error<()>> {
    let Self { client, body } = self;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_plugins/_security/api/actiongroups", client.baseurl,);
    let request = client
      .client
      .patch(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .json(&body)
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::get_action_groups`]
///
///[`Client::get_action_groups`]: super::Client::get_action_groups
#[derive(Debug, Clone)]
pub struct GetActionGroups<'a> {
  client: &'a super::Client,
}

impl<'a> GetActionGroups<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self { client }
  }

  ///Sends a `GET` request to `/_plugins/_security/api/actiongroups/`
  pub async fn send(self) -> Result<ResponseValue<types::ActionGroupsMap>, Error<()>> {
    let Self { client } = self;
    let url = format!("{}/_plugins/_security/api/actiongroups/", client.baseurl,);
    let request = client
      .client
      .get(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::get_action_group`]
///
///[`Client::get_action_group`]: super::Client::get_action_group
#[derive(Debug, Clone)]
pub struct GetActionGroup<'a> {
  client: &'a super::Client,
  action_group: Result<String, String>,
}

impl<'a> GetActionGroup<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      action_group: Err("action_group was not initialized".to_string()),
    }
  }

  pub fn action_group<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.action_group = value
      .try_into()
      .map_err(|_| "conversion to `String` for action_group failed".to_string());
    self
  }

  ///Sends a `GET` request to
  /// `/_plugins/_security/api/actiongroups/{action_group}`
  pub async fn send(self) -> Result<ResponseValue<types::ActionGroupsMap>, Error<()>> {
    let Self { client, action_group } = self;
    let action_group = action_group.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_plugins/_security/api/actiongroups/{}",
      client.baseurl,
      encode_path(&action_group.to_string()),
    );
    let request = client
      .client
      .get(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::create_action_group`]
///
///[`Client::create_action_group`]: super::Client::create_action_group
#[derive(Debug, Clone)]
pub struct CreateActionGroup<'a> {
  client: &'a super::Client,
  action_group: Result<String, String>,
  body: Result<types::builder::ActionGroup, String>,
}

impl<'a> CreateActionGroup<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      action_group: Err("action_group was not initialized".to_string()),
      body: Ok(types::builder::ActionGroup::default()),
    }
  }

  pub fn action_group<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.action_group = value
      .try_into()
      .map_err(|_| "conversion to `String` for action_group failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ActionGroup>, {
    self.body = value
      .try_into()
      .map(From::from)
      .map_err(|_| "conversion to `ActionGroup` for body failed".to_string());
    self
  }

  pub fn body_map<F>(mut self, f: F) -> Self
  where
    F: std::ops::FnOnce(types::builder::ActionGroup) -> types::builder::ActionGroup, {
    self.body = self.body.map(f);
    self
  }

  ///Sends a `PUT` request to
  /// `/_plugins/_security/api/actiongroups/{action_group}`
  pub async fn send(self) -> Result<ResponseValue<types::CreateActionGroupResponseContent>, Error<()>> {
    let Self {
      client,
      action_group,
      body,
    } = self;
    let action_group = action_group.map_err(Error::InvalidRequest)?;
    let body = body
      .and_then(std::convert::TryInto::<types::ActionGroup>::try_into)
      .map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_plugins/_security/api/actiongroups/{}",
      client.baseurl,
      encode_path(&action_group.to_string()),
    );
    let request = client
      .client
      .put(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .json(&body)
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::delete_action_group`]
///
///[`Client::delete_action_group`]: super::Client::delete_action_group
#[derive(Debug, Clone)]
pub struct DeleteActionGroup<'a> {
  client: &'a super::Client,
  action_group: Result<String, String>,
}

impl<'a> DeleteActionGroup<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      action_group: Err("action_group was not initialized".to_string()),
    }
  }

  pub fn action_group<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.action_group = value
      .try_into()
      .map_err(|_| "conversion to `String` for action_group failed".to_string());
    self
  }

  ///Sends a `DELETE` request to
  /// `/_plugins/_security/api/actiongroups/{action_group}`
  pub async fn send(self) -> Result<ResponseValue<types::DeleteActionGroupResponseContent>, Error<()>> {
    let Self { client, action_group } = self;
    let action_group = action_group.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_plugins/_security/api/actiongroups/{}",
      client.baseurl,
      encode_path(&action_group.to_string()),
    );
    let request = client
      .client
      .delete(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::patch_action_group`]
///
///[`Client::patch_action_group`]: super::Client::patch_action_group
#[derive(Debug, Clone)]
pub struct PatchActionGroup<'a> {
  client: &'a super::Client,
  action_group: Result<String, String>,
  body: Result<types::PatchActionGroupInputPayload, String>,
}

impl<'a> PatchActionGroup<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      action_group: Err("action_group was not initialized".to_string()),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn action_group<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.action_group = value
      .try_into()
      .map_err(|_| "conversion to `String` for action_group failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::PatchActionGroupInputPayload>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `PatchActionGroupInputPayload` for body failed".to_string());
    self
  }

  ///Sends a `PATCH` request to
  /// `/_plugins/_security/api/actiongroups/{action_group}`
  pub async fn send(self) -> Result<ResponseValue<types::PatchActionGroupResponseContent>, Error<()>> {
    let Self {
      client,
      action_group,
      body,
    } = self;
    let action_group = action_group.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_plugins/_security/api/actiongroups/{}",
      client.baseurl,
      encode_path(&action_group.to_string()),
    );
    let request = client
      .client
      .patch(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .json(&body)
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::get_audit_configuration`]
///
///[`Client::get_audit_configuration`]: super::Client::get_audit_configuration
#[derive(Debug, Clone)]
pub struct GetAuditConfiguration<'a> {
  client: &'a super::Client,
}

impl<'a> GetAuditConfiguration<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self { client }
  }

  ///Sends a `GET` request to `/_plugins/_security/api/audit`
  pub async fn send(self) -> Result<ResponseValue<types::AuditConfigWithReadOnly>, Error<()>> {
    let Self { client } = self;
    let url = format!("{}/_plugins/_security/api/audit", client.baseurl,);
    let request = client
      .client
      .get(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::patch_audit_configuration`]
///
///[`Client::patch_audit_configuration`]: super::Client::patch_audit_configuration
#[derive(Debug, Clone)]
pub struct PatchAuditConfiguration<'a> {
  client: &'a super::Client,
  body: Result<types::PatchAuditConfigurationInputPayload, String>,
}

impl<'a> PatchAuditConfiguration<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::PatchAuditConfigurationInputPayload>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `PatchAuditConfigurationInputPayload` for body failed".to_string());
    self
  }

  ///Sends a `PATCH` request to `/_plugins/_security/api/audit`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self { client, body } = self;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_plugins/_security/api/audit", client.baseurl,);
    let request = client.client.patch(url).json(&body).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::update_audit_configuration`]
///
///[`Client::update_audit_configuration`]: super::Client::update_audit_configuration
#[derive(Debug, Clone)]
pub struct UpdateAuditConfiguration<'a> {
  client: &'a super::Client,
  body: Result<types::builder::AuditConfig, String>,
}

impl<'a> UpdateAuditConfiguration<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      body: Ok(types::builder::AuditConfig::default()),
    }
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::AuditConfig>, {
    self.body = value
      .try_into()
      .map(From::from)
      .map_err(|_| "conversion to `AuditConfig` for body failed".to_string());
    self
  }

  pub fn body_map<F>(mut self, f: F) -> Self
  where
    F: std::ops::FnOnce(types::builder::AuditConfig) -> types::builder::AuditConfig, {
    self.body = self.body.map(f);
    self
  }

  ///Sends a `PUT` request to `/_plugins/_security/api/audit/config`
  pub async fn send(self) -> Result<ResponseValue<types::UpdateAuditConfigurationResponseContent>, Error<()>> {
    let Self { client, body } = self;
    let body = body
      .and_then(std::convert::TryInto::<types::AuditConfig>::try_into)
      .map_err(Error::InvalidRequest)?;
    let url = format!("{}/_plugins/_security/api/audit/config", client.baseurl,);
    let request = client
      .client
      .put(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .json(&body)
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::flush_cache`]
///
///[`Client::flush_cache`]: super::Client::flush_cache
#[derive(Debug, Clone)]
pub struct FlushCache<'a> {
  client: &'a super::Client,
}

impl<'a> FlushCache<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self { client }
  }

  ///Sends a `DELETE` request to `/_plugins/_security/api/cache`
  pub async fn send(self) -> Result<ResponseValue<types::FlushCacheResponseContent>, Error<()>> {
    let Self { client } = self;
    let url = format!("{}/_plugins/_security/api/cache", client.baseurl,);
    let request = client
      .client
      .delete(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::get_users`]
///
///[`Client::get_users`]: super::Client::get_users
#[derive(Debug, Clone)]
pub struct GetUsers<'a> {
  client: &'a super::Client,
}

impl<'a> GetUsers<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self { client }
  }

  ///Sends a `GET` request to `/_plugins/_security/api/internalusers`
  pub async fn send(self) -> Result<ResponseValue<types::UsersMap>, Error<()>> {
    let Self { client } = self;
    let url = format!("{}/_plugins/_security/api/internalusers", client.baseurl,);
    let request = client
      .client
      .get(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::patch_users`]
///
///[`Client::patch_users`]: super::Client::patch_users
#[derive(Debug, Clone)]
pub struct PatchUsers<'a> {
  client: &'a super::Client,
  body: Result<types::PatchUsersInputPayload, String>,
}

impl<'a> PatchUsers<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::PatchUsersInputPayload>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `PatchUsersInputPayload` for body failed".to_string());
    self
  }

  ///Sends a `PATCH` request to `/_plugins/_security/api/internalusers`
  pub async fn send(self) -> Result<ResponseValue<types::PatchUsersResponseContent>, Error<()>> {
    let Self { client, body } = self;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_plugins/_security/api/internalusers", client.baseurl,);
    let request = client
      .client
      .patch(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .json(&body)
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::get_user`]
///
///[`Client::get_user`]: super::Client::get_user
#[derive(Debug, Clone)]
pub struct GetUser<'a> {
  client: &'a super::Client,
  username: Result<String, String>,
}

impl<'a> GetUser<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      username: Err("username was not initialized".to_string()),
    }
  }

  pub fn username<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.username = value
      .try_into()
      .map_err(|_| "conversion to `String` for username failed".to_string());
    self
  }

  ///Sends a `GET` request to
  /// `/_plugins/_security/api/internalusers/{username}`
  pub async fn send(self) -> Result<ResponseValue<types::UsersMap>, Error<()>> {
    let Self { client, username } = self;
    let username = username.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_plugins/_security/api/internalusers/{}",
      client.baseurl,
      encode_path(&username.to_string()),
    );
    let request = client
      .client
      .get(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::create_user`]
///
///[`Client::create_user`]: super::Client::create_user
#[derive(Debug, Clone)]
pub struct CreateUser<'a> {
  client: &'a super::Client,
  username: Result<String, String>,
  body: Result<types::builder::User, String>,
}

impl<'a> CreateUser<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      username: Err("username was not initialized".to_string()),
      body: Ok(types::builder::User::default()),
    }
  }

  pub fn username<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.username = value
      .try_into()
      .map_err(|_| "conversion to `String` for username failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::User>, {
    self.body = value
      .try_into()
      .map(From::from)
      .map_err(|_| "conversion to `User` for body failed".to_string());
    self
  }

  pub fn body_map<F>(mut self, f: F) -> Self
  where
    F: std::ops::FnOnce(types::builder::User) -> types::builder::User, {
    self.body = self.body.map(f);
    self
  }

  ///Sends a `PUT` request to
  /// `/_plugins/_security/api/internalusers/{username}`
  pub async fn send(self) -> Result<ResponseValue<types::CreateUserResponseContent>, Error<()>> {
    let Self { client, username, body } = self;
    let username = username.map_err(Error::InvalidRequest)?;
    let body = body
      .and_then(std::convert::TryInto::<types::User>::try_into)
      .map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_plugins/_security/api/internalusers/{}",
      client.baseurl,
      encode_path(&username.to_string()),
    );
    let request = client
      .client
      .put(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .json(&body)
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::delete_user`]
///
///[`Client::delete_user`]: super::Client::delete_user
#[derive(Debug, Clone)]
pub struct DeleteUser<'a> {
  client: &'a super::Client,
  username: Result<String, String>,
}

impl<'a> DeleteUser<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      username: Err("username was not initialized".to_string()),
    }
  }

  pub fn username<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.username = value
      .try_into()
      .map_err(|_| "conversion to `String` for username failed".to_string());
    self
  }

  ///Sends a `DELETE` request to
  /// `/_plugins/_security/api/internalusers/{username}`
  pub async fn send(self) -> Result<ResponseValue<types::DeleteUserResponseContent>, Error<()>> {
    let Self { client, username } = self;
    let username = username.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_plugins/_security/api/internalusers/{}",
      client.baseurl,
      encode_path(&username.to_string()),
    );
    let request = client
      .client
      .delete(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::patch_user`]
///
///[`Client::patch_user`]: super::Client::patch_user
#[derive(Debug, Clone)]
pub struct PatchUser<'a> {
  client: &'a super::Client,
  username: Result<String, String>,
  body: Result<types::PatchUserInputPayload, String>,
}

impl<'a> PatchUser<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      username: Err("username was not initialized".to_string()),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn username<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.username = value
      .try_into()
      .map_err(|_| "conversion to `String` for username failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::PatchUserInputPayload>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `PatchUserInputPayload` for body failed".to_string());
    self
  }

  ///Sends a `PATCH` request to
  /// `/_plugins/_security/api/internalusers/{username}`
  pub async fn send(self) -> Result<ResponseValue<types::PatchUserResponseContent>, Error<()>> {
    let Self { client, username, body } = self;
    let username = username.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_plugins/_security/api/internalusers/{}",
      client.baseurl,
      encode_path(&username.to_string()),
    );
    let request = client
      .client
      .patch(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .json(&body)
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::get_distinguished_names`]
///
///[`Client::get_distinguished_names`]: super::Client::get_distinguished_names
#[derive(Debug, Clone)]
pub struct GetDistinguishedNames<'a> {
  client: &'a super::Client,
}

impl<'a> GetDistinguishedNames<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self { client }
  }

  ///Sends a `GET` request to `/_plugins/_security/api/nodesdn`
  pub async fn send(self) -> Result<ResponseValue<types::DistinguishedNamesMap>, Error<()>> {
    let Self { client } = self;
    let url = format!("{}/_plugins/_security/api/nodesdn", client.baseurl,);
    let request = client
      .client
      .get(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::patch_distinguished_names`]
///
///[`Client::patch_distinguished_names`]: super::Client::patch_distinguished_names
#[derive(Debug, Clone)]
pub struct PatchDistinguishedNames<'a> {
  client: &'a super::Client,
  body: Result<types::PatchDistinguishedNamesInputPayload, String>,
}

impl<'a> PatchDistinguishedNames<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::PatchDistinguishedNamesInputPayload>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `PatchDistinguishedNamesInputPayload` for body failed".to_string());
    self
  }

  ///Sends a `PATCH` request to `/_plugins/_security/api/nodesdn`
  pub async fn send(self) -> Result<ResponseValue<types::PatchDistinguishedNamesResponseContent>, Error<()>> {
    let Self { client, body } = self;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_plugins/_security/api/nodesdn", client.baseurl,);
    let request = client
      .client
      .patch(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .json(&body)
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::get_distinguished_names_with_cluster_name`]
///
///[`Client::get_distinguished_names_with_cluster_name`]: super::Client::get_distinguished_names_with_cluster_name
#[derive(Debug, Clone)]
pub struct GetDistinguishedNamesWithClusterName<'a> {
  client: &'a super::Client,
  cluster_name: Result<String, String>,
}

impl<'a> GetDistinguishedNamesWithClusterName<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      cluster_name: Err("cluster_name was not initialized".to_string()),
    }
  }

  pub fn cluster_name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.cluster_name = value
      .try_into()
      .map_err(|_| "conversion to `String` for cluster_name failed".to_string());
    self
  }

  ///Sends a `GET` request to
  /// `/_plugins/_security/api/nodesdn/{cluster_name}`
  pub async fn send(self) -> Result<ResponseValue<types::DistinguishedNamesMap>, Error<()>> {
    let Self { client, cluster_name } = self;
    let cluster_name = cluster_name.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_plugins/_security/api/nodesdn/{}",
      client.baseurl,
      encode_path(&cluster_name.to_string()),
    );
    let request = client
      .client
      .get(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::update_distinguished_names`]
///
///[`Client::update_distinguished_names`]: super::Client::update_distinguished_names
#[derive(Debug, Clone)]
pub struct UpdateDistinguishedNames<'a> {
  client: &'a super::Client,
  cluster_name: Result<String, String>,
  body: Result<types::builder::DistinguishedNames, String>,
}

impl<'a> UpdateDistinguishedNames<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      cluster_name: Err("cluster_name was not initialized".to_string()),
      body: Ok(types::builder::DistinguishedNames::default()),
    }
  }

  pub fn cluster_name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.cluster_name = value
      .try_into()
      .map_err(|_| "conversion to `String` for cluster_name failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::DistinguishedNames>, {
    self.body = value
      .try_into()
      .map(From::from)
      .map_err(|_| "conversion to `DistinguishedNames` for body failed".to_string());
    self
  }

  pub fn body_map<F>(mut self, f: F) -> Self
  where
    F: std::ops::FnOnce(types::builder::DistinguishedNames) -> types::builder::DistinguishedNames, {
    self.body = self.body.map(f);
    self
  }

  ///Sends a `PUT` request to
  /// `/_plugins/_security/api/nodesdn/{cluster_name}`
  pub async fn send(self) -> Result<ResponseValue<types::UpdateDistinguishedNamesResponseContent>, Error<()>> {
    let Self {
      client,
      cluster_name,
      body,
    } = self;
    let cluster_name = cluster_name.map_err(Error::InvalidRequest)?;
    let body = body
      .and_then(std::convert::TryInto::<types::DistinguishedNames>::try_into)
      .map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_plugins/_security/api/nodesdn/{}",
      client.baseurl,
      encode_path(&cluster_name.to_string()),
    );
    let request = client
      .client
      .put(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .json(&body)
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::delete_distinguished_names`]
///
///[`Client::delete_distinguished_names`]: super::Client::delete_distinguished_names
#[derive(Debug, Clone)]
pub struct DeleteDistinguishedNames<'a> {
  client: &'a super::Client,
  cluster_name: Result<String, String>,
}

impl<'a> DeleteDistinguishedNames<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      cluster_name: Err("cluster_name was not initialized".to_string()),
    }
  }

  pub fn cluster_name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.cluster_name = value
      .try_into()
      .map_err(|_| "conversion to `String` for cluster_name failed".to_string());
    self
  }

  ///Sends a `DELETE` request to
  /// `/_plugins/_security/api/nodesdn/{cluster_name}`
  pub async fn send(self) -> Result<ResponseValue<types::DeleteDistinguishedNamesResponseContent>, Error<()>> {
    let Self { client, cluster_name } = self;
    let cluster_name = cluster_name.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_plugins/_security/api/nodesdn/{}",
      client.baseurl,
      encode_path(&cluster_name.to_string()),
    );
    let request = client
      .client
      .delete(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::patch_roles`]
///
///[`Client::patch_roles`]: super::Client::patch_roles
#[derive(Debug, Clone)]
pub struct PatchRoles<'a> {
  client: &'a super::Client,
  body: Result<types::PatchRolesInputPayload, String>,
}

impl<'a> PatchRoles<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::PatchRolesInputPayload>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `PatchRolesInputPayload` for body failed".to_string());
    self
  }

  ///Sends a `PATCH` request to `/_plugins/_security/api/roles`
  pub async fn send(self) -> Result<ResponseValue<types::PatchRolesResponseContent>, Error<()>> {
    let Self { client, body } = self;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_plugins/_security/api/roles", client.baseurl,);
    let request = client
      .client
      .patch(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .json(&body)
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::get_roles`]
///
///[`Client::get_roles`]: super::Client::get_roles
#[derive(Debug, Clone)]
pub struct GetRoles<'a> {
  client: &'a super::Client,
}

impl<'a> GetRoles<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self { client }
  }

  ///Sends a `GET` request to `/_plugins/_security/api/roles/`
  pub async fn send(self) -> Result<ResponseValue<types::RolesMap>, Error<()>> {
    let Self { client } = self;
    let url = format!("{}/_plugins/_security/api/roles/", client.baseurl,);
    let request = client
      .client
      .get(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::get_role`]
///
///[`Client::get_role`]: super::Client::get_role
#[derive(Debug, Clone)]
pub struct GetRole<'a> {
  client: &'a super::Client,
  role: Result<String, String>,
}

impl<'a> GetRole<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      role: Err("role was not initialized".to_string()),
    }
  }

  pub fn role<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.role = value
      .try_into()
      .map_err(|_| "conversion to `String` for role failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_plugins/_security/api/roles/{role}`
  pub async fn send(self) -> Result<ResponseValue<types::RolesMap>, Error<()>> {
    let Self { client, role } = self;
    let role = role.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_plugins/_security/api/roles/{}",
      client.baseurl,
      encode_path(&role.to_string()),
    );
    let request = client
      .client
      .get(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::create_role`]
///
///[`Client::create_role`]: super::Client::create_role
#[derive(Debug, Clone)]
pub struct CreateRole<'a> {
  client: &'a super::Client,
  role: Result<String, String>,
  body: Result<types::builder::Role, String>,
}

impl<'a> CreateRole<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      role: Err("role was not initialized".to_string()),
      body: Ok(types::builder::Role::default()),
    }
  }

  pub fn role<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.role = value
      .try_into()
      .map_err(|_| "conversion to `String` for role failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::Role>, {
    self.body = value
      .try_into()
      .map(From::from)
      .map_err(|_| "conversion to `Role` for body failed".to_string());
    self
  }

  pub fn body_map<F>(mut self, f: F) -> Self
  where
    F: std::ops::FnOnce(types::builder::Role) -> types::builder::Role, {
    self.body = self.body.map(f);
    self
  }

  ///Sends a `PUT` request to `/_plugins/_security/api/roles/{role}`
  pub async fn send(self) -> Result<ResponseValue<types::CreateRoleResponseContent>, Error<()>> {
    let Self { client, role, body } = self;
    let role = role.map_err(Error::InvalidRequest)?;
    let body = body
      .and_then(std::convert::TryInto::<types::Role>::try_into)
      .map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_plugins/_security/api/roles/{}",
      client.baseurl,
      encode_path(&role.to_string()),
    );
    let request = client
      .client
      .put(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .json(&body)
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::delete_role`]
///
///[`Client::delete_role`]: super::Client::delete_role
#[derive(Debug, Clone)]
pub struct DeleteRole<'a> {
  client: &'a super::Client,
  role: Result<String, String>,
}

impl<'a> DeleteRole<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      role: Err("role was not initialized".to_string()),
    }
  }

  pub fn role<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.role = value
      .try_into()
      .map_err(|_| "conversion to `String` for role failed".to_string());
    self
  }

  ///Sends a `DELETE` request to `/_plugins/_security/api/roles/{role}`
  pub async fn send(self) -> Result<ResponseValue<types::DeleteRoleResponseContent>, Error<()>> {
    let Self { client, role } = self;
    let role = role.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_plugins/_security/api/roles/{}",
      client.baseurl,
      encode_path(&role.to_string()),
    );
    let request = client
      .client
      .delete(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::patch_role`]
///
///[`Client::patch_role`]: super::Client::patch_role
#[derive(Debug, Clone)]
pub struct PatchRole<'a> {
  client: &'a super::Client,
  role: Result<String, String>,
  body: Result<types::PatchRoleInputPayload, String>,
}

impl<'a> PatchRole<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      role: Err("role was not initialized".to_string()),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn role<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.role = value
      .try_into()
      .map_err(|_| "conversion to `String` for role failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::PatchRoleInputPayload>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `PatchRoleInputPayload` for body failed".to_string());
    self
  }

  ///Sends a `PATCH` request to `/_plugins/_security/api/roles/{role}`
  pub async fn send(self) -> Result<ResponseValue<types::PatchRoleResponseContent>, Error<()>> {
    let Self { client, role, body } = self;
    let role = role.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_plugins/_security/api/roles/{}",
      client.baseurl,
      encode_path(&role.to_string()),
    );
    let request = client
      .client
      .patch(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .json(&body)
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::get_role_mappings`]
///
///[`Client::get_role_mappings`]: super::Client::get_role_mappings
#[derive(Debug, Clone)]
pub struct GetRoleMappings<'a> {
  client: &'a super::Client,
}

impl<'a> GetRoleMappings<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self { client }
  }

  ///Sends a `GET` request to `/_plugins/_security/api/rolesmapping`
  pub async fn send(self) -> Result<ResponseValue<types::RoleMappings>, Error<()>> {
    let Self { client } = self;
    let url = format!("{}/_plugins/_security/api/rolesmapping", client.baseurl,);
    let request = client
      .client
      .get(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::patch_role_mappings`]
///
///[`Client::patch_role_mappings`]: super::Client::patch_role_mappings
#[derive(Debug, Clone)]
pub struct PatchRoleMappings<'a> {
  client: &'a super::Client,
  body: Result<types::PatchRoleMappingsInputPayload, String>,
}

impl<'a> PatchRoleMappings<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::PatchRoleMappingsInputPayload>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `PatchRoleMappingsInputPayload` for body failed".to_string());
    self
  }

  ///Sends a `PATCH` request to `/_plugins/_security/api/rolesmapping`
  pub async fn send(self) -> Result<ResponseValue<types::PatchRoleMappingsResponseContent>, Error<()>> {
    let Self { client, body } = self;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_plugins/_security/api/rolesmapping", client.baseurl,);
    let request = client
      .client
      .patch(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .json(&body)
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::get_role_mapping`]
///
///[`Client::get_role_mapping`]: super::Client::get_role_mapping
#[derive(Debug, Clone)]
pub struct GetRoleMapping<'a> {
  client: &'a super::Client,
  role: Result<String, String>,
}

impl<'a> GetRoleMapping<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      role: Err("role was not initialized".to_string()),
    }
  }

  pub fn role<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.role = value
      .try_into()
      .map_err(|_| "conversion to `String` for role failed".to_string());
    self
  }

  ///Sends a `GET` request to
  /// `/_plugins/_security/api/rolesmapping/{role}`
  pub async fn send(self) -> Result<ResponseValue<types::RoleMappings>, Error<()>> {
    let Self { client, role } = self;
    let role = role.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_plugins/_security/api/rolesmapping/{}",
      client.baseurl,
      encode_path(&role.to_string()),
    );
    let request = client
      .client
      .get(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::create_role_mapping`]
///
///[`Client::create_role_mapping`]: super::Client::create_role_mapping
#[derive(Debug, Clone)]
pub struct CreateRoleMapping<'a> {
  client: &'a super::Client,
  role: Result<String, String>,
  body: Result<types::builder::RoleMapping, String>,
}

impl<'a> CreateRoleMapping<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      role: Err("role was not initialized".to_string()),
      body: Ok(types::builder::RoleMapping::default()),
    }
  }

  pub fn role<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.role = value
      .try_into()
      .map_err(|_| "conversion to `String` for role failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::RoleMapping>, {
    self.body = value
      .try_into()
      .map(From::from)
      .map_err(|_| "conversion to `RoleMapping` for body failed".to_string());
    self
  }

  pub fn body_map<F>(mut self, f: F) -> Self
  where
    F: std::ops::FnOnce(types::builder::RoleMapping) -> types::builder::RoleMapping, {
    self.body = self.body.map(f);
    self
  }

  ///Sends a `PUT` request to
  /// `/_plugins/_security/api/rolesmapping/{role}`
  pub async fn send(self) -> Result<ResponseValue<types::CreateRoleMappingResponseContent>, Error<()>> {
    let Self { client, role, body } = self;
    let role = role.map_err(Error::InvalidRequest)?;
    let body = body
      .and_then(std::convert::TryInto::<types::RoleMapping>::try_into)
      .map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_plugins/_security/api/rolesmapping/{}",
      client.baseurl,
      encode_path(&role.to_string()),
    );
    let request = client
      .client
      .put(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .json(&body)
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::delete_role_mapping`]
///
///[`Client::delete_role_mapping`]: super::Client::delete_role_mapping
#[derive(Debug, Clone)]
pub struct DeleteRoleMapping<'a> {
  client: &'a super::Client,
  role: Result<String, String>,
}

impl<'a> DeleteRoleMapping<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      role: Err("role was not initialized".to_string()),
    }
  }

  pub fn role<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.role = value
      .try_into()
      .map_err(|_| "conversion to `String` for role failed".to_string());
    self
  }

  ///Sends a `DELETE` request to
  /// `/_plugins/_security/api/rolesmapping/{role}`
  pub async fn send(self) -> Result<ResponseValue<types::DeleteRoleMappingResponseContent>, Error<()>> {
    let Self { client, role } = self;
    let role = role.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_plugins/_security/api/rolesmapping/{}",
      client.baseurl,
      encode_path(&role.to_string()),
    );
    let request = client
      .client
      .delete(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::patch_role_mapping`]
///
///[`Client::patch_role_mapping`]: super::Client::patch_role_mapping
#[derive(Debug, Clone)]
pub struct PatchRoleMapping<'a> {
  client: &'a super::Client,
  role: Result<String, String>,
  body: Result<types::PatchRoleMappingInputPayload, String>,
}

impl<'a> PatchRoleMapping<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      role: Err("role was not initialized".to_string()),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn role<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.role = value
      .try_into()
      .map_err(|_| "conversion to `String` for role failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::PatchRoleMappingInputPayload>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `PatchRoleMappingInputPayload` for body failed".to_string());
    self
  }

  ///Sends a `PATCH` request to
  /// `/_plugins/_security/api/rolesmapping/{role}`
  pub async fn send(self) -> Result<ResponseValue<types::PatchRoleMappingResponseContent>, Error<()>> {
    let Self { client, role, body } = self;
    let role = role.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_plugins/_security/api/rolesmapping/{}",
      client.baseurl,
      encode_path(&role.to_string()),
    );
    let request = client
      .client
      .patch(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .json(&body)
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::get_configuration`]
///
///[`Client::get_configuration`]: super::Client::get_configuration
#[derive(Debug, Clone)]
pub struct GetConfiguration<'a> {
  client: &'a super::Client,
}

impl<'a> GetConfiguration<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self { client }
  }

  ///Sends a `GET` request to `/_plugins/_security/api/securityconfig`
  pub async fn send(self) -> Result<ResponseValue<types::DynamicConfig>, Error<()>> {
    let Self { client } = self;
    let url = format!("{}/_plugins/_security/api/securityconfig", client.baseurl,);
    let request = client
      .client
      .get(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::patch_configuration`]
///
///[`Client::patch_configuration`]: super::Client::patch_configuration
#[derive(Debug, Clone)]
pub struct PatchConfiguration<'a> {
  client: &'a super::Client,
  body: Result<types::PatchConfigurationInputPayload, String>,
}

impl<'a> PatchConfiguration<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::PatchConfigurationInputPayload>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `PatchConfigurationInputPayload` for body failed".to_string());
    self
  }

  ///Sends a `PATCH` request to `/_plugins/_security/api/securityconfig`
  pub async fn send(self) -> Result<ResponseValue<types::PatchConfigurationResponseContent>, Error<()>> {
    let Self { client, body } = self;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_plugins/_security/api/securityconfig", client.baseurl,);
    let request = client
      .client
      .patch(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .json(&body)
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::update_configuration`]
///
///[`Client::update_configuration`]: super::Client::update_configuration
#[derive(Debug, Clone)]
pub struct UpdateConfiguration<'a> {
  client: &'a super::Client,
  body: Result<types::builder::DynamicConfig, String>,
}

impl<'a> UpdateConfiguration<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      body: Ok(types::builder::DynamicConfig::default()),
    }
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::DynamicConfig>, {
    self.body = value
      .try_into()
      .map(From::from)
      .map_err(|_| "conversion to `DynamicConfig` for body failed".to_string());
    self
  }

  pub fn body_map<F>(mut self, f: F) -> Self
  where
    F: std::ops::FnOnce(types::builder::DynamicConfig) -> types::builder::DynamicConfig, {
    self.body = self.body.map(f);
    self
  }

  ///Sends a `PUT` request to
  /// `/_plugins/_security/api/securityconfig/config`
  pub async fn send(self) -> Result<ResponseValue<types::UpdateConfigurationResponseContent>, Error<()>> {
    let Self { client, body } = self;
    let body = body
      .and_then(std::convert::TryInto::<types::DynamicConfig>::try_into)
      .map_err(Error::InvalidRequest)?;
    let url = format!("{}/_plugins/_security/api/securityconfig/config", client.baseurl,);
    let request = client
      .client
      .put(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .json(&body)
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::get_certificates`]
///
///[`Client::get_certificates`]: super::Client::get_certificates
#[derive(Debug, Clone)]
pub struct GetCertificates<'a> {
  client: &'a super::Client,
}

impl<'a> GetCertificates<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self { client }
  }

  ///Sends a `GET` request to `/_plugins/_security/api/ssl/certs`
  pub async fn send(self) -> Result<ResponseValue<types::GetCertificatesResponseContent>, Error<()>> {
    let Self { client } = self;
    let url = format!("{}/_plugins/_security/api/ssl/certs", client.baseurl,);
    let request = client
      .client
      .get(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::reload_http_certificates`]
///
///[`Client::reload_http_certificates`]: super::Client::reload_http_certificates
#[derive(Debug, Clone)]
pub struct ReloadHttpCertificates<'a> {
  client: &'a super::Client,
}

impl<'a> ReloadHttpCertificates<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self { client }
  }

  ///Sends a `PUT` request to
  /// `/_plugins/_security/api/ssl/http/reloadcerts`
  pub async fn send(self) -> Result<ResponseValue<types::ReloadHttpCertificatesResponseContent>, Error<()>> {
    let Self { client } = self;
    let url = format!("{}/_plugins/_security/api/ssl/http/reloadcerts", client.baseurl,);
    let request = client
      .client
      .put(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::reload_transport_certificates`]
///
///[`Client::reload_transport_certificates`]: super::Client::reload_transport_certificates
#[derive(Debug, Clone)]
pub struct ReloadTransportCertificates<'a> {
  client: &'a super::Client,
}

impl<'a> ReloadTransportCertificates<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self { client }
  }

  ///Sends a `PUT` request to
  /// `/_plugins/_security/api/ssl/transport/reloadcerts`
  pub async fn send(self) -> Result<ResponseValue<types::ReloadTransportCertificatesResponseContent>, Error<()>> {
    let Self { client } = self;
    let url = format!("{}/_plugins/_security/api/ssl/transport/reloadcerts", client.baseurl,);
    let request = client
      .client
      .put(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::get_tenants`]
///
///[`Client::get_tenants`]: super::Client::get_tenants
#[derive(Debug, Clone)]
pub struct GetTenants<'a> {
  client: &'a super::Client,
}

impl<'a> GetTenants<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self { client }
  }

  ///Sends a `GET` request to `/_plugins/_security/api/tenants/`
  pub async fn send(self) -> Result<ResponseValue<types::TenantsMap>, Error<()>> {
    let Self { client } = self;
    let url = format!("{}/_plugins/_security/api/tenants/", client.baseurl,);
    let request = client
      .client
      .get(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::patch_tenants`]
///
///[`Client::patch_tenants`]: super::Client::patch_tenants
#[derive(Debug, Clone)]
pub struct PatchTenants<'a> {
  client: &'a super::Client,
  body: Result<types::PatchTenantsInputPayload, String>,
}

impl<'a> PatchTenants<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::PatchTenantsInputPayload>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `PatchTenantsInputPayload` for body failed".to_string());
    self
  }

  ///Sends a `PATCH` request to `/_plugins/_security/api/tenants/`
  pub async fn send(self) -> Result<ResponseValue<types::PatchTenantsResponseContent>, Error<()>> {
    let Self { client, body } = self;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_plugins/_security/api/tenants/", client.baseurl,);
    let request = client
      .client
      .patch(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .json(&body)
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::get_tenant`]
///
///[`Client::get_tenant`]: super::Client::get_tenant
#[derive(Debug, Clone)]
pub struct GetTenant<'a> {
  client: &'a super::Client,
  tenant: Result<String, String>,
}

impl<'a> GetTenant<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      tenant: Err("tenant was not initialized".to_string()),
    }
  }

  pub fn tenant<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.tenant = value
      .try_into()
      .map_err(|_| "conversion to `String` for tenant failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_plugins/_security/api/tenants/{tenant}`
  pub async fn send(self) -> Result<ResponseValue<types::TenantsMap>, Error<()>> {
    let Self { client, tenant } = self;
    let tenant = tenant.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_plugins/_security/api/tenants/{}",
      client.baseurl,
      encode_path(&tenant.to_string()),
    );
    let request = client
      .client
      .get(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::create_tenant`]
///
///[`Client::create_tenant`]: super::Client::create_tenant
#[derive(Debug, Clone)]
pub struct CreateTenant<'a> {
  client: &'a super::Client,
  tenant: Result<String, String>,
  body: Result<types::builder::CreateTenantParams, String>,
}

impl<'a> CreateTenant<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      tenant: Err("tenant was not initialized".to_string()),
      body: Ok(types::builder::CreateTenantParams::default()),
    }
  }

  pub fn tenant<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.tenant = value
      .try_into()
      .map_err(|_| "conversion to `String` for tenant failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CreateTenantParams>, {
    self.body = value
      .try_into()
      .map(From::from)
      .map_err(|_| "conversion to `CreateTenantParams` for body failed".to_string());
    self
  }

  pub fn body_map<F>(mut self, f: F) -> Self
  where
    F: std::ops::FnOnce(types::builder::CreateTenantParams) -> types::builder::CreateTenantParams, {
    self.body = self.body.map(f);
    self
  }

  ///Sends a `PUT` request to `/_plugins/_security/api/tenants/{tenant}`
  pub async fn send(self) -> Result<ResponseValue<types::CreateTenantResponseContent>, Error<()>> {
    let Self { client, tenant, body } = self;
    let tenant = tenant.map_err(Error::InvalidRequest)?;
    let body = body
      .and_then(std::convert::TryInto::<types::CreateTenantParams>::try_into)
      .map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_plugins/_security/api/tenants/{}",
      client.baseurl,
      encode_path(&tenant.to_string()),
    );
    let request = client
      .client
      .put(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .json(&body)
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::delete_tenant`]
///
///[`Client::delete_tenant`]: super::Client::delete_tenant
#[derive(Debug, Clone)]
pub struct DeleteTenant<'a> {
  client: &'a super::Client,
  tenant: Result<String, String>,
}

impl<'a> DeleteTenant<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      tenant: Err("tenant was not initialized".to_string()),
    }
  }

  pub fn tenant<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.tenant = value
      .try_into()
      .map_err(|_| "conversion to `String` for tenant failed".to_string());
    self
  }

  ///Sends a `DELETE` request to
  /// `/_plugins/_security/api/tenants/{tenant}`
  pub async fn send(self) -> Result<ResponseValue<types::DeleteTenantResponseContent>, Error<()>> {
    let Self { client, tenant } = self;
    let tenant = tenant.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_plugins/_security/api/tenants/{}",
      client.baseurl,
      encode_path(&tenant.to_string()),
    );
    let request = client
      .client
      .delete(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::patch_tenant`]
///
///[`Client::patch_tenant`]: super::Client::patch_tenant
#[derive(Debug, Clone)]
pub struct PatchTenant<'a> {
  client: &'a super::Client,
  tenant: Result<String, String>,
  body: Result<types::PatchTenantInputPayload, String>,
}

impl<'a> PatchTenant<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      tenant: Err("tenant was not initialized".to_string()),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn tenant<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.tenant = value
      .try_into()
      .map_err(|_| "conversion to `String` for tenant failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::PatchTenantInputPayload>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `PatchTenantInputPayload` for body failed".to_string());
    self
  }

  ///Sends a `PATCH` request to
  /// `/_plugins/_security/api/tenants/{tenant}`
  pub async fn send(self) -> Result<ResponseValue<types::PatchTenantResponseContent>, Error<()>> {
    let Self { client, tenant, body } = self;
    let tenant = tenant.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_plugins/_security/api/tenants/{}",
      client.baseurl,
      encode_path(&tenant.to_string()),
    );
    let request = client
      .client
      .patch(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .json(&body)
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::security_health`]
///
///[`Client::security_health`]: super::Client::security_health
#[derive(Debug, Clone)]
pub struct SecurityHealth<'a> {
  client: &'a super::Client,
}

impl<'a> SecurityHealth<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self { client }
  }

  ///Sends a `GET` request to `/_plugins/_security/health`
  pub async fn send(self) -> Result<ResponseValue<types::SecurityHealthResponseContent>, Error<()>> {
    let Self { client } = self;
    let url = format!("{}/_plugins/_security/health", client.baseurl,);
    let request = client
      .client
      .get(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::rank_eval_get`]
///
///[`Client::rank_eval_get`]: super::Client::rank_eval_get
#[derive(Debug, Clone)]
pub struct RankEvalGet<'a> {
  client: &'a super::Client,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  search_type: Result<Option<types::SearchType>, String>,
}

impl<'a> RankEvalGet<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      ignore_unavailable: Ok(None),
      search_type: Ok(None),
    }
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn search_type<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SearchType>, {
    self.search_type = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SearchType` for search_type failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_rank_eval`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      allow_no_indices,
      expand_wildcards,
      ignore_unavailable,
      search_type,
    } = self;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let search_type = search_type.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_rank_eval", client.baseurl,);
    let mut query = Vec::with_capacity(4usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &search_type {
      query.push(("search_type", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::rank_eval_post`]
///
///[`Client::rank_eval_post`]: super::Client::rank_eval_post
#[derive(Debug, Clone)]
pub struct RankEvalPost<'a> {
  client: &'a super::Client,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  search_type: Result<Option<types::SearchType>, String>,
  body: Result<types::RankEvalBodyParams, String>,
}

impl<'a> RankEvalPost<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      ignore_unavailable: Ok(None),
      search_type: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn search_type<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SearchType>, {
    self.search_type = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SearchType` for search_type failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::RankEvalBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `RankEvalBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_rank_eval`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      allow_no_indices,
      expand_wildcards,
      ignore_unavailable,
      search_type,
      body,
    } = self;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let search_type = search_type.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_rank_eval", client.baseurl,);
    let mut query = Vec::with_capacity(4usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &search_type {
      query.push(("search_type", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_recovery`]
///
///[`Client::indices_recovery`]: super::Client::indices_recovery
#[derive(Debug, Clone)]
pub struct IndicesRecovery<'a> {
  client: &'a super::Client,
  active_only: Result<Option<bool>, String>,
  detailed: Result<Option<bool>, String>,
}

impl<'a> IndicesRecovery<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      active_only: Ok(None),
      detailed: Ok(None),
    }
  }

  pub fn active_only<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.active_only = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for active_only failed".to_string());
    self
  }

  pub fn detailed<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.detailed = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for detailed failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_recovery`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      active_only,
      detailed,
    } = self;
    let active_only = active_only.map_err(Error::InvalidRequest)?;
    let detailed = detailed.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_recovery", client.baseurl,);
    let mut query = Vec::with_capacity(2usize);
    if let Some(v) = &active_only {
      query.push(("active_only", v.to_string()));
    }
    if let Some(v) = &detailed {
      query.push(("detailed", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_refresh_get`]
///
///[`Client::indices_refresh_get`]: super::Client::indices_refresh_get
#[derive(Debug, Clone)]
pub struct IndicesRefreshGet<'a> {
  client: &'a super::Client,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
}

impl<'a> IndicesRefreshGet<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      ignore_unavailable: Ok(None),
    }
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_refresh`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      allow_no_indices,
      expand_wildcards,
      ignore_unavailable,
    } = self;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_refresh", client.baseurl,);
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_refresh_post`]
///
///[`Client::indices_refresh_post`]: super::Client::indices_refresh_post
#[derive(Debug, Clone)]
pub struct IndicesRefreshPost<'a> {
  client: &'a super::Client,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
}

impl<'a> IndicesRefreshPost<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      ignore_unavailable: Ok(None),
    }
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_refresh`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      allow_no_indices,
      expand_wildcards,
      ignore_unavailable,
    } = self;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_refresh", client.baseurl,);
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    let request = client.client.post(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::reindex`]
///
///[`Client::reindex`]: super::Client::reindex
#[derive(Debug, Clone)]
pub struct Reindex<'a> {
  client: &'a super::Client,
  max_docs: Result<Option<i32>, String>,
  refresh: Result<Option<bool>, String>,
  requests_per_second: Result<Option<i32>, String>,
  scroll: Result<Option<types::ReindexScroll>, String>,
  slices: Result<Option<String>, String>,
  timeout: Result<Option<types::ReindexTimeout>, String>,
  wait_for_active_shards: Result<Option<String>, String>,
  wait_for_completion: Result<Option<bool>, String>,
  body: Result<types::ReindexBodyParams, String>,
}

impl<'a> Reindex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      max_docs: Ok(None),
      refresh: Ok(None),
      requests_per_second: Ok(None),
      scroll: Ok(None),
      slices: Ok(None),
      timeout: Ok(None),
      wait_for_active_shards: Ok(None),
      wait_for_completion: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn max_docs<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.max_docs = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for max_docs failed".to_string());
    self
  }

  pub fn refresh<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.refresh = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for refresh failed".to_string());
    self
  }

  pub fn requests_per_second<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.requests_per_second = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for requests_per_second failed".to_string());
    self
  }

  pub fn scroll<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ReindexScroll>, {
    self.scroll = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ReindexScroll` for scroll failed".to_string());
    self
  }

  pub fn slices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.slices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for slices failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ReindexTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ReindexTimeout` for timeout failed".to_string());
    self
  }

  pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.wait_for_active_shards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for wait_for_active_shards failed".to_string());
    self
  }

  pub fn wait_for_completion<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.wait_for_completion = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for wait_for_completion failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ReindexBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `ReindexBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_reindex`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      max_docs,
      refresh,
      requests_per_second,
      scroll,
      slices,
      timeout,
      wait_for_active_shards,
      wait_for_completion,
      body,
    } = self;
    let max_docs = max_docs.map_err(Error::InvalidRequest)?;
    let refresh = refresh.map_err(Error::InvalidRequest)?;
    let requests_per_second = requests_per_second.map_err(Error::InvalidRequest)?;
    let scroll = scroll.map_err(Error::InvalidRequest)?;
    let slices = slices.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
    let wait_for_completion = wait_for_completion.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_reindex", client.baseurl,);
    let mut query = Vec::with_capacity(8usize);
    if let Some(v) = &max_docs {
      query.push(("max_docs", v.to_string()));
    }
    if let Some(v) = &refresh {
      query.push(("refresh", v.to_string()));
    }
    if let Some(v) = &requests_per_second {
      query.push(("requests_per_second", v.to_string()));
    }
    if let Some(v) = &scroll {
      query.push(("scroll", v.to_string()));
    }
    if let Some(v) = &slices {
      query.push(("slices", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &wait_for_active_shards {
      query.push(("wait_for_active_shards", v.to_string()));
    }
    if let Some(v) = &wait_for_completion {
      query.push(("wait_for_completion", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::reindex_rethrottle`]
///
///[`Client::reindex_rethrottle`]: super::Client::reindex_rethrottle
#[derive(Debug, Clone)]
pub struct ReindexRethrottle<'a> {
  client: &'a super::Client,
  task_id: Result<types::ReindexRethrottleTaskId, String>,
  requests_per_second: Result<i32, String>,
}

impl<'a> ReindexRethrottle<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      task_id: Err("task_id was not initialized".to_string()),
      requests_per_second: Err("requests_per_second was not initialized".to_string()),
    }
  }

  pub fn task_id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ReindexRethrottleTaskId>, {
    self.task_id = value
      .try_into()
      .map_err(|_| "conversion to `ReindexRethrottleTaskId` for task_id failed".to_string());
    self
  }

  pub fn requests_per_second<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.requests_per_second = value
      .try_into()
      .map_err(|_| "conversion to `i32` for requests_per_second failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_reindex/{task_id}/_rethrottle`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      task_id,
      requests_per_second,
    } = self;
    let task_id = task_id.map_err(Error::InvalidRequest)?;
    let requests_per_second = requests_per_second.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_reindex/{}/_rethrottle",
      client.baseurl,
      encode_path(&task_id.to_string()),
    );
    let mut query = Vec::with_capacity(1usize);
    query.push(("requests_per_second", requests_per_second.to_string()));
    let request = client.client.post(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::cluster_remote_info`]
///
///[`Client::cluster_remote_info`]: super::Client::cluster_remote_info
#[derive(Debug, Clone)]
pub struct ClusterRemoteInfo<'a> {
  client: &'a super::Client,
}

impl<'a> ClusterRemoteInfo<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self { client }
  }

  ///Sends a `GET` request to `/_remote/info`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self { client } = self;
    let url = format!("{}/_remote/info", client.baseurl,);
    let request = client.client.get(url).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::remote_store_restore`]
///
///[`Client::remote_store_restore`]: super::Client::remote_store_restore
#[derive(Debug, Clone)]
pub struct RemoteStoreRestore<'a> {
  client: &'a super::Client,
  cluster_manager_timeout: Result<Option<types::RemoteStoreRestoreClusterManagerTimeout>, String>,
  wait_for_completion: Result<Option<bool>, String>,
  body: Result<types::builder::RemoteStoreRestoreBodyParams, String>,
}

impl<'a> RemoteStoreRestore<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      cluster_manager_timeout: Ok(None),
      wait_for_completion: Ok(None),
      body: Ok(types::builder::RemoteStoreRestoreBodyParams::default()),
    }
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::RemoteStoreRestoreClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `RemoteStoreRestoreClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn wait_for_completion<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.wait_for_completion = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for wait_for_completion failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::RemoteStoreRestoreBodyParams>, {
    self.body = value
      .try_into()
      .map(From::from)
      .map_err(|_| "conversion to `RemoteStoreRestoreBodyParams` for body failed".to_string());
    self
  }

  pub fn body_map<F>(mut self, f: F) -> Self
  where
    F: std::ops::FnOnce(types::builder::RemoteStoreRestoreBodyParams) -> types::builder::RemoteStoreRestoreBodyParams,
  {
    self.body = self.body.map(f);
    self
  }

  ///Sends a `POST` request to `/_remotestore/_restore`
  pub async fn send(self) -> Result<ResponseValue<types::RemoteStoreRestoreResponseContent>, Error<()>> {
    let Self {
      client,
      cluster_manager_timeout,
      wait_for_completion,
      body,
    } = self;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let wait_for_completion = wait_for_completion.map_err(Error::InvalidRequest)?;
    let body = body
      .and_then(std::convert::TryInto::<types::RemoteStoreRestoreBodyParams>::try_into)
      .map_err(Error::InvalidRequest)?;
    let url = format!("{}/_remotestore/_restore", client.baseurl,);
    let mut query = Vec::with_capacity(2usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &wait_for_completion {
      query.push(("wait_for_completion", v.to_string()));
    }
    let request = client
      .client
      .post(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .json(&body)
      .query(&query)
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::render_search_template_get`]
///
///[`Client::render_search_template_get`]: super::Client::render_search_template_get
#[derive(Debug, Clone)]
pub struct RenderSearchTemplateGet<'a> {
  client: &'a super::Client,
}

impl<'a> RenderSearchTemplateGet<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self { client }
  }

  ///Sends a `GET` request to `/_render/template`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self { client } = self;
    let url = format!("{}/_render/template", client.baseurl,);
    let request = client.client.get(url).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::render_search_template_post`]
///
///[`Client::render_search_template_post`]: super::Client::render_search_template_post
#[derive(Debug, Clone)]
pub struct RenderSearchTemplatePost<'a> {
  client: &'a super::Client,
  body: Result<types::RenderSearchTemplateBodyParams, String>,
}

impl<'a> RenderSearchTemplatePost<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::RenderSearchTemplateBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `RenderSearchTemplateBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_render/template`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self { client, body } = self;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_render/template", client.baseurl,);
    let request = client.client.post(url).json(&body).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::render_search_template_get_with_id`]
///
///[`Client::render_search_template_get_with_id`]: super::Client::render_search_template_get_with_id
#[derive(Debug, Clone)]
pub struct RenderSearchTemplateGetWithId<'a> {
  client: &'a super::Client,
  id: Result<types::RenderSearchTemplateGetWithIdId, String>,
}

impl<'a> RenderSearchTemplateGetWithId<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      id: Err("id was not initialized".to_string()),
    }
  }

  pub fn id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::RenderSearchTemplateGetWithIdId>, {
    self.id = value
      .try_into()
      .map_err(|_| "conversion to `RenderSearchTemplateGetWithIdId` for id failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_render/template/{id}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self { client, id } = self;
    let id = id.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_render/template/{}", client.baseurl, encode_path(&id.to_string()),);
    let request = client.client.get(url).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::render_search_template_post_with_id`]
///
///[`Client::render_search_template_post_with_id`]: super::Client::render_search_template_post_with_id
#[derive(Debug, Clone)]
pub struct RenderSearchTemplatePostWithId<'a> {
  client: &'a super::Client,
  id: Result<types::RenderSearchTemplatePostWithIdId, String>,
  body: Result<types::RenderSearchTemplateBodyParams, String>,
}

impl<'a> RenderSearchTemplatePostWithId<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      id: Err("id was not initialized".to_string()),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::RenderSearchTemplatePostWithIdId>, {
    self.id = value
      .try_into()
      .map_err(|_| "conversion to `RenderSearchTemplatePostWithIdId` for id failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::RenderSearchTemplateBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `RenderSearchTemplateBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_render/template/{id}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self { client, id, body } = self;
    let id = id.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_render/template/{}", client.baseurl, encode_path(&id.to_string()),);
    let request = client.client.post(url).json(&body).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_resolve_index`]
///
///[`Client::indices_resolve_index`]: super::Client::indices_resolve_index
#[derive(Debug, Clone)]
pub struct IndicesResolveIndex<'a> {
  client: &'a super::Client,
  name: Result<types::IndicesResolveIndexName, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
}

impl<'a> IndicesResolveIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      name: Err("name was not initialized".to_string()),
      expand_wildcards: Ok(None),
    }
  }

  pub fn name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesResolveIndexName>, {
    self.name = value
      .try_into()
      .map_err(|_| "conversion to `IndicesResolveIndexName` for name failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_resolve/index/{name}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      name,
      expand_wildcards,
    } = self;
    let name = name.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_resolve/index/{}", client.baseurl, encode_path(&name.to_string()),);
    let mut query = Vec::with_capacity(1usize);
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::get_script_context`]
///
///[`Client::get_script_context`]: super::Client::get_script_context
#[derive(Debug, Clone)]
pub struct GetScriptContext<'a> {
  client: &'a super::Client,
}

impl<'a> GetScriptContext<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self { client }
  }

  ///Sends a `GET` request to `/_script_context`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self { client } = self;
    let url = format!("{}/_script_context", client.baseurl,);
    let request = client.client.get(url).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::get_script_languages`]
///
///[`Client::get_script_languages`]: super::Client::get_script_languages
#[derive(Debug, Clone)]
pub struct GetScriptLanguages<'a> {
  client: &'a super::Client,
}

impl<'a> GetScriptLanguages<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self { client }
  }

  ///Sends a `GET` request to `/_script_language`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self { client } = self;
    let url = format!("{}/_script_language", client.baseurl,);
    let request = client.client.get(url).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::scripts_painless_execute_get`]
///
///[`Client::scripts_painless_execute_get`]: super::Client::scripts_painless_execute_get
#[derive(Debug, Clone)]
pub struct ScriptsPainlessExecuteGet<'a> {
  client: &'a super::Client,
}

impl<'a> ScriptsPainlessExecuteGet<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self { client }
  }

  ///Sends a `GET` request to `/_scripts/painless/_execute`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self { client } = self;
    let url = format!("{}/_scripts/painless/_execute", client.baseurl,);
    let request = client.client.get(url).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::scripts_painless_execute_post`]
///
///[`Client::scripts_painless_execute_post`]: super::Client::scripts_painless_execute_post
#[derive(Debug, Clone)]
pub struct ScriptsPainlessExecutePost<'a> {
  client: &'a super::Client,
  body: Result<types::ScriptsPainlessExecuteBodyParams, String>,
}

impl<'a> ScriptsPainlessExecutePost<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ScriptsPainlessExecuteBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `ScriptsPainlessExecuteBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_scripts/painless/_execute`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self { client, body } = self;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_scripts/painless/_execute", client.baseurl,);
    let request = client.client.post(url).json(&body).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::get_script`]
///
///[`Client::get_script`]: super::Client::get_script
#[derive(Debug, Clone)]
pub struct GetScript<'a> {
  client: &'a super::Client,
  id: Result<types::GetScriptId, String>,
  cluster_manager_timeout: Result<Option<types::GetScriptClusterManagerTimeout>, String>,
  master_timeout: Result<Option<types::GetScriptMasterTimeout>, String>,
}

impl<'a> GetScript<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      id: Err("id was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      master_timeout: Ok(None),
    }
  }

  pub fn id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::GetScriptId>, {
    self.id = value
      .try_into()
      .map_err(|_| "conversion to `GetScriptId` for id failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::GetScriptClusterManagerTimeout>, {
    self.cluster_manager_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `GetScriptClusterManagerTimeout` for cluster_manager_timeout failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::GetScriptMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `GetScriptMasterTimeout` for master_timeout failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_scripts/{id}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      id,
      cluster_manager_timeout,
      master_timeout,
    } = self;
    let id = id.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_scripts/{}", client.baseurl, encode_path(&id.to_string()),);
    let mut query = Vec::with_capacity(2usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::put_script_put`]
///
///[`Client::put_script_put`]: super::Client::put_script_put
#[derive(Debug, Clone)]
pub struct PutScriptPut<'a> {
  client: &'a super::Client,
  id: Result<types::PutScriptPutId, String>,
  cluster_manager_timeout: Result<Option<types::PutScriptPutClusterManagerTimeout>, String>,
  master_timeout: Result<Option<types::PutScriptPutMasterTimeout>, String>,
  timeout: Result<Option<types::PutScriptPutTimeout>, String>,
  body: Result<types::PutScriptBodyParams, String>,
}

impl<'a> PutScriptPut<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      id: Err("id was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::PutScriptPutId>, {
    self.id = value
      .try_into()
      .map_err(|_| "conversion to `PutScriptPutId` for id failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::PutScriptPutClusterManagerTimeout>, {
    self.cluster_manager_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `PutScriptPutClusterManagerTimeout` for cluster_manager_timeout failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::PutScriptPutMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `PutScriptPutMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::PutScriptPutTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `PutScriptPutTimeout` for timeout failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::PutScriptBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `PutScriptBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `PUT` request to `/_scripts/{id}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      id,
      cluster_manager_timeout,
      master_timeout,
      timeout,
      body,
    } = self;
    let id = id.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_scripts/{}", client.baseurl, encode_path(&id.to_string()),);
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client.client.put(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::put_script_post`]
///
///[`Client::put_script_post`]: super::Client::put_script_post
#[derive(Debug, Clone)]
pub struct PutScriptPost<'a> {
  client: &'a super::Client,
  id: Result<types::PutScriptPostId, String>,
  cluster_manager_timeout: Result<Option<types::PutScriptPostClusterManagerTimeout>, String>,
  master_timeout: Result<Option<types::PutScriptPostMasterTimeout>, String>,
  timeout: Result<Option<types::PutScriptPostTimeout>, String>,
  body: Result<types::PutScriptBodyParams, String>,
}

impl<'a> PutScriptPost<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      id: Err("id was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::PutScriptPostId>, {
    self.id = value
      .try_into()
      .map_err(|_| "conversion to `PutScriptPostId` for id failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::PutScriptPostClusterManagerTimeout>, {
    self.cluster_manager_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `PutScriptPostClusterManagerTimeout` for cluster_manager_timeout failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::PutScriptPostMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `PutScriptPostMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::PutScriptPostTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `PutScriptPostTimeout` for timeout failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::PutScriptBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `PutScriptBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_scripts/{id}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      id,
      cluster_manager_timeout,
      master_timeout,
      timeout,
      body,
    } = self;
    let id = id.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_scripts/{}", client.baseurl, encode_path(&id.to_string()),);
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::delete_script`]
///
///[`Client::delete_script`]: super::Client::delete_script
#[derive(Debug, Clone)]
pub struct DeleteScript<'a> {
  client: &'a super::Client,
  id: Result<types::DeleteScriptId, String>,
  cluster_manager_timeout: Result<Option<types::DeleteScriptClusterManagerTimeout>, String>,
  master_timeout: Result<Option<types::DeleteScriptMasterTimeout>, String>,
  timeout: Result<Option<types::DeleteScriptTimeout>, String>,
}

impl<'a> DeleteScript<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      id: Err("id was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
    }
  }

  pub fn id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::DeleteScriptId>, {
    self.id = value
      .try_into()
      .map_err(|_| "conversion to `DeleteScriptId` for id failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::DeleteScriptClusterManagerTimeout>, {
    self.cluster_manager_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `DeleteScriptClusterManagerTimeout` for cluster_manager_timeout failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::DeleteScriptMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `DeleteScriptMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::DeleteScriptTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `DeleteScriptTimeout` for timeout failed".to_string());
    self
  }

  ///Sends a `DELETE` request to `/_scripts/{id}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      id,
      cluster_manager_timeout,
      master_timeout,
      timeout,
    } = self;
    let id = id.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_scripts/{}", client.baseurl, encode_path(&id.to_string()),);
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client.client.delete(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::put_script_put_with_context`]
///
///[`Client::put_script_put_with_context`]: super::Client::put_script_put_with_context
#[derive(Debug, Clone)]
pub struct PutScriptPutWithContext<'a> {
  client: &'a super::Client,
  id: Result<types::PutScriptPutWithContextId, String>,
  context: Result<types::PutScriptPutWithContextContext, String>,
  cluster_manager_timeout: Result<Option<types::PutScriptPutWithContextClusterManagerTimeout>, String>,
  master_timeout: Result<Option<types::PutScriptPutWithContextMasterTimeout>, String>,
  timeout: Result<Option<types::PutScriptPutWithContextTimeout>, String>,
  body: Result<types::PutScriptBodyParams, String>,
}

impl<'a> PutScriptPutWithContext<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      id: Err("id was not initialized".to_string()),
      context: Err("context was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::PutScriptPutWithContextId>, {
    self.id = value
      .try_into()
      .map_err(|_| "conversion to `PutScriptPutWithContextId` for id failed".to_string());
    self
  }

  pub fn context<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::PutScriptPutWithContextContext>, {
    self.context = value
      .try_into()
      .map_err(|_| "conversion to `PutScriptPutWithContextContext` for context failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::PutScriptPutWithContextClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `PutScriptPutWithContextClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::PutScriptPutWithContextMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `PutScriptPutWithContextMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::PutScriptPutWithContextTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `PutScriptPutWithContextTimeout` for timeout failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::PutScriptBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `PutScriptBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `PUT` request to `/_scripts/{id}/{context}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      id,
      context,
      cluster_manager_timeout,
      master_timeout,
      timeout,
      body,
    } = self;
    let id = id.map_err(Error::InvalidRequest)?;
    let context = context.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_scripts/{}/{}",
      client.baseurl,
      encode_path(&id.to_string()),
      encode_path(&context.to_string()),
    );
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client.client.put(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::put_script_post_with_context`]
///
///[`Client::put_script_post_with_context`]: super::Client::put_script_post_with_context
#[derive(Debug, Clone)]
pub struct PutScriptPostWithContext<'a> {
  client: &'a super::Client,
  id: Result<types::PutScriptPostWithContextId, String>,
  context: Result<types::PutScriptPostWithContextContext, String>,
  cluster_manager_timeout: Result<Option<types::PutScriptPostWithContextClusterManagerTimeout>, String>,
  master_timeout: Result<Option<types::PutScriptPostWithContextMasterTimeout>, String>,
  timeout: Result<Option<types::PutScriptPostWithContextTimeout>, String>,
  body: Result<types::PutScriptBodyParams, String>,
}

impl<'a> PutScriptPostWithContext<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      id: Err("id was not initialized".to_string()),
      context: Err("context was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::PutScriptPostWithContextId>, {
    self.id = value
      .try_into()
      .map_err(|_| "conversion to `PutScriptPostWithContextId` for id failed".to_string());
    self
  }

  pub fn context<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::PutScriptPostWithContextContext>, {
    self.context = value
      .try_into()
      .map_err(|_| "conversion to `PutScriptPostWithContextContext` for context failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::PutScriptPostWithContextClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `PutScriptPostWithContextClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::PutScriptPostWithContextMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `PutScriptPostWithContextMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::PutScriptPostWithContextTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `PutScriptPostWithContextTimeout` for timeout failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::PutScriptBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `PutScriptBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_scripts/{id}/{context}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      id,
      context,
      cluster_manager_timeout,
      master_timeout,
      timeout,
      body,
    } = self;
    let id = id.map_err(Error::InvalidRequest)?;
    let context = context.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_scripts/{}/{}",
      client.baseurl,
      encode_path(&id.to_string()),
      encode_path(&context.to_string()),
    );
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::search_post`]
///
///[`Client::search_post`]: super::Client::search_post
#[derive(Debug, Clone)]
pub struct SearchPost<'a> {
  client: &'a super::Client,
  source: Result<Option<Vec<String>>, String>,
  source_excludes: Result<Option<Vec<String>>, String>,
  source_includes: Result<Option<Vec<String>>, String>,
  allow_no_indices: Result<Option<bool>, String>,
  allow_partial_search_results: Result<Option<bool>, String>,
  analyze_wildcard: Result<Option<bool>, String>,
  analyzer: Result<Option<String>, String>,
  batched_reduce_size: Result<Option<i32>, String>,
  ccs_minimize_roundtrips: Result<Option<bool>, String>,
  default_operator: Result<Option<types::DefaultOperator>, String>,
  df: Result<Option<String>, String>,
  docvalue_fields: Result<Option<Vec<String>>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  explain: Result<Option<bool>, String>,
  from: Result<Option<i32>, String>,
  ignore_throttled: Result<Option<bool>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  lenient: Result<Option<bool>, String>,
  max_concurrent_shard_requests: Result<Option<i32>, String>,
  pre_filter_shard_size: Result<Option<i32>, String>,
  preference: Result<Option<String>, String>,
  q: Result<Option<String>, String>,
  request_cache: Result<Option<bool>, String>,
  rest_total_hits_as_int: Result<Option<bool>, String>,
  routing: Result<Option<Vec<String>>, String>,
  scroll: Result<Option<types::SearchPostScroll>, String>,
  search_type: Result<Option<types::SearchType>, String>,
  seq_no_primary_term: Result<Option<bool>, String>,
  size: Result<Option<i32>, String>,
  sort: Result<Option<Vec<String>>, String>,
  stats: Result<Option<Vec<String>>, String>,
  stored_fields: Result<Option<Vec<String>>, String>,
  suggest_field: Result<Option<String>, String>,
  suggest_mode: Result<Option<types::SuggestMode>, String>,
  suggest_size: Result<Option<i32>, String>,
  suggest_text: Result<Option<String>, String>,
  terminate_after: Result<Option<i32>, String>,
  timeout: Result<Option<types::SearchPostTimeout>, String>,
  track_scores: Result<Option<bool>, String>,
  track_total_hits: Result<Option<bool>, String>,
  typed_keys: Result<Option<bool>, String>,
  version: Result<Option<bool>, String>,
  body: Result<types::builder::SearchBodyParams, String>,
}

impl<'a> SearchPost<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      source: Ok(None),
      source_excludes: Ok(None),
      source_includes: Ok(None),
      allow_no_indices: Ok(None),
      allow_partial_search_results: Ok(None),
      analyze_wildcard: Ok(None),
      analyzer: Ok(None),
      batched_reduce_size: Ok(None),
      ccs_minimize_roundtrips: Ok(None),
      default_operator: Ok(None),
      df: Ok(None),
      docvalue_fields: Ok(None),
      expand_wildcards: Ok(None),
      explain: Ok(None),
      from: Ok(None),
      ignore_throttled: Ok(None),
      ignore_unavailable: Ok(None),
      lenient: Ok(None),
      max_concurrent_shard_requests: Ok(None),
      pre_filter_shard_size: Ok(None),
      preference: Ok(None),
      q: Ok(None),
      request_cache: Ok(None),
      rest_total_hits_as_int: Ok(None),
      routing: Ok(None),
      scroll: Ok(None),
      search_type: Ok(None),
      seq_no_primary_term: Ok(None),
      size: Ok(None),
      sort: Ok(None),
      stats: Ok(None),
      stored_fields: Ok(None),
      suggest_field: Ok(None),
      suggest_mode: Ok(None),
      suggest_size: Ok(None),
      suggest_text: Ok(None),
      terminate_after: Ok(None),
      timeout: Ok(None),
      track_scores: Ok(None),
      track_total_hits: Ok(None),
      typed_keys: Ok(None),
      version: Ok(None),
      body: Ok(types::builder::SearchBodyParams::default()),
    }
  }

  pub fn source<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source failed".to_string());
    self
  }

  pub fn source_excludes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source_excludes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source_excludes failed".to_string());
    self
  }

  pub fn source_includes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source_includes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source_includes failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn allow_partial_search_results<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_partial_search_results = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_partial_search_results failed".to_string());
    self
  }

  pub fn analyze_wildcard<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.analyze_wildcard = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for analyze_wildcard failed".to_string());
    self
  }

  pub fn analyzer<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.analyzer = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for analyzer failed".to_string());
    self
  }

  pub fn batched_reduce_size<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.batched_reduce_size = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for batched_reduce_size failed".to_string());
    self
  }

  pub fn ccs_minimize_roundtrips<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ccs_minimize_roundtrips = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ccs_minimize_roundtrips failed".to_string());
    self
  }

  pub fn default_operator<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::DefaultOperator>, {
    self.default_operator = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `DefaultOperator` for default_operator failed".to_string());
    self
  }

  pub fn df<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.df = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for df failed".to_string());
    self
  }

  pub fn docvalue_fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.docvalue_fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for docvalue_fields failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn explain<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.explain = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for explain failed".to_string());
    self
  }

  pub fn from<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.from = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for from failed".to_string());
    self
  }

  pub fn ignore_throttled<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_throttled = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_throttled failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn lenient<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.lenient = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for lenient failed".to_string());
    self
  }

  pub fn max_concurrent_shard_requests<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.max_concurrent_shard_requests = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for max_concurrent_shard_requests failed".to_string());
    self
  }

  pub fn pre_filter_shard_size<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.pre_filter_shard_size = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for pre_filter_shard_size failed".to_string());
    self
  }

  pub fn preference<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.preference = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for preference failed".to_string());
    self
  }

  pub fn q<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.q = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for q failed".to_string());
    self
  }

  pub fn request_cache<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.request_cache = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for request_cache failed".to_string());
    self
  }

  pub fn rest_total_hits_as_int<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.rest_total_hits_as_int = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for rest_total_hits_as_int failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for routing failed".to_string());
    self
  }

  pub fn scroll<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SearchPostScroll>, {
    self.scroll = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SearchPostScroll` for scroll failed".to_string());
    self
  }

  pub fn search_type<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SearchType>, {
    self.search_type = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SearchType` for search_type failed".to_string());
    self
  }

  pub fn seq_no_primary_term<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.seq_no_primary_term = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for seq_no_primary_term failed".to_string());
    self
  }

  pub fn size<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.size = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for size failed".to_string());
    self
  }

  pub fn sort<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.sort = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for sort failed".to_string());
    self
  }

  pub fn stats<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.stats = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for stats failed".to_string());
    self
  }

  pub fn stored_fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.stored_fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for stored_fields failed".to_string());
    self
  }

  pub fn suggest_field<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.suggest_field = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for suggest_field failed".to_string());
    self
  }

  pub fn suggest_mode<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SuggestMode>, {
    self.suggest_mode = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SuggestMode` for suggest_mode failed".to_string());
    self
  }

  pub fn suggest_size<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.suggest_size = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for suggest_size failed".to_string());
    self
  }

  pub fn suggest_text<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.suggest_text = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for suggest_text failed".to_string());
    self
  }

  pub fn terminate_after<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.terminate_after = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for terminate_after failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SearchPostTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SearchPostTimeout` for timeout failed".to_string());
    self
  }

  pub fn track_scores<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.track_scores = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for track_scores failed".to_string());
    self
  }

  pub fn track_total_hits<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.track_total_hits = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for track_total_hits failed".to_string());
    self
  }

  pub fn typed_keys<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.typed_keys = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for typed_keys failed".to_string());
    self
  }

  pub fn version<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.version = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for version failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SearchBodyParams>, {
    self.body = value
      .try_into()
      .map(From::from)
      .map_err(|_| "conversion to `SearchBodyParams` for body failed".to_string());
    self
  }

  pub fn body_map<F>(mut self, f: F) -> Self
  where
    F: std::ops::FnOnce(types::builder::SearchBodyParams) -> types::builder::SearchBodyParams, {
    self.body = self.body.map(f);
    self
  }

  ///Sends a `POST` request to `/_search`
  pub async fn send<T: DeserializeOwned + std::default::Default>(
    self,
  ) -> Result<ResponseValue<types::SearchPostResponseContent<T>>, Error<()>> {
    let Self {
      client,
      source,
      source_excludes,
      source_includes,
      allow_no_indices,
      allow_partial_search_results,
      analyze_wildcard,
      analyzer,
      batched_reduce_size,
      ccs_minimize_roundtrips,
      default_operator,
      df,
      docvalue_fields,
      expand_wildcards,
      explain,
      from,
      ignore_throttled,
      ignore_unavailable,
      lenient,
      max_concurrent_shard_requests,
      pre_filter_shard_size,
      preference,
      q,
      request_cache,
      rest_total_hits_as_int,
      routing,
      scroll,
      search_type,
      seq_no_primary_term,
      size,
      sort,
      stats,
      stored_fields,
      suggest_field,
      suggest_mode,
      suggest_size,
      suggest_text,
      terminate_after,
      timeout,
      track_scores,
      track_total_hits,
      typed_keys,
      version,
      body,
    } = self;
    let source = source.map_err(Error::InvalidRequest)?;
    let source_excludes = source_excludes.map_err(Error::InvalidRequest)?;
    let source_includes = source_includes.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let allow_partial_search_results = allow_partial_search_results.map_err(Error::InvalidRequest)?;
    let analyze_wildcard = analyze_wildcard.map_err(Error::InvalidRequest)?;
    let analyzer = analyzer.map_err(Error::InvalidRequest)?;
    let batched_reduce_size = batched_reduce_size.map_err(Error::InvalidRequest)?;
    let ccs_minimize_roundtrips = ccs_minimize_roundtrips.map_err(Error::InvalidRequest)?;
    let default_operator = default_operator.map_err(Error::InvalidRequest)?;
    let df = df.map_err(Error::InvalidRequest)?;
    let docvalue_fields = docvalue_fields.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let explain = explain.map_err(Error::InvalidRequest)?;
    let from = from.map_err(Error::InvalidRequest)?;
    let ignore_throttled = ignore_throttled.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let lenient = lenient.map_err(Error::InvalidRequest)?;
    let max_concurrent_shard_requests = max_concurrent_shard_requests.map_err(Error::InvalidRequest)?;
    let pre_filter_shard_size = pre_filter_shard_size.map_err(Error::InvalidRequest)?;
    let preference = preference.map_err(Error::InvalidRequest)?;
    let q = q.map_err(Error::InvalidRequest)?;
    let request_cache = request_cache.map_err(Error::InvalidRequest)?;
    let rest_total_hits_as_int = rest_total_hits_as_int.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let scroll = scroll.map_err(Error::InvalidRequest)?;
    let search_type = search_type.map_err(Error::InvalidRequest)?;
    let seq_no_primary_term = seq_no_primary_term.map_err(Error::InvalidRequest)?;
    let size = size.map_err(Error::InvalidRequest)?;
    let sort = sort.map_err(Error::InvalidRequest)?;
    let stats = stats.map_err(Error::InvalidRequest)?;
    let stored_fields = stored_fields.map_err(Error::InvalidRequest)?;
    let suggest_field = suggest_field.map_err(Error::InvalidRequest)?;
    let suggest_mode = suggest_mode.map_err(Error::InvalidRequest)?;
    let suggest_size = suggest_size.map_err(Error::InvalidRequest)?;
    let suggest_text = suggest_text.map_err(Error::InvalidRequest)?;
    let terminate_after = terminate_after.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let track_scores = track_scores.map_err(Error::InvalidRequest)?;
    let track_total_hits = track_total_hits.map_err(Error::InvalidRequest)?;
    let typed_keys = typed_keys.map_err(Error::InvalidRequest)?;
    let version = version.map_err(Error::InvalidRequest)?;
    let body = body
      .and_then(std::convert::TryInto::<types::SearchBodyParams>::try_into)
      .map_err(Error::InvalidRequest)?;
    let url = format!("{}/_search", client.baseurl,);
    let mut query = Vec::with_capacity(42usize);
    if let Some(v) = &source {
      query.push(("_source", v.join(",")));
    }
    if let Some(v) = &source_excludes {
      query.push(("_source_excludes", v.join(",")));
    }
    if let Some(v) = &source_includes {
      query.push(("_source_includes", v.join(",")));
    }
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &allow_partial_search_results {
      query.push(("allow_partial_search_results", v.to_string()));
    }
    if let Some(v) = &analyze_wildcard {
      query.push(("analyze_wildcard", v.to_string()));
    }
    if let Some(v) = &analyzer {
      query.push(("analyzer", v.to_string()));
    }
    if let Some(v) = &batched_reduce_size {
      query.push(("batched_reduce_size", v.to_string()));
    }
    if let Some(v) = &ccs_minimize_roundtrips {
      query.push(("ccs_minimize_roundtrips", v.to_string()));
    }
    if let Some(v) = &default_operator {
      query.push(("default_operator", v.to_string()));
    }
    if let Some(v) = &df {
      query.push(("df", v.to_string()));
    }
    if let Some(v) = &docvalue_fields {
      query.push(("docvalue_fields", v.join(",")));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &explain {
      query.push(("explain", v.to_string()));
    }
    if let Some(v) = &from {
      query.push(("from", v.to_string()));
    }
    if let Some(v) = &ignore_throttled {
      query.push(("ignore_throttled", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &lenient {
      query.push(("lenient", v.to_string()));
    }
    if let Some(v) = &max_concurrent_shard_requests {
      query.push(("max_concurrent_shard_requests", v.to_string()));
    }
    if let Some(v) = &pre_filter_shard_size {
      query.push(("pre_filter_shard_size", v.to_string()));
    }
    if let Some(v) = &preference {
      query.push(("preference", v.to_string()));
    }
    if let Some(v) = &q {
      query.push(("q", v.to_string()));
    }
    if let Some(v) = &request_cache {
      query.push(("request_cache", v.to_string()));
    }
    if let Some(v) = &rest_total_hits_as_int {
      query.push(("rest_total_hits_as_int", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.join(",")));
    }
    if let Some(v) = &scroll {
      query.push(("scroll", v.to_string()));
    }
    if let Some(v) = &search_type {
      query.push(("search_type", v.to_string()));
    }
    if let Some(v) = &seq_no_primary_term {
      query.push(("seq_no_primary_term", v.to_string()));
    }
    if let Some(v) = &size {
      query.push(("size", v.to_string()));
    }
    if let Some(v) = &sort {
      query.push(("sort", v.join(",")));
    }
    if let Some(v) = &stats {
      query.push(("stats", v.join(",")));
    }
    if let Some(v) = &stored_fields {
      query.push(("stored_fields", v.join(",")));
    }
    if let Some(v) = &suggest_field {
      query.push(("suggest_field", v.to_string()));
    }
    if let Some(v) = &suggest_mode {
      query.push(("suggest_mode", v.to_string()));
    }
    if let Some(v) = &suggest_size {
      query.push(("suggest_size", v.to_string()));
    }
    if let Some(v) = &suggest_text {
      query.push(("suggest_text", v.to_string()));
    }
    if let Some(v) = &terminate_after {
      query.push(("terminate_after", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &track_scores {
      query.push(("track_scores", v.to_string()));
    }
    if let Some(v) = &track_total_hits {
      query.push(("track_total_hits", v.to_string()));
    }
    if let Some(v) = &typed_keys {
      query.push(("typed_keys", v.to_string()));
    }
    if let Some(v) = &version {
      query.push(("version", v.to_string()));
    }
    let request = client
      .client
      .post(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .json(&body)
      .query(&query)
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::delete_pit`]
///
///[`Client::delete_pit`]: super::Client::delete_pit
#[derive(Debug, Clone)]
pub struct DeletePit<'a> {
  client: &'a super::Client,
  body: Result<types::builder::DeletePitBodyParams, String>,
}

impl<'a> DeletePit<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      body: Ok(types::builder::DeletePitBodyParams::default()),
    }
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::DeletePitBodyParams>, {
    self.body = value
      .try_into()
      .map(From::from)
      .map_err(|_| "conversion to `DeletePitBodyParams` for body failed".to_string());
    self
  }

  pub fn body_map<F>(mut self, f: F) -> Self
  where
    F: std::ops::FnOnce(types::builder::DeletePitBodyParams) -> types::builder::DeletePitBodyParams, {
    self.body = self.body.map(f);
    self
  }

  ///Sends a `DELETE` request to `/_search/point_in_time`
  pub async fn send(self) -> Result<ResponseValue<types::DeletePitResponseContent>, Error<()>> {
    let Self { client, body } = self;
    let body = body
      .and_then(std::convert::TryInto::<types::DeletePitBodyParams>::try_into)
      .map_err(Error::InvalidRequest)?;
    let url = format!("{}/_search/point_in_time", client.baseurl,);
    let request = client
      .client
      .delete(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .json(&body)
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::get_all_pits`]
///
///[`Client::get_all_pits`]: super::Client::get_all_pits
#[derive(Debug, Clone)]
pub struct GetAllPits<'a> {
  client: &'a super::Client,
}

impl<'a> GetAllPits<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self { client }
  }

  ///Sends a `GET` request to `/_search/point_in_time/_all`
  pub async fn send(self) -> Result<ResponseValue<types::GetAllPitsResponseContent>, Error<()>> {
    let Self { client } = self;
    let url = format!("{}/_search/point_in_time/_all", client.baseurl,);
    let request = client
      .client
      .get(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::delete_all_pits`]
///
///[`Client::delete_all_pits`]: super::Client::delete_all_pits
#[derive(Debug, Clone)]
pub struct DeleteAllPits<'a> {
  client: &'a super::Client,
}

impl<'a> DeleteAllPits<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self { client }
  }

  ///Sends a `DELETE` request to `/_search/point_in_time/_all`
  pub async fn send(self) -> Result<ResponseValue<types::DeleteAllPitsResponseContent>, Error<()>> {
    let Self { client } = self;
    let url = format!("{}/_search/point_in_time/_all", client.baseurl,);
    let request = client
      .client
      .delete(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::scroll_get`]
///
///[`Client::scroll_get`]: super::Client::scroll_get
#[derive(Debug, Clone)]
pub struct ScrollGet<'a> {
  client: &'a super::Client,
  rest_total_hits_as_int: Result<Option<bool>, String>,
  scroll: Result<Option<types::ScrollGetScroll>, String>,
  scroll_id: Result<Option<String>, String>,
}

impl<'a> ScrollGet<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      rest_total_hits_as_int: Ok(None),
      scroll: Ok(None),
      scroll_id: Ok(None),
    }
  }

  pub fn rest_total_hits_as_int<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.rest_total_hits_as_int = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for rest_total_hits_as_int failed".to_string());
    self
  }

  pub fn scroll<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ScrollGetScroll>, {
    self.scroll = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ScrollGetScroll` for scroll failed".to_string());
    self
  }

  pub fn scroll_id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.scroll_id = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for scroll_id failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_search/scroll`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      rest_total_hits_as_int,
      scroll,
      scroll_id,
    } = self;
    let rest_total_hits_as_int = rest_total_hits_as_int.map_err(Error::InvalidRequest)?;
    let scroll = scroll.map_err(Error::InvalidRequest)?;
    let scroll_id = scroll_id.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_search/scroll", client.baseurl,);
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &rest_total_hits_as_int {
      query.push(("rest_total_hits_as_int", v.to_string()));
    }
    if let Some(v) = &scroll {
      query.push(("scroll", v.to_string()));
    }
    if let Some(v) = &scroll_id {
      query.push(("scroll_id", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::scroll_post`]
///
///[`Client::scroll_post`]: super::Client::scroll_post
#[derive(Debug, Clone)]
pub struct ScrollPost<'a> {
  client: &'a super::Client,
  rest_total_hits_as_int: Result<Option<bool>, String>,
  scroll: Result<Option<types::ScrollPostScroll>, String>,
  scroll_id: Result<Option<String>, String>,
  body: Result<types::ScrollBodyParams, String>,
}

impl<'a> ScrollPost<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      rest_total_hits_as_int: Ok(None),
      scroll: Ok(None),
      scroll_id: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn rest_total_hits_as_int<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.rest_total_hits_as_int = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for rest_total_hits_as_int failed".to_string());
    self
  }

  pub fn scroll<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ScrollPostScroll>, {
    self.scroll = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ScrollPostScroll` for scroll failed".to_string());
    self
  }

  pub fn scroll_id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.scroll_id = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for scroll_id failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ScrollBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `ScrollBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_search/scroll`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      rest_total_hits_as_int,
      scroll,
      scroll_id,
      body,
    } = self;
    let rest_total_hits_as_int = rest_total_hits_as_int.map_err(Error::InvalidRequest)?;
    let scroll = scroll.map_err(Error::InvalidRequest)?;
    let scroll_id = scroll_id.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_search/scroll", client.baseurl,);
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &rest_total_hits_as_int {
      query.push(("rest_total_hits_as_int", v.to_string()));
    }
    if let Some(v) = &scroll {
      query.push(("scroll", v.to_string()));
    }
    if let Some(v) = &scroll_id {
      query.push(("scroll_id", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::clear_scroll`]
///
///[`Client::clear_scroll`]: super::Client::clear_scroll
#[derive(Debug, Clone)]
pub struct ClearScroll<'a> {
  client: &'a super::Client,
  body: Result<types::ClearScrollBodyParams, String>,
}

impl<'a> ClearScroll<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClearScrollBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `ClearScrollBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `DELETE` request to `/_search/scroll`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self { client, body } = self;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_search/scroll", client.baseurl,);
    let request = client.client.delete(url).json(&body).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::scroll_get_with_scroll_id`]
///
///[`Client::scroll_get_with_scroll_id`]: super::Client::scroll_get_with_scroll_id
#[derive(Debug, Clone)]
pub struct ScrollGetWithScrollId<'a> {
  client: &'a super::Client,
  rest_total_hits_as_int: Result<Option<bool>, String>,
  scroll: Result<Option<types::ScrollGetWithScrollIdScroll>, String>,
  scroll_id: Result<Option<String>, String>,
}

impl<'a> ScrollGetWithScrollId<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      rest_total_hits_as_int: Ok(None),
      scroll: Ok(None),
      scroll_id: Ok(None),
    }
  }

  pub fn rest_total_hits_as_int<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.rest_total_hits_as_int = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for rest_total_hits_as_int failed".to_string());
    self
  }

  pub fn scroll<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ScrollGetWithScrollIdScroll>, {
    self.scroll = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ScrollGetWithScrollIdScroll` for scroll failed".to_string());
    self
  }

  pub fn scroll_id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.scroll_id = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for scroll_id failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_search/scroll/{scroll_id}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      rest_total_hits_as_int,
      scroll,
      scroll_id,
    } = self;
    let rest_total_hits_as_int = rest_total_hits_as_int.map_err(Error::InvalidRequest)?;
    let scroll = scroll.map_err(Error::InvalidRequest)?;
    let scroll_id = scroll_id.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_search/scroll/{}",
      client.baseurl,
      encode_path(&scroll_id.clone().unwrap_or(String::from("")).to_string()),
    );
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &rest_total_hits_as_int {
      query.push(("rest_total_hits_as_int", v.to_string()));
    }
    if let Some(v) = &scroll {
      query.push(("scroll", v.to_string()));
    }
    if let Some(v) = &scroll_id {
      query.push(("scroll_id", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::scroll_post_with_scroll_id`]
///
///[`Client::scroll_post_with_scroll_id`]: super::Client::scroll_post_with_scroll_id
#[derive(Debug, Clone)]
pub struct ScrollPostWithScrollId<'a> {
  client: &'a super::Client,
  rest_total_hits_as_int: Result<Option<bool>, String>,
  scroll: Result<Option<types::ScrollPostWithScrollIdScroll>, String>,
  scroll_id: Result<Option<String>, String>,
  body: Result<types::ScrollBodyParams, String>,
}

impl<'a> ScrollPostWithScrollId<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      rest_total_hits_as_int: Ok(None),
      scroll: Ok(None),
      scroll_id: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn rest_total_hits_as_int<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.rest_total_hits_as_int = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for rest_total_hits_as_int failed".to_string());
    self
  }

  pub fn scroll<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ScrollPostWithScrollIdScroll>, {
    self.scroll = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ScrollPostWithScrollIdScroll` for scroll failed".to_string());
    self
  }

  pub fn scroll_id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.scroll_id = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for scroll_id failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ScrollBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `ScrollBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_search/scroll/{scroll_id}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      rest_total_hits_as_int,
      scroll,
      scroll_id,
      body,
    } = self;
    let rest_total_hits_as_int = rest_total_hits_as_int.map_err(Error::InvalidRequest)?;
    let scroll = scroll.map_err(Error::InvalidRequest)?;
    let scroll_id = scroll_id.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_search/scroll/{}",
      client.baseurl,
      encode_path(&scroll_id.clone().unwrap_or(String::from(""))),
    );
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &rest_total_hits_as_int {
      query.push(("rest_total_hits_as_int", v.to_string()));
    }
    if let Some(v) = &scroll {
      query.push(("scroll", v.to_string()));
    }
    if let Some(v) = &scroll_id {
      query.push(("scroll_id", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::clear_scroll_with_scroll_id`]
///
///[`Client::clear_scroll_with_scroll_id`]: super::Client::clear_scroll_with_scroll_id
#[derive(Debug, Clone)]
pub struct ClearScrollWithScrollId<'a> {
  client: &'a super::Client,
  scroll_id: Result<types::ClearScrollWithScrollIdScrollId, String>,
  body: Result<types::ClearScrollBodyParams, String>,
}

impl<'a> ClearScrollWithScrollId<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      scroll_id: Err("scroll_id was not initialized".to_string()),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn scroll_id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClearScrollWithScrollIdScrollId>, {
    self.scroll_id = value
      .try_into()
      .map_err(|_| "conversion to `ClearScrollWithScrollIdScrollId` for scroll_id failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ClearScrollBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `ClearScrollBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `DELETE` request to `/_search/scroll/{scroll_id}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      scroll_id,
      body,
    } = self;
    let scroll_id = scroll_id.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_search/scroll/{}",
      client.baseurl,
      encode_path(&scroll_id.to_string()),
    );
    let request = client.client.delete(url).json(&body).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::search_template_get`]
///
///[`Client::search_template_get`]: super::Client::search_template_get
#[derive(Debug, Clone)]
pub struct SearchTemplateGet<'a> {
  client: &'a super::Client,
  allow_no_indices: Result<Option<bool>, String>,
  ccs_minimize_roundtrips: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  explain: Result<Option<bool>, String>,
  ignore_throttled: Result<Option<bool>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  preference: Result<Option<String>, String>,
  profile: Result<Option<bool>, String>,
  rest_total_hits_as_int: Result<Option<bool>, String>,
  routing: Result<Option<Vec<String>>, String>,
  scroll: Result<Option<types::SearchTemplateGetScroll>, String>,
  search_type: Result<Option<types::SearchTypeMulti>, String>,
  typed_keys: Result<Option<bool>, String>,
}

impl<'a> SearchTemplateGet<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      allow_no_indices: Ok(None),
      ccs_minimize_roundtrips: Ok(None),
      expand_wildcards: Ok(None),
      explain: Ok(None),
      ignore_throttled: Ok(None),
      ignore_unavailable: Ok(None),
      preference: Ok(None),
      profile: Ok(None),
      rest_total_hits_as_int: Ok(None),
      routing: Ok(None),
      scroll: Ok(None),
      search_type: Ok(None),
      typed_keys: Ok(None),
    }
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn ccs_minimize_roundtrips<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ccs_minimize_roundtrips = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ccs_minimize_roundtrips failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn explain<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.explain = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for explain failed".to_string());
    self
  }

  pub fn ignore_throttled<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_throttled = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_throttled failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn preference<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.preference = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for preference failed".to_string());
    self
  }

  pub fn profile<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.profile = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for profile failed".to_string());
    self
  }

  pub fn rest_total_hits_as_int<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.rest_total_hits_as_int = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for rest_total_hits_as_int failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for routing failed".to_string());
    self
  }

  pub fn scroll<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SearchTemplateGetScroll>, {
    self.scroll = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SearchTemplateGetScroll` for scroll failed".to_string());
    self
  }

  pub fn search_type<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SearchTypeMulti>, {
    self.search_type = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SearchTypeMulti` for search_type failed".to_string());
    self
  }

  pub fn typed_keys<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.typed_keys = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for typed_keys failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_search/template`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      allow_no_indices,
      ccs_minimize_roundtrips,
      expand_wildcards,
      explain,
      ignore_throttled,
      ignore_unavailable,
      preference,
      profile,
      rest_total_hits_as_int,
      routing,
      scroll,
      search_type,
      typed_keys,
    } = self;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let ccs_minimize_roundtrips = ccs_minimize_roundtrips.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let explain = explain.map_err(Error::InvalidRequest)?;
    let ignore_throttled = ignore_throttled.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let preference = preference.map_err(Error::InvalidRequest)?;
    let profile = profile.map_err(Error::InvalidRequest)?;
    let rest_total_hits_as_int = rest_total_hits_as_int.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let scroll = scroll.map_err(Error::InvalidRequest)?;
    let search_type = search_type.map_err(Error::InvalidRequest)?;
    let typed_keys = typed_keys.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_search/template", client.baseurl,);
    let mut query = Vec::with_capacity(13usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &ccs_minimize_roundtrips {
      query.push(("ccs_minimize_roundtrips", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &explain {
      query.push(("explain", v.to_string()));
    }
    if let Some(v) = &ignore_throttled {
      query.push(("ignore_throttled", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &preference {
      query.push(("preference", v.to_string()));
    }
    if let Some(v) = &profile {
      query.push(("profile", v.to_string()));
    }
    if let Some(v) = &rest_total_hits_as_int {
      query.push(("rest_total_hits_as_int", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.join(",")));
    }
    if let Some(v) = &scroll {
      query.push(("scroll", v.to_string()));
    }
    if let Some(v) = &search_type {
      query.push(("search_type", v.to_string()));
    }
    if let Some(v) = &typed_keys {
      query.push(("typed_keys", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::search_template_post`]
///
///[`Client::search_template_post`]: super::Client::search_template_post
#[derive(Debug, Clone)]
pub struct SearchTemplatePost<'a> {
  client: &'a super::Client,
  allow_no_indices: Result<Option<bool>, String>,
  ccs_minimize_roundtrips: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  explain: Result<Option<bool>, String>,
  ignore_throttled: Result<Option<bool>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  preference: Result<Option<String>, String>,
  profile: Result<Option<bool>, String>,
  rest_total_hits_as_int: Result<Option<bool>, String>,
  routing: Result<Option<Vec<String>>, String>,
  scroll: Result<Option<types::SearchTemplatePostScroll>, String>,
  search_type: Result<Option<types::SearchTypeMulti>, String>,
  typed_keys: Result<Option<bool>, String>,
  body: Result<types::SearchTemplateBodyParams, String>,
}

impl<'a> SearchTemplatePost<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      allow_no_indices: Ok(None),
      ccs_minimize_roundtrips: Ok(None),
      expand_wildcards: Ok(None),
      explain: Ok(None),
      ignore_throttled: Ok(None),
      ignore_unavailable: Ok(None),
      preference: Ok(None),
      profile: Ok(None),
      rest_total_hits_as_int: Ok(None),
      routing: Ok(None),
      scroll: Ok(None),
      search_type: Ok(None),
      typed_keys: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn ccs_minimize_roundtrips<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ccs_minimize_roundtrips = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ccs_minimize_roundtrips failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn explain<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.explain = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for explain failed".to_string());
    self
  }

  pub fn ignore_throttled<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_throttled = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_throttled failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn preference<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.preference = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for preference failed".to_string());
    self
  }

  pub fn profile<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.profile = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for profile failed".to_string());
    self
  }

  pub fn rest_total_hits_as_int<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.rest_total_hits_as_int = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for rest_total_hits_as_int failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for routing failed".to_string());
    self
  }

  pub fn scroll<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SearchTemplatePostScroll>, {
    self.scroll = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SearchTemplatePostScroll` for scroll failed".to_string());
    self
  }

  pub fn search_type<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SearchTypeMulti>, {
    self.search_type = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SearchTypeMulti` for search_type failed".to_string());
    self
  }

  pub fn typed_keys<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.typed_keys = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for typed_keys failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SearchTemplateBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `SearchTemplateBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_search/template`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      allow_no_indices,
      ccs_minimize_roundtrips,
      expand_wildcards,
      explain,
      ignore_throttled,
      ignore_unavailable,
      preference,
      profile,
      rest_total_hits_as_int,
      routing,
      scroll,
      search_type,
      typed_keys,
      body,
    } = self;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let ccs_minimize_roundtrips = ccs_minimize_roundtrips.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let explain = explain.map_err(Error::InvalidRequest)?;
    let ignore_throttled = ignore_throttled.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let preference = preference.map_err(Error::InvalidRequest)?;
    let profile = profile.map_err(Error::InvalidRequest)?;
    let rest_total_hits_as_int = rest_total_hits_as_int.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let scroll = scroll.map_err(Error::InvalidRequest)?;
    let search_type = search_type.map_err(Error::InvalidRequest)?;
    let typed_keys = typed_keys.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_search/template", client.baseurl,);
    let mut query = Vec::with_capacity(13usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &ccs_minimize_roundtrips {
      query.push(("ccs_minimize_roundtrips", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &explain {
      query.push(("explain", v.to_string()));
    }
    if let Some(v) = &ignore_throttled {
      query.push(("ignore_throttled", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &preference {
      query.push(("preference", v.to_string()));
    }
    if let Some(v) = &profile {
      query.push(("profile", v.to_string()));
    }
    if let Some(v) = &rest_total_hits_as_int {
      query.push(("rest_total_hits_as_int", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.join(",")));
    }
    if let Some(v) = &scroll {
      query.push(("scroll", v.to_string()));
    }
    if let Some(v) = &search_type {
      query.push(("search_type", v.to_string()));
    }
    if let Some(v) = &typed_keys {
      query.push(("typed_keys", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::search_shards_get`]
///
///[`Client::search_shards_get`]: super::Client::search_shards_get
#[derive(Debug, Clone)]
pub struct SearchShardsGet<'a> {
  client: &'a super::Client,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
  preference: Result<Option<String>, String>,
  routing: Result<Option<String>, String>,
}

impl<'a> SearchShardsGet<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      ignore_unavailable: Ok(None),
      local: Ok(None),
      preference: Ok(None),
      routing: Ok(None),
    }
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn preference<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.preference = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for preference failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for routing failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_search_shards`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      allow_no_indices,
      expand_wildcards,
      ignore_unavailable,
      local,
      preference,
      routing,
    } = self;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let preference = preference.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_search_shards", client.baseurl,);
    let mut query = Vec::with_capacity(6usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &preference {
      query.push(("preference", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::search_shards_post`]
///
///[`Client::search_shards_post`]: super::Client::search_shards_post
#[derive(Debug, Clone)]
pub struct SearchShardsPost<'a> {
  client: &'a super::Client,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
  preference: Result<Option<String>, String>,
  routing: Result<Option<String>, String>,
}

impl<'a> SearchShardsPost<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      ignore_unavailable: Ok(None),
      local: Ok(None),
      preference: Ok(None),
      routing: Ok(None),
    }
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn preference<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.preference = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for preference failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for routing failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_search_shards`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      allow_no_indices,
      expand_wildcards,
      ignore_unavailable,
      local,
      preference,
      routing,
    } = self;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let preference = preference.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_search_shards", client.baseurl,);
    let mut query = Vec::with_capacity(6usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &preference {
      query.push(("preference", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.to_string()));
    }
    let request = client.client.post(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_segments`]
///
///[`Client::indices_segments`]: super::Client::indices_segments
#[derive(Debug, Clone)]
pub struct IndicesSegments<'a> {
  client: &'a super::Client,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  verbose: Result<Option<bool>, String>,
}

impl<'a> IndicesSegments<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      ignore_unavailable: Ok(None),
      verbose: Ok(None),
    }
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn verbose<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.verbose = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for verbose failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_segments`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      allow_no_indices,
      expand_wildcards,
      ignore_unavailable,
      verbose,
    } = self;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let verbose = verbose.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_segments", client.baseurl,);
    let mut query = Vec::with_capacity(4usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &verbose {
      query.push(("verbose", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_get_settings`]
///
///[`Client::indices_get_settings`]: super::Client::indices_get_settings
#[derive(Debug, Clone)]
pub struct IndicesGetSettings<'a> {
  client: &'a super::Client,
  allow_no_indices: Result<Option<bool>, String>,
  cluster_manager_timeout: Result<Option<types::IndicesGetSettingsClusterManagerTimeout>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  flat_settings: Result<Option<bool>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  include_defaults: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::IndicesGetSettingsMasterTimeout>, String>,
}

impl<'a> IndicesGetSettings<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      allow_no_indices: Ok(None),
      cluster_manager_timeout: Ok(None),
      expand_wildcards: Ok(None),
      flat_settings: Ok(None),
      ignore_unavailable: Ok(None),
      include_defaults: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
    }
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesGetSettingsClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesGetSettingsClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn flat_settings<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.flat_settings = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn include_defaults<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.include_defaults = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for include_defaults failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesGetSettingsMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesGetSettingsMasterTimeout` for master_timeout failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_settings`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      allow_no_indices,
      cluster_manager_timeout,
      expand_wildcards,
      flat_settings,
      ignore_unavailable,
      include_defaults,
      local,
      master_timeout,
    } = self;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let include_defaults = include_defaults.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_settings", client.baseurl,);
    let mut query = Vec::with_capacity(8usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &flat_settings {
      query.push(("flat_settings", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &include_defaults {
      query.push(("include_defaults", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_put_settings`]
///
///[`Client::indices_put_settings`]: super::Client::indices_put_settings
#[derive(Debug, Clone)]
pub struct IndicesPutSettings<'a> {
  client: &'a super::Client,
  allow_no_indices: Result<Option<bool>, String>,
  cluster_manager_timeout: Result<Option<types::IndicesPutSettingsClusterManagerTimeout>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  flat_settings: Result<Option<bool>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::IndicesPutSettingsMasterTimeout>, String>,
  preserve_existing: Result<Option<bool>, String>,
  timeout: Result<Option<types::IndicesPutSettingsTimeout>, String>,
  body: Result<types::IndicesPutSettingsBodyParams, String>,
}

impl<'a> IndicesPutSettings<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      allow_no_indices: Ok(None),
      cluster_manager_timeout: Ok(None),
      expand_wildcards: Ok(None),
      flat_settings: Ok(None),
      ignore_unavailable: Ok(None),
      master_timeout: Ok(None),
      preserve_existing: Ok(None),
      timeout: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutSettingsClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesPutSettingsClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn flat_settings<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.flat_settings = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutSettingsMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesPutSettingsMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn preserve_existing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.preserve_existing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for preserve_existing failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutSettingsTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesPutSettingsTimeout` for timeout failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutSettingsBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `IndicesPutSettingsBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `PUT` request to `/_settings`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      allow_no_indices,
      cluster_manager_timeout,
      expand_wildcards,
      flat_settings,
      ignore_unavailable,
      master_timeout,
      preserve_existing,
      timeout,
      body,
    } = self;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let preserve_existing = preserve_existing.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_settings", client.baseurl,);
    let mut query = Vec::with_capacity(8usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &flat_settings {
      query.push(("flat_settings", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &preserve_existing {
      query.push(("preserve_existing", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client.client.put(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_get_settings_with_name`]
///
///[`Client::indices_get_settings_with_name`]: super::Client::indices_get_settings_with_name
#[derive(Debug, Clone)]
pub struct IndicesGetSettingsWithName<'a> {
  client: &'a super::Client,
  name: Result<types::IndicesGetSettingsWithNameName, String>,
  allow_no_indices: Result<Option<bool>, String>,
  cluster_manager_timeout: Result<Option<types::IndicesGetSettingsWithNameClusterManagerTimeout>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  flat_settings: Result<Option<bool>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  include_defaults: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::IndicesGetSettingsWithNameMasterTimeout>, String>,
}

impl<'a> IndicesGetSettingsWithName<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      name: Err("name was not initialized".to_string()),
      allow_no_indices: Ok(None),
      cluster_manager_timeout: Ok(None),
      expand_wildcards: Ok(None),
      flat_settings: Ok(None),
      ignore_unavailable: Ok(None),
      include_defaults: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
    }
  }

  pub fn name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesGetSettingsWithNameName>, {
    self.name = value
      .try_into()
      .map_err(|_| "conversion to `IndicesGetSettingsWithNameName` for name failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesGetSettingsWithNameClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesGetSettingsWithNameClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn flat_settings<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.flat_settings = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn include_defaults<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.include_defaults = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for include_defaults failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesGetSettingsWithNameMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesGetSettingsWithNameMasterTimeout` for master_timeout failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_settings/{name}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      name,
      allow_no_indices,
      cluster_manager_timeout,
      expand_wildcards,
      flat_settings,
      ignore_unavailable,
      include_defaults,
      local,
      master_timeout,
    } = self;
    let name = name.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let include_defaults = include_defaults.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_settings/{}", client.baseurl, encode_path(&name.to_string()),);
    let mut query = Vec::with_capacity(8usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &flat_settings {
      query.push(("flat_settings", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &include_defaults {
      query.push(("include_defaults", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_shard_stores`]
///
///[`Client::indices_shard_stores`]: super::Client::indices_shard_stores
#[derive(Debug, Clone)]
pub struct IndicesShardStores<'a> {
  client: &'a super::Client,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  status: Result<Option<Vec<types::StatusMember>>, String>,
}

impl<'a> IndicesShardStores<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      ignore_unavailable: Ok(None),
      status: Ok(None),
    }
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn status<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<types::StatusMember>>, {
    self.status = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < StatusMember >` for status failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_shard_stores`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      allow_no_indices,
      expand_wildcards,
      ignore_unavailable,
      status,
    } = self;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let status = status.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_shard_stores", client.baseurl,);
    let mut query = Vec::with_capacity(4usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    // if let Some(v) = &status {
    //   query.push(("status", v.to_string()));
    // }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::snapshot_get_repository`]
///
///[`Client::snapshot_get_repository`]: super::Client::snapshot_get_repository
#[derive(Debug, Clone)]
pub struct SnapshotGetRepository<'a> {
  client: &'a super::Client,
  cluster_manager_timeout: Result<Option<types::SnapshotGetRepositoryClusterManagerTimeout>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::SnapshotGetRepositoryMasterTimeout>, String>,
}

impl<'a> SnapshotGetRepository<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      cluster_manager_timeout: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
    }
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotGetRepositoryClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `SnapshotGetRepositoryClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotGetRepositoryMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SnapshotGetRepositoryMasterTimeout` for master_timeout failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_snapshot`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      cluster_manager_timeout,
      local,
      master_timeout,
    } = self;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_snapshot", client.baseurl,);
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::snapshot_status`]
///
///[`Client::snapshot_status`]: super::Client::snapshot_status
#[derive(Debug, Clone)]
pub struct SnapshotStatus<'a> {
  client: &'a super::Client,
  cluster_manager_timeout: Result<Option<types::SnapshotStatusClusterManagerTimeout>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::SnapshotStatusMasterTimeout>, String>,
}

impl<'a> SnapshotStatus<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      cluster_manager_timeout: Ok(None),
      ignore_unavailable: Ok(None),
      master_timeout: Ok(None),
    }
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotStatusClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `SnapshotStatusClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotStatusMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SnapshotStatusMasterTimeout` for master_timeout failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_snapshot/_status`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      cluster_manager_timeout,
      ignore_unavailable,
      master_timeout,
    } = self;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_snapshot/_status", client.baseurl,);
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::snapshot_get_repository_with_repository`]
///
///[`Client::snapshot_get_repository_with_repository`]: super::Client::snapshot_get_repository_with_repository
#[derive(Debug, Clone)]
pub struct SnapshotGetRepositoryWithRepository<'a> {
  client: &'a super::Client,
  repository: Result<types::SnapshotGetRepositoryWithRepositoryRepository, String>,
  cluster_manager_timeout: Result<Option<types::SnapshotGetRepositoryWithRepositoryClusterManagerTimeout>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::SnapshotGetRepositoryWithRepositoryMasterTimeout>, String>,
}

impl<'a> SnapshotGetRepositoryWithRepository<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      repository: Err("repository was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
    }
  }

  pub fn repository<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotGetRepositoryWithRepositoryRepository>, {
    self.repository = value
      .try_into()
      .map_err(|_| "conversion to `SnapshotGetRepositoryWithRepositoryRepository` for repository failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotGetRepositoryWithRepositoryClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `SnapshotGetRepositoryWithRepositoryClusterManagerTimeout` for cluster_manager_timeout failed"
        .to_string()
    });
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotGetRepositoryWithRepositoryMasterTimeout>, {
    self.master_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `SnapshotGetRepositoryWithRepositoryMasterTimeout` for master_timeout failed".to_string()
    });
    self
  }

  ///Sends a `GET` request to `/_snapshot/{repository}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      repository,
      cluster_manager_timeout,
      local,
      master_timeout,
    } = self;
    let repository = repository.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_snapshot/{}", client.baseurl, encode_path(&repository.to_string()),);
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::snapshot_create_repository_put`]
///
///[`Client::snapshot_create_repository_put`]: super::Client::snapshot_create_repository_put
#[derive(Debug, Clone)]
pub struct SnapshotCreateRepositoryPut<'a> {
  client: &'a super::Client,
  repository: Result<types::SnapshotCreateRepositoryPutRepository, String>,
  cluster_manager_timeout: Result<Option<types::SnapshotCreateRepositoryPutClusterManagerTimeout>, String>,
  master_timeout: Result<Option<types::SnapshotCreateRepositoryPutMasterTimeout>, String>,
  timeout: Result<Option<types::SnapshotCreateRepositoryPutTimeout>, String>,
  verify: Result<Option<bool>, String>,
  body: Result<types::SnapshotCreateRepositoryBodyParams, String>,
}

impl<'a> SnapshotCreateRepositoryPut<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      repository: Err("repository was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
      verify: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn repository<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotCreateRepositoryPutRepository>, {
    self.repository = value
      .try_into()
      .map_err(|_| "conversion to `SnapshotCreateRepositoryPutRepository` for repository failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotCreateRepositoryPutClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `SnapshotCreateRepositoryPutClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotCreateRepositoryPutMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SnapshotCreateRepositoryPutMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotCreateRepositoryPutTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SnapshotCreateRepositoryPutTimeout` for timeout failed".to_string());
    self
  }

  pub fn verify<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.verify = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for verify failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotCreateRepositoryBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `SnapshotCreateRepositoryBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `PUT` request to `/_snapshot/{repository}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      repository,
      cluster_manager_timeout,
      master_timeout,
      timeout,
      verify,
      body,
    } = self;
    let repository = repository.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let verify = verify.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_snapshot/{}", client.baseurl, encode_path(&repository.to_string()),);
    let mut query = Vec::with_capacity(4usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &verify {
      query.push(("verify", v.to_string()));
    }
    let request = client.client.put(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::snapshot_create_repository_post`]
///
///[`Client::snapshot_create_repository_post`]: super::Client::snapshot_create_repository_post
#[derive(Debug, Clone)]
pub struct SnapshotCreateRepositoryPost<'a> {
  client: &'a super::Client,
  repository: Result<types::SnapshotCreateRepositoryPostRepository, String>,
  cluster_manager_timeout: Result<Option<types::SnapshotCreateRepositoryPostClusterManagerTimeout>, String>,
  master_timeout: Result<Option<types::SnapshotCreateRepositoryPostMasterTimeout>, String>,
  timeout: Result<Option<types::SnapshotCreateRepositoryPostTimeout>, String>,
  verify: Result<Option<bool>, String>,
  body: Result<types::SnapshotCreateRepositoryBodyParams, String>,
}

impl<'a> SnapshotCreateRepositoryPost<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      repository: Err("repository was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
      verify: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn repository<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotCreateRepositoryPostRepository>, {
    self.repository = value
      .try_into()
      .map_err(|_| "conversion to `SnapshotCreateRepositoryPostRepository` for repository failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotCreateRepositoryPostClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `SnapshotCreateRepositoryPostClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotCreateRepositoryPostMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SnapshotCreateRepositoryPostMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotCreateRepositoryPostTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SnapshotCreateRepositoryPostTimeout` for timeout failed".to_string());
    self
  }

  pub fn verify<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.verify = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for verify failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotCreateRepositoryBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `SnapshotCreateRepositoryBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_snapshot/{repository}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      repository,
      cluster_manager_timeout,
      master_timeout,
      timeout,
      verify,
      body,
    } = self;
    let repository = repository.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let verify = verify.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_snapshot/{}", client.baseurl, encode_path(&repository.to_string()),);
    let mut query = Vec::with_capacity(4usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &verify {
      query.push(("verify", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::snapshot_delete_repository`]
///
///[`Client::snapshot_delete_repository`]: super::Client::snapshot_delete_repository
#[derive(Debug, Clone)]
pub struct SnapshotDeleteRepository<'a> {
  client: &'a super::Client,
  repository: Result<types::SnapshotDeleteRepositoryRepository, String>,
  cluster_manager_timeout: Result<Option<types::SnapshotDeleteRepositoryClusterManagerTimeout>, String>,
  master_timeout: Result<Option<types::SnapshotDeleteRepositoryMasterTimeout>, String>,
  timeout: Result<Option<types::SnapshotDeleteRepositoryTimeout>, String>,
}

impl<'a> SnapshotDeleteRepository<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      repository: Err("repository was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
    }
  }

  pub fn repository<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotDeleteRepositoryRepository>, {
    self.repository = value
      .try_into()
      .map_err(|_| "conversion to `SnapshotDeleteRepositoryRepository` for repository failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotDeleteRepositoryClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `SnapshotDeleteRepositoryClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotDeleteRepositoryMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SnapshotDeleteRepositoryMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotDeleteRepositoryTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SnapshotDeleteRepositoryTimeout` for timeout failed".to_string());
    self
  }

  ///Sends a `DELETE` request to `/_snapshot/{repository}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      repository,
      cluster_manager_timeout,
      master_timeout,
      timeout,
    } = self;
    let repository = repository.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_snapshot/{}", client.baseurl, encode_path(&repository.to_string()),);
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client.client.delete(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::snapshot_cleanup_repository`]
///
///[`Client::snapshot_cleanup_repository`]: super::Client::snapshot_cleanup_repository
#[derive(Debug, Clone)]
pub struct SnapshotCleanupRepository<'a> {
  client: &'a super::Client,
  repository: Result<types::SnapshotCleanupRepositoryRepository, String>,
  cluster_manager_timeout: Result<Option<types::SnapshotCleanupRepositoryClusterManagerTimeout>, String>,
  master_timeout: Result<Option<types::SnapshotCleanupRepositoryMasterTimeout>, String>,
  timeout: Result<Option<types::SnapshotCleanupRepositoryTimeout>, String>,
}

impl<'a> SnapshotCleanupRepository<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      repository: Err("repository was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
    }
  }

  pub fn repository<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotCleanupRepositoryRepository>, {
    self.repository = value
      .try_into()
      .map_err(|_| "conversion to `SnapshotCleanupRepositoryRepository` for repository failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotCleanupRepositoryClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `SnapshotCleanupRepositoryClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotCleanupRepositoryMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SnapshotCleanupRepositoryMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotCleanupRepositoryTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SnapshotCleanupRepositoryTimeout` for timeout failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_snapshot/{repository}/_cleanup`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      repository,
      cluster_manager_timeout,
      master_timeout,
      timeout,
    } = self;
    let repository = repository.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_snapshot/{}/_cleanup",
      client.baseurl,
      encode_path(&repository.to_string()),
    );
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client.client.post(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::snapshot_status_with_repository`]
///
///[`Client::snapshot_status_with_repository`]: super::Client::snapshot_status_with_repository
#[derive(Debug, Clone)]
pub struct SnapshotStatusWithRepository<'a> {
  client: &'a super::Client,
  repository: Result<types::SnapshotStatusWithRepositoryRepository, String>,
  cluster_manager_timeout: Result<Option<types::SnapshotStatusWithRepositoryClusterManagerTimeout>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::SnapshotStatusWithRepositoryMasterTimeout>, String>,
}

impl<'a> SnapshotStatusWithRepository<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      repository: Err("repository was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      ignore_unavailable: Ok(None),
      master_timeout: Ok(None),
    }
  }

  pub fn repository<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotStatusWithRepositoryRepository>, {
    self.repository = value
      .try_into()
      .map_err(|_| "conversion to `SnapshotStatusWithRepositoryRepository` for repository failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotStatusWithRepositoryClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `SnapshotStatusWithRepositoryClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotStatusWithRepositoryMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SnapshotStatusWithRepositoryMasterTimeout` for master_timeout failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_snapshot/{repository}/_status`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      repository,
      cluster_manager_timeout,
      ignore_unavailable,
      master_timeout,
    } = self;
    let repository = repository.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_snapshot/{}/_status",
      client.baseurl,
      encode_path(&repository.to_string()),
    );
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::snapshot_verify_repository`]
///
///[`Client::snapshot_verify_repository`]: super::Client::snapshot_verify_repository
#[derive(Debug, Clone)]
pub struct SnapshotVerifyRepository<'a> {
  client: &'a super::Client,
  repository: Result<types::SnapshotVerifyRepositoryRepository, String>,
  cluster_manager_timeout: Result<Option<types::SnapshotVerifyRepositoryClusterManagerTimeout>, String>,
  master_timeout: Result<Option<types::SnapshotVerifyRepositoryMasterTimeout>, String>,
  timeout: Result<Option<types::SnapshotVerifyRepositoryTimeout>, String>,
}

impl<'a> SnapshotVerifyRepository<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      repository: Err("repository was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
    }
  }

  pub fn repository<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotVerifyRepositoryRepository>, {
    self.repository = value
      .try_into()
      .map_err(|_| "conversion to `SnapshotVerifyRepositoryRepository` for repository failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotVerifyRepositoryClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `SnapshotVerifyRepositoryClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotVerifyRepositoryMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SnapshotVerifyRepositoryMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotVerifyRepositoryTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SnapshotVerifyRepositoryTimeout` for timeout failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_snapshot/{repository}/_verify`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      repository,
      cluster_manager_timeout,
      master_timeout,
      timeout,
    } = self;
    let repository = repository.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_snapshot/{}/_verify",
      client.baseurl,
      encode_path(&repository.to_string()),
    );
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client.client.post(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::snapshot_get`]
///
///[`Client::snapshot_get`]: super::Client::snapshot_get
#[derive(Debug, Clone)]
pub struct SnapshotGet<'a> {
  client: &'a super::Client,
  repository: Result<types::SnapshotGetRepository, String>,
  snapshot: Result<types::SnapshotGetSnapshot, String>,
  cluster_manager_timeout: Result<Option<types::SnapshotGetClusterManagerTimeout>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::SnapshotGetMasterTimeout>, String>,
  verbose: Result<Option<bool>, String>,
}

impl<'a> SnapshotGet<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      repository: Err("repository was not initialized".to_string()),
      snapshot: Err("snapshot was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      ignore_unavailable: Ok(None),
      master_timeout: Ok(None),
      verbose: Ok(None),
    }
  }

  pub fn repository<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotGetRepository>, {
    self.repository = value
      .try_into()
      .map_err(|_| "conversion to `SnapshotGetRepository` for repository failed".to_string());
    self
  }

  pub fn snapshot<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotGetSnapshot>, {
    self.snapshot = value
      .try_into()
      .map_err(|_| "conversion to `SnapshotGetSnapshot` for snapshot failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotGetClusterManagerTimeout>, {
    self.cluster_manager_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SnapshotGetClusterManagerTimeout` for cluster_manager_timeout failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotGetMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SnapshotGetMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn verbose<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.verbose = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for verbose failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_snapshot/{repository}/{snapshot}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      repository,
      snapshot,
      cluster_manager_timeout,
      ignore_unavailable,
      master_timeout,
      verbose,
    } = self;
    let repository = repository.map_err(Error::InvalidRequest)?;
    let snapshot = snapshot.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let verbose = verbose.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_snapshot/{}/{}",
      client.baseurl,
      encode_path(&repository.to_string()),
      encode_path(&snapshot.to_string()),
    );
    let mut query = Vec::with_capacity(4usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &verbose {
      query.push(("verbose", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::snapshot_create_put`]
///
///[`Client::snapshot_create_put`]: super::Client::snapshot_create_put
#[derive(Debug, Clone)]
pub struct SnapshotCreatePut<'a> {
  client: &'a super::Client,
  repository: Result<types::SnapshotCreatePutRepository, String>,
  snapshot: Result<types::SnapshotCreatePutSnapshot, String>,
  cluster_manager_timeout: Result<Option<types::SnapshotCreatePutClusterManagerTimeout>, String>,
  master_timeout: Result<Option<types::SnapshotCreatePutMasterTimeout>, String>,
  wait_for_completion: Result<Option<bool>, String>,
  body: Result<types::SnapshotCreateBodyParams, String>,
}

impl<'a> SnapshotCreatePut<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      repository: Err("repository was not initialized".to_string()),
      snapshot: Err("snapshot was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      master_timeout: Ok(None),
      wait_for_completion: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn repository<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotCreatePutRepository>, {
    self.repository = value
      .try_into()
      .map_err(|_| "conversion to `SnapshotCreatePutRepository` for repository failed".to_string());
    self
  }

  pub fn snapshot<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotCreatePutSnapshot>, {
    self.snapshot = value
      .try_into()
      .map_err(|_| "conversion to `SnapshotCreatePutSnapshot` for snapshot failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotCreatePutClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `SnapshotCreatePutClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotCreatePutMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SnapshotCreatePutMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn wait_for_completion<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.wait_for_completion = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for wait_for_completion failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotCreateBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `SnapshotCreateBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `PUT` request to `/_snapshot/{repository}/{snapshot}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      repository,
      snapshot,
      cluster_manager_timeout,
      master_timeout,
      wait_for_completion,
      body,
    } = self;
    let repository = repository.map_err(Error::InvalidRequest)?;
    let snapshot = snapshot.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let wait_for_completion = wait_for_completion.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_snapshot/{}/{}",
      client.baseurl,
      encode_path(&repository.to_string()),
      encode_path(&snapshot.to_string()),
    );
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &wait_for_completion {
      query.push(("wait_for_completion", v.to_string()));
    }
    let request = client.client.put(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::snapshot_create_post`]
///
///[`Client::snapshot_create_post`]: super::Client::snapshot_create_post
#[derive(Debug, Clone)]
pub struct SnapshotCreatePost<'a> {
  client: &'a super::Client,
  repository: Result<types::SnapshotCreatePostRepository, String>,
  snapshot: Result<types::SnapshotCreatePostSnapshot, String>,
  cluster_manager_timeout: Result<Option<types::SnapshotCreatePostClusterManagerTimeout>, String>,
  master_timeout: Result<Option<types::SnapshotCreatePostMasterTimeout>, String>,
  wait_for_completion: Result<Option<bool>, String>,
  body: Result<types::SnapshotCreateBodyParams, String>,
}

impl<'a> SnapshotCreatePost<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      repository: Err("repository was not initialized".to_string()),
      snapshot: Err("snapshot was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      master_timeout: Ok(None),
      wait_for_completion: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn repository<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotCreatePostRepository>, {
    self.repository = value
      .try_into()
      .map_err(|_| "conversion to `SnapshotCreatePostRepository` for repository failed".to_string());
    self
  }

  pub fn snapshot<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotCreatePostSnapshot>, {
    self.snapshot = value
      .try_into()
      .map_err(|_| "conversion to `SnapshotCreatePostSnapshot` for snapshot failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotCreatePostClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `SnapshotCreatePostClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotCreatePostMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SnapshotCreatePostMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn wait_for_completion<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.wait_for_completion = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for wait_for_completion failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotCreateBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `SnapshotCreateBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_snapshot/{repository}/{snapshot}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      repository,
      snapshot,
      cluster_manager_timeout,
      master_timeout,
      wait_for_completion,
      body,
    } = self;
    let repository = repository.map_err(Error::InvalidRequest)?;
    let snapshot = snapshot.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let wait_for_completion = wait_for_completion.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_snapshot/{}/{}",
      client.baseurl,
      encode_path(&repository.to_string()),
      encode_path(&snapshot.to_string()),
    );
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &wait_for_completion {
      query.push(("wait_for_completion", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::snapshot_delete`]
///
///[`Client::snapshot_delete`]: super::Client::snapshot_delete
#[derive(Debug, Clone)]
pub struct SnapshotDelete<'a> {
  client: &'a super::Client,
  repository: Result<types::SnapshotDeleteRepository, String>,
  snapshot: Result<types::SnapshotDeleteSnapshot, String>,
  cluster_manager_timeout: Result<Option<types::SnapshotDeleteClusterManagerTimeout>, String>,
  master_timeout: Result<Option<types::SnapshotDeleteMasterTimeout>, String>,
}

impl<'a> SnapshotDelete<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      repository: Err("repository was not initialized".to_string()),
      snapshot: Err("snapshot was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      master_timeout: Ok(None),
    }
  }

  pub fn repository<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotDeleteRepository>, {
    self.repository = value
      .try_into()
      .map_err(|_| "conversion to `SnapshotDeleteRepository` for repository failed".to_string());
    self
  }

  pub fn snapshot<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotDeleteSnapshot>, {
    self.snapshot = value
      .try_into()
      .map_err(|_| "conversion to `SnapshotDeleteSnapshot` for snapshot failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotDeleteClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `SnapshotDeleteClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotDeleteMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SnapshotDeleteMasterTimeout` for master_timeout failed".to_string());
    self
  }

  ///Sends a `DELETE` request to `/_snapshot/{repository}/{snapshot}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      repository,
      snapshot,
      cluster_manager_timeout,
      master_timeout,
    } = self;
    let repository = repository.map_err(Error::InvalidRequest)?;
    let snapshot = snapshot.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_snapshot/{}/{}",
      client.baseurl,
      encode_path(&repository.to_string()),
      encode_path(&snapshot.to_string()),
    );
    let mut query = Vec::with_capacity(2usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    let request = client.client.delete(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::snapshot_clone`]
///
///[`Client::snapshot_clone`]: super::Client::snapshot_clone
#[derive(Debug, Clone)]
pub struct SnapshotClone<'a> {
  client: &'a super::Client,
  repository: Result<types::SnapshotCloneRepository, String>,
  snapshot: Result<types::SnapshotCloneSnapshot, String>,
  target_snapshot: Result<types::SnapshotCloneTargetSnapshot, String>,
  cluster_manager_timeout: Result<Option<types::SnapshotCloneClusterManagerTimeout>, String>,
  master_timeout: Result<Option<types::SnapshotCloneMasterTimeout>, String>,
  body: Result<types::SnapshotCloneBodyParams, String>,
}

impl<'a> SnapshotClone<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      repository: Err("repository was not initialized".to_string()),
      snapshot: Err("snapshot was not initialized".to_string()),
      target_snapshot: Err("target_snapshot was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      master_timeout: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn repository<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotCloneRepository>, {
    self.repository = value
      .try_into()
      .map_err(|_| "conversion to `SnapshotCloneRepository` for repository failed".to_string());
    self
  }

  pub fn snapshot<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotCloneSnapshot>, {
    self.snapshot = value
      .try_into()
      .map_err(|_| "conversion to `SnapshotCloneSnapshot` for snapshot failed".to_string());
    self
  }

  pub fn target_snapshot<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotCloneTargetSnapshot>, {
    self.target_snapshot = value
      .try_into()
      .map_err(|_| "conversion to `SnapshotCloneTargetSnapshot` for target_snapshot failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotCloneClusterManagerTimeout>, {
    self.cluster_manager_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SnapshotCloneClusterManagerTimeout` for cluster_manager_timeout failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotCloneMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SnapshotCloneMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotCloneBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `SnapshotCloneBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `PUT` request to
  /// `/_snapshot/{repository}/{snapshot}/_clone/{target_snapshot}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      repository,
      snapshot,
      target_snapshot,
      cluster_manager_timeout,
      master_timeout,
      body,
    } = self;
    let repository = repository.map_err(Error::InvalidRequest)?;
    let snapshot = snapshot.map_err(Error::InvalidRequest)?;
    let target_snapshot = target_snapshot.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_snapshot/{}/{}/_clone/{}",
      client.baseurl,
      encode_path(&repository.to_string()),
      encode_path(&snapshot.to_string()),
      encode_path(&target_snapshot.to_string()),
    );
    let mut query = Vec::with_capacity(2usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    let request = client.client.put(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::snapshot_restore`]
///
///[`Client::snapshot_restore`]: super::Client::snapshot_restore
#[derive(Debug, Clone)]
pub struct SnapshotRestore<'a> {
  client: &'a super::Client,
  repository: Result<types::SnapshotRestoreRepository, String>,
  snapshot: Result<types::SnapshotRestoreSnapshot, String>,
  cluster_manager_timeout: Result<Option<types::SnapshotRestoreClusterManagerTimeout>, String>,
  master_timeout: Result<Option<types::SnapshotRestoreMasterTimeout>, String>,
  wait_for_completion: Result<Option<bool>, String>,
  body: Result<types::SnapshotRestoreBodyParams, String>,
}

impl<'a> SnapshotRestore<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      repository: Err("repository was not initialized".to_string()),
      snapshot: Err("snapshot was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      master_timeout: Ok(None),
      wait_for_completion: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn repository<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotRestoreRepository>, {
    self.repository = value
      .try_into()
      .map_err(|_| "conversion to `SnapshotRestoreRepository` for repository failed".to_string());
    self
  }

  pub fn snapshot<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotRestoreSnapshot>, {
    self.snapshot = value
      .try_into()
      .map_err(|_| "conversion to `SnapshotRestoreSnapshot` for snapshot failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotRestoreClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `SnapshotRestoreClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotRestoreMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SnapshotRestoreMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn wait_for_completion<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.wait_for_completion = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for wait_for_completion failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotRestoreBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `SnapshotRestoreBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to
  /// `/_snapshot/{repository}/{snapshot}/_restore`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      repository,
      snapshot,
      cluster_manager_timeout,
      master_timeout,
      wait_for_completion,
      body,
    } = self;
    let repository = repository.map_err(Error::InvalidRequest)?;
    let snapshot = snapshot.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let wait_for_completion = wait_for_completion.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_snapshot/{}/{}/_restore",
      client.baseurl,
      encode_path(&repository.to_string()),
      encode_path(&snapshot.to_string()),
    );
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &wait_for_completion {
      query.push(("wait_for_completion", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::snapshot_status_with_repository_snapshot`]
///
///[`Client::snapshot_status_with_repository_snapshot`]: super::Client::snapshot_status_with_repository_snapshot
#[derive(Debug, Clone)]
pub struct SnapshotStatusWithRepositorySnapshot<'a> {
  client: &'a super::Client,
  repository: Result<types::SnapshotStatusWithRepositorySnapshotRepository, String>,
  snapshot: Result<types::SnapshotStatusWithRepositorySnapshotSnapshot, String>,
  cluster_manager_timeout: Result<Option<types::SnapshotStatusWithRepositorySnapshotClusterManagerTimeout>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::SnapshotStatusWithRepositorySnapshotMasterTimeout>, String>,
}

impl<'a> SnapshotStatusWithRepositorySnapshot<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      repository: Err("repository was not initialized".to_string()),
      snapshot: Err("snapshot was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      ignore_unavailable: Ok(None),
      master_timeout: Ok(None),
    }
  }

  pub fn repository<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotStatusWithRepositorySnapshotRepository>, {
    self.repository = value
      .try_into()
      .map_err(|_| "conversion to `SnapshotStatusWithRepositorySnapshotRepository` for repository failed".to_string());
    self
  }

  pub fn snapshot<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotStatusWithRepositorySnapshotSnapshot>, {
    self.snapshot = value
      .try_into()
      .map_err(|_| "conversion to `SnapshotStatusWithRepositorySnapshotSnapshot` for snapshot failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotStatusWithRepositorySnapshotClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `SnapshotStatusWithRepositorySnapshotClusterManagerTimeout` for cluster_manager_timeout failed"
        .to_string()
    });
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SnapshotStatusWithRepositorySnapshotMasterTimeout>, {
    self.master_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `SnapshotStatusWithRepositorySnapshotMasterTimeout` for master_timeout failed".to_string()
    });
    self
  }

  ///Sends a `GET` request to
  /// `/_snapshot/{repository}/{snapshot}/_status`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      repository,
      snapshot,
      cluster_manager_timeout,
      ignore_unavailable,
      master_timeout,
    } = self;
    let repository = repository.map_err(Error::InvalidRequest)?;
    let snapshot = snapshot.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_snapshot/{}/{}/_status",
      client.baseurl,
      encode_path(&repository.to_string()),
      encode_path(&snapshot.to_string()),
    );
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_stats`]
///
///[`Client::indices_stats`]: super::Client::indices_stats
#[derive(Debug, Clone)]
pub struct IndicesStats<'a> {
  client: &'a super::Client,
  completion_fields: Result<Option<Vec<String>>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  fielddata_fields: Result<Option<Vec<String>>, String>,
  fields: Result<Option<Vec<String>>, String>,
  forbid_closed_indices: Result<Option<bool>, String>,
  groups: Result<Option<Vec<String>>, String>,
  include_segment_file_sizes: Result<Option<bool>, String>,
  include_unloaded_segments: Result<Option<bool>, String>,
  level: Result<Option<types::IndiciesStatLevel>, String>,
}

impl<'a> IndicesStats<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      completion_fields: Ok(None),
      expand_wildcards: Ok(None),
      fielddata_fields: Ok(None),
      fields: Ok(None),
      forbid_closed_indices: Ok(None),
      groups: Ok(None),
      include_segment_file_sizes: Ok(None),
      include_unloaded_segments: Ok(None),
      level: Ok(None),
    }
  }

  pub fn completion_fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.completion_fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for completion_fields failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn fielddata_fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.fielddata_fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for fielddata_fields failed".to_string());
    self
  }

  pub fn fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
    self
  }

  pub fn forbid_closed_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.forbid_closed_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for forbid_closed_indices failed".to_string());
    self
  }

  pub fn groups<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.groups = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for groups failed".to_string());
    self
  }

  pub fn include_segment_file_sizes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.include_segment_file_sizes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for include_segment_file_sizes failed".to_string());
    self
  }

  pub fn include_unloaded_segments<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.include_unloaded_segments = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for include_unloaded_segments failed".to_string());
    self
  }

  pub fn level<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndiciesStatLevel>, {
    self.level = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndiciesStatLevel` for level failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_stats`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      completion_fields,
      expand_wildcards,
      fielddata_fields,
      fields,
      forbid_closed_indices,
      groups,
      include_segment_file_sizes,
      include_unloaded_segments,
      level,
    } = self;
    let completion_fields = completion_fields.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let fielddata_fields = fielddata_fields.map_err(Error::InvalidRequest)?;
    let fields = fields.map_err(Error::InvalidRequest)?;
    let forbid_closed_indices = forbid_closed_indices.map_err(Error::InvalidRequest)?;
    let groups = groups.map_err(Error::InvalidRequest)?;
    let include_segment_file_sizes = include_segment_file_sizes.map_err(Error::InvalidRequest)?;
    let include_unloaded_segments = include_unloaded_segments.map_err(Error::InvalidRequest)?;
    let level = level.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_stats", client.baseurl,);
    let mut query = Vec::with_capacity(9usize);
    if let Some(v) = &completion_fields {
      query.push(("completion_fields", v.join(",")));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &fielddata_fields {
      query.push(("fielddata_fields", v.join(",")));
    }
    if let Some(v) = &fields {
      query.push(("fields", v.join(",")));
    }
    if let Some(v) = &forbid_closed_indices {
      query.push(("forbid_closed_indices", v.to_string()));
    }
    if let Some(v) = &groups {
      query.push(("groups", v.join(",")));
    }
    if let Some(v) = &include_segment_file_sizes {
      query.push(("include_segment_file_sizes", v.to_string()));
    }
    if let Some(v) = &include_unloaded_segments {
      query.push(("include_unloaded_segments", v.to_string()));
    }
    if let Some(v) = &level {
      query.push(("level", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_stats_with_metric`]
///
///[`Client::indices_stats_with_metric`]: super::Client::indices_stats_with_metric
#[derive(Debug, Clone)]
pub struct IndicesStatsWithMetric<'a> {
  client: &'a super::Client,
  metric: Result<types::IndicesStatsWithMetricMetric, String>,
  completion_fields: Result<Option<Vec<String>>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  fielddata_fields: Result<Option<Vec<String>>, String>,
  fields: Result<Option<Vec<String>>, String>,
  forbid_closed_indices: Result<Option<bool>, String>,
  groups: Result<Option<Vec<String>>, String>,
  include_segment_file_sizes: Result<Option<bool>, String>,
  include_unloaded_segments: Result<Option<bool>, String>,
  level: Result<Option<types::IndiciesStatLevel>, String>,
}

impl<'a> IndicesStatsWithMetric<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      metric: Err("metric was not initialized".to_string()),
      completion_fields: Ok(None),
      expand_wildcards: Ok(None),
      fielddata_fields: Ok(None),
      fields: Ok(None),
      forbid_closed_indices: Ok(None),
      groups: Ok(None),
      include_segment_file_sizes: Ok(None),
      include_unloaded_segments: Ok(None),
      level: Ok(None),
    }
  }

  pub fn metric<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesStatsWithMetricMetric>, {
    self.metric = value
      .try_into()
      .map_err(|_| "conversion to `IndicesStatsWithMetricMetric` for metric failed".to_string());
    self
  }

  pub fn completion_fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.completion_fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for completion_fields failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn fielddata_fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.fielddata_fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for fielddata_fields failed".to_string());
    self
  }

  pub fn fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
    self
  }

  pub fn forbid_closed_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.forbid_closed_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for forbid_closed_indices failed".to_string());
    self
  }

  pub fn groups<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.groups = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for groups failed".to_string());
    self
  }

  pub fn include_segment_file_sizes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.include_segment_file_sizes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for include_segment_file_sizes failed".to_string());
    self
  }

  pub fn include_unloaded_segments<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.include_unloaded_segments = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for include_unloaded_segments failed".to_string());
    self
  }

  pub fn level<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndiciesStatLevel>, {
    self.level = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndiciesStatLevel` for level failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_stats/{metric}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      metric,
      completion_fields,
      expand_wildcards,
      fielddata_fields,
      fields,
      forbid_closed_indices,
      groups,
      include_segment_file_sizes,
      include_unloaded_segments,
      level,
    } = self;
    let metric = metric.map_err(Error::InvalidRequest)?;
    let completion_fields = completion_fields.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let fielddata_fields = fielddata_fields.map_err(Error::InvalidRequest)?;
    let fields = fields.map_err(Error::InvalidRequest)?;
    let forbid_closed_indices = forbid_closed_indices.map_err(Error::InvalidRequest)?;
    let groups = groups.map_err(Error::InvalidRequest)?;
    let include_segment_file_sizes = include_segment_file_sizes.map_err(Error::InvalidRequest)?;
    let include_unloaded_segments = include_unloaded_segments.map_err(Error::InvalidRequest)?;
    let level = level.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_stats/{}", client.baseurl, encode_path(&metric.to_string()),);
    let mut query = Vec::with_capacity(9usize);
    if let Some(v) = &completion_fields {
      query.push(("completion_fields", v.join(",")));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &fielddata_fields {
      query.push(("fielddata_fields", v.join(",")));
    }
    if let Some(v) = &fields {
      query.push(("fields", v.join(",")));
    }
    if let Some(v) = &forbid_closed_indices {
      query.push(("forbid_closed_indices", v.to_string()));
    }
    if let Some(v) = &groups {
      query.push(("groups", v.join(",")));
    }
    if let Some(v) = &include_segment_file_sizes {
      query.push(("include_segment_file_sizes", v.to_string()));
    }
    if let Some(v) = &include_unloaded_segments {
      query.push(("include_unloaded_segments", v.to_string()));
    }
    if let Some(v) = &level {
      query.push(("level", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::tasks_list`]
///
///[`Client::tasks_list`]: super::Client::tasks_list
#[derive(Debug, Clone)]
pub struct TasksList<'a> {
  client: &'a super::Client,
  actions: Result<Option<Vec<String>>, String>,
  detailed: Result<Option<bool>, String>,
  group_by: Result<Option<types::GroupBy>, String>,
  nodes: Result<Option<Vec<String>>, String>,
  parent_task_id: Result<Option<String>, String>,
  timeout: Result<Option<types::TasksListTimeout>, String>,
  wait_for_completion: Result<Option<bool>, String>,
}

impl<'a> TasksList<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      actions: Ok(None),
      detailed: Ok(None),
      group_by: Ok(None),
      nodes: Ok(None),
      parent_task_id: Ok(None),
      timeout: Ok(None),
      wait_for_completion: Ok(None),
    }
  }

  pub fn actions<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.actions = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for actions failed".to_string());
    self
  }

  pub fn detailed<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.detailed = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for detailed failed".to_string());
    self
  }

  pub fn group_by<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::GroupBy>, {
    self.group_by = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `GroupBy` for group_by failed".to_string());
    self
  }

  pub fn nodes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.nodes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for nodes failed".to_string());
    self
  }

  pub fn parent_task_id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.parent_task_id = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for parent_task_id failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::TasksListTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `TasksListTimeout` for timeout failed".to_string());
    self
  }

  pub fn wait_for_completion<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.wait_for_completion = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for wait_for_completion failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_tasks`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      actions,
      detailed,
      group_by,
      nodes,
      parent_task_id,
      timeout,
      wait_for_completion,
    } = self;
    let actions = actions.map_err(Error::InvalidRequest)?;
    let detailed = detailed.map_err(Error::InvalidRequest)?;
    let group_by = group_by.map_err(Error::InvalidRequest)?;
    let nodes = nodes.map_err(Error::InvalidRequest)?;
    let parent_task_id = parent_task_id.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let wait_for_completion = wait_for_completion.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_tasks", client.baseurl,);
    let mut query = Vec::with_capacity(7usize);
    if let Some(v) = &actions {
      query.push(("actions", v.join(",")));
    }
    if let Some(v) = &detailed {
      query.push(("detailed", v.to_string()));
    }
    if let Some(v) = &group_by {
      query.push(("group_by", v.to_string()));
    }
    if let Some(v) = &nodes {
      query.push(("nodes", v.join(",")));
    }
    if let Some(v) = &parent_task_id {
      query.push(("parent_task_id", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &wait_for_completion {
      query.push(("wait_for_completion", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::tasks_cancel`]
///
///[`Client::tasks_cancel`]: super::Client::tasks_cancel
#[derive(Debug, Clone)]
pub struct TasksCancel<'a> {
  client: &'a super::Client,
  actions: Result<Option<Vec<String>>, String>,
  nodes: Result<Option<Vec<String>>, String>,
  parent_task_id: Result<Option<String>, String>,
  wait_for_completion: Result<Option<bool>, String>,
}

impl<'a> TasksCancel<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      actions: Ok(None),
      nodes: Ok(None),
      parent_task_id: Ok(None),
      wait_for_completion: Ok(None),
    }
  }

  pub fn actions<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.actions = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for actions failed".to_string());
    self
  }

  pub fn nodes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.nodes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for nodes failed".to_string());
    self
  }

  pub fn parent_task_id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.parent_task_id = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for parent_task_id failed".to_string());
    self
  }

  pub fn wait_for_completion<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.wait_for_completion = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for wait_for_completion failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_tasks/_cancel`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      actions,
      nodes,
      parent_task_id,
      wait_for_completion,
    } = self;
    let actions = actions.map_err(Error::InvalidRequest)?;
    let nodes = nodes.map_err(Error::InvalidRequest)?;
    let parent_task_id = parent_task_id.map_err(Error::InvalidRequest)?;
    let wait_for_completion = wait_for_completion.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_tasks/_cancel", client.baseurl,);
    let mut query = Vec::with_capacity(4usize);
    if let Some(v) = &actions {
      query.push(("actions", v.join(",")));
    }
    if let Some(v) = &nodes {
      query.push(("nodes", v.join(",")));
    }
    if let Some(v) = &parent_task_id {
      query.push(("parent_task_id", v.to_string()));
    }
    if let Some(v) = &wait_for_completion {
      query.push(("wait_for_completion", v.to_string()));
    }
    let request = client.client.post(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::tasks_get`]
///
///[`Client::tasks_get`]: super::Client::tasks_get
#[derive(Debug, Clone)]
pub struct TasksGet<'a> {
  client: &'a super::Client,
  task_id: Result<types::TasksGetTaskId, String>,
  timeout: Result<Option<types::TasksGetTimeout>, String>,
  wait_for_completion: Result<Option<bool>, String>,
}

impl<'a> TasksGet<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      task_id: Err("task_id was not initialized".to_string()),
      timeout: Ok(None),
      wait_for_completion: Ok(None),
    }
  }

  pub fn task_id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::TasksGetTaskId>, {
    self.task_id = value
      .try_into()
      .map_err(|_| "conversion to `TasksGetTaskId` for task_id failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::TasksGetTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `TasksGetTimeout` for timeout failed".to_string());
    self
  }

  pub fn wait_for_completion<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.wait_for_completion = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for wait_for_completion failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_tasks/{task_id}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      task_id,
      timeout,
      wait_for_completion,
    } = self;
    let task_id = task_id.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let wait_for_completion = wait_for_completion.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_tasks/{}", client.baseurl, encode_path(&task_id.to_string()),);
    let mut query = Vec::with_capacity(2usize);
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &wait_for_completion {
      query.push(("wait_for_completion", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::tasks_cancel_with_task_id`]
///
///[`Client::tasks_cancel_with_task_id`]: super::Client::tasks_cancel_with_task_id
#[derive(Debug, Clone)]
pub struct TasksCancelWithTaskId<'a> {
  client: &'a super::Client,
  task_id: Result<types::TasksCancelWithTaskIdTaskId, String>,
  actions: Result<Option<Vec<String>>, String>,
  nodes: Result<Option<Vec<String>>, String>,
  parent_task_id: Result<Option<String>, String>,
  wait_for_completion: Result<Option<bool>, String>,
}

impl<'a> TasksCancelWithTaskId<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      task_id: Err("task_id was not initialized".to_string()),
      actions: Ok(None),
      nodes: Ok(None),
      parent_task_id: Ok(None),
      wait_for_completion: Ok(None),
    }
  }

  pub fn task_id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::TasksCancelWithTaskIdTaskId>, {
    self.task_id = value
      .try_into()
      .map_err(|_| "conversion to `TasksCancelWithTaskIdTaskId` for task_id failed".to_string());
    self
  }

  pub fn actions<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.actions = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for actions failed".to_string());
    self
  }

  pub fn nodes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.nodes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for nodes failed".to_string());
    self
  }

  pub fn parent_task_id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.parent_task_id = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for parent_task_id failed".to_string());
    self
  }

  pub fn wait_for_completion<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.wait_for_completion = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for wait_for_completion failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_tasks/{task_id}/_cancel`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      task_id,
      actions,
      nodes,
      parent_task_id,
      wait_for_completion,
    } = self;
    let task_id = task_id.map_err(Error::InvalidRequest)?;
    let actions = actions.map_err(Error::InvalidRequest)?;
    let nodes = nodes.map_err(Error::InvalidRequest)?;
    let parent_task_id = parent_task_id.map_err(Error::InvalidRequest)?;
    let wait_for_completion = wait_for_completion.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_tasks/{}/_cancel",
      client.baseurl,
      encode_path(&task_id.to_string()),
    );
    let mut query = Vec::with_capacity(4usize);
    if let Some(v) = &actions {
      query.push(("actions", v.join(",")));
    }
    if let Some(v) = &nodes {
      query.push(("nodes", v.join(",")));
    }
    if let Some(v) = &parent_task_id {
      query.push(("parent_task_id", v.to_string()));
    }
    if let Some(v) = &wait_for_completion {
      query.push(("wait_for_completion", v.to_string()));
    }
    let request = client.client.post(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_get_template`]
///
///[`Client::indices_get_template`]: super::Client::indices_get_template
#[derive(Debug, Clone)]
pub struct IndicesGetTemplate<'a> {
  client: &'a super::Client,
  cluster_manager_timeout: Result<Option<types::IndicesGetTemplateClusterManagerTimeout>, String>,
  flat_settings: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::IndicesGetTemplateMasterTimeout>, String>,
}

impl<'a> IndicesGetTemplate<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      cluster_manager_timeout: Ok(None),
      flat_settings: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
    }
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesGetTemplateClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesGetTemplateClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn flat_settings<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.flat_settings = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesGetTemplateMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesGetTemplateMasterTimeout` for master_timeout failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_template`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      cluster_manager_timeout,
      flat_settings,
      local,
      master_timeout,
    } = self;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_template", client.baseurl,);
    let mut query = Vec::with_capacity(4usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &flat_settings {
      query.push(("flat_settings", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_get_template_with_name`]
///
///[`Client::indices_get_template_with_name`]: super::Client::indices_get_template_with_name
#[derive(Debug, Clone)]
pub struct IndicesGetTemplateWithName<'a> {
  client: &'a super::Client,
  name: Result<types::IndicesGetTemplateWithNameName, String>,
  cluster_manager_timeout: Result<Option<types::IndicesGetTemplateWithNameClusterManagerTimeout>, String>,
  flat_settings: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::IndicesGetTemplateWithNameMasterTimeout>, String>,
}

impl<'a> IndicesGetTemplateWithName<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      name: Err("name was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      flat_settings: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
    }
  }

  pub fn name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesGetTemplateWithNameName>, {
    self.name = value
      .try_into()
      .map_err(|_| "conversion to `IndicesGetTemplateWithNameName` for name failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesGetTemplateWithNameClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesGetTemplateWithNameClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn flat_settings<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.flat_settings = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesGetTemplateWithNameMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesGetTemplateWithNameMasterTimeout` for master_timeout failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_template/{name}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      name,
      cluster_manager_timeout,
      flat_settings,
      local,
      master_timeout,
    } = self;
    let name = name.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_template/{}", client.baseurl, encode_path(&name.to_string()),);
    let mut query = Vec::with_capacity(4usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &flat_settings {
      query.push(("flat_settings", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_put_template_put`]
///
///[`Client::indices_put_template_put`]: super::Client::indices_put_template_put
#[derive(Debug, Clone)]
pub struct IndicesPutTemplatePut<'a> {
  client: &'a super::Client,
  name: Result<types::IndicesPutTemplatePutName, String>,
  cluster_manager_timeout: Result<Option<types::IndicesPutTemplatePutClusterManagerTimeout>, String>,
  create: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::IndicesPutTemplatePutMasterTimeout>, String>,
  order: Result<Option<i32>, String>,
  body: Result<types::IndicesPutTemplateBodyParams, String>,
}

impl<'a> IndicesPutTemplatePut<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      name: Err("name was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      create: Ok(None),
      master_timeout: Ok(None),
      order: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutTemplatePutName>, {
    self.name = value
      .try_into()
      .map_err(|_| "conversion to `IndicesPutTemplatePutName` for name failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutTemplatePutClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesPutTemplatePutClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn create<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.create = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for create failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutTemplatePutMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesPutTemplatePutMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn order<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.order = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for order failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutTemplateBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `IndicesPutTemplateBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `PUT` request to `/_template/{name}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      name,
      cluster_manager_timeout,
      create,
      master_timeout,
      order,
      body,
    } = self;
    let name = name.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let create = create.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let order = order.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_template/{}", client.baseurl, encode_path(&name.to_string()),);
    let mut query = Vec::with_capacity(4usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &create {
      query.push(("create", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &order {
      query.push(("order", v.to_string()));
    }
    let request = client.client.put(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_put_template_post`]
///
///[`Client::indices_put_template_post`]: super::Client::indices_put_template_post
#[derive(Debug, Clone)]
pub struct IndicesPutTemplatePost<'a> {
  client: &'a super::Client,
  name: Result<types::IndicesPutTemplatePostName, String>,
  cluster_manager_timeout: Result<Option<types::IndicesPutTemplatePostClusterManagerTimeout>, String>,
  create: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::IndicesPutTemplatePostMasterTimeout>, String>,
  order: Result<Option<i32>, String>,
  body: Result<types::IndicesPutTemplateBodyParams, String>,
}

impl<'a> IndicesPutTemplatePost<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      name: Err("name was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      create: Ok(None),
      master_timeout: Ok(None),
      order: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutTemplatePostName>, {
    self.name = value
      .try_into()
      .map_err(|_| "conversion to `IndicesPutTemplatePostName` for name failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutTemplatePostClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesPutTemplatePostClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn create<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.create = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for create failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutTemplatePostMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesPutTemplatePostMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn order<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.order = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for order failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutTemplateBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `IndicesPutTemplateBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_template/{name}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      name,
      cluster_manager_timeout,
      create,
      master_timeout,
      order,
      body,
    } = self;
    let name = name.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let create = create.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let order = order.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_template/{}", client.baseurl, encode_path(&name.to_string()),);
    let mut query = Vec::with_capacity(4usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &create {
      query.push(("create", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &order {
      query.push(("order", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_delete_template`]
///
///[`Client::indices_delete_template`]: super::Client::indices_delete_template
#[derive(Debug, Clone)]
pub struct IndicesDeleteTemplate<'a> {
  client: &'a super::Client,
  name: Result<types::IndicesDeleteTemplateName, String>,
  cluster_manager_timeout: Result<Option<types::IndicesDeleteTemplateClusterManagerTimeout>, String>,
  master_timeout: Result<Option<types::IndicesDeleteTemplateMasterTimeout>, String>,
  timeout: Result<Option<types::IndicesDeleteTemplateTimeout>, String>,
}

impl<'a> IndicesDeleteTemplate<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      name: Err("name was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
    }
  }

  pub fn name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesDeleteTemplateName>, {
    self.name = value
      .try_into()
      .map_err(|_| "conversion to `IndicesDeleteTemplateName` for name failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesDeleteTemplateClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesDeleteTemplateClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesDeleteTemplateMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesDeleteTemplateMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesDeleteTemplateTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesDeleteTemplateTimeout` for timeout failed".to_string());
    self
  }

  ///Sends a `DELETE` request to `/_template/{name}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      name,
      cluster_manager_timeout,
      master_timeout,
      timeout,
    } = self;
    let name = name.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_template/{}", client.baseurl, encode_path(&name.to_string()),);
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client.client.delete(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_exists_template`]
///
///[`Client::indices_exists_template`]: super::Client::indices_exists_template
#[derive(Debug, Clone)]
pub struct IndicesExistsTemplate<'a> {
  client: &'a super::Client,
  name: Result<types::IndicesExistsTemplateName, String>,
  flat_settings: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::IndicesExistsTemplateMasterTimeout>, String>,
}

impl<'a> IndicesExistsTemplate<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      name: Err("name was not initialized".to_string()),
      flat_settings: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
    }
  }

  pub fn name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesExistsTemplateName>, {
    self.name = value
      .try_into()
      .map_err(|_| "conversion to `IndicesExistsTemplateName` for name failed".to_string());
    self
  }

  pub fn flat_settings<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.flat_settings = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesExistsTemplateMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesExistsTemplateMasterTimeout` for master_timeout failed".to_string());
    self
  }

  ///Sends a `HEAD` request to `/_template/{name}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      name,
      flat_settings,
      local,
      master_timeout,
    } = self;
    let name = name.map_err(Error::InvalidRequest)?;
    let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_template/{}", client.baseurl, encode_path(&name.to_string()),);
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &flat_settings {
      query.push(("flat_settings", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    let request = client.client.head(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::update_by_query_rethrottle`]
///
///[`Client::update_by_query_rethrottle`]: super::Client::update_by_query_rethrottle
#[derive(Debug, Clone)]
pub struct UpdateByQueryRethrottle<'a> {
  client: &'a super::Client,
  task_id: Result<types::UpdateByQueryRethrottleTaskId, String>,
  requests_per_second: Result<i32, String>,
}

impl<'a> UpdateByQueryRethrottle<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      task_id: Err("task_id was not initialized".to_string()),
      requests_per_second: Err("requests_per_second was not initialized".to_string()),
    }
  }

  pub fn task_id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::UpdateByQueryRethrottleTaskId>, {
    self.task_id = value
      .try_into()
      .map_err(|_| "conversion to `UpdateByQueryRethrottleTaskId` for task_id failed".to_string());
    self
  }

  pub fn requests_per_second<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.requests_per_second = value
      .try_into()
      .map_err(|_| "conversion to `i32` for requests_per_second failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_update_by_query/{task_id}/_rethrottle`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      task_id,
      requests_per_second,
    } = self;
    let task_id = task_id.map_err(Error::InvalidRequest)?;
    let requests_per_second = requests_per_second.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/_update_by_query/{}/_rethrottle",
      client.baseurl,
      encode_path(&task_id.to_string()),
    );
    let mut query = Vec::with_capacity(1usize);
    query.push(("requests_per_second", requests_per_second.to_string()));
    let request = client.client.post(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_get_upgrade`]
///
///[`Client::indices_get_upgrade`]: super::Client::indices_get_upgrade
#[derive(Debug, Clone)]
pub struct IndicesGetUpgrade<'a> {
  client: &'a super::Client,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
}

impl<'a> IndicesGetUpgrade<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      ignore_unavailable: Ok(None),
    }
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_upgrade`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      allow_no_indices,
      expand_wildcards,
      ignore_unavailable,
    } = self;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_upgrade", client.baseurl,);
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_upgrade`]
///
///[`Client::indices_upgrade`]: super::Client::indices_upgrade
#[derive(Debug, Clone)]
pub struct IndicesUpgrade<'a> {
  client: &'a super::Client,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  only_ancient_segments: Result<Option<bool>, String>,
  wait_for_completion: Result<Option<bool>, String>,
}

impl<'a> IndicesUpgrade<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      ignore_unavailable: Ok(None),
      only_ancient_segments: Ok(None),
      wait_for_completion: Ok(None),
    }
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn only_ancient_segments<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.only_ancient_segments = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for only_ancient_segments failed".to_string());
    self
  }

  pub fn wait_for_completion<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.wait_for_completion = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for wait_for_completion failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_upgrade`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      allow_no_indices,
      expand_wildcards,
      ignore_unavailable,
      only_ancient_segments,
      wait_for_completion,
    } = self;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let only_ancient_segments = only_ancient_segments.map_err(Error::InvalidRequest)?;
    let wait_for_completion = wait_for_completion.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_upgrade", client.baseurl,);
    let mut query = Vec::with_capacity(5usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &only_ancient_segments {
      query.push(("only_ancient_segments", v.to_string()));
    }
    if let Some(v) = &wait_for_completion {
      query.push(("wait_for_completion", v.to_string()));
    }
    let request = client.client.post(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_validate_query_get`]
///
///[`Client::indices_validate_query_get`]: super::Client::indices_validate_query_get
#[derive(Debug, Clone)]
pub struct IndicesValidateQueryGet<'a> {
  client: &'a super::Client,
  all_shards: Result<Option<bool>, String>,
  allow_no_indices: Result<Option<bool>, String>,
  analyze_wildcard: Result<Option<bool>, String>,
  analyzer: Result<Option<String>, String>,
  default_operator: Result<Option<types::DefaultOperator>, String>,
  df: Result<Option<String>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  explain: Result<Option<bool>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  lenient: Result<Option<bool>, String>,
  q: Result<Option<String>, String>,
  rewrite: Result<Option<bool>, String>,
}

impl<'a> IndicesValidateQueryGet<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      all_shards: Ok(None),
      allow_no_indices: Ok(None),
      analyze_wildcard: Ok(None),
      analyzer: Ok(None),
      default_operator: Ok(None),
      df: Ok(None),
      expand_wildcards: Ok(None),
      explain: Ok(None),
      ignore_unavailable: Ok(None),
      lenient: Ok(None),
      q: Ok(None),
      rewrite: Ok(None),
    }
  }

  pub fn all_shards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.all_shards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for all_shards failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn analyze_wildcard<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.analyze_wildcard = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for analyze_wildcard failed".to_string());
    self
  }

  pub fn analyzer<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.analyzer = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for analyzer failed".to_string());
    self
  }

  pub fn default_operator<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::DefaultOperator>, {
    self.default_operator = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `DefaultOperator` for default_operator failed".to_string());
    self
  }

  pub fn df<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.df = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for df failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn explain<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.explain = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for explain failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn lenient<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.lenient = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for lenient failed".to_string());
    self
  }

  pub fn q<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.q = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for q failed".to_string());
    self
  }

  pub fn rewrite<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.rewrite = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for rewrite failed".to_string());
    self
  }

  ///Sends a `GET` request to `/_validate/query`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      all_shards,
      allow_no_indices,
      analyze_wildcard,
      analyzer,
      default_operator,
      df,
      expand_wildcards,
      explain,
      ignore_unavailable,
      lenient,
      q,
      rewrite,
    } = self;
    let all_shards = all_shards.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let analyze_wildcard = analyze_wildcard.map_err(Error::InvalidRequest)?;
    let analyzer = analyzer.map_err(Error::InvalidRequest)?;
    let default_operator = default_operator.map_err(Error::InvalidRequest)?;
    let df = df.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let explain = explain.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let lenient = lenient.map_err(Error::InvalidRequest)?;
    let q = q.map_err(Error::InvalidRequest)?;
    let rewrite = rewrite.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_validate/query", client.baseurl,);
    let mut query = Vec::with_capacity(12usize);
    if let Some(v) = &all_shards {
      query.push(("all_shards", v.to_string()));
    }
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &analyze_wildcard {
      query.push(("analyze_wildcard", v.to_string()));
    }
    if let Some(v) = &analyzer {
      query.push(("analyzer", v.to_string()));
    }
    if let Some(v) = &default_operator {
      query.push(("default_operator", v.to_string()));
    }
    if let Some(v) = &df {
      query.push(("df", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &explain {
      query.push(("explain", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &lenient {
      query.push(("lenient", v.to_string()));
    }
    if let Some(v) = &q {
      query.push(("q", v.to_string()));
    }
    if let Some(v) = &rewrite {
      query.push(("rewrite", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_validate_query_post`]
///
///[`Client::indices_validate_query_post`]: super::Client::indices_validate_query_post
#[derive(Debug, Clone)]
pub struct IndicesValidateQueryPost<'a> {
  client: &'a super::Client,
  all_shards: Result<Option<bool>, String>,
  allow_no_indices: Result<Option<bool>, String>,
  analyze_wildcard: Result<Option<bool>, String>,
  analyzer: Result<Option<String>, String>,
  default_operator: Result<Option<types::DefaultOperator>, String>,
  df: Result<Option<String>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  explain: Result<Option<bool>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  lenient: Result<Option<bool>, String>,
  q: Result<Option<String>, String>,
  rewrite: Result<Option<bool>, String>,
  body: Result<types::IndicesValidateQueryBodyParams, String>,
}

impl<'a> IndicesValidateQueryPost<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      all_shards: Ok(None),
      allow_no_indices: Ok(None),
      analyze_wildcard: Ok(None),
      analyzer: Ok(None),
      default_operator: Ok(None),
      df: Ok(None),
      expand_wildcards: Ok(None),
      explain: Ok(None),
      ignore_unavailable: Ok(None),
      lenient: Ok(None),
      q: Ok(None),
      rewrite: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn all_shards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.all_shards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for all_shards failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn analyze_wildcard<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.analyze_wildcard = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for analyze_wildcard failed".to_string());
    self
  }

  pub fn analyzer<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.analyzer = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for analyzer failed".to_string());
    self
  }

  pub fn default_operator<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::DefaultOperator>, {
    self.default_operator = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `DefaultOperator` for default_operator failed".to_string());
    self
  }

  pub fn df<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.df = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for df failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn explain<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.explain = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for explain failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn lenient<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.lenient = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for lenient failed".to_string());
    self
  }

  pub fn q<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.q = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for q failed".to_string());
    self
  }

  pub fn rewrite<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.rewrite = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for rewrite failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesValidateQueryBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `IndicesValidateQueryBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/_validate/query`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      all_shards,
      allow_no_indices,
      analyze_wildcard,
      analyzer,
      default_operator,
      df,
      expand_wildcards,
      explain,
      ignore_unavailable,
      lenient,
      q,
      rewrite,
      body,
    } = self;
    let all_shards = all_shards.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let analyze_wildcard = analyze_wildcard.map_err(Error::InvalidRequest)?;
    let analyzer = analyzer.map_err(Error::InvalidRequest)?;
    let default_operator = default_operator.map_err(Error::InvalidRequest)?;
    let df = df.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let explain = explain.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let lenient = lenient.map_err(Error::InvalidRequest)?;
    let q = q.map_err(Error::InvalidRequest)?;
    let rewrite = rewrite.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_validate/query", client.baseurl,);
    let mut query = Vec::with_capacity(12usize);
    if let Some(v) = &all_shards {
      query.push(("all_shards", v.to_string()));
    }
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &analyze_wildcard {
      query.push(("analyze_wildcard", v.to_string()));
    }
    if let Some(v) = &analyzer {
      query.push(("analyzer", v.to_string()));
    }
    if let Some(v) = &default_operator {
      query.push(("default_operator", v.to_string()));
    }
    if let Some(v) = &df {
      query.push(("df", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &explain {
      query.push(("explain", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &lenient {
      query.push(("lenient", v.to_string()));
    }
    if let Some(v) = &q {
      query.push(("q", v.to_string()));
    }
    if let Some(v) = &rewrite {
      query.push(("rewrite", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_rollover`]
///
///[`Client::indices_rollover`]: super::Client::indices_rollover
#[derive(Debug, Clone)]
pub struct IndicesRollover<'a> {
  client: &'a super::Client,
  alias: Result<types::IndicesRolloverAlias, String>,
  cluster_manager_timeout: Result<Option<types::IndicesRolloverClusterManagerTimeout>, String>,
  dry_run: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::IndicesRolloverMasterTimeout>, String>,
  timeout: Result<Option<types::IndicesRolloverTimeout>, String>,
  wait_for_active_shards: Result<Option<String>, String>,
  body: Result<types::IndicesRolloverBodyParams, String>,
}

impl<'a> IndicesRollover<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      alias: Err("alias was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      dry_run: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
      wait_for_active_shards: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn alias<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesRolloverAlias>, {
    self.alias = value
      .try_into()
      .map_err(|_| "conversion to `IndicesRolloverAlias` for alias failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesRolloverClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesRolloverClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn dry_run<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.dry_run = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for dry_run failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesRolloverMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesRolloverMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesRolloverTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesRolloverTimeout` for timeout failed".to_string());
    self
  }

  pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.wait_for_active_shards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for wait_for_active_shards failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesRolloverBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `IndicesRolloverBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/{alias}/_rollover`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      alias,
      cluster_manager_timeout,
      dry_run,
      master_timeout,
      timeout,
      wait_for_active_shards,
      body,
    } = self;
    let alias = alias.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let dry_run = dry_run.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}/_rollover", client.baseurl, encode_path(&alias.to_string()),);
    let mut query = Vec::with_capacity(5usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &dry_run {
      query.push(("dry_run", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &wait_for_active_shards {
      query.push(("wait_for_active_shards", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_rollover_with_new_index`]
///
///[`Client::indices_rollover_with_new_index`]: super::Client::indices_rollover_with_new_index
#[derive(Debug, Clone)]
pub struct IndicesRolloverWithNewIndex<'a> {
  client: &'a super::Client,
  alias: Result<types::IndicesRolloverWithNewIndexAlias, String>,
  new_index: Result<types::IndicesRolloverWithNewIndexNewIndex, String>,
  cluster_manager_timeout: Result<Option<types::IndicesRolloverWithNewIndexClusterManagerTimeout>, String>,
  dry_run: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::IndicesRolloverWithNewIndexMasterTimeout>, String>,
  timeout: Result<Option<types::IndicesRolloverWithNewIndexTimeout>, String>,
  wait_for_active_shards: Result<Option<String>, String>,
  body: Result<types::IndicesRolloverBodyParams, String>,
}

impl<'a> IndicesRolloverWithNewIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      alias: Err("alias was not initialized".to_string()),
      new_index: Err("new_index was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      dry_run: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
      wait_for_active_shards: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn alias<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesRolloverWithNewIndexAlias>, {
    self.alias = value
      .try_into()
      .map_err(|_| "conversion to `IndicesRolloverWithNewIndexAlias` for alias failed".to_string());
    self
  }

  pub fn new_index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesRolloverWithNewIndexNewIndex>, {
    self.new_index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesRolloverWithNewIndexNewIndex` for new_index failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesRolloverWithNewIndexClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesRolloverWithNewIndexClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn dry_run<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.dry_run = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for dry_run failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesRolloverWithNewIndexMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesRolloverWithNewIndexMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesRolloverWithNewIndexTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesRolloverWithNewIndexTimeout` for timeout failed".to_string());
    self
  }

  pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.wait_for_active_shards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for wait_for_active_shards failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesRolloverBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `IndicesRolloverBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/{alias}/_rollover/{new_index}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      alias,
      new_index,
      cluster_manager_timeout,
      dry_run,
      master_timeout,
      timeout,
      wait_for_active_shards,
      body,
    } = self;
    let alias = alias.map_err(Error::InvalidRequest)?;
    let new_index = new_index.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let dry_run = dry_run.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_rollover/{}",
      client.baseurl,
      encode_path(&alias.to_string()),
      encode_path(&new_index.to_string()),
    );
    let mut query = Vec::with_capacity(5usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &dry_run {
      query.push(("dry_run", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &wait_for_active_shards {
      query.push(("wait_for_active_shards", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_get`]
///
///[`Client::indices_get`]: super::Client::indices_get
#[derive(Debug, Clone)]
pub struct IndicesGet<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesGetIndex, String>,
  allow_no_indices: Result<Option<bool>, String>,
  cluster_manager_timeout: Result<Option<types::IndicesGetClusterManagerTimeout>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  flat_settings: Result<Option<bool>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  include_defaults: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::IndicesGetMasterTimeout>, String>,
}

impl<'a> IndicesGet<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      allow_no_indices: Ok(None),
      cluster_manager_timeout: Ok(None),
      expand_wildcards: Ok(None),
      flat_settings: Ok(None),
      ignore_unavailable: Ok(None),
      include_defaults: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesGetIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesGetIndex` for index failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesGetClusterManagerTimeout>, {
    self.cluster_manager_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesGetClusterManagerTimeout` for cluster_manager_timeout failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn flat_settings<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.flat_settings = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn include_defaults<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.include_defaults = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for include_defaults failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesGetMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesGetMasterTimeout` for master_timeout failed".to_string());
    self
  }

  ///Sends a `GET` request to `/{index}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      allow_no_indices,
      cluster_manager_timeout,
      expand_wildcards,
      flat_settings,
      ignore_unavailable,
      include_defaults,
      local,
      master_timeout,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let include_defaults = include_defaults.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(8usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &flat_settings {
      query.push(("flat_settings", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &include_defaults {
      query.push(("include_defaults", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_create`]
///
///[`Client::indices_create`]: super::Client::indices_create
#[derive(Debug, Clone)]
pub struct IndicesCreate<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesCreateIndex, String>,
  cluster_manager_timeout: Result<Option<types::IndicesCreateClusterManagerTimeout>, String>,
  master_timeout: Result<Option<types::IndicesCreateMasterTimeout>, String>,
  timeout: Result<Option<types::IndicesCreateTimeout>, String>,
  wait_for_active_shards: Result<Option<String>, String>,
  body: Result<types::builder::IndicesCreateBodyParams, String>,
}

impl<'a> IndicesCreate<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
      wait_for_active_shards: Ok(None),
      body: Ok(types::builder::IndicesCreateBodyParams::default()),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesCreateIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesCreateIndex` for index failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesCreateClusterManagerTimeout>, {
    self.cluster_manager_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesCreateClusterManagerTimeout` for cluster_manager_timeout failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesCreateMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesCreateMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesCreateTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesCreateTimeout` for timeout failed".to_string());
    self
  }

  pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.wait_for_active_shards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for wait_for_active_shards failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesCreateBodyParams>, {
    self.body = value
      .try_into()
      .map(From::from)
      .map_err(|_| "conversion to `IndicesCreateBodyParams` for body failed".to_string());
    self
  }

  pub fn body_map<F>(mut self, f: F) -> Self
  where
    F: std::ops::FnOnce(types::builder::IndicesCreateBodyParams) -> types::builder::IndicesCreateBodyParams, {
    self.body = self.body.map(f);
    self
  }

  ///Sends a `PUT` request to `/{index}`
  pub async fn send(self) -> Result<ResponseValue<types::IndicesCreateResponseContent>, Error<()>> {
    let Self {
      client,
      index,
      cluster_manager_timeout,
      master_timeout,
      timeout,
      wait_for_active_shards,
      body,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
    let body = body
      .and_then(std::convert::TryInto::<types::IndicesCreateBodyParams>::try_into)
      .map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(4usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &wait_for_active_shards {
      query.push(("wait_for_active_shards", v.to_string()));
    }
    let request = client
      .client
      .put(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .json(&body)
      .query(&query)
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_delete`]
///
///[`Client::indices_delete`]: super::Client::indices_delete
#[derive(Debug, Clone)]
pub struct IndicesDelete<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesDeleteIndex, String>,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::IndicesDeleteMasterTimeout>, String>,
  timeout: Result<Option<types::IndicesDeleteTimeout>, String>,
}

impl<'a> IndicesDelete<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      ignore_unavailable: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesDeleteIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesDeleteIndex` for index failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesDeleteMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesDeleteMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesDeleteTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesDeleteTimeout` for timeout failed".to_string());
    self
  }

  ///Sends a `DELETE` request to `/{index}`
  pub async fn send(self) -> Result<ResponseValue<types::IndicesDeleteResponseContent>, Error<()>> {
    let Self {
      client,
      index,
      allow_no_indices,
      expand_wildcards,
      ignore_unavailable,
      master_timeout,
      timeout,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(5usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client
      .client
      .delete(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .query(&query)
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_exists`]
///
///[`Client::indices_exists`]: super::Client::indices_exists
#[derive(Debug, Clone)]
pub struct IndicesExists<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesExistsIndex, String>,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  flat_settings: Result<Option<bool>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  include_defaults: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
}

impl<'a> IndicesExists<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      flat_settings: Ok(None),
      ignore_unavailable: Ok(None),
      include_defaults: Ok(None),
      local: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesExistsIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesExistsIndex` for index failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn flat_settings<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.flat_settings = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn include_defaults<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.include_defaults = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for include_defaults failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  ///Sends a `HEAD` request to `/{index}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      allow_no_indices,
      expand_wildcards,
      flat_settings,
      ignore_unavailable,
      include_defaults,
      local,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let include_defaults = include_defaults.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(6usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &flat_settings {
      query.push(("flat_settings", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &include_defaults {
      query.push(("include_defaults", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    let request = client.client.head(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_get_alias_with_index`]
///
///[`Client::indices_get_alias_with_index`]: super::Client::indices_get_alias_with_index
#[derive(Debug, Clone)]
pub struct IndicesGetAliasWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesGetAliasWithIndexIndex, String>,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
}

impl<'a> IndicesGetAliasWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      ignore_unavailable: Ok(None),
      local: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesGetAliasWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesGetAliasWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  ///Sends a `GET` request to `/{index}/_alias`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      allow_no_indices,
      expand_wildcards,
      ignore_unavailable,
      local,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}/_alias", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(4usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_get_alias_with_index_name`]
///
///[`Client::indices_get_alias_with_index_name`]: super::Client::indices_get_alias_with_index_name
#[derive(Debug, Clone)]
pub struct IndicesGetAliasWithIndexName<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesGetAliasWithIndexNameIndex, String>,
  name: Result<types::IndicesGetAliasWithIndexNameName, String>,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
}

impl<'a> IndicesGetAliasWithIndexName<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      name: Err("name was not initialized".to_string()),
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      ignore_unavailable: Ok(None),
      local: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesGetAliasWithIndexNameIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesGetAliasWithIndexNameIndex` for index failed".to_string());
    self
  }

  pub fn name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesGetAliasWithIndexNameName>, {
    self.name = value
      .try_into()
      .map_err(|_| "conversion to `IndicesGetAliasWithIndexNameName` for name failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  ///Sends a `GET` request to `/{index}/_alias/{name}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      name,
      allow_no_indices,
      expand_wildcards,
      ignore_unavailable,
      local,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let name = name.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_alias/{}",
      client.baseurl,
      encode_path(&index.to_string()),
      encode_path(&name.to_string()),
    );
    let mut query = Vec::with_capacity(4usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_put_alias_put`]
///
///[`Client::indices_put_alias_put`]: super::Client::indices_put_alias_put
#[derive(Debug, Clone)]
pub struct IndicesPutAliasPut<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesPutAliasPutIndex, String>,
  name: Result<types::IndicesPutAliasPutName, String>,
  cluster_manager_timeout: Result<Option<types::IndicesPutAliasPutClusterManagerTimeout>, String>,
  master_timeout: Result<Option<types::IndicesPutAliasPutMasterTimeout>, String>,
  timeout: Result<Option<types::IndicesPutAliasPutTimeout>, String>,
  body: Result<types::IndicesPutAliasBodyParams, String>,
}

impl<'a> IndicesPutAliasPut<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      name: Err("name was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutAliasPutIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesPutAliasPutIndex` for index failed".to_string());
    self
  }

  pub fn name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutAliasPutName>, {
    self.name = value
      .try_into()
      .map_err(|_| "conversion to `IndicesPutAliasPutName` for name failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutAliasPutClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesPutAliasPutClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutAliasPutMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesPutAliasPutMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutAliasPutTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesPutAliasPutTimeout` for timeout failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutAliasBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `IndicesPutAliasBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `PUT` request to `/{index}/_alias/{name}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      name,
      cluster_manager_timeout,
      master_timeout,
      timeout,
      body,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let name = name.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_alias/{}",
      client.baseurl,
      encode_path(&index.to_string()),
      encode_path(&name.to_string()),
    );
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client.client.put(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_put_alias_post`]
///
///[`Client::indices_put_alias_post`]: super::Client::indices_put_alias_post
#[derive(Debug, Clone)]
pub struct IndicesPutAliasPost<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesPutAliasPostIndex, String>,
  name: Result<types::IndicesPutAliasPostName, String>,
  cluster_manager_timeout: Result<Option<types::IndicesPutAliasPostClusterManagerTimeout>, String>,
  master_timeout: Result<Option<types::IndicesPutAliasPostMasterTimeout>, String>,
  timeout: Result<Option<types::IndicesPutAliasPostTimeout>, String>,
  body: Result<types::IndicesPutAliasBodyParams, String>,
}

impl<'a> IndicesPutAliasPost<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      name: Err("name was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutAliasPostIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesPutAliasPostIndex` for index failed".to_string());
    self
  }

  pub fn name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutAliasPostName>, {
    self.name = value
      .try_into()
      .map_err(|_| "conversion to `IndicesPutAliasPostName` for name failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutAliasPostClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesPutAliasPostClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutAliasPostMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesPutAliasPostMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutAliasPostTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesPutAliasPostTimeout` for timeout failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutAliasBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `IndicesPutAliasBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/{index}/_alias/{name}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      name,
      cluster_manager_timeout,
      master_timeout,
      timeout,
      body,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let name = name.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_alias/{}",
      client.baseurl,
      encode_path(&index.to_string()),
      encode_path(&name.to_string()),
    );
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_delete_alias`]
///
///[`Client::indices_delete_alias`]: super::Client::indices_delete_alias
#[derive(Debug, Clone)]
pub struct IndicesDeleteAlias<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesDeleteAliasIndex, String>,
  name: Result<types::IndicesDeleteAliasName, String>,
  cluster_manager_timeout: Result<Option<types::IndicesDeleteAliasClusterManagerTimeout>, String>,
  master_timeout: Result<Option<types::IndicesDeleteAliasMasterTimeout>, String>,
  timeout: Result<Option<types::IndicesDeleteAliasTimeout>, String>,
}

impl<'a> IndicesDeleteAlias<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      name: Err("name was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesDeleteAliasIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesDeleteAliasIndex` for index failed".to_string());
    self
  }

  pub fn name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesDeleteAliasName>, {
    self.name = value
      .try_into()
      .map_err(|_| "conversion to `IndicesDeleteAliasName` for name failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesDeleteAliasClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesDeleteAliasClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesDeleteAliasMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesDeleteAliasMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesDeleteAliasTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesDeleteAliasTimeout` for timeout failed".to_string());
    self
  }

  ///Sends a `DELETE` request to `/{index}/_alias/{name}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      name,
      cluster_manager_timeout,
      master_timeout,
      timeout,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let name = name.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_alias/{}",
      client.baseurl,
      encode_path(&index.to_string()),
      encode_path(&name.to_string()),
    );
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client.client.delete(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_exists_alias_with_index`]
///
///[`Client::indices_exists_alias_with_index`]: super::Client::indices_exists_alias_with_index
#[derive(Debug, Clone)]
pub struct IndicesExistsAliasWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesExistsAliasWithIndexIndex, String>,
  name: Result<types::IndicesExistsAliasWithIndexName, String>,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
}

impl<'a> IndicesExistsAliasWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      name: Err("name was not initialized".to_string()),
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      ignore_unavailable: Ok(None),
      local: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesExistsAliasWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesExistsAliasWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesExistsAliasWithIndexName>, {
    self.name = value
      .try_into()
      .map_err(|_| "conversion to `IndicesExistsAliasWithIndexName` for name failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  ///Sends a `HEAD` request to `/{index}/_alias/{name}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      name,
      allow_no_indices,
      expand_wildcards,
      ignore_unavailable,
      local,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let name = name.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_alias/{}",
      client.baseurl,
      encode_path(&index.to_string()),
      encode_path(&name.to_string()),
    );
    let mut query = Vec::with_capacity(4usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    let request = client.client.head(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_put_alias_put_plural`]
///
///[`Client::indices_put_alias_put_plural`]: super::Client::indices_put_alias_put_plural
#[derive(Debug, Clone)]
pub struct IndicesPutAliasPutPlural<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesPutAliasPutPluralIndex, String>,
  name: Result<types::IndicesPutAliasPutPluralName, String>,
  cluster_manager_timeout: Result<Option<types::IndicesPutAliasPutPluralClusterManagerTimeout>, String>,
  master_timeout: Result<Option<types::IndicesPutAliasPutPluralMasterTimeout>, String>,
  timeout: Result<Option<types::IndicesPutAliasPutPluralTimeout>, String>,
  body: Result<types::IndicesPutAliasBodyParams, String>,
}

impl<'a> IndicesPutAliasPutPlural<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      name: Err("name was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutAliasPutPluralIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesPutAliasPutPluralIndex` for index failed".to_string());
    self
  }

  pub fn name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutAliasPutPluralName>, {
    self.name = value
      .try_into()
      .map_err(|_| "conversion to `IndicesPutAliasPutPluralName` for name failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutAliasPutPluralClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesPutAliasPutPluralClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutAliasPutPluralMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesPutAliasPutPluralMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutAliasPutPluralTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesPutAliasPutPluralTimeout` for timeout failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutAliasBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `IndicesPutAliasBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `PUT` request to `/{index}/_aliases/{name}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      name,
      cluster_manager_timeout,
      master_timeout,
      timeout,
      body,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let name = name.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_aliases/{}",
      client.baseurl,
      encode_path(&index.to_string()),
      encode_path(&name.to_string()),
    );
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client.client.put(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_put_alias_post_plural`]
///
///[`Client::indices_put_alias_post_plural`]: super::Client::indices_put_alias_post_plural
#[derive(Debug, Clone)]
pub struct IndicesPutAliasPostPlural<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesPutAliasPostPluralIndex, String>,
  name: Result<types::IndicesPutAliasPostPluralName, String>,
  cluster_manager_timeout: Result<Option<types::IndicesPutAliasPostPluralClusterManagerTimeout>, String>,
  master_timeout: Result<Option<types::IndicesPutAliasPostPluralMasterTimeout>, String>,
  timeout: Result<Option<types::IndicesPutAliasPostPluralTimeout>, String>,
  body: Result<types::IndicesPutAliasBodyParams, String>,
}

impl<'a> IndicesPutAliasPostPlural<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      name: Err("name was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutAliasPostPluralIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesPutAliasPostPluralIndex` for index failed".to_string());
    self
  }

  pub fn name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutAliasPostPluralName>, {
    self.name = value
      .try_into()
      .map_err(|_| "conversion to `IndicesPutAliasPostPluralName` for name failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutAliasPostPluralClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesPutAliasPostPluralClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutAliasPostPluralMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesPutAliasPostPluralMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutAliasPostPluralTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesPutAliasPostPluralTimeout` for timeout failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutAliasBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `IndicesPutAliasBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/{index}/_aliases/{name}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      name,
      cluster_manager_timeout,
      master_timeout,
      timeout,
      body,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let name = name.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_aliases/{}",
      client.baseurl,
      encode_path(&index.to_string()),
      encode_path(&name.to_string()),
    );
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_delete_alias_plural`]
///
///[`Client::indices_delete_alias_plural`]: super::Client::indices_delete_alias_plural
#[derive(Debug, Clone)]
pub struct IndicesDeleteAliasPlural<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesDeleteAliasPluralIndex, String>,
  name: Result<types::IndicesDeleteAliasPluralName, String>,
  cluster_manager_timeout: Result<Option<types::IndicesDeleteAliasPluralClusterManagerTimeout>, String>,
  master_timeout: Result<Option<types::IndicesDeleteAliasPluralMasterTimeout>, String>,
  timeout: Result<Option<types::IndicesDeleteAliasPluralTimeout>, String>,
}

impl<'a> IndicesDeleteAliasPlural<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      name: Err("name was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesDeleteAliasPluralIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesDeleteAliasPluralIndex` for index failed".to_string());
    self
  }

  pub fn name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesDeleteAliasPluralName>, {
    self.name = value
      .try_into()
      .map_err(|_| "conversion to `IndicesDeleteAliasPluralName` for name failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesDeleteAliasPluralClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesDeleteAliasPluralClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesDeleteAliasPluralMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesDeleteAliasPluralMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesDeleteAliasPluralTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesDeleteAliasPluralTimeout` for timeout failed".to_string());
    self
  }

  ///Sends a `DELETE` request to `/{index}/_aliases/{name}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      name,
      cluster_manager_timeout,
      master_timeout,
      timeout,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let name = name.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_aliases/{}",
      client.baseurl,
      encode_path(&index.to_string()),
      encode_path(&name.to_string()),
    );
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client.client.delete(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_analyze_get_with_index`]
///
///[`Client::indices_analyze_get_with_index`]: super::Client::indices_analyze_get_with_index
#[derive(Debug, Clone)]
pub struct IndicesAnalyzeGetWithIndex<'a> {
  client: &'a super::Client,
  index: Result<Option<String>, String>,
}

impl<'a> IndicesAnalyzeGetWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.index = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for index failed".to_string());
    self
  }

  ///Sends a `GET` request to `/{index}/_analyze`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self { client, index } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_analyze",
      client.baseurl,
      encode_path(&index.clone().unwrap_or(String::from("_all"))),
    );
    let mut query = Vec::with_capacity(1usize);
    if let Some(v) = &index {
      query.push(("index", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_analyze_post_with_index`]
///
///[`Client::indices_analyze_post_with_index`]: super::Client::indices_analyze_post_with_index
#[derive(Debug, Clone)]
pub struct IndicesAnalyzePostWithIndex<'a> {
  client: &'a super::Client,
  index: Result<Option<String>, String>,
  body: Result<types::IndicesAnalyzeBodyParams, String>,
}

impl<'a> IndicesAnalyzePostWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.index = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for index failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesAnalyzeBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `IndicesAnalyzeBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/{index}/_analyze`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self { client, index, body } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/_analyze", client.baseurl);
    let mut query = Vec::with_capacity(1usize);
    if let Some(v) = &index {
      query.push(("index", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_add_block`]
///
///[`Client::indices_add_block`]: super::Client::indices_add_block
#[derive(Debug, Clone)]
pub struct IndicesAddBlock<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesAddBlockIndex, String>,
  block: Result<types::IndicesAddBlockBlock, String>,
  allow_no_indices: Result<Option<bool>, String>,
  cluster_manager_timeout: Result<Option<types::IndicesAddBlockClusterManagerTimeout>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::IndicesAddBlockMasterTimeout>, String>,
  timeout: Result<Option<types::IndicesAddBlockTimeout>, String>,
}

impl<'a> IndicesAddBlock<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      block: Err("block was not initialized".to_string()),
      allow_no_indices: Ok(None),
      cluster_manager_timeout: Ok(None),
      expand_wildcards: Ok(None),
      ignore_unavailable: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesAddBlockIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesAddBlockIndex` for index failed".to_string());
    self
  }

  pub fn block<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesAddBlockBlock>, {
    self.block = value
      .try_into()
      .map_err(|_| "conversion to `IndicesAddBlockBlock` for block failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesAddBlockClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesAddBlockClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesAddBlockMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesAddBlockMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesAddBlockTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesAddBlockTimeout` for timeout failed".to_string());
    self
  }

  ///Sends a `PUT` request to `/{index}/_block/{block}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      block,
      allow_no_indices,
      cluster_manager_timeout,
      expand_wildcards,
      ignore_unavailable,
      master_timeout,
      timeout,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let block = block.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_block/{}",
      client.baseurl,
      encode_path(&index.to_string()),
      encode_path(&block.to_string()),
    );
    let mut query = Vec::with_capacity(6usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client.client.put(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}
///Builder for [`Client::indices_clear_cache_with_index`]
///
///[`Client::indices_clear_cache_with_index`]: super::Client::indices_clear_cache_with_index
#[derive(Debug, Clone)]
pub struct IndicesClearCacheWithIndex<'a> {
  client: &'a super::Client,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  fielddata: Result<Option<bool>, String>,
  fields: Result<Option<Vec<String>>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  index: Result<Option<Vec<String>>, String>,
  query: Result<Option<bool>, String>,
  request: Result<Option<bool>, String>,
}

impl<'a> IndicesClearCacheWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      fielddata: Ok(None),
      fields: Ok(None),
      ignore_unavailable: Ok(None),
      index: Ok(None),
      query: Ok(None),
      request: Ok(None),
    }
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn fielddata<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.fielddata = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for fielddata failed".to_string());
    self
  }

  pub fn fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.index = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for index failed".to_string());
    self
  }

  pub fn query<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.query = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for query failed".to_string());
    self
  }

  pub fn request<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.request = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for request failed".to_string());
    self
  }

  ///Sends a `POST` request to `/{index}/_cache/clear`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      allow_no_indices,
      expand_wildcards,
      fielddata,
      fields,
      ignore_unavailable,
      index,
      query,
      request,
    } = self;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let fielddata = fielddata.map_err(Error::InvalidRequest)?;
    let fields = fields.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let index = index.map_err(Error::InvalidRequest)?;
    let query_opt = query.map_err(Error::InvalidRequest)?;
    let request = request.map_err(Error::InvalidRequest)?;
    let url = match &index {
      Some(idx) => {
        format!(
          "{}/{}/_cache/clear",
          client.baseurl,
          encode_path(&index.clone().unwrap().join(",")),
        )
      }
      None => format!("{}/_cache/clear", client.baseurl),
    };
    let mut query = Vec::with_capacity(8usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &fielddata {
      query.push(("fielddata", v.to_string()));
    }
    if let Some(v) = &fields {
      query.push(("fields", v.join(",")));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &index {
      query.push(("index", v.join(",")));
    }
    if let Some(v) = &query_opt {
      query.push(("query", v.to_string()));
    }
    if let Some(v) = &request {
      query.push(("request", v.to_string()));
    }
    let request = client.client.post(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_clone_put`]
///
///[`Client::indices_clone_put`]: super::Client::indices_clone_put
#[derive(Debug, Clone)]
pub struct IndicesClonePut<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesClonePutIndex, String>,
  target: Result<types::IndicesClonePutTarget, String>,
  cluster_manager_timeout: Result<Option<types::IndicesClonePutClusterManagerTimeout>, String>,
  master_timeout: Result<Option<types::IndicesClonePutMasterTimeout>, String>,
  timeout: Result<Option<types::IndicesClonePutTimeout>, String>,
  wait_for_active_shards: Result<Option<String>, String>,
  body: Result<types::IndicesCloneBodyParams, String>,
}

impl<'a> IndicesClonePut<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      target: Err("target was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
      wait_for_active_shards: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesClonePutIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesClonePutIndex` for index failed".to_string());
    self
  }

  pub fn target<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesClonePutTarget>, {
    self.target = value
      .try_into()
      .map_err(|_| "conversion to `IndicesClonePutTarget` for target failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesClonePutClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesClonePutClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesClonePutMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesClonePutMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesClonePutTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesClonePutTimeout` for timeout failed".to_string());
    self
  }

  pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.wait_for_active_shards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for wait_for_active_shards failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesCloneBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `IndicesCloneBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `PUT` request to `/{index}/_clone/{target}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      target,
      cluster_manager_timeout,
      master_timeout,
      timeout,
      wait_for_active_shards,
      body,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let target = target.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_clone/{}",
      client.baseurl,
      encode_path(&index.to_string()),
      encode_path(&target.to_string()),
    );
    let mut query = Vec::with_capacity(4usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &wait_for_active_shards {
      query.push(("wait_for_active_shards", v.to_string()));
    }
    let request = client.client.put(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_clone_post`]
///
///[`Client::indices_clone_post`]: super::Client::indices_clone_post
#[derive(Debug, Clone)]
pub struct IndicesClonePost<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesClonePostIndex, String>,
  target: Result<types::IndicesClonePostTarget, String>,
  cluster_manager_timeout: Result<Option<types::IndicesClonePostClusterManagerTimeout>, String>,
  master_timeout: Result<Option<types::IndicesClonePostMasterTimeout>, String>,
  timeout: Result<Option<types::IndicesClonePostTimeout>, String>,
  wait_for_active_shards: Result<Option<String>, String>,
  body: Result<types::IndicesCloneBodyParams, String>,
}

impl<'a> IndicesClonePost<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      target: Err("target was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
      wait_for_active_shards: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesClonePostIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesClonePostIndex` for index failed".to_string());
    self
  }

  pub fn target<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesClonePostTarget>, {
    self.target = value
      .try_into()
      .map_err(|_| "conversion to `IndicesClonePostTarget` for target failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesClonePostClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesClonePostClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesClonePostMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesClonePostMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesClonePostTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesClonePostTimeout` for timeout failed".to_string());
    self
  }

  pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.wait_for_active_shards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for wait_for_active_shards failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesCloneBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `IndicesCloneBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/{index}/_clone/{target}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      target,
      cluster_manager_timeout,
      master_timeout,
      timeout,
      wait_for_active_shards,
      body,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let target = target.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_clone/{}",
      client.baseurl,
      encode_path(&index.to_string()),
      encode_path(&target.to_string()),
    );
    let mut query = Vec::with_capacity(4usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &wait_for_active_shards {
      query.push(("wait_for_active_shards", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_close`]
///
///[`Client::indices_close`]: super::Client::indices_close
#[derive(Debug, Clone)]
pub struct IndicesClose<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesCloseIndex, String>,
  allow_no_indices: Result<Option<bool>, String>,
  cluster_manager_timeout: Result<Option<types::IndicesCloseClusterManagerTimeout>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::IndicesCloseMasterTimeout>, String>,
  timeout: Result<Option<types::IndicesCloseTimeout>, String>,
  wait_for_active_shards: Result<Option<String>, String>,
}

impl<'a> IndicesClose<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      allow_no_indices: Ok(None),
      cluster_manager_timeout: Ok(None),
      expand_wildcards: Ok(None),
      ignore_unavailable: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
      wait_for_active_shards: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesCloseIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesCloseIndex` for index failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesCloseClusterManagerTimeout>, {
    self.cluster_manager_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesCloseClusterManagerTimeout` for cluster_manager_timeout failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesCloseMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesCloseMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesCloseTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesCloseTimeout` for timeout failed".to_string());
    self
  }

  pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.wait_for_active_shards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for wait_for_active_shards failed".to_string());
    self
  }

  ///Sends a `POST` request to `/{index}/_close`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      allow_no_indices,
      cluster_manager_timeout,
      expand_wildcards,
      ignore_unavailable,
      master_timeout,
      timeout,
      wait_for_active_shards,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}/_close", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(7usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &wait_for_active_shards {
      query.push(("wait_for_active_shards", v.to_string()));
    }
    let request = client.client.post(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::count_get_with_index`]
///
///[`Client::count_get_with_index`]: super::Client::count_get_with_index
#[derive(Debug, Clone)]
pub struct CountGetWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::CountGetWithIndexIndex, String>,
  allow_no_indices: Result<Option<bool>, String>,
  analyze_wildcard: Result<Option<bool>, String>,
  analyzer: Result<Option<String>, String>,
  default_operator: Result<Option<types::DefaultOperator>, String>,
  df: Result<Option<String>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_throttled: Result<Option<bool>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  lenient: Result<Option<bool>, String>,
  min_score: Result<Option<i32>, String>,
  preference: Result<Option<String>, String>,
  q: Result<Option<String>, String>,
  routing: Result<Option<Vec<String>>, String>,
  terminate_after: Result<Option<i32>, String>,
}

impl<'a> CountGetWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      allow_no_indices: Ok(None),
      analyze_wildcard: Ok(None),
      analyzer: Ok(None),
      default_operator: Ok(None),
      df: Ok(None),
      expand_wildcards: Ok(None),
      ignore_throttled: Ok(None),
      ignore_unavailable: Ok(None),
      lenient: Ok(None),
      min_score: Ok(None),
      preference: Ok(None),
      q: Ok(None),
      routing: Ok(None),
      terminate_after: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CountGetWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `CountGetWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn analyze_wildcard<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.analyze_wildcard = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for analyze_wildcard failed".to_string());
    self
  }

  pub fn analyzer<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.analyzer = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for analyzer failed".to_string());
    self
  }

  pub fn default_operator<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::DefaultOperator>, {
    self.default_operator = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `DefaultOperator` for default_operator failed".to_string());
    self
  }

  pub fn df<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.df = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for df failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_throttled<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_throttled = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_throttled failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn lenient<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.lenient = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for lenient failed".to_string());
    self
  }

  pub fn min_score<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.min_score = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for min_score failed".to_string());
    self
  }

  pub fn preference<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.preference = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for preference failed".to_string());
    self
  }

  pub fn q<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.q = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for q failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for routing failed".to_string());
    self
  }

  pub fn terminate_after<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.terminate_after = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for terminate_after failed".to_string());
    self
  }

  ///Sends a `GET` request to `/{index}/_count`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      allow_no_indices,
      analyze_wildcard,
      analyzer,
      default_operator,
      df,
      expand_wildcards,
      ignore_throttled,
      ignore_unavailable,
      lenient,
      min_score,
      preference,
      q,
      routing,
      terminate_after,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let analyze_wildcard = analyze_wildcard.map_err(Error::InvalidRequest)?;
    let analyzer = analyzer.map_err(Error::InvalidRequest)?;
    let default_operator = default_operator.map_err(Error::InvalidRequest)?;
    let df = df.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_throttled = ignore_throttled.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let lenient = lenient.map_err(Error::InvalidRequest)?;
    let min_score = min_score.map_err(Error::InvalidRequest)?;
    let preference = preference.map_err(Error::InvalidRequest)?;
    let q = q.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let terminate_after = terminate_after.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}/_count", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(14usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &analyze_wildcard {
      query.push(("analyze_wildcard", v.to_string()));
    }
    if let Some(v) = &analyzer {
      query.push(("analyzer", v.to_string()));
    }
    if let Some(v) = &default_operator {
      query.push(("default_operator", v.to_string()));
    }
    if let Some(v) = &df {
      query.push(("df", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_throttled {
      query.push(("ignore_throttled", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &lenient {
      query.push(("lenient", v.to_string()));
    }
    if let Some(v) = &min_score {
      query.push(("min_score", v.to_string()));
    }
    if let Some(v) = &preference {
      query.push(("preference", v.to_string()));
    }
    if let Some(v) = &q {
      query.push(("q", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.join(",")));
    }
    if let Some(v) = &terminate_after {
      query.push(("terminate_after", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::count_post_with_index`]
///
///[`Client::count_post_with_index`]: super::Client::count_post_with_index
#[derive(Debug, Clone)]
pub struct CountPostWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::CountPostWithIndexIndex, String>,
  allow_no_indices: Result<Option<bool>, String>,
  analyze_wildcard: Result<Option<bool>, String>,
  analyzer: Result<Option<String>, String>,
  default_operator: Result<Option<types::DefaultOperator>, String>,
  df: Result<Option<String>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_throttled: Result<Option<bool>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  lenient: Result<Option<bool>, String>,
  min_score: Result<Option<i32>, String>,
  preference: Result<Option<String>, String>,
  q: Result<Option<String>, String>,
  routing: Result<Option<Vec<String>>, String>,
  terminate_after: Result<Option<i32>, String>,
  body: Result<types::CountBodyParams, String>,
}

impl<'a> CountPostWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      allow_no_indices: Ok(None),
      analyze_wildcard: Ok(None),
      analyzer: Ok(None),
      default_operator: Ok(None),
      df: Ok(None),
      expand_wildcards: Ok(None),
      ignore_throttled: Ok(None),
      ignore_unavailable: Ok(None),
      lenient: Ok(None),
      min_score: Ok(None),
      preference: Ok(None),
      q: Ok(None),
      routing: Ok(None),
      terminate_after: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CountPostWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `CountPostWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn analyze_wildcard<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.analyze_wildcard = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for analyze_wildcard failed".to_string());
    self
  }

  pub fn analyzer<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.analyzer = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for analyzer failed".to_string());
    self
  }

  pub fn default_operator<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::DefaultOperator>, {
    self.default_operator = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `DefaultOperator` for default_operator failed".to_string());
    self
  }

  pub fn df<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.df = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for df failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_throttled<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_throttled = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_throttled failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn lenient<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.lenient = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for lenient failed".to_string());
    self
  }

  pub fn min_score<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.min_score = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for min_score failed".to_string());
    self
  }

  pub fn preference<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.preference = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for preference failed".to_string());
    self
  }

  pub fn q<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.q = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for q failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for routing failed".to_string());
    self
  }

  pub fn terminate_after<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.terminate_after = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for terminate_after failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CountBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `CountBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/{index}/_count`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      allow_no_indices,
      analyze_wildcard,
      analyzer,
      default_operator,
      df,
      expand_wildcards,
      ignore_throttled,
      ignore_unavailable,
      lenient,
      min_score,
      preference,
      q,
      routing,
      terminate_after,
      body,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let analyze_wildcard = analyze_wildcard.map_err(Error::InvalidRequest)?;
    let analyzer = analyzer.map_err(Error::InvalidRequest)?;
    let default_operator = default_operator.map_err(Error::InvalidRequest)?;
    let df = df.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_throttled = ignore_throttled.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let lenient = lenient.map_err(Error::InvalidRequest)?;
    let min_score = min_score.map_err(Error::InvalidRequest)?;
    let preference = preference.map_err(Error::InvalidRequest)?;
    let q = q.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let terminate_after = terminate_after.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}/_count", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(14usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &analyze_wildcard {
      query.push(("analyze_wildcard", v.to_string()));
    }
    if let Some(v) = &analyzer {
      query.push(("analyzer", v.to_string()));
    }
    if let Some(v) = &default_operator {
      query.push(("default_operator", v.to_string()));
    }
    if let Some(v) = &df {
      query.push(("df", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_throttled {
      query.push(("ignore_throttled", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &lenient {
      query.push(("lenient", v.to_string()));
    }
    if let Some(v) = &min_score {
      query.push(("min_score", v.to_string()));
    }
    if let Some(v) = &preference {
      query.push(("preference", v.to_string()));
    }
    if let Some(v) = &q {
      query.push(("q", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.join(",")));
    }
    if let Some(v) = &terminate_after {
      query.push(("terminate_after", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::create_put`]
///
///[`Client::create_put`]: super::Client::create_put
#[derive(Debug, Clone)]
pub struct CreatePut<'a> {
  client: &'a super::Client,
  index: Result<types::CreatePutIndex, String>,
  id: Result<types::CreatePutId, String>,
  pipeline: Result<Option<String>, String>,
  refresh: Result<Option<types::RefreshEnum>, String>,
  routing: Result<Option<String>, String>,
  timeout: Result<Option<types::CreatePutTimeout>, String>,
  version: Result<Option<i32>, String>,
  version_type: Result<Option<types::VersionType>, String>,
  wait_for_active_shards: Result<Option<String>, String>,
  body: Result<types::CreateBodyParams, String>,
}

impl<'a> CreatePut<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      id: Err("id was not initialized".to_string()),
      pipeline: Ok(None),
      refresh: Ok(None),
      routing: Ok(None),
      timeout: Ok(None),
      version: Ok(None),
      version_type: Ok(None),
      wait_for_active_shards: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CreatePutIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `CreatePutIndex` for index failed".to_string());
    self
  }

  pub fn id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CreatePutId>, {
    self.id = value
      .try_into()
      .map_err(|_| "conversion to `CreatePutId` for id failed".to_string());
    self
  }

  pub fn pipeline<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.pipeline = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for pipeline failed".to_string());
    self
  }

  pub fn refresh<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::RefreshEnum>, {
    self.refresh = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `RefreshEnum` for refresh failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for routing failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CreatePutTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `CreatePutTimeout` for timeout failed".to_string());
    self
  }

  pub fn version<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.version = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for version failed".to_string());
    self
  }

  pub fn version_type<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::VersionType>, {
    self.version_type = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `VersionType` for version_type failed".to_string());
    self
  }

  pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.wait_for_active_shards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for wait_for_active_shards failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CreateBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `CreateBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `PUT` request to `/{index}/_create/{id}`
  pub async fn send(self) -> Result<ResponseValue<types::IndexResponse>, Error<()>> {
    let Self {
      client,
      index,
      id,
      pipeline,
      refresh,
      routing,
      timeout,
      version,
      version_type,
      wait_for_active_shards,
      body,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let id = id.map_err(Error::InvalidRequest)?;
    let pipeline = pipeline.map_err(Error::InvalidRequest)?;
    let refresh = refresh.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let version = version.map_err(Error::InvalidRequest)?;
    let version_type = version_type.map_err(Error::InvalidRequest)?;
    let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_create/{}",
      client.baseurl,
      encode_path(&index.to_string()),
      encode_path(&id.to_string()),
    );
    let mut query = Vec::with_capacity(7usize);
    if let Some(v) = &pipeline {
      query.push(("pipeline", v.to_string()));
    }
    if let Some(v) = &refresh {
      query.push(("refresh", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &version {
      query.push(("version", v.to_string()));
    }
    if let Some(v) = &version_type {
      query.push(("version_type", v.to_string()));
    }
    if let Some(v) = &wait_for_active_shards {
      query.push(("wait_for_active_shards", v.to_string()));
    }
    let request = client.client.put(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::create_post`]
///
///[`Client::create_post`]: super::Client::create_post
#[derive(Debug, Clone)]
pub struct CreatePost<'a> {
  client: &'a super::Client,
  index: Result<types::CreatePostIndex, String>,
  id: Result<types::CreatePostId, String>,
  pipeline: Result<Option<String>, String>,
  refresh: Result<Option<types::RefreshEnum>, String>,
  routing: Result<Option<String>, String>,
  timeout: Result<Option<types::CreatePostTimeout>, String>,
  version: Result<Option<i32>, String>,
  version_type: Result<Option<types::VersionType>, String>,
  wait_for_active_shards: Result<Option<String>, String>,
  body: Result<types::CreateBodyParams, String>,
}

impl<'a> CreatePost<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      id: Err("id was not initialized".to_string()),
      pipeline: Ok(None),
      refresh: Ok(None),
      routing: Ok(None),
      timeout: Ok(None),
      version: Ok(None),
      version_type: Ok(None),
      wait_for_active_shards: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CreatePostIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `CreatePostIndex` for index failed".to_string());
    self
  }

  pub fn id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CreatePostId>, {
    self.id = value
      .try_into()
      .map_err(|_| "conversion to `CreatePostId` for id failed".to_string());
    self
  }

  pub fn pipeline<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.pipeline = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for pipeline failed".to_string());
    self
  }

  pub fn refresh<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::RefreshEnum>, {
    self.refresh = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `RefreshEnum` for refresh failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for routing failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CreatePostTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `CreatePostTimeout` for timeout failed".to_string());
    self
  }

  pub fn version<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.version = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for version failed".to_string());
    self
  }

  pub fn version_type<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::VersionType>, {
    self.version_type = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `VersionType` for version_type failed".to_string());
    self
  }

  pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.wait_for_active_shards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for wait_for_active_shards failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CreateBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `CreateBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/{index}/_create/{id}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      id,
      pipeline,
      refresh,
      routing,
      timeout,
      version,
      version_type,
      wait_for_active_shards,
      body,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let id = id.map_err(Error::InvalidRequest)?;
    let pipeline = pipeline.map_err(Error::InvalidRequest)?;
    let refresh = refresh.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let version = version.map_err(Error::InvalidRequest)?;
    let version_type = version_type.map_err(Error::InvalidRequest)?;
    let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_create/{}",
      client.baseurl,
      encode_path(&index.to_string()),
      encode_path(&id.to_string()),
    );
    let mut query = Vec::with_capacity(7usize);
    if let Some(v) = &pipeline {
      query.push(("pipeline", v.to_string()));
    }
    if let Some(v) = &refresh {
      query.push(("refresh", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &version {
      query.push(("version", v.to_string()));
    }
    if let Some(v) = &version_type {
      query.push(("version_type", v.to_string()));
    }
    if let Some(v) = &wait_for_active_shards {
      query.push(("wait_for_active_shards", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::delete_by_query`]
///
///[`Client::delete_by_query`]: super::Client::delete_by_query
#[derive(Debug, Clone)]
pub struct DeleteByQuery<'a> {
  client: &'a super::Client,
  index: Result<types::DeleteByQueryIndex, String>,
  source: Result<Option<Vec<String>>, String>,
  source_excludes: Result<Option<Vec<String>>, String>,
  source_includes: Result<Option<Vec<String>>, String>,
  allow_no_indices: Result<Option<bool>, String>,
  analyze_wildcard: Result<Option<bool>, String>,
  analyzer: Result<Option<String>, String>,
  conflicts: Result<Option<types::Conflicts>, String>,
  default_operator: Result<Option<types::DefaultOperator>, String>,
  df: Result<Option<String>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  from: Result<Option<i32>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  lenient: Result<Option<bool>, String>,
  max_docs: Result<Option<i32>, String>,
  preference: Result<Option<String>, String>,
  q: Result<Option<String>, String>,
  refresh: Result<Option<bool>, String>,
  request_cache: Result<Option<bool>, String>,
  requests_per_second: Result<Option<i32>, String>,
  routing: Result<Option<Vec<String>>, String>,
  scroll: Result<Option<types::DeleteByQueryScroll>, String>,
  scroll_size: Result<Option<i32>, String>,
  search_timeout: Result<Option<types::DeleteByQuerySearchTimeout>, String>,
  search_type: Result<Option<types::SearchType>, String>,
  size: Result<Option<i32>, String>,
  slices: Result<Option<String>, String>,
  sort: Result<Option<Vec<String>>, String>,
  stats: Result<Option<Vec<String>>, String>,
  terminate_after: Result<Option<i32>, String>,
  timeout: Result<Option<types::DeleteByQueryTimeout>, String>,
  version: Result<Option<bool>, String>,
  wait_for_active_shards: Result<Option<String>, String>,
  wait_for_completion: Result<Option<bool>, String>,
  body: Result<types::DeleteByQueryBodyParams, String>,
}

impl<'a> DeleteByQuery<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      source: Ok(None),
      source_excludes: Ok(None),
      source_includes: Ok(None),
      allow_no_indices: Ok(None),
      analyze_wildcard: Ok(None),
      analyzer: Ok(None),
      conflicts: Ok(None),
      default_operator: Ok(None),
      df: Ok(None),
      expand_wildcards: Ok(None),
      from: Ok(None),
      ignore_unavailable: Ok(None),
      lenient: Ok(None),
      max_docs: Ok(None),
      preference: Ok(None),
      q: Ok(None),
      refresh: Ok(None),
      request_cache: Ok(None),
      requests_per_second: Ok(None),
      routing: Ok(None),
      scroll: Ok(None),
      scroll_size: Ok(None),
      search_timeout: Ok(None),
      search_type: Ok(None),
      size: Ok(None),
      slices: Ok(None),
      sort: Ok(None),
      stats: Ok(None),
      terminate_after: Ok(None),
      timeout: Ok(None),
      version: Ok(None),
      wait_for_active_shards: Ok(None),
      wait_for_completion: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::DeleteByQueryIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `DeleteByQueryIndex` for index failed".to_string());
    self
  }

  pub fn source<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source failed".to_string());
    self
  }

  pub fn source_excludes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source_excludes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source_excludes failed".to_string());
    self
  }

  pub fn source_includes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source_includes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source_includes failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn analyze_wildcard<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.analyze_wildcard = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for analyze_wildcard failed".to_string());
    self
  }

  pub fn analyzer<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.analyzer = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for analyzer failed".to_string());
    self
  }

  pub fn conflicts<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::Conflicts>, {
    self.conflicts = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Conflicts` for conflicts failed".to_string());
    self
  }

  pub fn default_operator<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::DefaultOperator>, {
    self.default_operator = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `DefaultOperator` for default_operator failed".to_string());
    self
  }

  pub fn df<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.df = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for df failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn from<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.from = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for from failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn lenient<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.lenient = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for lenient failed".to_string());
    self
  }

  pub fn max_docs<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.max_docs = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for max_docs failed".to_string());
    self
  }

  pub fn preference<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.preference = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for preference failed".to_string());
    self
  }

  pub fn q<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.q = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for q failed".to_string());
    self
  }

  pub fn refresh<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.refresh = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for refresh failed".to_string());
    self
  }

  pub fn request_cache<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.request_cache = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for request_cache failed".to_string());
    self
  }

  pub fn requests_per_second<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.requests_per_second = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for requests_per_second failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for routing failed".to_string());
    self
  }

  pub fn scroll<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::DeleteByQueryScroll>, {
    self.scroll = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `DeleteByQueryScroll` for scroll failed".to_string());
    self
  }

  pub fn scroll_size<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.scroll_size = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for scroll_size failed".to_string());
    self
  }

  pub fn search_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::DeleteByQuerySearchTimeout>, {
    self.search_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `DeleteByQuerySearchTimeout` for search_timeout failed".to_string());
    self
  }

  pub fn search_type<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SearchType>, {
    self.search_type = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SearchType` for search_type failed".to_string());
    self
  }

  pub fn size<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.size = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for size failed".to_string());
    self
  }

  pub fn slices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.slices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for slices failed".to_string());
    self
  }

  pub fn sort<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.sort = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for sort failed".to_string());
    self
  }

  pub fn stats<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.stats = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for stats failed".to_string());
    self
  }

  pub fn terminate_after<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.terminate_after = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for terminate_after failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::DeleteByQueryTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `DeleteByQueryTimeout` for timeout failed".to_string());
    self
  }

  pub fn version<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.version = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for version failed".to_string());
    self
  }

  pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.wait_for_active_shards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for wait_for_active_shards failed".to_string());
    self
  }

  pub fn wait_for_completion<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.wait_for_completion = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for wait_for_completion failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::DeleteByQueryBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `DeleteByQueryBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/{index}/_delete_by_query`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      source,
      source_excludes,
      source_includes,
      allow_no_indices,
      analyze_wildcard,
      analyzer,
      conflicts,
      default_operator,
      df,
      expand_wildcards,
      from,
      ignore_unavailable,
      lenient,
      max_docs,
      preference,
      q,
      refresh,
      request_cache,
      requests_per_second,
      routing,
      scroll,
      scroll_size,
      search_timeout,
      search_type,
      size,
      slices,
      sort,
      stats,
      terminate_after,
      timeout,
      version,
      wait_for_active_shards,
      wait_for_completion,
      body,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let source = source.map_err(Error::InvalidRequest)?;
    let source_excludes = source_excludes.map_err(Error::InvalidRequest)?;
    let source_includes = source_includes.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let analyze_wildcard = analyze_wildcard.map_err(Error::InvalidRequest)?;
    let analyzer = analyzer.map_err(Error::InvalidRequest)?;
    let conflicts = conflicts.map_err(Error::InvalidRequest)?;
    let default_operator = default_operator.map_err(Error::InvalidRequest)?;
    let df = df.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let from = from.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let lenient = lenient.map_err(Error::InvalidRequest)?;
    let max_docs = max_docs.map_err(Error::InvalidRequest)?;
    let preference = preference.map_err(Error::InvalidRequest)?;
    let q = q.map_err(Error::InvalidRequest)?;
    let refresh = refresh.map_err(Error::InvalidRequest)?;
    let request_cache = request_cache.map_err(Error::InvalidRequest)?;
    let requests_per_second = requests_per_second.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let scroll = scroll.map_err(Error::InvalidRequest)?;
    let scroll_size = scroll_size.map_err(Error::InvalidRequest)?;
    let search_timeout = search_timeout.map_err(Error::InvalidRequest)?;
    let search_type = search_type.map_err(Error::InvalidRequest)?;
    let size = size.map_err(Error::InvalidRequest)?;
    let slices = slices.map_err(Error::InvalidRequest)?;
    let sort = sort.map_err(Error::InvalidRequest)?;
    let stats = stats.map_err(Error::InvalidRequest)?;
    let terminate_after = terminate_after.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let version = version.map_err(Error::InvalidRequest)?;
    let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
    let wait_for_completion = wait_for_completion.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_delete_by_query",
      client.baseurl,
      encode_path(&index.to_string()),
    );
    let mut query = Vec::with_capacity(33usize);
    if let Some(v) = &source {
      query.push(("_source", v.join(",")));
    }
    if let Some(v) = &source_excludes {
      query.push(("_source_excludes", v.join(",")));
    }
    if let Some(v) = &source_includes {
      query.push(("_source_includes", v.join(",")));
    }
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &analyze_wildcard {
      query.push(("analyze_wildcard", v.to_string()));
    }
    if let Some(v) = &analyzer {
      query.push(("analyzer", v.to_string()));
    }
    if let Some(v) = &conflicts {
      query.push(("conflicts", v.to_string()));
    }
    if let Some(v) = &default_operator {
      query.push(("default_operator", v.to_string()));
    }
    if let Some(v) = &df {
      query.push(("df", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &from {
      query.push(("from", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &lenient {
      query.push(("lenient", v.to_string()));
    }
    if let Some(v) = &max_docs {
      query.push(("max_docs", v.to_string()));
    }
    if let Some(v) = &preference {
      query.push(("preference", v.to_string()));
    }
    if let Some(v) = &q {
      query.push(("q", v.to_string()));
    }
    if let Some(v) = &refresh {
      query.push(("refresh", v.to_string()));
    }
    if let Some(v) = &request_cache {
      query.push(("request_cache", v.to_string()));
    }
    if let Some(v) = &requests_per_second {
      query.push(("requests_per_second", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.join(",")));
    }
    if let Some(v) = &scroll {
      query.push(("scroll", v.to_string()));
    }
    if let Some(v) = &scroll_size {
      query.push(("scroll_size", v.to_string()));
    }
    if let Some(v) = &search_timeout {
      query.push(("search_timeout", v.to_string()));
    }
    if let Some(v) = &search_type {
      query.push(("search_type", v.to_string()));
    }
    if let Some(v) = &size {
      query.push(("size", v.to_string()));
    }
    if let Some(v) = &slices {
      query.push(("slices", v.to_string()));
    }
    if let Some(v) = &sort {
      query.push(("sort", v.join(",")));
    }
    if let Some(v) = &stats {
      query.push(("stats", v.join(",")));
    }
    if let Some(v) = &terminate_after {
      query.push(("terminate_after", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &version {
      query.push(("version", v.to_string()));
    }
    if let Some(v) = &wait_for_active_shards {
      query.push(("wait_for_active_shards", v.to_string()));
    }
    if let Some(v) = &wait_for_completion {
      query.push(("wait_for_completion", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::get`]
///
///[`Client::get`]: super::Client::get
#[derive(Debug, Clone)]
pub struct Get<'a> {
  client: &'a super::Client,
  index: Result<types::GetIndex, String>,
  id: Result<types::GetId, String>,
  source: Result<Option<Vec<String>>, String>,
  source_excludes: Result<Option<Vec<String>>, String>,
  source_includes: Result<Option<Vec<String>>, String>,
  preference: Result<Option<String>, String>,
  realtime: Result<Option<bool>, String>,
  refresh: Result<Option<bool>, String>,
  routing: Result<Option<String>, String>,
  stored_fields: Result<Option<Vec<String>>, String>,
  version: Result<Option<i32>, String>,
  version_type: Result<Option<types::VersionType>, String>,
}

impl<'a> Get<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      id: Err("id was not initialized".to_string()),
      source: Ok(None),
      source_excludes: Ok(None),
      source_includes: Ok(None),
      preference: Ok(None),
      realtime: Ok(None),
      refresh: Ok(None),
      routing: Ok(None),
      stored_fields: Ok(None),
      version: Ok(None),
      version_type: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::GetIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `GetIndex` for index failed".to_string());
    self
  }

  pub fn id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::GetId>, {
    self.id = value
      .try_into()
      .map_err(|_| "conversion to `GetId` for id failed".to_string());
    self
  }

  pub fn source<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source failed".to_string());
    self
  }

  pub fn source_excludes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source_excludes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source_excludes failed".to_string());
    self
  }

  pub fn source_includes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source_includes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source_includes failed".to_string());
    self
  }

  pub fn preference<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.preference = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for preference failed".to_string());
    self
  }

  pub fn realtime<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.realtime = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for realtime failed".to_string());
    self
  }

  pub fn refresh<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.refresh = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for refresh failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for routing failed".to_string());
    self
  }

  pub fn stored_fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.stored_fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for stored_fields failed".to_string());
    self
  }

  pub fn version<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.version = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for version failed".to_string());
    self
  }

  pub fn version_type<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::VersionType>, {
    self.version_type = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `VersionType` for version_type failed".to_string());
    self
  }

  ///Sends a `GET` request to `/{index}/_doc/{id}`
  pub async fn send<T: DeserializeOwned + std::default::Default>(
    self,
  ) -> Result<ResponseValue<types::GetResponseContent<T>>, Error<()>> {
    let Self {
      client,
      index,
      id,
      source,
      source_excludes,
      source_includes,
      preference,
      realtime,
      refresh,
      routing,
      stored_fields,
      version,
      version_type,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let id = id.map_err(Error::InvalidRequest)?;
    let source = source.map_err(Error::InvalidRequest)?;
    let source_excludes = source_excludes.map_err(Error::InvalidRequest)?;
    let source_includes = source_includes.map_err(Error::InvalidRequest)?;
    let preference = preference.map_err(Error::InvalidRequest)?;
    let realtime = realtime.map_err(Error::InvalidRequest)?;
    let refresh = refresh.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let stored_fields = stored_fields.map_err(Error::InvalidRequest)?;
    let version = version.map_err(Error::InvalidRequest)?;
    let version_type = version_type.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_doc/{}",
      client.baseurl,
      encode_path(&index.to_string()),
      encode_path(&id.to_string()),
    );
    let mut query = Vec::with_capacity(10usize);
    if let Some(v) = &source {
      query.push(("_source", v.join(",")));
    }
    if let Some(v) = &source_excludes {
      query.push(("_source_excludes", v.join(",")));
    }
    if let Some(v) = &source_includes {
      query.push(("_source_includes", v.join(",")));
    }
    if let Some(v) = &preference {
      query.push(("preference", v.to_string()));
    }
    if let Some(v) = &realtime {
      query.push(("realtime", v.to_string()));
    }
    if let Some(v) = &refresh {
      query.push(("refresh", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.to_string()));
    }
    if let Some(v) = &stored_fields {
      query.push(("stored_fields", v.join(",")));
    }
    if let Some(v) = &version {
      query.push(("version", v.to_string()));
    }
    if let Some(v) = &version_type {
      query.push(("version_type", v.to_string()));
    }
    let request = client
      .client
      .get(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .query(&query)
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::index_put_with_id`]
///
///[`Client::index_put_with_id`]: super::Client::index_put_with_id
#[derive(Debug, Clone)]
pub struct IndexPutWithId<'a> {
  client: &'a super::Client,
  index: Result<types::IndexPutWithIdIndex, String>,
  id: Result<types::IndexPutWithIdId, String>,
  if_primary_term: Result<Option<i32>, String>,
  if_seq_no: Result<Option<i32>, String>,
  op_type: Result<Option<types::OpType>, String>,
  pipeline: Result<Option<String>, String>,
  refresh: Result<Option<types::RefreshEnum>, String>,
  require_alias: Result<Option<bool>, String>,
  routing: Result<Option<String>, String>,
  timeout: Result<Option<types::IndexPutWithIdTimeout>, String>,
  version: Result<Option<i32>, String>,
  version_type: Result<Option<types::VersionType>, String>,
  wait_for_active_shards: Result<Option<String>, String>,
  body: Result<types::IndexBodyParams, String>,
}

impl<'a> IndexPutWithId<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      id: Err("id was not initialized".to_string()),
      if_primary_term: Ok(None),
      if_seq_no: Ok(None),
      op_type: Ok(None),
      pipeline: Ok(None),
      refresh: Ok(None),
      require_alias: Ok(None),
      routing: Ok(None),
      timeout: Ok(None),
      version: Ok(None),
      version_type: Ok(None),
      wait_for_active_shards: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndexPutWithIdIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndexPutWithIdIndex` for index failed".to_string());
    self
  }

  pub fn id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndexPutWithIdId>, {
    self.id = value
      .try_into()
      .map_err(|_| "conversion to `IndexPutWithIdId` for id failed".to_string());
    self
  }

  pub fn if_primary_term<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.if_primary_term = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for if_primary_term failed".to_string());
    self
  }

  pub fn if_seq_no<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.if_seq_no = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for if_seq_no failed".to_string());
    self
  }

  pub fn op_type<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::OpType>, {
    self.op_type = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `OpType` for op_type failed".to_string());
    self
  }

  pub fn pipeline<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.pipeline = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for pipeline failed".to_string());
    self
  }

  pub fn refresh<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::RefreshEnum>, {
    self.refresh = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `RefreshEnum` for refresh failed".to_string());
    self
  }

  pub fn require_alias<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.require_alias = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for require_alias failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for routing failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndexPutWithIdTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndexPutWithIdTimeout` for timeout failed".to_string());
    self
  }

  pub fn version<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.version = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for version failed".to_string());
    self
  }

  pub fn version_type<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::VersionType>, {
    self.version_type = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `VersionType` for version_type failed".to_string());
    self
  }

  pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.wait_for_active_shards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for wait_for_active_shards failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndexBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `IndexBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `PUT` request to `/{index}/_doc/{id}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      id,
      if_primary_term,
      if_seq_no,
      op_type,
      pipeline,
      refresh,
      require_alias,
      routing,
      timeout,
      version,
      version_type,
      wait_for_active_shards,
      body,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let id = id.map_err(Error::InvalidRequest)?;
    let if_primary_term = if_primary_term.map_err(Error::InvalidRequest)?;
    let if_seq_no = if_seq_no.map_err(Error::InvalidRequest)?;
    let op_type = op_type.map_err(Error::InvalidRequest)?;
    let pipeline = pipeline.map_err(Error::InvalidRequest)?;
    let refresh = refresh.map_err(Error::InvalidRequest)?;
    let require_alias = require_alias.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let version = version.map_err(Error::InvalidRequest)?;
    let version_type = version_type.map_err(Error::InvalidRequest)?;
    let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_doc/{}",
      client.baseurl,
      encode_path(&index.to_string()),
      encode_path(&id.to_string()),
    );
    let mut query = Vec::with_capacity(11usize);
    if let Some(v) = &if_primary_term {
      query.push(("if_primary_term", v.to_string()));
    }
    if let Some(v) = &if_seq_no {
      query.push(("if_seq_no", v.to_string()));
    }
    if let Some(v) = &op_type {
      query.push(("op_type", v.to_string()));
    }
    if let Some(v) = &pipeline {
      query.push(("pipeline", v.to_string()));
    }
    if let Some(v) = &refresh {
      query.push(("refresh", v.to_string()));
    }
    if let Some(v) = &require_alias {
      query.push(("require_alias", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &version {
      query.push(("version", v.to_string()));
    }
    if let Some(v) = &version_type {
      query.push(("version_type", v.to_string()));
    }
    if let Some(v) = &wait_for_active_shards {
      query.push(("wait_for_active_shards", v.to_string()));
    }
    let request = client.client.put(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::index_post_with_id`]
///
///[`Client::index_post_with_id`]: super::Client::index_post_with_id
#[derive(Debug, Clone)]
pub struct IndexPost<'a> {
  client: &'a super::Client,
  index: Result<types::IndexPostIndex, String>,
  id: Result<Option<String>, String>,
  if_primary_term: Result<Option<i32>, String>,
  if_seq_no: Result<Option<i32>, String>,
  op_type: Result<Option<types::OpType>, String>,
  pipeline: Result<Option<String>, String>,
  refresh: Result<Option<types::RefreshEnum>, String>,
  require_alias: Result<Option<bool>, String>,
  routing: Result<Option<String>, String>,
  timeout: Result<Option<types::IndexPostTimeout>, String>,
  version: Result<Option<i32>, String>,
  version_type: Result<Option<types::VersionType>, String>,
  wait_for_active_shards: Result<Option<String>, String>,
  body: Result<serde_json::Value, String>,
}

impl<'a> IndexPost<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      id: Ok(None),
      if_primary_term: Ok(None),
      if_seq_no: Ok(None),
      op_type: Ok(None),
      pipeline: Ok(None),
      refresh: Ok(None),
      require_alias: Ok(None),
      routing: Ok(None),
      timeout: Ok(None),
      version: Ok(None),
      version_type: Ok(None),
      wait_for_active_shards: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndexPostIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndexPostIndex` for index failed".to_string());
    self
  }

  pub fn id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.id = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for id failed".to_string());
    self
  }

  pub fn if_primary_term<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.if_primary_term = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for if_primary_term failed".to_string());
    self
  }

  pub fn if_seq_no<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.if_seq_no = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for if_seq_no failed".to_string());
    self
  }

  pub fn op_type<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::OpType>, {
    self.op_type = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `OpType` for op_type failed".to_string());
    self
  }

  pub fn pipeline<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.pipeline = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for pipeline failed".to_string());
    self
  }

  pub fn refresh<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::RefreshEnum>, {
    self.refresh = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `RefreshEnum` for refresh failed".to_string());
    self
  }

  pub fn require_alias<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.require_alias = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for require_alias failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for routing failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndexPostTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndexPostTimeout` for timeout failed".to_string());
    self
  }

  pub fn version<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.version = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for version failed".to_string());
    self
  }

  pub fn version_type<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::VersionType>, {
    self.version_type = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `VersionType` for version_type failed".to_string());
    self
  }

  pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.wait_for_active_shards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for wait_for_active_shards failed".to_string());
    self
  }

  pub fn body<V: Serialize>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<serde_json::Value>, {
    self.body = serde_json::to_value(value).map_err(|_| "conversion to `serde_json:Value` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/{index}/_doc/{id}`
  pub async fn send(self) -> Result<ResponseValue<types::IndexResponse>, Error<()>> {
    let Self {
      client,
      index,
      id,
      if_primary_term,
      if_seq_no,
      op_type,
      pipeline,
      refresh,
      require_alias,
      routing,
      timeout,
      version,
      version_type,
      wait_for_active_shards,
      body,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let id = id.map_err(Error::InvalidRequest)?;
    let if_primary_term = if_primary_term.map_err(Error::InvalidRequest)?;
    let if_seq_no = if_seq_no.map_err(Error::InvalidRequest)?;
    let op_type = op_type.map_err(Error::InvalidRequest)?;
    let pipeline = pipeline.map_err(Error::InvalidRequest)?;
    let refresh = refresh.map_err(Error::InvalidRequest)?;
    let require_alias = require_alias.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let version = version.map_err(Error::InvalidRequest)?;
    let version_type = version_type.map_err(Error::InvalidRequest)?;
    let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = match &id {
      Some(id) => {
        format!(
          "{}/{}/_doc/{}",
          client.baseurl,
          encode_path(&index.to_string()),
          encode_path(&id.to_string()),
        )
      }
      None => format!("{}/{}/_doc", client.baseurl, encode_path(&index.to_string()),),
    };
    let mut query = Vec::with_capacity(11usize);
    if let Some(v) = &if_primary_term {
      query.push(("if_primary_term", v.to_string()));
    }
    if let Some(v) = &if_seq_no {
      query.push(("if_seq_no", v.to_string()));
    }
    if let Some(v) = &op_type {
      query.push(("op_type", v.to_string()));
    }
    if let Some(v) = &pipeline {
      query.push(("pipeline", v.to_string()));
    }
    if let Some(v) = &refresh {
      query.push(("refresh", v.to_string()));
    }
    if let Some(v) = &require_alias {
      query.push(("require_alias", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &version {
      query.push(("version", v.to_string()));
    }
    if let Some(v) = &version_type {
      query.push(("version_type", v.to_string()));
    }
    if let Some(v) = &wait_for_active_shards {
      query.push(("wait_for_active_shards", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::delete`]
///
///[`Client::delete`]: super::Client::delete
#[derive(Debug, Clone)]
pub struct Delete<'a> {
  client: &'a super::Client,
  index: Result<types::DeleteIndex, String>,
  id: Result<types::DeleteId, String>,
  if_primary_term: Result<Option<i32>, String>,
  if_seq_no: Result<Option<i32>, String>,
  refresh: Result<Option<types::RefreshEnum>, String>,
  routing: Result<Option<String>, String>,
  timeout: Result<Option<types::DeleteTimeout>, String>,
  version: Result<Option<i32>, String>,
  version_type: Result<Option<types::VersionType>, String>,
  wait_for_active_shards: Result<Option<String>, String>,
}

impl<'a> Delete<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      id: Err("id was not initialized".to_string()),
      if_primary_term: Ok(None),
      if_seq_no: Ok(None),
      refresh: Ok(None),
      routing: Ok(None),
      timeout: Ok(None),
      version: Ok(None),
      version_type: Ok(None),
      wait_for_active_shards: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::DeleteIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `DeleteIndex` for index failed".to_string());
    self
  }

  pub fn id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::DeleteId>, {
    self.id = value
      .try_into()
      .map_err(|_| "conversion to `DeleteId` for id failed".to_string());
    self
  }

  pub fn if_primary_term<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.if_primary_term = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for if_primary_term failed".to_string());
    self
  }

  pub fn if_seq_no<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.if_seq_no = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for if_seq_no failed".to_string());
    self
  }

  pub fn refresh<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::RefreshEnum>, {
    self.refresh = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `RefreshEnum` for refresh failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for routing failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::DeleteTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `DeleteTimeout` for timeout failed".to_string());
    self
  }

  pub fn version<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.version = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for version failed".to_string());
    self
  }

  pub fn version_type<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::VersionType>, {
    self.version_type = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `VersionType` for version_type failed".to_string());
    self
  }

  pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.wait_for_active_shards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for wait_for_active_shards failed".to_string());
    self
  }

  ///Sends a `DELETE` request to `/{index}/_doc/{id}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      id,
      if_primary_term,
      if_seq_no,
      refresh,
      routing,
      timeout,
      version,
      version_type,
      wait_for_active_shards,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let id = id.map_err(Error::InvalidRequest)?;
    let if_primary_term = if_primary_term.map_err(Error::InvalidRequest)?;
    let if_seq_no = if_seq_no.map_err(Error::InvalidRequest)?;
    let refresh = refresh.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let version = version.map_err(Error::InvalidRequest)?;
    let version_type = version_type.map_err(Error::InvalidRequest)?;
    let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_doc/{}",
      client.baseurl,
      encode_path(&index.to_string()),
      encode_path(&id.to_string()),
    );
    let mut query = Vec::with_capacity(8usize);
    if let Some(v) = &if_primary_term {
      query.push(("if_primary_term", v.to_string()));
    }
    if let Some(v) = &if_seq_no {
      query.push(("if_seq_no", v.to_string()));
    }
    if let Some(v) = &refresh {
      query.push(("refresh", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &version {
      query.push(("version", v.to_string()));
    }
    if let Some(v) = &version_type {
      query.push(("version_type", v.to_string()));
    }
    if let Some(v) = &wait_for_active_shards {
      query.push(("wait_for_active_shards", v.to_string()));
    }
    let request = client.client.delete(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::exists`]
///
///[`Client::exists`]: super::Client::exists
#[derive(Debug, Clone)]
pub struct Exists<'a> {
  client: &'a super::Client,
  index: Result<types::ExistsIndex, String>,
  id: Result<types::ExistsId, String>,
  source: Result<Option<Vec<String>>, String>,
  source_excludes: Result<Option<Vec<String>>, String>,
  source_includes: Result<Option<Vec<String>>, String>,
  preference: Result<Option<String>, String>,
  realtime: Result<Option<bool>, String>,
  refresh: Result<Option<bool>, String>,
  routing: Result<Option<String>, String>,
  stored_fields: Result<Option<Vec<String>>, String>,
  version: Result<Option<i32>, String>,
  version_type: Result<Option<types::VersionType>, String>,
}

impl<'a> Exists<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      id: Err("id was not initialized".to_string()),
      source: Ok(None),
      source_excludes: Ok(None),
      source_includes: Ok(None),
      preference: Ok(None),
      realtime: Ok(None),
      refresh: Ok(None),
      routing: Ok(None),
      stored_fields: Ok(None),
      version: Ok(None),
      version_type: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExistsIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `ExistsIndex` for index failed".to_string());
    self
  }

  pub fn id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExistsId>, {
    self.id = value
      .try_into()
      .map_err(|_| "conversion to `ExistsId` for id failed".to_string());
    self
  }

  pub fn source<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source failed".to_string());
    self
  }

  pub fn source_excludes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source_excludes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source_excludes failed".to_string());
    self
  }

  pub fn source_includes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source_includes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source_includes failed".to_string());
    self
  }

  pub fn preference<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.preference = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for preference failed".to_string());
    self
  }

  pub fn realtime<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.realtime = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for realtime failed".to_string());
    self
  }

  pub fn refresh<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.refresh = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for refresh failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for routing failed".to_string());
    self
  }

  pub fn stored_fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.stored_fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for stored_fields failed".to_string());
    self
  }

  pub fn version<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.version = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for version failed".to_string());
    self
  }

  pub fn version_type<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::VersionType>, {
    self.version_type = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `VersionType` for version_type failed".to_string());
    self
  }

  ///Sends a `HEAD` request to `/{index}/_doc/{id}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      id,
      source,
      source_excludes,
      source_includes,
      preference,
      realtime,
      refresh,
      routing,
      stored_fields,
      version,
      version_type,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let id = id.map_err(Error::InvalidRequest)?;
    let source = source.map_err(Error::InvalidRequest)?;
    let source_excludes = source_excludes.map_err(Error::InvalidRequest)?;
    let source_includes = source_includes.map_err(Error::InvalidRequest)?;
    let preference = preference.map_err(Error::InvalidRequest)?;
    let realtime = realtime.map_err(Error::InvalidRequest)?;
    let refresh = refresh.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let stored_fields = stored_fields.map_err(Error::InvalidRequest)?;
    let version = version.map_err(Error::InvalidRequest)?;
    let version_type = version_type.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_doc/{}",
      client.baseurl,
      encode_path(&index.to_string()),
      encode_path(&id.to_string()),
    );
    let mut query = Vec::with_capacity(10usize);
    if let Some(v) = &source {
      query.push(("_source", v.join(",")));
    }
    if let Some(v) = &source_excludes {
      query.push(("_source_excludes", v.join(",")));
    }
    if let Some(v) = &source_includes {
      query.push(("_source_includes", v.join(",")));
    }
    if let Some(v) = &preference {
      query.push(("preference", v.to_string()));
    }
    if let Some(v) = &realtime {
      query.push(("realtime", v.to_string()));
    }
    if let Some(v) = &refresh {
      query.push(("refresh", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.to_string()));
    }
    if let Some(v) = &stored_fields {
      query.push(("stored_fields", v.join(",")));
    }
    if let Some(v) = &version {
      query.push(("version", v.to_string()));
    }
    if let Some(v) = &version_type {
      query.push(("version_type", v.to_string()));
    }
    let request = client.client.head(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::explain_get`]
///
///[`Client::explain_get`]: super::Client::explain_get
#[derive(Debug, Clone)]
pub struct ExplainGet<'a> {
  client: &'a super::Client,
  index: Result<types::ExplainGetIndex, String>,
  id: Result<types::ExplainGetId, String>,
  source: Result<Option<Vec<String>>, String>,
  source_excludes: Result<Option<Vec<String>>, String>,
  source_includes: Result<Option<Vec<String>>, String>,
  analyze_wildcard: Result<Option<bool>, String>,
  analyzer: Result<Option<String>, String>,
  default_operator: Result<Option<types::DefaultOperator>, String>,
  df: Result<Option<String>, String>,
  lenient: Result<Option<bool>, String>,
  preference: Result<Option<String>, String>,
  q: Result<Option<String>, String>,
  routing: Result<Option<String>, String>,
  stored_fields: Result<Option<Vec<String>>, String>,
}

impl<'a> ExplainGet<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      id: Err("id was not initialized".to_string()),
      source: Ok(None),
      source_excludes: Ok(None),
      source_includes: Ok(None),
      analyze_wildcard: Ok(None),
      analyzer: Ok(None),
      default_operator: Ok(None),
      df: Ok(None),
      lenient: Ok(None),
      preference: Ok(None),
      q: Ok(None),
      routing: Ok(None),
      stored_fields: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExplainGetIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `ExplainGetIndex` for index failed".to_string());
    self
  }

  pub fn id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExplainGetId>, {
    self.id = value
      .try_into()
      .map_err(|_| "conversion to `ExplainGetId` for id failed".to_string());
    self
  }

  pub fn source<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source failed".to_string());
    self
  }

  pub fn source_excludes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source_excludes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source_excludes failed".to_string());
    self
  }

  pub fn source_includes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source_includes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source_includes failed".to_string());
    self
  }

  pub fn analyze_wildcard<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.analyze_wildcard = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for analyze_wildcard failed".to_string());
    self
  }

  pub fn analyzer<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.analyzer = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for analyzer failed".to_string());
    self
  }

  pub fn default_operator<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::DefaultOperator>, {
    self.default_operator = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `DefaultOperator` for default_operator failed".to_string());
    self
  }

  pub fn df<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.df = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for df failed".to_string());
    self
  }

  pub fn lenient<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.lenient = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for lenient failed".to_string());
    self
  }

  pub fn preference<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.preference = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for preference failed".to_string());
    self
  }

  pub fn q<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.q = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for q failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for routing failed".to_string());
    self
  }

  pub fn stored_fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.stored_fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for stored_fields failed".to_string());
    self
  }

  ///Sends a `GET` request to `/{index}/_explain/{id}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      id,
      source,
      source_excludes,
      source_includes,
      analyze_wildcard,
      analyzer,
      default_operator,
      df,
      lenient,
      preference,
      q,
      routing,
      stored_fields,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let id = id.map_err(Error::InvalidRequest)?;
    let source = source.map_err(Error::InvalidRequest)?;
    let source_excludes = source_excludes.map_err(Error::InvalidRequest)?;
    let source_includes = source_includes.map_err(Error::InvalidRequest)?;
    let analyze_wildcard = analyze_wildcard.map_err(Error::InvalidRequest)?;
    let analyzer = analyzer.map_err(Error::InvalidRequest)?;
    let default_operator = default_operator.map_err(Error::InvalidRequest)?;
    let df = df.map_err(Error::InvalidRequest)?;
    let lenient = lenient.map_err(Error::InvalidRequest)?;
    let preference = preference.map_err(Error::InvalidRequest)?;
    let q = q.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let stored_fields = stored_fields.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_explain/{}",
      client.baseurl,
      encode_path(&index.to_string()),
      encode_path(&id.to_string()),
    );
    let mut query = Vec::with_capacity(12usize);
    if let Some(v) = &source {
      query.push(("_source", v.join(",")));
    }
    if let Some(v) = &source_excludes {
      query.push(("_source_excludes", v.join(",")));
    }
    if let Some(v) = &source_includes {
      query.push(("_source_includes", v.join(",")));
    }
    if let Some(v) = &analyze_wildcard {
      query.push(("analyze_wildcard", v.to_string()));
    }
    if let Some(v) = &analyzer {
      query.push(("analyzer", v.to_string()));
    }
    if let Some(v) = &default_operator {
      query.push(("default_operator", v.to_string()));
    }
    if let Some(v) = &df {
      query.push(("df", v.to_string()));
    }
    if let Some(v) = &lenient {
      query.push(("lenient", v.to_string()));
    }
    if let Some(v) = &preference {
      query.push(("preference", v.to_string()));
    }
    if let Some(v) = &q {
      query.push(("q", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.to_string()));
    }
    if let Some(v) = &stored_fields {
      query.push(("stored_fields", v.join(",")));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::explain_post`]
///
///[`Client::explain_post`]: super::Client::explain_post
#[derive(Debug, Clone)]
pub struct ExplainPost<'a> {
  client: &'a super::Client,
  index: Result<types::ExplainPostIndex, String>,
  id: Result<types::ExplainPostId, String>,
  source: Result<Option<Vec<String>>, String>,
  source_excludes: Result<Option<Vec<String>>, String>,
  source_includes: Result<Option<Vec<String>>, String>,
  analyze_wildcard: Result<Option<bool>, String>,
  analyzer: Result<Option<String>, String>,
  default_operator: Result<Option<types::DefaultOperator>, String>,
  df: Result<Option<String>, String>,
  lenient: Result<Option<bool>, String>,
  preference: Result<Option<String>, String>,
  q: Result<Option<String>, String>,
  routing: Result<Option<String>, String>,
  stored_fields: Result<Option<Vec<String>>, String>,
  body: Result<types::ExplainBodyParams, String>,
}

impl<'a> ExplainPost<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      id: Err("id was not initialized".to_string()),
      source: Ok(None),
      source_excludes: Ok(None),
      source_includes: Ok(None),
      analyze_wildcard: Ok(None),
      analyzer: Ok(None),
      default_operator: Ok(None),
      df: Ok(None),
      lenient: Ok(None),
      preference: Ok(None),
      q: Ok(None),
      routing: Ok(None),
      stored_fields: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExplainPostIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `ExplainPostIndex` for index failed".to_string());
    self
  }

  pub fn id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExplainPostId>, {
    self.id = value
      .try_into()
      .map_err(|_| "conversion to `ExplainPostId` for id failed".to_string());
    self
  }

  pub fn source<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source failed".to_string());
    self
  }

  pub fn source_excludes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source_excludes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source_excludes failed".to_string());
    self
  }

  pub fn source_includes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source_includes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source_includes failed".to_string());
    self
  }

  pub fn analyze_wildcard<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.analyze_wildcard = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for analyze_wildcard failed".to_string());
    self
  }

  pub fn analyzer<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.analyzer = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for analyzer failed".to_string());
    self
  }

  pub fn default_operator<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::DefaultOperator>, {
    self.default_operator = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `DefaultOperator` for default_operator failed".to_string());
    self
  }

  pub fn df<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.df = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for df failed".to_string());
    self
  }

  pub fn lenient<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.lenient = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for lenient failed".to_string());
    self
  }

  pub fn preference<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.preference = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for preference failed".to_string());
    self
  }

  pub fn q<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.q = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for q failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for routing failed".to_string());
    self
  }

  pub fn stored_fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.stored_fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for stored_fields failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExplainBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `ExplainBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/{index}/_explain/{id}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      id,
      source,
      source_excludes,
      source_includes,
      analyze_wildcard,
      analyzer,
      default_operator,
      df,
      lenient,
      preference,
      q,
      routing,
      stored_fields,
      body,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let id = id.map_err(Error::InvalidRequest)?;
    let source = source.map_err(Error::InvalidRequest)?;
    let source_excludes = source_excludes.map_err(Error::InvalidRequest)?;
    let source_includes = source_includes.map_err(Error::InvalidRequest)?;
    let analyze_wildcard = analyze_wildcard.map_err(Error::InvalidRequest)?;
    let analyzer = analyzer.map_err(Error::InvalidRequest)?;
    let default_operator = default_operator.map_err(Error::InvalidRequest)?;
    let df = df.map_err(Error::InvalidRequest)?;
    let lenient = lenient.map_err(Error::InvalidRequest)?;
    let preference = preference.map_err(Error::InvalidRequest)?;
    let q = q.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let stored_fields = stored_fields.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_explain/{}",
      client.baseurl,
      encode_path(&index.to_string()),
      encode_path(&id.to_string()),
    );
    let mut query = Vec::with_capacity(12usize);
    if let Some(v) = &source {
      query.push(("_source", v.join(",")));
    }
    if let Some(v) = &source_excludes {
      query.push(("_source_excludes", v.join(",")));
    }
    if let Some(v) = &source_includes {
      query.push(("_source_includes", v.join(",")));
    }
    if let Some(v) = &analyze_wildcard {
      query.push(("analyze_wildcard", v.to_string()));
    }
    if let Some(v) = &analyzer {
      query.push(("analyzer", v.to_string()));
    }
    if let Some(v) = &default_operator {
      query.push(("default_operator", v.to_string()));
    }
    if let Some(v) = &df {
      query.push(("df", v.to_string()));
    }
    if let Some(v) = &lenient {
      query.push(("lenient", v.to_string()));
    }
    if let Some(v) = &preference {
      query.push(("preference", v.to_string()));
    }
    if let Some(v) = &q {
      query.push(("q", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.to_string()));
    }
    if let Some(v) = &stored_fields {
      query.push(("stored_fields", v.join(",")));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::field_caps_get_with_index`]
///
///[`Client::field_caps_get_with_index`]: super::Client::field_caps_get_with_index
#[derive(Debug, Clone)]
pub struct FieldCapsGetWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::FieldCapsGetWithIndexIndex, String>,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  fields: Result<Option<Vec<String>>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  include_unmapped: Result<Option<bool>, String>,
}

impl<'a> FieldCapsGetWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      fields: Ok(None),
      ignore_unavailable: Ok(None),
      include_unmapped: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::FieldCapsGetWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `FieldCapsGetWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn include_unmapped<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.include_unmapped = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for include_unmapped failed".to_string());
    self
  }

  ///Sends a `GET` request to `/{index}/_field_caps`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      allow_no_indices,
      expand_wildcards,
      fields,
      ignore_unavailable,
      include_unmapped,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let fields = fields.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let include_unmapped = include_unmapped.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}/_field_caps", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(5usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &fields {
      query.push(("fields", v.join(",")));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &include_unmapped {
      query.push(("include_unmapped", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::field_caps_post_with_index`]
///
///[`Client::field_caps_post_with_index`]: super::Client::field_caps_post_with_index
#[derive(Debug, Clone)]
pub struct FieldCapsPostWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::FieldCapsPostWithIndexIndex, String>,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  fields: Result<Option<Vec<String>>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  include_unmapped: Result<Option<bool>, String>,
  body: Result<types::FieldCapsBodyParams, String>,
}

impl<'a> FieldCapsPostWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      fields: Ok(None),
      ignore_unavailable: Ok(None),
      include_unmapped: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::FieldCapsPostWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `FieldCapsPostWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn include_unmapped<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.include_unmapped = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for include_unmapped failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::FieldCapsBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `FieldCapsBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/{index}/_field_caps`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      allow_no_indices,
      expand_wildcards,
      fields,
      ignore_unavailable,
      include_unmapped,
      body,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let fields = fields.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let include_unmapped = include_unmapped.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}/_field_caps", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(5usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &fields {
      query.push(("fields", v.join(",")));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &include_unmapped {
      query.push(("include_unmapped", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_flush_get_with_index`]
///
///[`Client::indices_flush_get_with_index`]: super::Client::indices_flush_get_with_index
#[derive(Debug, Clone)]
pub struct IndicesFlushGetWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesFlushGetWithIndexIndex, String>,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  force: Result<Option<bool>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  wait_if_ongoing: Result<Option<bool>, String>,
}

impl<'a> IndicesFlushGetWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      force: Ok(None),
      ignore_unavailable: Ok(None),
      wait_if_ongoing: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesFlushGetWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesFlushGetWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn force<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.force = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for force failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn wait_if_ongoing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.wait_if_ongoing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for wait_if_ongoing failed".to_string());
    self
  }

  ///Sends a `GET` request to `/{index}/_flush`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      allow_no_indices,
      expand_wildcards,
      force,
      ignore_unavailable,
      wait_if_ongoing,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let force = force.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let wait_if_ongoing = wait_if_ongoing.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}/_flush", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(5usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &force {
      query.push(("force", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &wait_if_ongoing {
      query.push(("wait_if_ongoing", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_flush_post_with_index`]
///
///[`Client::indices_flush_post_with_index`]: super::Client::indices_flush_post_with_index
#[derive(Debug, Clone)]
pub struct IndicesFlushPostWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesFlushPostWithIndexIndex, String>,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  force: Result<Option<bool>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  wait_if_ongoing: Result<Option<bool>, String>,
}

impl<'a> IndicesFlushPostWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      force: Ok(None),
      ignore_unavailable: Ok(None),
      wait_if_ongoing: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesFlushPostWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesFlushPostWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn force<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.force = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for force failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn wait_if_ongoing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.wait_if_ongoing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for wait_if_ongoing failed".to_string());
    self
  }

  ///Sends a `POST` request to `/{index}/_flush`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      allow_no_indices,
      expand_wildcards,
      force,
      ignore_unavailable,
      wait_if_ongoing,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let force = force.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let wait_if_ongoing = wait_if_ongoing.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}/_flush", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(5usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &force {
      query.push(("force", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &wait_if_ongoing {
      query.push(("wait_if_ongoing", v.to_string()));
    }
    let request = client.client.post(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_forcemerge_with_index`]
///
///[`Client::indices_forcemerge_with_index`]: super::Client::indices_forcemerge_with_index
#[derive(Debug, Clone)]
pub struct IndicesForcemergeWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesForcemergeWithIndexIndex, String>,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  flush: Result<Option<bool>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  max_num_segments: Result<Option<i32>, String>,
  only_expunge_deletes: Result<Option<bool>, String>,
}

impl<'a> IndicesForcemergeWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      flush: Ok(None),
      ignore_unavailable: Ok(None),
      max_num_segments: Ok(None),
      only_expunge_deletes: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesForcemergeWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesForcemergeWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn flush<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.flush = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for flush failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn max_num_segments<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.max_num_segments = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for max_num_segments failed".to_string());
    self
  }

  pub fn only_expunge_deletes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.only_expunge_deletes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for only_expunge_deletes failed".to_string());
    self
  }

  ///Sends a `POST` request to `/{index}/_forcemerge`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      allow_no_indices,
      expand_wildcards,
      flush,
      ignore_unavailable,
      max_num_segments,
      only_expunge_deletes,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let flush = flush.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let max_num_segments = max_num_segments.map_err(Error::InvalidRequest)?;
    let only_expunge_deletes = only_expunge_deletes.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}/_forcemerge", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(6usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &flush {
      query.push(("flush", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &max_num_segments {
      query.push(("max_num_segments", v.to_string()));
    }
    if let Some(v) = &only_expunge_deletes {
      query.push(("only_expunge_deletes", v.to_string()));
    }
    let request = client.client.post(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_get_mapping_with_index`]
///
///[`Client::indices_get_mapping_with_index`]: super::Client::indices_get_mapping_with_index
#[derive(Debug, Clone)]
pub struct IndicesGetMappingWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesGetMappingWithIndexIndex, String>,
  allow_no_indices: Result<Option<bool>, String>,
  cluster_manager_timeout: Result<Option<types::IndicesGetMappingWithIndexClusterManagerTimeout>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::IndicesGetMappingWithIndexMasterTimeout>, String>,
}

impl<'a> IndicesGetMappingWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      allow_no_indices: Ok(None),
      cluster_manager_timeout: Ok(None),
      expand_wildcards: Ok(None),
      ignore_unavailable: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesGetMappingWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesGetMappingWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesGetMappingWithIndexClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesGetMappingWithIndexClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesGetMappingWithIndexMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesGetMappingWithIndexMasterTimeout` for master_timeout failed".to_string());
    self
  }

  ///Sends a `GET` request to `/{index}/_mapping`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      allow_no_indices,
      cluster_manager_timeout,
      expand_wildcards,
      ignore_unavailable,
      local,
      master_timeout,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}/_mapping", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(6usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_put_mapping_put`]
///
///[`Client::indices_put_mapping_put`]: super::Client::indices_put_mapping_put
#[derive(Debug, Clone)]
pub struct IndicesPutMappingPut<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesPutMappingPutIndex, String>,
  allow_no_indices: Result<Option<bool>, String>,
  cluster_manager_timeout: Result<Option<types::IndicesPutMappingPutClusterManagerTimeout>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::IndicesPutMappingPutMasterTimeout>, String>,
  timeout: Result<Option<types::IndicesPutMappingPutTimeout>, String>,
  write_index_only: Result<Option<bool>, String>,
  body: Result<types::IndicesPutMappingBodyParams, String>,
}

impl<'a> IndicesPutMappingPut<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      allow_no_indices: Ok(None),
      cluster_manager_timeout: Ok(None),
      expand_wildcards: Ok(None),
      ignore_unavailable: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
      write_index_only: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutMappingPutIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesPutMappingPutIndex` for index failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutMappingPutClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesPutMappingPutClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutMappingPutMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesPutMappingPutMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutMappingPutTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesPutMappingPutTimeout` for timeout failed".to_string());
    self
  }

  pub fn write_index_only<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.write_index_only = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for write_index_only failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutMappingBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `IndicesPutMappingBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `PUT` request to `/{index}/_mapping`
  pub async fn send(self) -> Result<ResponseValue<types::IndicesPutMappingPutResponseContent>, Error<()>> {
    let Self {
      client,
      index,
      allow_no_indices,
      cluster_manager_timeout,
      expand_wildcards,
      ignore_unavailable,
      master_timeout,
      timeout,
      write_index_only,
      body,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let write_index_only = write_index_only.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}/_mapping", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(7usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &write_index_only {
      query.push(("write_index_only", v.to_string()));
    }
    let request = client
      .client
      .put(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .json(&body)
      .query(&query)
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_put_mapping_post`]
///
///[`Client::indices_put_mapping_post`]: super::Client::indices_put_mapping_post
#[derive(Debug, Clone)]
pub struct IndicesPutMappingPost<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesPutMappingPostIndex, String>,
  allow_no_indices: Result<Option<bool>, String>,
  cluster_manager_timeout: Result<Option<types::IndicesPutMappingPostClusterManagerTimeout>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::IndicesPutMappingPostMasterTimeout>, String>,
  timeout: Result<Option<types::IndicesPutMappingPostTimeout>, String>,
  write_index_only: Result<Option<bool>, String>,
  body: Result<types::IndicesPutMappingBodyParams, String>,
}

impl<'a> IndicesPutMappingPost<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      allow_no_indices: Ok(None),
      cluster_manager_timeout: Ok(None),
      expand_wildcards: Ok(None),
      ignore_unavailable: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
      write_index_only: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutMappingPostIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesPutMappingPostIndex` for index failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutMappingPostClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesPutMappingPostClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutMappingPostMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesPutMappingPostMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutMappingPostTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesPutMappingPostTimeout` for timeout failed".to_string());
    self
  }

  pub fn write_index_only<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.write_index_only = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for write_index_only failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutMappingBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `IndicesPutMappingBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/{index}/_mapping`
  pub async fn send(self) -> Result<ResponseValue<types::IndicesPutMappingPostResponseContent>, Error<()>> {
    let Self {
      client,
      index,
      allow_no_indices,
      cluster_manager_timeout,
      expand_wildcards,
      ignore_unavailable,
      master_timeout,
      timeout,
      write_index_only,
      body,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let write_index_only = write_index_only.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}/_mapping", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(7usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &write_index_only {
      query.push(("write_index_only", v.to_string()));
    }
    let request = client
      .client
      .post(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .json(&body)
      .query(&query)
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_get_field_mapping_with_index`]
///
///[`Client::indices_get_field_mapping_with_index`]: super::Client::indices_get_field_mapping_with_index
#[derive(Debug, Clone)]
pub struct IndicesGetFieldMappingWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesGetFieldMappingWithIndexIndex, String>,
  fields: Result<types::IndicesGetFieldMappingWithIndexFields, String>,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  include_defaults: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
}

impl<'a> IndicesGetFieldMappingWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      fields: Err("fields was not initialized".to_string()),
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      ignore_unavailable: Ok(None),
      include_defaults: Ok(None),
      local: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesGetFieldMappingWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesGetFieldMappingWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesGetFieldMappingWithIndexFields>, {
    self.fields = value
      .try_into()
      .map_err(|_| "conversion to `IndicesGetFieldMappingWithIndexFields` for fields failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn include_defaults<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.include_defaults = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for include_defaults failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  ///Sends a `GET` request to `/{index}/_mapping/field/{fields}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      fields,
      allow_no_indices,
      expand_wildcards,
      ignore_unavailable,
      include_defaults,
      local,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let fields = fields.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let include_defaults = include_defaults.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_mapping/field/{}",
      client.baseurl,
      encode_path(&index.to_string()),
      encode_path(&fields.to_string()),
    );
    let mut query = Vec::with_capacity(5usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &include_defaults {
      query.push(("include_defaults", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::mget_get_with_index`]
///
///[`Client::mget_get_with_index`]: super::Client::mget_get_with_index
#[derive(Debug, Clone)]
pub struct MgetGetWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::MgetGetWithIndexIndex, String>,
  source: Result<Option<Vec<String>>, String>,
  source_excludes: Result<Option<Vec<String>>, String>,
  source_includes: Result<Option<Vec<String>>, String>,
  preference: Result<Option<String>, String>,
  realtime: Result<Option<bool>, String>,
  refresh: Result<Option<bool>, String>,
  routing: Result<Option<String>, String>,
  stored_fields: Result<Option<Vec<String>>, String>,
}

impl<'a> MgetGetWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      source: Ok(None),
      source_excludes: Ok(None),
      source_includes: Ok(None),
      preference: Ok(None),
      realtime: Ok(None),
      refresh: Ok(None),
      routing: Ok(None),
      stored_fields: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::MgetGetWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `MgetGetWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn source<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source failed".to_string());
    self
  }

  pub fn source_excludes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source_excludes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source_excludes failed".to_string());
    self
  }

  pub fn source_includes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source_includes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source_includes failed".to_string());
    self
  }

  pub fn preference<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.preference = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for preference failed".to_string());
    self
  }

  pub fn realtime<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.realtime = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for realtime failed".to_string());
    self
  }

  pub fn refresh<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.refresh = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for refresh failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for routing failed".to_string());
    self
  }

  pub fn stored_fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.stored_fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for stored_fields failed".to_string());
    self
  }

  ///Sends a `GET` request to `/{index}/_mget`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      source,
      source_excludes,
      source_includes,
      preference,
      realtime,
      refresh,
      routing,
      stored_fields,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let source = source.map_err(Error::InvalidRequest)?;
    let source_excludes = source_excludes.map_err(Error::InvalidRequest)?;
    let source_includes = source_includes.map_err(Error::InvalidRequest)?;
    let preference = preference.map_err(Error::InvalidRequest)?;
    let realtime = realtime.map_err(Error::InvalidRequest)?;
    let refresh = refresh.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let stored_fields = stored_fields.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}/_mget", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(8usize);
    if let Some(v) = &source {
      query.push(("_source", v.join(",")));
    }
    if let Some(v) = &source_excludes {
      query.push(("_source_excludes", v.join(",")));
    }
    if let Some(v) = &source_includes {
      query.push(("_source_includes", v.join(",")));
    }
    if let Some(v) = &preference {
      query.push(("preference", v.to_string()));
    }
    if let Some(v) = &realtime {
      query.push(("realtime", v.to_string()));
    }
    if let Some(v) = &refresh {
      query.push(("refresh", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.to_string()));
    }
    if let Some(v) = &stored_fields {
      query.push(("stored_fields", v.join(",")));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::mget_post_with_index`]
///
///[`Client::mget_post_with_index`]: super::Client::mget_post_with_index
#[derive(Debug, Clone)]
pub struct MgetPostWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::MgetPostWithIndexIndex, String>,
  source: Result<Option<Vec<String>>, String>,
  source_excludes: Result<Option<Vec<String>>, String>,
  source_includes: Result<Option<Vec<String>>, String>,
  preference: Result<Option<String>, String>,
  realtime: Result<Option<bool>, String>,
  refresh: Result<Option<bool>, String>,
  routing: Result<Option<String>, String>,
  stored_fields: Result<Option<Vec<String>>, String>,
  body: Result<types::MgetBodyParams, String>,
}

impl<'a> MgetPostWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      source: Ok(None),
      source_excludes: Ok(None),
      source_includes: Ok(None),
      preference: Ok(None),
      realtime: Ok(None),
      refresh: Ok(None),
      routing: Ok(None),
      stored_fields: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::MgetPostWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `MgetPostWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn source<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source failed".to_string());
    self
  }

  pub fn source_excludes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source_excludes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source_excludes failed".to_string());
    self
  }

  pub fn source_includes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source_includes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source_includes failed".to_string());
    self
  }

  pub fn preference<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.preference = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for preference failed".to_string());
    self
  }

  pub fn realtime<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.realtime = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for realtime failed".to_string());
    self
  }

  pub fn refresh<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.refresh = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for refresh failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for routing failed".to_string());
    self
  }

  pub fn stored_fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.stored_fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for stored_fields failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::MgetBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `MgetBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/{index}/_mget`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      source,
      source_excludes,
      source_includes,
      preference,
      realtime,
      refresh,
      routing,
      stored_fields,
      body,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let source = source.map_err(Error::InvalidRequest)?;
    let source_excludes = source_excludes.map_err(Error::InvalidRequest)?;
    let source_includes = source_includes.map_err(Error::InvalidRequest)?;
    let preference = preference.map_err(Error::InvalidRequest)?;
    let realtime = realtime.map_err(Error::InvalidRequest)?;
    let refresh = refresh.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let stored_fields = stored_fields.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}/_mget", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(8usize);
    if let Some(v) = &source {
      query.push(("_source", v.join(",")));
    }
    if let Some(v) = &source_excludes {
      query.push(("_source_excludes", v.join(",")));
    }
    if let Some(v) = &source_includes {
      query.push(("_source_includes", v.join(",")));
    }
    if let Some(v) = &preference {
      query.push(("preference", v.to_string()));
    }
    if let Some(v) = &realtime {
      query.push(("realtime", v.to_string()));
    }
    if let Some(v) = &refresh {
      query.push(("refresh", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.to_string()));
    }
    if let Some(v) = &stored_fields {
      query.push(("stored_fields", v.join(",")));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::msearch_get_with_index`]
///
///[`Client::msearch_get_with_index`]: super::Client::msearch_get_with_index
#[derive(Debug, Clone)]
pub struct MsearchGetWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::MsearchGetWithIndexIndex, String>,
  ccs_minimize_roundtrips: Result<Option<bool>, String>,
  max_concurrent_searches: Result<Option<i32>, String>,
  max_concurrent_shard_requests: Result<Option<i32>, String>,
  pre_filter_shard_size: Result<Option<i32>, String>,
  rest_total_hits_as_int: Result<Option<bool>, String>,
  search_type: Result<Option<types::SearchTypeMulti>, String>,
  typed_keys: Result<Option<bool>, String>,
}

impl<'a> MsearchGetWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      ccs_minimize_roundtrips: Ok(None),
      max_concurrent_searches: Ok(None),
      max_concurrent_shard_requests: Ok(None),
      pre_filter_shard_size: Ok(None),
      rest_total_hits_as_int: Ok(None),
      search_type: Ok(None),
      typed_keys: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::MsearchGetWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `MsearchGetWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn ccs_minimize_roundtrips<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ccs_minimize_roundtrips = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ccs_minimize_roundtrips failed".to_string());
    self
  }

  pub fn max_concurrent_searches<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.max_concurrent_searches = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for max_concurrent_searches failed".to_string());
    self
  }

  pub fn max_concurrent_shard_requests<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.max_concurrent_shard_requests = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for max_concurrent_shard_requests failed".to_string());
    self
  }

  pub fn pre_filter_shard_size<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.pre_filter_shard_size = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for pre_filter_shard_size failed".to_string());
    self
  }

  pub fn rest_total_hits_as_int<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.rest_total_hits_as_int = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for rest_total_hits_as_int failed".to_string());
    self
  }

  pub fn search_type<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SearchTypeMulti>, {
    self.search_type = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SearchTypeMulti` for search_type failed".to_string());
    self
  }

  pub fn typed_keys<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.typed_keys = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for typed_keys failed".to_string());
    self
  }

  ///Sends a `GET` request to `/{index}/_msearch`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      ccs_minimize_roundtrips,
      max_concurrent_searches,
      max_concurrent_shard_requests,
      pre_filter_shard_size,
      rest_total_hits_as_int,
      search_type,
      typed_keys,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let ccs_minimize_roundtrips = ccs_minimize_roundtrips.map_err(Error::InvalidRequest)?;
    let max_concurrent_searches = max_concurrent_searches.map_err(Error::InvalidRequest)?;
    let max_concurrent_shard_requests = max_concurrent_shard_requests.map_err(Error::InvalidRequest)?;
    let pre_filter_shard_size = pre_filter_shard_size.map_err(Error::InvalidRequest)?;
    let rest_total_hits_as_int = rest_total_hits_as_int.map_err(Error::InvalidRequest)?;
    let search_type = search_type.map_err(Error::InvalidRequest)?;
    let typed_keys = typed_keys.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}/_msearch", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(7usize);
    if let Some(v) = &ccs_minimize_roundtrips {
      query.push(("ccs_minimize_roundtrips", v.to_string()));
    }
    if let Some(v) = &max_concurrent_searches {
      query.push(("max_concurrent_searches", v.to_string()));
    }
    if let Some(v) = &max_concurrent_shard_requests {
      query.push(("max_concurrent_shard_requests", v.to_string()));
    }
    if let Some(v) = &pre_filter_shard_size {
      query.push(("pre_filter_shard_size", v.to_string()));
    }
    if let Some(v) = &rest_total_hits_as_int {
      query.push(("rest_total_hits_as_int", v.to_string()));
    }
    if let Some(v) = &search_type {
      query.push(("search_type", v.to_string()));
    }
    if let Some(v) = &typed_keys {
      query.push(("typed_keys", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::msearch_post_with_index`]
///
///[`Client::msearch_post_with_index`]: super::Client::msearch_post_with_index
#[derive(Debug, Clone)]
pub struct MsearchPostWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::MsearchPostWithIndexIndex, String>,
  ccs_minimize_roundtrips: Result<Option<bool>, String>,
  max_concurrent_searches: Result<Option<i32>, String>,
  max_concurrent_shard_requests: Result<Option<i32>, String>,
  pre_filter_shard_size: Result<Option<i32>, String>,
  rest_total_hits_as_int: Result<Option<bool>, String>,
  search_type: Result<Option<types::SearchTypeMulti>, String>,
  typed_keys: Result<Option<bool>, String>,
  body: Result<types::MsearchBodyParams, String>,
}

impl<'a> MsearchPostWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      ccs_minimize_roundtrips: Ok(None),
      max_concurrent_searches: Ok(None),
      max_concurrent_shard_requests: Ok(None),
      pre_filter_shard_size: Ok(None),
      rest_total_hits_as_int: Ok(None),
      search_type: Ok(None),
      typed_keys: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::MsearchPostWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `MsearchPostWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn ccs_minimize_roundtrips<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ccs_minimize_roundtrips = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ccs_minimize_roundtrips failed".to_string());
    self
  }

  pub fn max_concurrent_searches<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.max_concurrent_searches = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for max_concurrent_searches failed".to_string());
    self
  }

  pub fn max_concurrent_shard_requests<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.max_concurrent_shard_requests = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for max_concurrent_shard_requests failed".to_string());
    self
  }

  pub fn pre_filter_shard_size<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.pre_filter_shard_size = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for pre_filter_shard_size failed".to_string());
    self
  }

  pub fn rest_total_hits_as_int<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.rest_total_hits_as_int = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for rest_total_hits_as_int failed".to_string());
    self
  }

  pub fn search_type<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SearchTypeMulti>, {
    self.search_type = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SearchTypeMulti` for search_type failed".to_string());
    self
  }

  pub fn typed_keys<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.typed_keys = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for typed_keys failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::MsearchBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `MsearchBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/{index}/_msearch`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      ccs_minimize_roundtrips,
      max_concurrent_searches,
      max_concurrent_shard_requests,
      pre_filter_shard_size,
      rest_total_hits_as_int,
      search_type,
      typed_keys,
      body,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let ccs_minimize_roundtrips = ccs_minimize_roundtrips.map_err(Error::InvalidRequest)?;
    let max_concurrent_searches = max_concurrent_searches.map_err(Error::InvalidRequest)?;
    let max_concurrent_shard_requests = max_concurrent_shard_requests.map_err(Error::InvalidRequest)?;
    let pre_filter_shard_size = pre_filter_shard_size.map_err(Error::InvalidRequest)?;
    let rest_total_hits_as_int = rest_total_hits_as_int.map_err(Error::InvalidRequest)?;
    let search_type = search_type.map_err(Error::InvalidRequest)?;
    let typed_keys = typed_keys.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}/_msearch", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(7usize);
    if let Some(v) = &ccs_minimize_roundtrips {
      query.push(("ccs_minimize_roundtrips", v.to_string()));
    }
    if let Some(v) = &max_concurrent_searches {
      query.push(("max_concurrent_searches", v.to_string()));
    }
    if let Some(v) = &max_concurrent_shard_requests {
      query.push(("max_concurrent_shard_requests", v.to_string()));
    }
    if let Some(v) = &pre_filter_shard_size {
      query.push(("pre_filter_shard_size", v.to_string()));
    }
    if let Some(v) = &rest_total_hits_as_int {
      query.push(("rest_total_hits_as_int", v.to_string()));
    }
    if let Some(v) = &search_type {
      query.push(("search_type", v.to_string()));
    }
    if let Some(v) = &typed_keys {
      query.push(("typed_keys", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::msearch_template_get_with_index`]
///
///[`Client::msearch_template_get_with_index`]: super::Client::msearch_template_get_with_index
#[derive(Debug, Clone)]
pub struct MsearchTemplateGetWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::MsearchTemplateGetWithIndexIndex, String>,
  ccs_minimize_roundtrips: Result<Option<bool>, String>,
  max_concurrent_searches: Result<Option<i32>, String>,
  rest_total_hits_as_int: Result<Option<bool>, String>,
  search_type: Result<Option<types::SearchTypeMulti>, String>,
  typed_keys: Result<Option<bool>, String>,
}

impl<'a> MsearchTemplateGetWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      ccs_minimize_roundtrips: Ok(None),
      max_concurrent_searches: Ok(None),
      rest_total_hits_as_int: Ok(None),
      search_type: Ok(None),
      typed_keys: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::MsearchTemplateGetWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `MsearchTemplateGetWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn ccs_minimize_roundtrips<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ccs_minimize_roundtrips = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ccs_minimize_roundtrips failed".to_string());
    self
  }

  pub fn max_concurrent_searches<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.max_concurrent_searches = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for max_concurrent_searches failed".to_string());
    self
  }

  pub fn rest_total_hits_as_int<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.rest_total_hits_as_int = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for rest_total_hits_as_int failed".to_string());
    self
  }

  pub fn search_type<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SearchTypeMulti>, {
    self.search_type = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SearchTypeMulti` for search_type failed".to_string());
    self
  }

  pub fn typed_keys<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.typed_keys = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for typed_keys failed".to_string());
    self
  }

  ///Sends a `GET` request to `/{index}/_msearch/template`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      ccs_minimize_roundtrips,
      max_concurrent_searches,
      rest_total_hits_as_int,
      search_type,
      typed_keys,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let ccs_minimize_roundtrips = ccs_minimize_roundtrips.map_err(Error::InvalidRequest)?;
    let max_concurrent_searches = max_concurrent_searches.map_err(Error::InvalidRequest)?;
    let rest_total_hits_as_int = rest_total_hits_as_int.map_err(Error::InvalidRequest)?;
    let search_type = search_type.map_err(Error::InvalidRequest)?;
    let typed_keys = typed_keys.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_msearch/template",
      client.baseurl,
      encode_path(&index.to_string()),
    );
    let mut query = Vec::with_capacity(5usize);
    if let Some(v) = &ccs_minimize_roundtrips {
      query.push(("ccs_minimize_roundtrips", v.to_string()));
    }
    if let Some(v) = &max_concurrent_searches {
      query.push(("max_concurrent_searches", v.to_string()));
    }
    if let Some(v) = &rest_total_hits_as_int {
      query.push(("rest_total_hits_as_int", v.to_string()));
    }
    if let Some(v) = &search_type {
      query.push(("search_type", v.to_string()));
    }
    if let Some(v) = &typed_keys {
      query.push(("typed_keys", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::msearch_template_post_with_index`]
///
///[`Client::msearch_template_post_with_index`]: super::Client::msearch_template_post_with_index
#[derive(Debug, Clone)]
pub struct MsearchTemplatePostWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::MsearchTemplatePostWithIndexIndex, String>,
  ccs_minimize_roundtrips: Result<Option<bool>, String>,
  max_concurrent_searches: Result<Option<i32>, String>,
  rest_total_hits_as_int: Result<Option<bool>, String>,
  search_type: Result<Option<types::SearchTypeMulti>, String>,
  typed_keys: Result<Option<bool>, String>,
  body: Result<types::MsearchTemplateBodyParams, String>,
}

impl<'a> MsearchTemplatePostWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      ccs_minimize_roundtrips: Ok(None),
      max_concurrent_searches: Ok(None),
      rest_total_hits_as_int: Ok(None),
      search_type: Ok(None),
      typed_keys: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::MsearchTemplatePostWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `MsearchTemplatePostWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn ccs_minimize_roundtrips<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ccs_minimize_roundtrips = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ccs_minimize_roundtrips failed".to_string());
    self
  }

  pub fn max_concurrent_searches<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.max_concurrent_searches = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for max_concurrent_searches failed".to_string());
    self
  }

  pub fn rest_total_hits_as_int<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.rest_total_hits_as_int = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for rest_total_hits_as_int failed".to_string());
    self
  }

  pub fn search_type<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SearchTypeMulti>, {
    self.search_type = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SearchTypeMulti` for search_type failed".to_string());
    self
  }

  pub fn typed_keys<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.typed_keys = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for typed_keys failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::MsearchTemplateBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `MsearchTemplateBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/{index}/_msearch/template`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      ccs_minimize_roundtrips,
      max_concurrent_searches,
      rest_total_hits_as_int,
      search_type,
      typed_keys,
      body,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let ccs_minimize_roundtrips = ccs_minimize_roundtrips.map_err(Error::InvalidRequest)?;
    let max_concurrent_searches = max_concurrent_searches.map_err(Error::InvalidRequest)?;
    let rest_total_hits_as_int = rest_total_hits_as_int.map_err(Error::InvalidRequest)?;
    let search_type = search_type.map_err(Error::InvalidRequest)?;
    let typed_keys = typed_keys.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_msearch/template",
      client.baseurl,
      encode_path(&index.to_string()),
    );
    let mut query = Vec::with_capacity(5usize);
    if let Some(v) = &ccs_minimize_roundtrips {
      query.push(("ccs_minimize_roundtrips", v.to_string()));
    }
    if let Some(v) = &max_concurrent_searches {
      query.push(("max_concurrent_searches", v.to_string()));
    }
    if let Some(v) = &rest_total_hits_as_int {
      query.push(("rest_total_hits_as_int", v.to_string()));
    }
    if let Some(v) = &search_type {
      query.push(("search_type", v.to_string()));
    }
    if let Some(v) = &typed_keys {
      query.push(("typed_keys", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::mtermvectors_get_with_index`]
///
///[`Client::mtermvectors_get_with_index`]: super::Client::mtermvectors_get_with_index
#[derive(Debug, Clone)]
pub struct MtermvectorsGetWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::MtermvectorsGetWithIndexIndex, String>,
  field_statistics: Result<Option<bool>, String>,
  fields: Result<Option<Vec<String>>, String>,
  ids: Result<Option<Vec<String>>, String>,
  offsets: Result<Option<bool>, String>,
  payloads: Result<Option<bool>, String>,
  positions: Result<Option<bool>, String>,
  preference: Result<Option<String>, String>,
  realtime: Result<Option<bool>, String>,
  routing: Result<Option<String>, String>,
  term_statistics: Result<Option<bool>, String>,
  version: Result<Option<i32>, String>,
  version_type: Result<Option<types::VersionType>, String>,
}

impl<'a> MtermvectorsGetWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      field_statistics: Ok(None),
      fields: Ok(None),
      ids: Ok(None),
      offsets: Ok(None),
      payloads: Ok(None),
      positions: Ok(None),
      preference: Ok(None),
      realtime: Ok(None),
      routing: Ok(None),
      term_statistics: Ok(None),
      version: Ok(None),
      version_type: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::MtermvectorsGetWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `MtermvectorsGetWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn field_statistics<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.field_statistics = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for field_statistics failed".to_string());
    self
  }

  pub fn fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
    self
  }

  pub fn ids<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.ids = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for ids failed".to_string());
    self
  }

  pub fn offsets<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.offsets = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for offsets failed".to_string());
    self
  }

  pub fn payloads<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.payloads = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for payloads failed".to_string());
    self
  }

  pub fn positions<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.positions = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for positions failed".to_string());
    self
  }

  pub fn preference<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.preference = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for preference failed".to_string());
    self
  }

  pub fn realtime<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.realtime = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for realtime failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for routing failed".to_string());
    self
  }

  pub fn term_statistics<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.term_statistics = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for term_statistics failed".to_string());
    self
  }

  pub fn version<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.version = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for version failed".to_string());
    self
  }

  pub fn version_type<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::VersionType>, {
    self.version_type = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `VersionType` for version_type failed".to_string());
    self
  }

  ///Sends a `GET` request to `/{index}/_mtermvectors`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      field_statistics,
      fields,
      ids,
      offsets,
      payloads,
      positions,
      preference,
      realtime,
      routing,
      term_statistics,
      version,
      version_type,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let field_statistics = field_statistics.map_err(Error::InvalidRequest)?;
    let fields = fields.map_err(Error::InvalidRequest)?;
    let ids = ids.map_err(Error::InvalidRequest)?;
    let offsets = offsets.map_err(Error::InvalidRequest)?;
    let payloads = payloads.map_err(Error::InvalidRequest)?;
    let positions = positions.map_err(Error::InvalidRequest)?;
    let preference = preference.map_err(Error::InvalidRequest)?;
    let realtime = realtime.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let term_statistics = term_statistics.map_err(Error::InvalidRequest)?;
    let version = version.map_err(Error::InvalidRequest)?;
    let version_type = version_type.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}/_mtermvectors", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(12usize);
    if let Some(v) = &field_statistics {
      query.push(("field_statistics", v.to_string()));
    }
    if let Some(v) = &fields {
      query.push(("fields", v.join(",")));
    }
    if let Some(v) = &ids {
      query.push(("ids", v.join(",")));
    }
    if let Some(v) = &offsets {
      query.push(("offsets", v.to_string()));
    }
    if let Some(v) = &payloads {
      query.push(("payloads", v.to_string()));
    }
    if let Some(v) = &positions {
      query.push(("positions", v.to_string()));
    }
    if let Some(v) = &preference {
      query.push(("preference", v.to_string()));
    }
    if let Some(v) = &realtime {
      query.push(("realtime", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.to_string()));
    }
    if let Some(v) = &term_statistics {
      query.push(("term_statistics", v.to_string()));
    }
    if let Some(v) = &version {
      query.push(("version", v.to_string()));
    }
    if let Some(v) = &version_type {
      query.push(("version_type", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::mtermvectors_post_with_index`]
///
///[`Client::mtermvectors_post_with_index`]: super::Client::mtermvectors_post_with_index
#[derive(Debug, Clone)]
pub struct MtermvectorsPostWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::MtermvectorsPostWithIndexIndex, String>,
  field_statistics: Result<Option<bool>, String>,
  fields: Result<Option<Vec<String>>, String>,
  ids: Result<Option<Vec<String>>, String>,
  offsets: Result<Option<bool>, String>,
  payloads: Result<Option<bool>, String>,
  positions: Result<Option<bool>, String>,
  preference: Result<Option<String>, String>,
  realtime: Result<Option<bool>, String>,
  routing: Result<Option<String>, String>,
  term_statistics: Result<Option<bool>, String>,
  version: Result<Option<i32>, String>,
  version_type: Result<Option<types::VersionType>, String>,
  body: Result<types::MtermvectorsBodyParams, String>,
}

impl<'a> MtermvectorsPostWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      field_statistics: Ok(None),
      fields: Ok(None),
      ids: Ok(None),
      offsets: Ok(None),
      payloads: Ok(None),
      positions: Ok(None),
      preference: Ok(None),
      realtime: Ok(None),
      routing: Ok(None),
      term_statistics: Ok(None),
      version: Ok(None),
      version_type: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::MtermvectorsPostWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `MtermvectorsPostWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn field_statistics<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.field_statistics = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for field_statistics failed".to_string());
    self
  }

  pub fn fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
    self
  }

  pub fn ids<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.ids = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for ids failed".to_string());
    self
  }

  pub fn offsets<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.offsets = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for offsets failed".to_string());
    self
  }

  pub fn payloads<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.payloads = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for payloads failed".to_string());
    self
  }

  pub fn positions<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.positions = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for positions failed".to_string());
    self
  }

  pub fn preference<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.preference = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for preference failed".to_string());
    self
  }

  pub fn realtime<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.realtime = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for realtime failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for routing failed".to_string());
    self
  }

  pub fn term_statistics<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.term_statistics = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for term_statistics failed".to_string());
    self
  }

  pub fn version<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.version = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for version failed".to_string());
    self
  }

  pub fn version_type<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::VersionType>, {
    self.version_type = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `VersionType` for version_type failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::MtermvectorsBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `MtermvectorsBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/{index}/_mtermvectors`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      field_statistics,
      fields,
      ids,
      offsets,
      payloads,
      positions,
      preference,
      realtime,
      routing,
      term_statistics,
      version,
      version_type,
      body,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let field_statistics = field_statistics.map_err(Error::InvalidRequest)?;
    let fields = fields.map_err(Error::InvalidRequest)?;
    let ids = ids.map_err(Error::InvalidRequest)?;
    let offsets = offsets.map_err(Error::InvalidRequest)?;
    let payloads = payloads.map_err(Error::InvalidRequest)?;
    let positions = positions.map_err(Error::InvalidRequest)?;
    let preference = preference.map_err(Error::InvalidRequest)?;
    let realtime = realtime.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let term_statistics = term_statistics.map_err(Error::InvalidRequest)?;
    let version = version.map_err(Error::InvalidRequest)?;
    let version_type = version_type.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}/_mtermvectors", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(12usize);
    if let Some(v) = &field_statistics {
      query.push(("field_statistics", v.to_string()));
    }
    if let Some(v) = &fields {
      query.push(("fields", v.join(",")));
    }
    if let Some(v) = &ids {
      query.push(("ids", v.join(",")));
    }
    if let Some(v) = &offsets {
      query.push(("offsets", v.to_string()));
    }
    if let Some(v) = &payloads {
      query.push(("payloads", v.to_string()));
    }
    if let Some(v) = &positions {
      query.push(("positions", v.to_string()));
    }
    if let Some(v) = &preference {
      query.push(("preference", v.to_string()));
    }
    if let Some(v) = &realtime {
      query.push(("realtime", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.to_string()));
    }
    if let Some(v) = &term_statistics {
      query.push(("term_statistics", v.to_string()));
    }
    if let Some(v) = &version {
      query.push(("version", v.to_string()));
    }
    if let Some(v) = &version_type {
      query.push(("version_type", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_open`]
///
///[`Client::indices_open`]: super::Client::indices_open
#[derive(Debug, Clone)]
pub struct IndicesOpen<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesOpenIndex, String>,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::IndicesOpenMasterTimeout>, String>,
  timeout: Result<Option<types::IndicesOpenTimeout>, String>,
  wait_for_active_shards: Result<Option<String>, String>,
}

impl<'a> IndicesOpen<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      ignore_unavailable: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
      wait_for_active_shards: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesOpenIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesOpenIndex` for index failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesOpenMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesOpenMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesOpenTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesOpenTimeout` for timeout failed".to_string());
    self
  }

  pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.wait_for_active_shards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for wait_for_active_shards failed".to_string());
    self
  }

  ///Sends a `POST` request to `/{index}/_open`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      allow_no_indices,
      expand_wildcards,
      ignore_unavailable,
      master_timeout,
      timeout,
      wait_for_active_shards,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}/_open", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(6usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &wait_for_active_shards {
      query.push(("wait_for_active_shards", v.to_string()));
    }
    let request = client.client.post(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::rank_eval_get_with_index`]
///
///[`Client::rank_eval_get_with_index`]: super::Client::rank_eval_get_with_index
#[derive(Debug, Clone)]
pub struct RankEvalGetWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::RankEvalGetWithIndexIndex, String>,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  search_type: Result<Option<types::SearchType>, String>,
}

impl<'a> RankEvalGetWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      ignore_unavailable: Ok(None),
      search_type: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::RankEvalGetWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `RankEvalGetWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn search_type<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SearchType>, {
    self.search_type = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SearchType` for search_type failed".to_string());
    self
  }

  ///Sends a `GET` request to `/{index}/_rank_eval`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      allow_no_indices,
      expand_wildcards,
      ignore_unavailable,
      search_type,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let search_type = search_type.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}/_rank_eval", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(4usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &search_type {
      query.push(("search_type", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::rank_eval_post_with_index`]
///
///[`Client::rank_eval_post_with_index`]: super::Client::rank_eval_post_with_index
#[derive(Debug, Clone)]
pub struct RankEvalPostWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::RankEvalPostWithIndexIndex, String>,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  search_type: Result<Option<types::SearchType>, String>,
  body: Result<types::RankEvalBodyParams, String>,
}

impl<'a> RankEvalPostWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      ignore_unavailable: Ok(None),
      search_type: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::RankEvalPostWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `RankEvalPostWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn search_type<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SearchType>, {
    self.search_type = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SearchType` for search_type failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::RankEvalBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `RankEvalBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/{index}/_rank_eval`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      allow_no_indices,
      expand_wildcards,
      ignore_unavailable,
      search_type,
      body,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let search_type = search_type.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}/_rank_eval", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(4usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &search_type {
      query.push(("search_type", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_recovery_with_index`]
///
///[`Client::indices_recovery_with_index`]: super::Client::indices_recovery_with_index
#[derive(Debug, Clone)]
pub struct IndicesRecoveryWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesRecoveryWithIndexIndex, String>,
  active_only: Result<Option<bool>, String>,
  detailed: Result<Option<bool>, String>,
}

impl<'a> IndicesRecoveryWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      active_only: Ok(None),
      detailed: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesRecoveryWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesRecoveryWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn active_only<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.active_only = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for active_only failed".to_string());
    self
  }

  pub fn detailed<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.detailed = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for detailed failed".to_string());
    self
  }

  ///Sends a `GET` request to `/{index}/_recovery`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      active_only,
      detailed,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let active_only = active_only.map_err(Error::InvalidRequest)?;
    let detailed = detailed.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}/_recovery", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(2usize);
    if let Some(v) = &active_only {
      query.push(("active_only", v.to_string()));
    }
    if let Some(v) = &detailed {
      query.push(("detailed", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_refresh_get_with_index`]
///
///[`Client::indices_refresh_get_with_index`]: super::Client::indices_refresh_get_with_index
#[derive(Debug, Clone)]
pub struct IndicesRefreshGetWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesRefreshGetWithIndexIndex, String>,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
}

impl<'a> IndicesRefreshGetWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      ignore_unavailable: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesRefreshGetWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesRefreshGetWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  ///Sends a `GET` request to `/{index}/_refresh`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      allow_no_indices,
      expand_wildcards,
      ignore_unavailable,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}/_refresh", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_refresh_post_with_index`]
///
///[`Client::indices_refresh_post_with_index`]: super::Client::indices_refresh_post_with_index
#[derive(Debug, Clone)]
pub struct IndicesRefreshPostWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesRefreshPostWithIndexIndex, String>,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
}

impl<'a> IndicesRefreshPostWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      ignore_unavailable: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesRefreshPostWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesRefreshPostWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  ///Sends a `POST` request to `/{index}/_refresh`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      allow_no_indices,
      expand_wildcards,
      ignore_unavailable,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}/_refresh", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    let request = client.client.post(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::search_post_with_index`]
///
///[`Client::search_post_with_index`]: super::Client::search_post_with_index
#[derive(Debug, Clone)]
pub struct SearchPostWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::SearchPostWithIndexIndex, String>,
  source: Result<Option<Vec<String>>, String>,
  source_excludes: Result<Option<Vec<String>>, String>,
  source_includes: Result<Option<Vec<String>>, String>,
  allow_no_indices: Result<Option<bool>, String>,
  allow_partial_search_results: Result<Option<bool>, String>,
  analyze_wildcard: Result<Option<bool>, String>,
  analyzer: Result<Option<String>, String>,
  batched_reduce_size: Result<Option<i32>, String>,
  ccs_minimize_roundtrips: Result<Option<bool>, String>,
  default_operator: Result<Option<types::DefaultOperator>, String>,
  df: Result<Option<String>, String>,
  docvalue_fields: Result<Option<Vec<String>>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  explain: Result<Option<bool>, String>,
  from: Result<Option<i32>, String>,
  ignore_throttled: Result<Option<bool>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  lenient: Result<Option<bool>, String>,
  max_concurrent_shard_requests: Result<Option<i32>, String>,
  pre_filter_shard_size: Result<Option<i32>, String>,
  preference: Result<Option<String>, String>,
  q: Result<Option<String>, String>,
  request_cache: Result<Option<bool>, String>,
  rest_total_hits_as_int: Result<Option<bool>, String>,
  routing: Result<Option<Vec<String>>, String>,
  scroll: Result<Option<types::SearchPostWithIndexScroll>, String>,
  search_type: Result<Option<types::SearchType>, String>,
  seq_no_primary_term: Result<Option<bool>, String>,
  size: Result<Option<i32>, String>,
  sort: Result<Option<Vec<String>>, String>,
  stats: Result<Option<Vec<String>>, String>,
  stored_fields: Result<Option<Vec<String>>, String>,
  suggest_field: Result<Option<String>, String>,
  suggest_mode: Result<Option<types::SuggestMode>, String>,
  suggest_size: Result<Option<i32>, String>,
  suggest_text: Result<Option<String>, String>,
  terminate_after: Result<Option<i32>, String>,
  timeout: Result<Option<types::SearchPostWithIndexTimeout>, String>,
  track_scores: Result<Option<bool>, String>,
  track_total_hits: Result<Option<bool>, String>,
  typed_keys: Result<Option<bool>, String>,
  version: Result<Option<bool>, String>,
  body: Result<types::builder::SearchBodyParams, String>,
}

impl<'a> SearchPostWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      source: Ok(None),
      source_excludes: Ok(None),
      source_includes: Ok(None),
      allow_no_indices: Ok(None),
      allow_partial_search_results: Ok(None),
      analyze_wildcard: Ok(None),
      analyzer: Ok(None),
      batched_reduce_size: Ok(None),
      ccs_minimize_roundtrips: Ok(None),
      default_operator: Ok(None),
      df: Ok(None),
      docvalue_fields: Ok(None),
      expand_wildcards: Ok(None),
      explain: Ok(None),
      from: Ok(None),
      ignore_throttled: Ok(None),
      ignore_unavailable: Ok(None),
      lenient: Ok(None),
      max_concurrent_shard_requests: Ok(None),
      pre_filter_shard_size: Ok(None),
      preference: Ok(None),
      q: Ok(None),
      request_cache: Ok(None),
      rest_total_hits_as_int: Ok(None),
      routing: Ok(None),
      scroll: Ok(None),
      search_type: Ok(None),
      seq_no_primary_term: Ok(None),
      size: Ok(None),
      sort: Ok(None),
      stats: Ok(None),
      stored_fields: Ok(None),
      suggest_field: Ok(None),
      suggest_mode: Ok(None),
      suggest_size: Ok(None),
      suggest_text: Ok(None),
      terminate_after: Ok(None),
      timeout: Ok(None),
      track_scores: Ok(None),
      track_total_hits: Ok(None),
      typed_keys: Ok(None),
      version: Ok(None),
      body: Ok(types::builder::SearchBodyParams::default()),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SearchPostWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `SearchPostWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn source<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source failed".to_string());
    self
  }

  pub fn source_excludes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source_excludes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source_excludes failed".to_string());
    self
  }

  pub fn source_includes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source_includes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source_includes failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn allow_partial_search_results<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_partial_search_results = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_partial_search_results failed".to_string());
    self
  }

  pub fn analyze_wildcard<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.analyze_wildcard = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for analyze_wildcard failed".to_string());
    self
  }

  pub fn analyzer<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.analyzer = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for analyzer failed".to_string());
    self
  }

  pub fn batched_reduce_size<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.batched_reduce_size = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for batched_reduce_size failed".to_string());
    self
  }

  pub fn ccs_minimize_roundtrips<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ccs_minimize_roundtrips = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ccs_minimize_roundtrips failed".to_string());
    self
  }

  pub fn default_operator<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::DefaultOperator>, {
    self.default_operator = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `DefaultOperator` for default_operator failed".to_string());
    self
  }

  pub fn df<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.df = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for df failed".to_string());
    self
  }

  pub fn docvalue_fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.docvalue_fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for docvalue_fields failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn explain<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.explain = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for explain failed".to_string());
    self
  }

  pub fn from<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.from = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for from failed".to_string());
    self
  }

  pub fn ignore_throttled<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_throttled = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_throttled failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn lenient<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.lenient = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for lenient failed".to_string());
    self
  }

  pub fn max_concurrent_shard_requests<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.max_concurrent_shard_requests = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for max_concurrent_shard_requests failed".to_string());
    self
  }

  pub fn pre_filter_shard_size<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.pre_filter_shard_size = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for pre_filter_shard_size failed".to_string());
    self
  }

  pub fn preference<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.preference = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for preference failed".to_string());
    self
  }

  pub fn q<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.q = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for q failed".to_string());
    self
  }

  pub fn request_cache<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.request_cache = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for request_cache failed".to_string());
    self
  }

  pub fn rest_total_hits_as_int<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.rest_total_hits_as_int = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for rest_total_hits_as_int failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for routing failed".to_string());
    self
  }

  pub fn scroll<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SearchPostWithIndexScroll>, {
    self.scroll = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SearchPostWithIndexScroll` for scroll failed".to_string());
    self
  }

  pub fn search_type<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SearchType>, {
    self.search_type = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SearchType` for search_type failed".to_string());
    self
  }

  pub fn seq_no_primary_term<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.seq_no_primary_term = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for seq_no_primary_term failed".to_string());
    self
  }

  pub fn size<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.size = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for size failed".to_string());
    self
  }

  pub fn sort<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.sort = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for sort failed".to_string());
    self
  }

  pub fn stats<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.stats = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for stats failed".to_string());
    self
  }

  pub fn stored_fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.stored_fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for stored_fields failed".to_string());
    self
  }

  pub fn suggest_field<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.suggest_field = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for suggest_field failed".to_string());
    self
  }

  pub fn suggest_mode<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SuggestMode>, {
    self.suggest_mode = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SuggestMode` for suggest_mode failed".to_string());
    self
  }

  pub fn suggest_size<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.suggest_size = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for suggest_size failed".to_string());
    self
  }

  pub fn suggest_text<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.suggest_text = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for suggest_text failed".to_string());
    self
  }

  pub fn terminate_after<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.terminate_after = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for terminate_after failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SearchPostWithIndexTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SearchPostWithIndexTimeout` for timeout failed".to_string());
    self
  }

  pub fn track_scores<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.track_scores = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for track_scores failed".to_string());
    self
  }

  pub fn track_total_hits<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.track_total_hits = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for track_total_hits failed".to_string());
    self
  }

  pub fn typed_keys<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.typed_keys = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for typed_keys failed".to_string());
    self
  }

  pub fn version<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.version = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for version failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SearchBodyParams>, {
    self.body = value
      .try_into()
      .map(From::from)
      .map_err(|_| "conversion to `SearchBodyParams` for body failed".to_string());
    self
  }

  pub fn body_map<F>(mut self, f: F) -> Self
  where
    F: std::ops::FnOnce(types::builder::SearchBodyParams) -> types::builder::SearchBodyParams, {
    self.body = self.body.map(f);
    self
  }

  ///Sends a `POST` request to `/{index}/_search`
  pub async fn send<T: DeserializeOwned + std::default::Default>(
    self,
  ) -> Result<ResponseValue<types::SearchPostWithIndexResponseContent<T>>, Error<()>> {
    let Self {
      client,
      index,
      source,
      source_excludes,
      source_includes,
      allow_no_indices,
      allow_partial_search_results,
      analyze_wildcard,
      analyzer,
      batched_reduce_size,
      ccs_minimize_roundtrips,
      default_operator,
      df,
      docvalue_fields,
      expand_wildcards,
      explain,
      from,
      ignore_throttled,
      ignore_unavailable,
      lenient,
      max_concurrent_shard_requests,
      pre_filter_shard_size,
      preference,
      q,
      request_cache,
      rest_total_hits_as_int,
      routing,
      scroll,
      search_type,
      seq_no_primary_term,
      size,
      sort,
      stats,
      stored_fields,
      suggest_field,
      suggest_mode,
      suggest_size,
      suggest_text,
      terminate_after,
      timeout,
      track_scores,
      track_total_hits,
      typed_keys,
      version,
      body,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let source = source.map_err(Error::InvalidRequest)?;
    let source_excludes = source_excludes.map_err(Error::InvalidRequest)?;
    let source_includes = source_includes.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let allow_partial_search_results = allow_partial_search_results.map_err(Error::InvalidRequest)?;
    let analyze_wildcard = analyze_wildcard.map_err(Error::InvalidRequest)?;
    let analyzer = analyzer.map_err(Error::InvalidRequest)?;
    let batched_reduce_size = batched_reduce_size.map_err(Error::InvalidRequest)?;
    let ccs_minimize_roundtrips = ccs_minimize_roundtrips.map_err(Error::InvalidRequest)?;
    let default_operator = default_operator.map_err(Error::InvalidRequest)?;
    let df = df.map_err(Error::InvalidRequest)?;
    let docvalue_fields = docvalue_fields.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let explain = explain.map_err(Error::InvalidRequest)?;
    let from = from.map_err(Error::InvalidRequest)?;
    let ignore_throttled = ignore_throttled.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let lenient = lenient.map_err(Error::InvalidRequest)?;
    let max_concurrent_shard_requests = max_concurrent_shard_requests.map_err(Error::InvalidRequest)?;
    let pre_filter_shard_size = pre_filter_shard_size.map_err(Error::InvalidRequest)?;
    let preference = preference.map_err(Error::InvalidRequest)?;
    let q = q.map_err(Error::InvalidRequest)?;
    let request_cache = request_cache.map_err(Error::InvalidRequest)?;
    let rest_total_hits_as_int = rest_total_hits_as_int.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let scroll = scroll.map_err(Error::InvalidRequest)?;
    let search_type = search_type.map_err(Error::InvalidRequest)?;
    let seq_no_primary_term = seq_no_primary_term.map_err(Error::InvalidRequest)?;
    let size = size.map_err(Error::InvalidRequest)?;
    let sort = sort.map_err(Error::InvalidRequest)?;
    let stats = stats.map_err(Error::InvalidRequest)?;
    let stored_fields = stored_fields.map_err(Error::InvalidRequest)?;
    let suggest_field = suggest_field.map_err(Error::InvalidRequest)?;
    let suggest_mode = suggest_mode.map_err(Error::InvalidRequest)?;
    let suggest_size = suggest_size.map_err(Error::InvalidRequest)?;
    let suggest_text = suggest_text.map_err(Error::InvalidRequest)?;
    let terminate_after = terminate_after.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let track_scores = track_scores.map_err(Error::InvalidRequest)?;
    let track_total_hits = track_total_hits.map_err(Error::InvalidRequest)?;
    let typed_keys = typed_keys.map_err(Error::InvalidRequest)?;
    let version = version.map_err(Error::InvalidRequest)?;
    let body = body
      .and_then(std::convert::TryInto::<types::SearchBodyParams>::try_into)
      .map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}/_search", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(42usize);
    if let Some(v) = &source {
      query.push(("_source", v.join(",")));
    }
    if let Some(v) = &source_excludes {
      query.push(("_source_excludes", v.join(",")));
    }
    if let Some(v) = &source_includes {
      query.push(("_source_includes", v.join(",")));
    }
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &allow_partial_search_results {
      query.push(("allow_partial_search_results", v.to_string()));
    }
    if let Some(v) = &analyze_wildcard {
      query.push(("analyze_wildcard", v.to_string()));
    }
    if let Some(v) = &analyzer {
      query.push(("analyzer", v.to_string()));
    }
    if let Some(v) = &batched_reduce_size {
      query.push(("batched_reduce_size", v.to_string()));
    }
    if let Some(v) = &ccs_minimize_roundtrips {
      query.push(("ccs_minimize_roundtrips", v.to_string()));
    }
    if let Some(v) = &default_operator {
      query.push(("default_operator", v.to_string()));
    }
    if let Some(v) = &df {
      query.push(("df", v.to_string()));
    }
    if let Some(v) = &docvalue_fields {
      query.push(("docvalue_fields", v.join(",")));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &explain {
      query.push(("explain", v.to_string()));
    }
    if let Some(v) = &from {
      query.push(("from", v.to_string()));
    }
    if let Some(v) = &ignore_throttled {
      query.push(("ignore_throttled", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &lenient {
      query.push(("lenient", v.to_string()));
    }
    if let Some(v) = &max_concurrent_shard_requests {
      query.push(("max_concurrent_shard_requests", v.to_string()));
    }
    if let Some(v) = &pre_filter_shard_size {
      query.push(("pre_filter_shard_size", v.to_string()));
    }
    if let Some(v) = &preference {
      query.push(("preference", v.to_string()));
    }
    if let Some(v) = &q {
      query.push(("q", v.to_string()));
    }
    if let Some(v) = &request_cache {
      query.push(("request_cache", v.to_string()));
    }
    if let Some(v) = &rest_total_hits_as_int {
      query.push(("rest_total_hits_as_int", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.join(",")));
    }
    if let Some(v) = &scroll {
      query.push(("scroll", v.to_string()));
    }
    if let Some(v) = &search_type {
      query.push(("search_type", v.to_string()));
    }
    if let Some(v) = &seq_no_primary_term {
      query.push(("seq_no_primary_term", v.to_string()));
    }
    if let Some(v) = &size {
      query.push(("size", v.to_string()));
    }
    if let Some(v) = &sort {
      query.push(("sort", v.join(",")));
    }
    if let Some(v) = &stats {
      query.push(("stats", v.join(",")));
    }
    if let Some(v) = &stored_fields {
      query.push(("stored_fields", v.join(",")));
    }
    if let Some(v) = &suggest_field {
      query.push(("suggest_field", v.to_string()));
    }
    if let Some(v) = &suggest_mode {
      query.push(("suggest_mode", v.to_string()));
    }
    if let Some(v) = &suggest_size {
      query.push(("suggest_size", v.to_string()));
    }
    if let Some(v) = &suggest_text {
      query.push(("suggest_text", v.to_string()));
    }
    if let Some(v) = &terminate_after {
      query.push(("terminate_after", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &track_scores {
      query.push(("track_scores", v.to_string()));
    }
    if let Some(v) = &track_total_hits {
      query.push(("track_total_hits", v.to_string()));
    }
    if let Some(v) = &typed_keys {
      query.push(("typed_keys", v.to_string()));
    }
    if let Some(v) = &version {
      query.push(("version", v.to_string()));
    }
    let request = client
      .client
      .post(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .json(&body)
      .query(&query)
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::create_pit`]
///
///[`Client::create_pit`]: super::Client::create_pit
#[derive(Debug, Clone)]
pub struct CreatePit<'a> {
  client: &'a super::Client,
  index: Result<types::CreatePitIndex, String>,
  allow_partial_pit_creation: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  keep_alive: Result<Option<String>, String>,
  preference: Result<Option<String>, String>,
  routing: Result<Option<Vec<String>>, String>,
}

impl<'a> CreatePit<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      allow_partial_pit_creation: Ok(None),
      expand_wildcards: Ok(None),
      keep_alive: Ok(None),
      preference: Ok(None),
      routing: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::CreatePitIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `CreatePitIndex` for index failed".to_string());
    self
  }

  pub fn allow_partial_pit_creation<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_partial_pit_creation = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_partial_pit_creation failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn keep_alive<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.keep_alive = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for keep_alive failed".to_string());
    self
  }

  pub fn preference<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.preference = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for preference failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for routing failed".to_string());
    self
  }

  ///Sends a `POST` request to `/{index}/_search/point_in_time`
  pub async fn send(self) -> Result<ResponseValue<types::CreatePitResponseContent>, Error<()>> {
    let Self {
      client,
      index,
      allow_partial_pit_creation,
      expand_wildcards,
      keep_alive,
      preference,
      routing,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let allow_partial_pit_creation = allow_partial_pit_creation.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let keep_alive = keep_alive.map_err(Error::InvalidRequest)?;
    let preference = preference.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_search/point_in_time",
      client.baseurl,
      encode_path(&index.to_string()),
    );
    let mut query = Vec::with_capacity(5usize);
    if let Some(v) = &allow_partial_pit_creation {
      query.push(("allow_partial_pit_creation", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &keep_alive {
      query.push(("keep_alive", v.to_string()));
    }
    if let Some(v) = &preference {
      query.push(("preference", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.join(",")));
    }
    let request = client
      .client
      .post(url)
      .header(
        reqwest::header::ACCEPT,
        reqwest::header::HeaderValue::from_static("application/json"),
      )
      .query(&query)
      .build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::search_template_get_with_index`]
///
///[`Client::search_template_get_with_index`]: super::Client::search_template_get_with_index
#[derive(Debug, Clone)]
pub struct SearchTemplateGetWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::SearchTemplateGetWithIndexIndex, String>,
  allow_no_indices: Result<Option<bool>, String>,
  ccs_minimize_roundtrips: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  explain: Result<Option<bool>, String>,
  ignore_throttled: Result<Option<bool>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  preference: Result<Option<String>, String>,
  profile: Result<Option<bool>, String>,
  rest_total_hits_as_int: Result<Option<bool>, String>,
  routing: Result<Option<Vec<String>>, String>,
  scroll: Result<Option<types::SearchTemplateGetWithIndexScroll>, String>,
  search_type: Result<Option<types::SearchTypeMulti>, String>,
  typed_keys: Result<Option<bool>, String>,
}

impl<'a> SearchTemplateGetWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      allow_no_indices: Ok(None),
      ccs_minimize_roundtrips: Ok(None),
      expand_wildcards: Ok(None),
      explain: Ok(None),
      ignore_throttled: Ok(None),
      ignore_unavailable: Ok(None),
      preference: Ok(None),
      profile: Ok(None),
      rest_total_hits_as_int: Ok(None),
      routing: Ok(None),
      scroll: Ok(None),
      search_type: Ok(None),
      typed_keys: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SearchTemplateGetWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `SearchTemplateGetWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn ccs_minimize_roundtrips<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ccs_minimize_roundtrips = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ccs_minimize_roundtrips failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn explain<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.explain = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for explain failed".to_string());
    self
  }

  pub fn ignore_throttled<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_throttled = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_throttled failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn preference<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.preference = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for preference failed".to_string());
    self
  }

  pub fn profile<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.profile = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for profile failed".to_string());
    self
  }

  pub fn rest_total_hits_as_int<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.rest_total_hits_as_int = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for rest_total_hits_as_int failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for routing failed".to_string());
    self
  }

  pub fn scroll<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SearchTemplateGetWithIndexScroll>, {
    self.scroll = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SearchTemplateGetWithIndexScroll` for scroll failed".to_string());
    self
  }

  pub fn search_type<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SearchTypeMulti>, {
    self.search_type = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SearchTypeMulti` for search_type failed".to_string());
    self
  }

  pub fn typed_keys<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.typed_keys = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for typed_keys failed".to_string());
    self
  }

  ///Sends a `GET` request to `/{index}/_search/template`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      allow_no_indices,
      ccs_minimize_roundtrips,
      expand_wildcards,
      explain,
      ignore_throttled,
      ignore_unavailable,
      preference,
      profile,
      rest_total_hits_as_int,
      routing,
      scroll,
      search_type,
      typed_keys,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let ccs_minimize_roundtrips = ccs_minimize_roundtrips.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let explain = explain.map_err(Error::InvalidRequest)?;
    let ignore_throttled = ignore_throttled.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let preference = preference.map_err(Error::InvalidRequest)?;
    let profile = profile.map_err(Error::InvalidRequest)?;
    let rest_total_hits_as_int = rest_total_hits_as_int.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let scroll = scroll.map_err(Error::InvalidRequest)?;
    let search_type = search_type.map_err(Error::InvalidRequest)?;
    let typed_keys = typed_keys.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_search/template",
      client.baseurl,
      encode_path(&index.to_string()),
    );
    let mut query = Vec::with_capacity(13usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &ccs_minimize_roundtrips {
      query.push(("ccs_minimize_roundtrips", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &explain {
      query.push(("explain", v.to_string()));
    }
    if let Some(v) = &ignore_throttled {
      query.push(("ignore_throttled", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &preference {
      query.push(("preference", v.to_string()));
    }
    if let Some(v) = &profile {
      query.push(("profile", v.to_string()));
    }
    if let Some(v) = &rest_total_hits_as_int {
      query.push(("rest_total_hits_as_int", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.join(",")));
    }
    if let Some(v) = &scroll {
      query.push(("scroll", v.to_string()));
    }
    if let Some(v) = &search_type {
      query.push(("search_type", v.to_string()));
    }
    if let Some(v) = &typed_keys {
      query.push(("typed_keys", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::search_template_post_with_index`]
///
///[`Client::search_template_post_with_index`]: super::Client::search_template_post_with_index
#[derive(Debug, Clone)]
pub struct SearchTemplatePostWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::SearchTemplatePostWithIndexIndex, String>,
  allow_no_indices: Result<Option<bool>, String>,
  ccs_minimize_roundtrips: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  explain: Result<Option<bool>, String>,
  ignore_throttled: Result<Option<bool>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  preference: Result<Option<String>, String>,
  profile: Result<Option<bool>, String>,
  rest_total_hits_as_int: Result<Option<bool>, String>,
  routing: Result<Option<Vec<String>>, String>,
  scroll: Result<Option<types::SearchTemplatePostWithIndexScroll>, String>,
  search_type: Result<Option<types::SearchTypeMulti>, String>,
  typed_keys: Result<Option<bool>, String>,
  body: Result<types::SearchTemplateBodyParams, String>,
}

impl<'a> SearchTemplatePostWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      allow_no_indices: Ok(None),
      ccs_minimize_roundtrips: Ok(None),
      expand_wildcards: Ok(None),
      explain: Ok(None),
      ignore_throttled: Ok(None),
      ignore_unavailable: Ok(None),
      preference: Ok(None),
      profile: Ok(None),
      rest_total_hits_as_int: Ok(None),
      routing: Ok(None),
      scroll: Ok(None),
      search_type: Ok(None),
      typed_keys: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SearchTemplatePostWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `SearchTemplatePostWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn ccs_minimize_roundtrips<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ccs_minimize_roundtrips = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ccs_minimize_roundtrips failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn explain<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.explain = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for explain failed".to_string());
    self
  }

  pub fn ignore_throttled<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_throttled = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_throttled failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn preference<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.preference = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for preference failed".to_string());
    self
  }

  pub fn profile<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.profile = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for profile failed".to_string());
    self
  }

  pub fn rest_total_hits_as_int<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.rest_total_hits_as_int = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for rest_total_hits_as_int failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for routing failed".to_string());
    self
  }

  pub fn scroll<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SearchTemplatePostWithIndexScroll>, {
    self.scroll = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SearchTemplatePostWithIndexScroll` for scroll failed".to_string());
    self
  }

  pub fn search_type<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SearchTypeMulti>, {
    self.search_type = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SearchTypeMulti` for search_type failed".to_string());
    self
  }

  pub fn typed_keys<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.typed_keys = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for typed_keys failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SearchTemplateBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `SearchTemplateBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/{index}/_search/template`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      allow_no_indices,
      ccs_minimize_roundtrips,
      expand_wildcards,
      explain,
      ignore_throttled,
      ignore_unavailable,
      preference,
      profile,
      rest_total_hits_as_int,
      routing,
      scroll,
      search_type,
      typed_keys,
      body,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let ccs_minimize_roundtrips = ccs_minimize_roundtrips.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let explain = explain.map_err(Error::InvalidRequest)?;
    let ignore_throttled = ignore_throttled.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let preference = preference.map_err(Error::InvalidRequest)?;
    let profile = profile.map_err(Error::InvalidRequest)?;
    let rest_total_hits_as_int = rest_total_hits_as_int.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let scroll = scroll.map_err(Error::InvalidRequest)?;
    let search_type = search_type.map_err(Error::InvalidRequest)?;
    let typed_keys = typed_keys.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_search/template",
      client.baseurl,
      encode_path(&index.to_string()),
    );
    let mut query = Vec::with_capacity(13usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &ccs_minimize_roundtrips {
      query.push(("ccs_minimize_roundtrips", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &explain {
      query.push(("explain", v.to_string()));
    }
    if let Some(v) = &ignore_throttled {
      query.push(("ignore_throttled", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &preference {
      query.push(("preference", v.to_string()));
    }
    if let Some(v) = &profile {
      query.push(("profile", v.to_string()));
    }
    if let Some(v) = &rest_total_hits_as_int {
      query.push(("rest_total_hits_as_int", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.join(",")));
    }
    if let Some(v) = &scroll {
      query.push(("scroll", v.to_string()));
    }
    if let Some(v) = &search_type {
      query.push(("search_type", v.to_string()));
    }
    if let Some(v) = &typed_keys {
      query.push(("typed_keys", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::search_shards_get_with_index`]
///
///[`Client::search_shards_get_with_index`]: super::Client::search_shards_get_with_index
#[derive(Debug, Clone)]
pub struct SearchShardsGetWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::SearchShardsGetWithIndexIndex, String>,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
  preference: Result<Option<String>, String>,
  routing: Result<Option<String>, String>,
}

impl<'a> SearchShardsGetWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      ignore_unavailable: Ok(None),
      local: Ok(None),
      preference: Ok(None),
      routing: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SearchShardsGetWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `SearchShardsGetWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn preference<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.preference = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for preference failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for routing failed".to_string());
    self
  }

  ///Sends a `GET` request to `/{index}/_search_shards`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      allow_no_indices,
      expand_wildcards,
      ignore_unavailable,
      local,
      preference,
      routing,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let preference = preference.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}/_search_shards", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(6usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &preference {
      query.push(("preference", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::search_shards_post_with_index`]
///
///[`Client::search_shards_post_with_index`]: super::Client::search_shards_post_with_index
#[derive(Debug, Clone)]
pub struct SearchShardsPostWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::SearchShardsPostWithIndexIndex, String>,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
  preference: Result<Option<String>, String>,
  routing: Result<Option<String>, String>,
}

impl<'a> SearchShardsPostWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      ignore_unavailable: Ok(None),
      local: Ok(None),
      preference: Ok(None),
      routing: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SearchShardsPostWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `SearchShardsPostWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn preference<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.preference = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for preference failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for routing failed".to_string());
    self
  }

  ///Sends a `POST` request to `/{index}/_search_shards`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      allow_no_indices,
      expand_wildcards,
      ignore_unavailable,
      local,
      preference,
      routing,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let preference = preference.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}/_search_shards", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(6usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &preference {
      query.push(("preference", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.to_string()));
    }
    let request = client.client.post(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_segments_with_index`]
///
///[`Client::indices_segments_with_index`]: super::Client::indices_segments_with_index
#[derive(Debug, Clone)]
pub struct IndicesSegmentsWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesSegmentsWithIndexIndex, String>,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  verbose: Result<Option<bool>, String>,
}

impl<'a> IndicesSegmentsWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      ignore_unavailable: Ok(None),
      verbose: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesSegmentsWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesSegmentsWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn verbose<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.verbose = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for verbose failed".to_string());
    self
  }

  ///Sends a `GET` request to `/{index}/_segments`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      allow_no_indices,
      expand_wildcards,
      ignore_unavailable,
      verbose,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let verbose = verbose.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}/_segments", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(4usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &verbose {
      query.push(("verbose", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_get_settings_with_index`]
///
///[`Client::indices_get_settings_with_index`]: super::Client::indices_get_settings_with_index
#[derive(Debug, Clone)]
pub struct IndicesGetSettingsWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesGetSettingsWithIndexIndex, String>,
  allow_no_indices: Result<Option<bool>, String>,
  cluster_manager_timeout: Result<Option<types::IndicesGetSettingsWithIndexClusterManagerTimeout>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  flat_settings: Result<Option<bool>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  include_defaults: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::IndicesGetSettingsWithIndexMasterTimeout>, String>,
}

impl<'a> IndicesGetSettingsWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      allow_no_indices: Ok(None),
      cluster_manager_timeout: Ok(None),
      expand_wildcards: Ok(None),
      flat_settings: Ok(None),
      ignore_unavailable: Ok(None),
      include_defaults: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesGetSettingsWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesGetSettingsWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesGetSettingsWithIndexClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesGetSettingsWithIndexClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn flat_settings<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.flat_settings = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn include_defaults<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.include_defaults = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for include_defaults failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesGetSettingsWithIndexMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesGetSettingsWithIndexMasterTimeout` for master_timeout failed".to_string());
    self
  }

  ///Sends a `GET` request to `/{index}/_settings`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      allow_no_indices,
      cluster_manager_timeout,
      expand_wildcards,
      flat_settings,
      ignore_unavailable,
      include_defaults,
      local,
      master_timeout,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let include_defaults = include_defaults.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}/_settings", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(8usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &flat_settings {
      query.push(("flat_settings", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &include_defaults {
      query.push(("include_defaults", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_put_settings_with_index`]
///
///[`Client::indices_put_settings_with_index`]: super::Client::indices_put_settings_with_index
#[derive(Debug, Clone)]
pub struct IndicesPutSettingsWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesPutSettingsWithIndexIndex, String>,
  allow_no_indices: Result<Option<bool>, String>,
  cluster_manager_timeout: Result<Option<types::IndicesPutSettingsWithIndexClusterManagerTimeout>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  flat_settings: Result<Option<bool>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::IndicesPutSettingsWithIndexMasterTimeout>, String>,
  preserve_existing: Result<Option<bool>, String>,
  timeout: Result<Option<types::IndicesPutSettingsWithIndexTimeout>, String>,
  body: Result<types::IndicesPutSettingsBodyParams, String>,
}

impl<'a> IndicesPutSettingsWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      allow_no_indices: Ok(None),
      cluster_manager_timeout: Ok(None),
      expand_wildcards: Ok(None),
      flat_settings: Ok(None),
      ignore_unavailable: Ok(None),
      master_timeout: Ok(None),
      preserve_existing: Ok(None),
      timeout: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutSettingsWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesPutSettingsWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutSettingsWithIndexClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesPutSettingsWithIndexClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn flat_settings<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.flat_settings = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutSettingsWithIndexMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesPutSettingsWithIndexMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn preserve_existing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.preserve_existing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for preserve_existing failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutSettingsWithIndexTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesPutSettingsWithIndexTimeout` for timeout failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesPutSettingsBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `IndicesPutSettingsBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `PUT` request to `/{index}/_settings`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      allow_no_indices,
      cluster_manager_timeout,
      expand_wildcards,
      flat_settings,
      ignore_unavailable,
      master_timeout,
      preserve_existing,
      timeout,
      body,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let preserve_existing = preserve_existing.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}/_settings", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(8usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &flat_settings {
      query.push(("flat_settings", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &preserve_existing {
      query.push(("preserve_existing", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    let request = client.client.put(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_get_settings_with_index_name`]
///
///[`Client::indices_get_settings_with_index_name`]: super::Client::indices_get_settings_with_index_name
#[derive(Debug, Clone)]
pub struct IndicesGetSettingsWithIndexName<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesGetSettingsWithIndexNameIndex, String>,
  name: Result<types::IndicesGetSettingsWithIndexNameName, String>,
  allow_no_indices: Result<Option<bool>, String>,
  cluster_manager_timeout: Result<Option<types::IndicesGetSettingsWithIndexNameClusterManagerTimeout>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  flat_settings: Result<Option<bool>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  include_defaults: Result<Option<bool>, String>,
  local: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::IndicesGetSettingsWithIndexNameMasterTimeout>, String>,
}

impl<'a> IndicesGetSettingsWithIndexName<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      name: Err("name was not initialized".to_string()),
      allow_no_indices: Ok(None),
      cluster_manager_timeout: Ok(None),
      expand_wildcards: Ok(None),
      flat_settings: Ok(None),
      ignore_unavailable: Ok(None),
      include_defaults: Ok(None),
      local: Ok(None),
      master_timeout: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesGetSettingsWithIndexNameIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesGetSettingsWithIndexNameIndex` for index failed".to_string());
    self
  }

  pub fn name<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesGetSettingsWithIndexNameName>, {
    self.name = value
      .try_into()
      .map_err(|_| "conversion to `IndicesGetSettingsWithIndexNameName` for name failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesGetSettingsWithIndexNameClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesGetSettingsWithIndexNameClusterManagerTimeout` for cluster_manager_timeout failed"
        .to_string()
    });
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn flat_settings<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.flat_settings = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn include_defaults<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.include_defaults = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for include_defaults failed".to_string());
    self
  }

  pub fn local<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.local = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for local failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesGetSettingsWithIndexNameMasterTimeout>, {
    self.master_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesGetSettingsWithIndexNameMasterTimeout` for master_timeout failed".to_string()
    });
    self
  }

  ///Sends a `GET` request to `/{index}/_settings/{name}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      name,
      allow_no_indices,
      cluster_manager_timeout,
      expand_wildcards,
      flat_settings,
      ignore_unavailable,
      include_defaults,
      local,
      master_timeout,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let name = name.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let include_defaults = include_defaults.map_err(Error::InvalidRequest)?;
    let local = local.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_settings/{}",
      client.baseurl,
      encode_path(&index.to_string()),
      encode_path(&name.to_string()),
    );
    let mut query = Vec::with_capacity(8usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &flat_settings {
      query.push(("flat_settings", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &include_defaults {
      query.push(("include_defaults", v.to_string()));
    }
    if let Some(v) = &local {
      query.push(("local", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_shard_stores_with_index`]
///
///[`Client::indices_shard_stores_with_index`]: super::Client::indices_shard_stores_with_index
#[derive(Debug, Clone)]
pub struct IndicesShardStoresWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesShardStoresWithIndexIndex, String>,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  status: Result<Option<Vec<types::StatusMember>>, String>,
}

impl<'a> IndicesShardStoresWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      ignore_unavailable: Ok(None),
      status: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesShardStoresWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesShardStoresWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn status<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<types::StatusMember>>, {
    self.status = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < StatusMember >` for status failed".to_string());
    self
  }

  ///Sends a `GET` request to `/{index}/_shard_stores`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      allow_no_indices,
      expand_wildcards,
      ignore_unavailable,
      status,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let status = status.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}/_shard_stores", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(4usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    // if let Some(v) = &status {
    //   query.push(("status", v.to_string()));
    // }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_shrink_put`]
///
///[`Client::indices_shrink_put`]: super::Client::indices_shrink_put
#[derive(Debug, Clone)]
pub struct IndicesShrinkPut<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesShrinkPutIndex, String>,
  target: Result<types::IndicesShrinkPutTarget, String>,
  cluster_manager_timeout: Result<Option<types::IndicesShrinkPutClusterManagerTimeout>, String>,
  copy_settings: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::IndicesShrinkPutMasterTimeout>, String>,
  timeout: Result<Option<types::IndicesShrinkPutTimeout>, String>,
  wait_for_active_shards: Result<Option<String>, String>,
  body: Result<types::IndicesShrinkBodyParams, String>,
}

impl<'a> IndicesShrinkPut<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      target: Err("target was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      copy_settings: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
      wait_for_active_shards: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesShrinkPutIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesShrinkPutIndex` for index failed".to_string());
    self
  }

  pub fn target<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesShrinkPutTarget>, {
    self.target = value
      .try_into()
      .map_err(|_| "conversion to `IndicesShrinkPutTarget` for target failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesShrinkPutClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesShrinkPutClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn copy_settings<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.copy_settings = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for copy_settings failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesShrinkPutMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesShrinkPutMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesShrinkPutTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesShrinkPutTimeout` for timeout failed".to_string());
    self
  }

  pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.wait_for_active_shards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for wait_for_active_shards failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesShrinkBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `IndicesShrinkBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `PUT` request to `/{index}/_shrink/{target}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      target,
      cluster_manager_timeout,
      copy_settings,
      master_timeout,
      timeout,
      wait_for_active_shards,
      body,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let target = target.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let copy_settings = copy_settings.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_shrink/{}",
      client.baseurl,
      encode_path(&index.to_string()),
      encode_path(&target.to_string()),
    );
    let mut query = Vec::with_capacity(5usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &copy_settings {
      query.push(("copy_settings", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &wait_for_active_shards {
      query.push(("wait_for_active_shards", v.to_string()));
    }
    let request = client.client.put(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_shrink_post`]
///
///[`Client::indices_shrink_post`]: super::Client::indices_shrink_post
#[derive(Debug, Clone)]
pub struct IndicesShrinkPost<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesShrinkPostIndex, String>,
  target: Result<types::IndicesShrinkPostTarget, String>,
  cluster_manager_timeout: Result<Option<types::IndicesShrinkPostClusterManagerTimeout>, String>,
  copy_settings: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::IndicesShrinkPostMasterTimeout>, String>,
  timeout: Result<Option<types::IndicesShrinkPostTimeout>, String>,
  wait_for_active_shards: Result<Option<String>, String>,
  body: Result<types::IndicesShrinkBodyParams, String>,
}

impl<'a> IndicesShrinkPost<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      target: Err("target was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      copy_settings: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
      wait_for_active_shards: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesShrinkPostIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesShrinkPostIndex` for index failed".to_string());
    self
  }

  pub fn target<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesShrinkPostTarget>, {
    self.target = value
      .try_into()
      .map_err(|_| "conversion to `IndicesShrinkPostTarget` for target failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesShrinkPostClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesShrinkPostClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn copy_settings<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.copy_settings = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for copy_settings failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesShrinkPostMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesShrinkPostMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesShrinkPostTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesShrinkPostTimeout` for timeout failed".to_string());
    self
  }

  pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.wait_for_active_shards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for wait_for_active_shards failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesShrinkBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `IndicesShrinkBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/{index}/_shrink/{target}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      target,
      cluster_manager_timeout,
      copy_settings,
      master_timeout,
      timeout,
      wait_for_active_shards,
      body,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let target = target.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let copy_settings = copy_settings.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_shrink/{}",
      client.baseurl,
      encode_path(&index.to_string()),
      encode_path(&target.to_string()),
    );
    let mut query = Vec::with_capacity(5usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &copy_settings {
      query.push(("copy_settings", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &wait_for_active_shards {
      query.push(("wait_for_active_shards", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::get_source`]
///
///[`Client::get_source`]: super::Client::get_source
#[derive(Debug, Clone)]
pub struct GetSource<'a> {
  client: &'a super::Client,
  index: Result<types::GetSourceIndex, String>,
  id: Result<types::GetSourceId, String>,
  source: Result<Option<Vec<String>>, String>,
  source_excludes: Result<Option<Vec<String>>, String>,
  source_includes: Result<Option<Vec<String>>, String>,
  preference: Result<Option<String>, String>,
  realtime: Result<Option<bool>, String>,
  refresh: Result<Option<bool>, String>,
  routing: Result<Option<String>, String>,
  version: Result<Option<i32>, String>,
  version_type: Result<Option<types::VersionType>, String>,
}

impl<'a> GetSource<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      id: Err("id was not initialized".to_string()),
      source: Ok(None),
      source_excludes: Ok(None),
      source_includes: Ok(None),
      preference: Ok(None),
      realtime: Ok(None),
      refresh: Ok(None),
      routing: Ok(None),
      version: Ok(None),
      version_type: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::GetSourceIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `GetSourceIndex` for index failed".to_string());
    self
  }

  pub fn id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::GetSourceId>, {
    self.id = value
      .try_into()
      .map_err(|_| "conversion to `GetSourceId` for id failed".to_string());
    self
  }

  pub fn source<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source failed".to_string());
    self
  }

  pub fn source_excludes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source_excludes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source_excludes failed".to_string());
    self
  }

  pub fn source_includes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source_includes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source_includes failed".to_string());
    self
  }

  pub fn preference<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.preference = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for preference failed".to_string());
    self
  }

  pub fn realtime<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.realtime = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for realtime failed".to_string());
    self
  }

  pub fn refresh<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.refresh = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for refresh failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for routing failed".to_string());
    self
  }

  pub fn version<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.version = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for version failed".to_string());
    self
  }

  pub fn version_type<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::VersionType>, {
    self.version_type = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `VersionType` for version_type failed".to_string());
    self
  }

  ///Sends a `GET` request to `/{index}/_source/{id}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      id,
      source,
      source_excludes,
      source_includes,
      preference,
      realtime,
      refresh,
      routing,
      version,
      version_type,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let id = id.map_err(Error::InvalidRequest)?;
    let source = source.map_err(Error::InvalidRequest)?;
    let source_excludes = source_excludes.map_err(Error::InvalidRequest)?;
    let source_includes = source_includes.map_err(Error::InvalidRequest)?;
    let preference = preference.map_err(Error::InvalidRequest)?;
    let realtime = realtime.map_err(Error::InvalidRequest)?;
    let refresh = refresh.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let version = version.map_err(Error::InvalidRequest)?;
    let version_type = version_type.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_source/{}",
      client.baseurl,
      encode_path(&index.to_string()),
      encode_path(&id.to_string()),
    );
    let mut query = Vec::with_capacity(9usize);
    if let Some(v) = &source {
      query.push(("_source", v.join(",")));
    }
    if let Some(v) = &source_excludes {
      query.push(("_source_excludes", v.join(",")));
    }
    if let Some(v) = &source_includes {
      query.push(("_source_includes", v.join(",")));
    }
    if let Some(v) = &preference {
      query.push(("preference", v.to_string()));
    }
    if let Some(v) = &realtime {
      query.push(("realtime", v.to_string()));
    }
    if let Some(v) = &refresh {
      query.push(("refresh", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.to_string()));
    }
    if let Some(v) = &version {
      query.push(("version", v.to_string()));
    }
    if let Some(v) = &version_type {
      query.push(("version_type", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::exists_source`]
///
///[`Client::exists_source`]: super::Client::exists_source
#[derive(Debug, Clone)]
pub struct ExistsSource<'a> {
  client: &'a super::Client,
  index: Result<types::ExistsSourceIndex, String>,
  id: Result<types::ExistsSourceId, String>,
  source: Result<Option<Vec<String>>, String>,
  source_excludes: Result<Option<Vec<String>>, String>,
  source_includes: Result<Option<Vec<String>>, String>,
  preference: Result<Option<String>, String>,
  realtime: Result<Option<bool>, String>,
  refresh: Result<Option<bool>, String>,
  routing: Result<Option<String>, String>,
  version: Result<Option<i32>, String>,
  version_type: Result<Option<types::VersionType>, String>,
}

impl<'a> ExistsSource<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      id: Err("id was not initialized".to_string()),
      source: Ok(None),
      source_excludes: Ok(None),
      source_includes: Ok(None),
      preference: Ok(None),
      realtime: Ok(None),
      refresh: Ok(None),
      routing: Ok(None),
      version: Ok(None),
      version_type: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExistsSourceIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `ExistsSourceIndex` for index failed".to_string());
    self
  }

  pub fn id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExistsSourceId>, {
    self.id = value
      .try_into()
      .map_err(|_| "conversion to `ExistsSourceId` for id failed".to_string());
    self
  }

  pub fn source<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source failed".to_string());
    self
  }

  pub fn source_excludes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source_excludes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source_excludes failed".to_string());
    self
  }

  pub fn source_includes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source_includes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source_includes failed".to_string());
    self
  }

  pub fn preference<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.preference = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for preference failed".to_string());
    self
  }

  pub fn realtime<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.realtime = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for realtime failed".to_string());
    self
  }

  pub fn refresh<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.refresh = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for refresh failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for routing failed".to_string());
    self
  }

  pub fn version<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.version = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for version failed".to_string());
    self
  }

  pub fn version_type<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::VersionType>, {
    self.version_type = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `VersionType` for version_type failed".to_string());
    self
  }

  ///Sends a `HEAD` request to `/{index}/_source/{id}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      id,
      source,
      source_excludes,
      source_includes,
      preference,
      realtime,
      refresh,
      routing,
      version,
      version_type,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let id = id.map_err(Error::InvalidRequest)?;
    let source = source.map_err(Error::InvalidRequest)?;
    let source_excludes = source_excludes.map_err(Error::InvalidRequest)?;
    let source_includes = source_includes.map_err(Error::InvalidRequest)?;
    let preference = preference.map_err(Error::InvalidRequest)?;
    let realtime = realtime.map_err(Error::InvalidRequest)?;
    let refresh = refresh.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let version = version.map_err(Error::InvalidRequest)?;
    let version_type = version_type.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_source/{}",
      client.baseurl,
      encode_path(&index.to_string()),
      encode_path(&id.to_string()),
    );
    let mut query = Vec::with_capacity(9usize);
    if let Some(v) = &source {
      query.push(("_source", v.join(",")));
    }
    if let Some(v) = &source_excludes {
      query.push(("_source_excludes", v.join(",")));
    }
    if let Some(v) = &source_includes {
      query.push(("_source_includes", v.join(",")));
    }
    if let Some(v) = &preference {
      query.push(("preference", v.to_string()));
    }
    if let Some(v) = &realtime {
      query.push(("realtime", v.to_string()));
    }
    if let Some(v) = &refresh {
      query.push(("refresh", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.to_string()));
    }
    if let Some(v) = &version {
      query.push(("version", v.to_string()));
    }
    if let Some(v) = &version_type {
      query.push(("version_type", v.to_string()));
    }
    let request = client.client.head(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_split_put`]
///
///[`Client::indices_split_put`]: super::Client::indices_split_put
#[derive(Debug, Clone)]
pub struct IndicesSplitPut<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesSplitPutIndex, String>,
  target: Result<types::IndicesSplitPutTarget, String>,
  cluster_manager_timeout: Result<Option<types::IndicesSplitPutClusterManagerTimeout>, String>,
  copy_settings: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::IndicesSplitPutMasterTimeout>, String>,
  timeout: Result<Option<types::IndicesSplitPutTimeout>, String>,
  wait_for_active_shards: Result<Option<String>, String>,
  body: Result<types::IndicesSplitBodyParams, String>,
}

impl<'a> IndicesSplitPut<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      target: Err("target was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      copy_settings: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
      wait_for_active_shards: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesSplitPutIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesSplitPutIndex` for index failed".to_string());
    self
  }

  pub fn target<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesSplitPutTarget>, {
    self.target = value
      .try_into()
      .map_err(|_| "conversion to `IndicesSplitPutTarget` for target failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesSplitPutClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesSplitPutClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn copy_settings<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.copy_settings = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for copy_settings failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesSplitPutMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesSplitPutMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesSplitPutTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesSplitPutTimeout` for timeout failed".to_string());
    self
  }

  pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.wait_for_active_shards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for wait_for_active_shards failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesSplitBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `IndicesSplitBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `PUT` request to `/{index}/_split/{target}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      target,
      cluster_manager_timeout,
      copy_settings,
      master_timeout,
      timeout,
      wait_for_active_shards,
      body,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let target = target.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let copy_settings = copy_settings.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_split/{}",
      client.baseurl,
      encode_path(&index.to_string()),
      encode_path(&target.to_string()),
    );
    let mut query = Vec::with_capacity(5usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &copy_settings {
      query.push(("copy_settings", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &wait_for_active_shards {
      query.push(("wait_for_active_shards", v.to_string()));
    }
    let request = client.client.put(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_split_post`]
///
///[`Client::indices_split_post`]: super::Client::indices_split_post
#[derive(Debug, Clone)]
pub struct IndicesSplitPost<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesSplitPostIndex, String>,
  target: Result<types::IndicesSplitPostTarget, String>,
  cluster_manager_timeout: Result<Option<types::IndicesSplitPostClusterManagerTimeout>, String>,
  copy_settings: Result<Option<bool>, String>,
  master_timeout: Result<Option<types::IndicesSplitPostMasterTimeout>, String>,
  timeout: Result<Option<types::IndicesSplitPostTimeout>, String>,
  wait_for_active_shards: Result<Option<String>, String>,
  body: Result<types::IndicesSplitBodyParams, String>,
}

impl<'a> IndicesSplitPost<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      target: Err("target was not initialized".to_string()),
      cluster_manager_timeout: Ok(None),
      copy_settings: Ok(None),
      master_timeout: Ok(None),
      timeout: Ok(None),
      wait_for_active_shards: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesSplitPostIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesSplitPostIndex` for index failed".to_string());
    self
  }

  pub fn target<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesSplitPostTarget>, {
    self.target = value
      .try_into()
      .map_err(|_| "conversion to `IndicesSplitPostTarget` for target failed".to_string());
    self
  }

  pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesSplitPostClusterManagerTimeout>, {
    self.cluster_manager_timeout = value.try_into().map(Some).map_err(|_| {
      "conversion to `IndicesSplitPostClusterManagerTimeout` for cluster_manager_timeout failed".to_string()
    });
    self
  }

  pub fn copy_settings<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.copy_settings = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for copy_settings failed".to_string());
    self
  }

  pub fn master_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesSplitPostMasterTimeout>, {
    self.master_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesSplitPostMasterTimeout` for master_timeout failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesSplitPostTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndicesSplitPostTimeout` for timeout failed".to_string());
    self
  }

  pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.wait_for_active_shards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for wait_for_active_shards failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesSplitBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `IndicesSplitBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/{index}/_split/{target}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      target,
      cluster_manager_timeout,
      copy_settings,
      master_timeout,
      timeout,
      wait_for_active_shards,
      body,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let target = target.map_err(Error::InvalidRequest)?;
    let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
    let copy_settings = copy_settings.map_err(Error::InvalidRequest)?;
    let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_split/{}",
      client.baseurl,
      encode_path(&index.to_string()),
      encode_path(&target.to_string()),
    );
    let mut query = Vec::with_capacity(5usize);
    if let Some(v) = &cluster_manager_timeout {
      query.push(("cluster_manager_timeout", v.to_string()));
    }
    if let Some(v) = &copy_settings {
      query.push(("copy_settings", v.to_string()));
    }
    if let Some(v) = &master_timeout {
      query.push(("master_timeout", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &wait_for_active_shards {
      query.push(("wait_for_active_shards", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_stats_with_index`]
///
///[`Client::indices_stats_with_index`]: super::Client::indices_stats_with_index
#[derive(Debug, Clone)]
pub struct IndicesStatsWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesStatsWithIndexIndex, String>,
  completion_fields: Result<Option<Vec<String>>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  fielddata_fields: Result<Option<Vec<String>>, String>,
  fields: Result<Option<Vec<String>>, String>,
  forbid_closed_indices: Result<Option<bool>, String>,
  groups: Result<Option<Vec<String>>, String>,
  include_segment_file_sizes: Result<Option<bool>, String>,
  include_unloaded_segments: Result<Option<bool>, String>,
  level: Result<Option<types::IndiciesStatLevel>, String>,
}

impl<'a> IndicesStatsWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      completion_fields: Ok(None),
      expand_wildcards: Ok(None),
      fielddata_fields: Ok(None),
      fields: Ok(None),
      forbid_closed_indices: Ok(None),
      groups: Ok(None),
      include_segment_file_sizes: Ok(None),
      include_unloaded_segments: Ok(None),
      level: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesStatsWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesStatsWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn completion_fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.completion_fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for completion_fields failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn fielddata_fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.fielddata_fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for fielddata_fields failed".to_string());
    self
  }

  pub fn fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
    self
  }

  pub fn forbid_closed_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.forbid_closed_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for forbid_closed_indices failed".to_string());
    self
  }

  pub fn groups<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.groups = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for groups failed".to_string());
    self
  }

  pub fn include_segment_file_sizes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.include_segment_file_sizes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for include_segment_file_sizes failed".to_string());
    self
  }

  pub fn include_unloaded_segments<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.include_unloaded_segments = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for include_unloaded_segments failed".to_string());
    self
  }

  pub fn level<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndiciesStatLevel>, {
    self.level = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndiciesStatLevel` for level failed".to_string());
    self
  }

  ///Sends a `GET` request to `/{index}/_stats`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      completion_fields,
      expand_wildcards,
      fielddata_fields,
      fields,
      forbid_closed_indices,
      groups,
      include_segment_file_sizes,
      include_unloaded_segments,
      level,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let completion_fields = completion_fields.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let fielddata_fields = fielddata_fields.map_err(Error::InvalidRequest)?;
    let fields = fields.map_err(Error::InvalidRequest)?;
    let forbid_closed_indices = forbid_closed_indices.map_err(Error::InvalidRequest)?;
    let groups = groups.map_err(Error::InvalidRequest)?;
    let include_segment_file_sizes = include_segment_file_sizes.map_err(Error::InvalidRequest)?;
    let include_unloaded_segments = include_unloaded_segments.map_err(Error::InvalidRequest)?;
    let level = level.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}/_stats", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(9usize);
    if let Some(v) = &completion_fields {
      query.push(("completion_fields", v.join(",")));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &fielddata_fields {
      query.push(("fielddata_fields", v.join(",")));
    }
    if let Some(v) = &fields {
      query.push(("fields", v.join(",")));
    }
    if let Some(v) = &forbid_closed_indices {
      query.push(("forbid_closed_indices", v.to_string()));
    }
    if let Some(v) = &groups {
      query.push(("groups", v.join(",")));
    }
    if let Some(v) = &include_segment_file_sizes {
      query.push(("include_segment_file_sizes", v.to_string()));
    }
    if let Some(v) = &include_unloaded_segments {
      query.push(("include_unloaded_segments", v.to_string()));
    }
    if let Some(v) = &level {
      query.push(("level", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_stats_with_index_metric`]
///
///[`Client::indices_stats_with_index_metric`]: super::Client::indices_stats_with_index_metric
#[derive(Debug, Clone)]
pub struct IndicesStatsWithIndexMetric<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesStatsWithIndexMetricIndex, String>,
  metric: Result<types::IndicesStatsWithIndexMetricMetric, String>,
  completion_fields: Result<Option<Vec<String>>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  fielddata_fields: Result<Option<Vec<String>>, String>,
  fields: Result<Option<Vec<String>>, String>,
  forbid_closed_indices: Result<Option<bool>, String>,
  groups: Result<Option<Vec<String>>, String>,
  include_segment_file_sizes: Result<Option<bool>, String>,
  include_unloaded_segments: Result<Option<bool>, String>,
  level: Result<Option<types::IndiciesStatLevel>, String>,
}

impl<'a> IndicesStatsWithIndexMetric<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      metric: Err("metric was not initialized".to_string()),
      completion_fields: Ok(None),
      expand_wildcards: Ok(None),
      fielddata_fields: Ok(None),
      fields: Ok(None),
      forbid_closed_indices: Ok(None),
      groups: Ok(None),
      include_segment_file_sizes: Ok(None),
      include_unloaded_segments: Ok(None),
      level: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesStatsWithIndexMetricIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesStatsWithIndexMetricIndex` for index failed".to_string());
    self
  }

  pub fn metric<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesStatsWithIndexMetricMetric>, {
    self.metric = value
      .try_into()
      .map_err(|_| "conversion to `IndicesStatsWithIndexMetricMetric` for metric failed".to_string());
    self
  }

  pub fn completion_fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.completion_fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for completion_fields failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn fielddata_fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.fielddata_fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for fielddata_fields failed".to_string());
    self
  }

  pub fn fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
    self
  }

  pub fn forbid_closed_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.forbid_closed_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for forbid_closed_indices failed".to_string());
    self
  }

  pub fn groups<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.groups = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for groups failed".to_string());
    self
  }

  pub fn include_segment_file_sizes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.include_segment_file_sizes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for include_segment_file_sizes failed".to_string());
    self
  }

  pub fn include_unloaded_segments<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.include_unloaded_segments = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for include_unloaded_segments failed".to_string());
    self
  }

  pub fn level<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndiciesStatLevel>, {
    self.level = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `IndiciesStatLevel` for level failed".to_string());
    self
  }

  ///Sends a `GET` request to `/{index}/_stats/{metric}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      metric,
      completion_fields,
      expand_wildcards,
      fielddata_fields,
      fields,
      forbid_closed_indices,
      groups,
      include_segment_file_sizes,
      include_unloaded_segments,
      level,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let metric = metric.map_err(Error::InvalidRequest)?;
    let completion_fields = completion_fields.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let fielddata_fields = fielddata_fields.map_err(Error::InvalidRequest)?;
    let fields = fields.map_err(Error::InvalidRequest)?;
    let forbid_closed_indices = forbid_closed_indices.map_err(Error::InvalidRequest)?;
    let groups = groups.map_err(Error::InvalidRequest)?;
    let include_segment_file_sizes = include_segment_file_sizes.map_err(Error::InvalidRequest)?;
    let include_unloaded_segments = include_unloaded_segments.map_err(Error::InvalidRequest)?;
    let level = level.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_stats/{}",
      client.baseurl,
      encode_path(&index.to_string()),
      encode_path(&metric.to_string()),
    );
    let mut query = Vec::with_capacity(9usize);
    if let Some(v) = &completion_fields {
      query.push(("completion_fields", v.join(",")));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &fielddata_fields {
      query.push(("fielddata_fields", v.join(",")));
    }
    if let Some(v) = &fields {
      query.push(("fields", v.join(",")));
    }
    if let Some(v) = &forbid_closed_indices {
      query.push(("forbid_closed_indices", v.to_string()));
    }
    if let Some(v) = &groups {
      query.push(("groups", v.join(",")));
    }
    if let Some(v) = &include_segment_file_sizes {
      query.push(("include_segment_file_sizes", v.to_string()));
    }
    if let Some(v) = &include_unloaded_segments {
      query.push(("include_unloaded_segments", v.to_string()));
    }
    if let Some(v) = &level {
      query.push(("level", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::termvectors_get`]
///
///[`Client::termvectors_get`]: super::Client::termvectors_get
#[derive(Debug, Clone)]
pub struct TermvectorsGet<'a> {
  client: &'a super::Client,
  index: Result<types::TermvectorsGetIndex, String>,
  field_statistics: Result<Option<bool>, String>,
  fields: Result<Option<Vec<String>>, String>,
  offsets: Result<Option<bool>, String>,
  payloads: Result<Option<bool>, String>,
  positions: Result<Option<bool>, String>,
  preference: Result<Option<String>, String>,
  realtime: Result<Option<bool>, String>,
  routing: Result<Option<String>, String>,
  term_statistics: Result<Option<bool>, String>,
  version: Result<Option<i32>, String>,
  version_type: Result<Option<types::VersionType>, String>,
}

impl<'a> TermvectorsGet<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      field_statistics: Ok(None),
      fields: Ok(None),
      offsets: Ok(None),
      payloads: Ok(None),
      positions: Ok(None),
      preference: Ok(None),
      realtime: Ok(None),
      routing: Ok(None),
      term_statistics: Ok(None),
      version: Ok(None),
      version_type: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::TermvectorsGetIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `TermvectorsGetIndex` for index failed".to_string());
    self
  }

  pub fn field_statistics<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.field_statistics = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for field_statistics failed".to_string());
    self
  }

  pub fn fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
    self
  }

  pub fn offsets<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.offsets = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for offsets failed".to_string());
    self
  }

  pub fn payloads<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.payloads = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for payloads failed".to_string());
    self
  }

  pub fn positions<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.positions = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for positions failed".to_string());
    self
  }

  pub fn preference<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.preference = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for preference failed".to_string());
    self
  }

  pub fn realtime<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.realtime = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for realtime failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for routing failed".to_string());
    self
  }

  pub fn term_statistics<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.term_statistics = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for term_statistics failed".to_string());
    self
  }

  pub fn version<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.version = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for version failed".to_string());
    self
  }

  pub fn version_type<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::VersionType>, {
    self.version_type = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `VersionType` for version_type failed".to_string());
    self
  }

  ///Sends a `GET` request to `/{index}/_termvectors`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      field_statistics,
      fields,
      offsets,
      payloads,
      positions,
      preference,
      realtime,
      routing,
      term_statistics,
      version,
      version_type,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let field_statistics = field_statistics.map_err(Error::InvalidRequest)?;
    let fields = fields.map_err(Error::InvalidRequest)?;
    let offsets = offsets.map_err(Error::InvalidRequest)?;
    let payloads = payloads.map_err(Error::InvalidRequest)?;
    let positions = positions.map_err(Error::InvalidRequest)?;
    let preference = preference.map_err(Error::InvalidRequest)?;
    let realtime = realtime.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let term_statistics = term_statistics.map_err(Error::InvalidRequest)?;
    let version = version.map_err(Error::InvalidRequest)?;
    let version_type = version_type.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}/_termvectors", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(11usize);
    if let Some(v) = &field_statistics {
      query.push(("field_statistics", v.to_string()));
    }
    if let Some(v) = &fields {
      query.push(("fields", v.join(",")));
    }
    if let Some(v) = &offsets {
      query.push(("offsets", v.to_string()));
    }
    if let Some(v) = &payloads {
      query.push(("payloads", v.to_string()));
    }
    if let Some(v) = &positions {
      query.push(("positions", v.to_string()));
    }
    if let Some(v) = &preference {
      query.push(("preference", v.to_string()));
    }
    if let Some(v) = &realtime {
      query.push(("realtime", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.to_string()));
    }
    if let Some(v) = &term_statistics {
      query.push(("term_statistics", v.to_string()));
    }
    if let Some(v) = &version {
      query.push(("version", v.to_string()));
    }
    if let Some(v) = &version_type {
      query.push(("version_type", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::termvectors_post`]
///
///[`Client::termvectors_post`]: super::Client::termvectors_post
#[derive(Debug, Clone)]
pub struct TermvectorsPost<'a> {
  client: &'a super::Client,
  index: Result<types::TermvectorsPostIndex, String>,
  field_statistics: Result<Option<bool>, String>,
  fields: Result<Option<Vec<String>>, String>,
  offsets: Result<Option<bool>, String>,
  payloads: Result<Option<bool>, String>,
  positions: Result<Option<bool>, String>,
  preference: Result<Option<String>, String>,
  realtime: Result<Option<bool>, String>,
  routing: Result<Option<String>, String>,
  term_statistics: Result<Option<bool>, String>,
  version: Result<Option<i32>, String>,
  version_type: Result<Option<types::VersionType>, String>,
  body: Result<types::TermvectorsBodyParams, String>,
}

impl<'a> TermvectorsPost<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      field_statistics: Ok(None),
      fields: Ok(None),
      offsets: Ok(None),
      payloads: Ok(None),
      positions: Ok(None),
      preference: Ok(None),
      realtime: Ok(None),
      routing: Ok(None),
      term_statistics: Ok(None),
      version: Ok(None),
      version_type: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::TermvectorsPostIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `TermvectorsPostIndex` for index failed".to_string());
    self
  }

  pub fn field_statistics<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.field_statistics = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for field_statistics failed".to_string());
    self
  }

  pub fn fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
    self
  }

  pub fn offsets<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.offsets = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for offsets failed".to_string());
    self
  }

  pub fn payloads<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.payloads = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for payloads failed".to_string());
    self
  }

  pub fn positions<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.positions = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for positions failed".to_string());
    self
  }

  pub fn preference<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.preference = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for preference failed".to_string());
    self
  }

  pub fn realtime<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.realtime = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for realtime failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for routing failed".to_string());
    self
  }

  pub fn term_statistics<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.term_statistics = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for term_statistics failed".to_string());
    self
  }

  pub fn version<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.version = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for version failed".to_string());
    self
  }

  pub fn version_type<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::VersionType>, {
    self.version_type = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `VersionType` for version_type failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::TermvectorsBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `TermvectorsBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/{index}/_termvectors`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      field_statistics,
      fields,
      offsets,
      payloads,
      positions,
      preference,
      realtime,
      routing,
      term_statistics,
      version,
      version_type,
      body,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let field_statistics = field_statistics.map_err(Error::InvalidRequest)?;
    let fields = fields.map_err(Error::InvalidRequest)?;
    let offsets = offsets.map_err(Error::InvalidRequest)?;
    let payloads = payloads.map_err(Error::InvalidRequest)?;
    let positions = positions.map_err(Error::InvalidRequest)?;
    let preference = preference.map_err(Error::InvalidRequest)?;
    let realtime = realtime.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let term_statistics = term_statistics.map_err(Error::InvalidRequest)?;
    let version = version.map_err(Error::InvalidRequest)?;
    let version_type = version_type.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}/_termvectors", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(11usize);
    if let Some(v) = &field_statistics {
      query.push(("field_statistics", v.to_string()));
    }
    if let Some(v) = &fields {
      query.push(("fields", v.join(",")));
    }
    if let Some(v) = &offsets {
      query.push(("offsets", v.to_string()));
    }
    if let Some(v) = &payloads {
      query.push(("payloads", v.to_string()));
    }
    if let Some(v) = &positions {
      query.push(("positions", v.to_string()));
    }
    if let Some(v) = &preference {
      query.push(("preference", v.to_string()));
    }
    if let Some(v) = &realtime {
      query.push(("realtime", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.to_string()));
    }
    if let Some(v) = &term_statistics {
      query.push(("term_statistics", v.to_string()));
    }
    if let Some(v) = &version {
      query.push(("version", v.to_string()));
    }
    if let Some(v) = &version_type {
      query.push(("version_type", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::termvectors_get_with_id`]
///
///[`Client::termvectors_get_with_id`]: super::Client::termvectors_get_with_id
#[derive(Debug, Clone)]
pub struct TermvectorsGetWithId<'a> {
  client: &'a super::Client,
  index: Result<types::TermvectorsGetWithIdIndex, String>,
  id: Result<types::TermvectorsGetWithIdId, String>,
  field_statistics: Result<Option<bool>, String>,
  fields: Result<Option<Vec<String>>, String>,
  offsets: Result<Option<bool>, String>,
  payloads: Result<Option<bool>, String>,
  positions: Result<Option<bool>, String>,
  preference: Result<Option<String>, String>,
  realtime: Result<Option<bool>, String>,
  routing: Result<Option<String>, String>,
  term_statistics: Result<Option<bool>, String>,
  version: Result<Option<i32>, String>,
  version_type: Result<Option<types::VersionType>, String>,
}

impl<'a> TermvectorsGetWithId<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      id: Err("id was not initialized".to_string()),
      field_statistics: Ok(None),
      fields: Ok(None),
      offsets: Ok(None),
      payloads: Ok(None),
      positions: Ok(None),
      preference: Ok(None),
      realtime: Ok(None),
      routing: Ok(None),
      term_statistics: Ok(None),
      version: Ok(None),
      version_type: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::TermvectorsGetWithIdIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `TermvectorsGetWithIdIndex` for index failed".to_string());
    self
  }

  pub fn id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::TermvectorsGetWithIdId>, {
    self.id = value
      .try_into()
      .map_err(|_| "conversion to `TermvectorsGetWithIdId` for id failed".to_string());
    self
  }

  pub fn field_statistics<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.field_statistics = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for field_statistics failed".to_string());
    self
  }

  pub fn fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
    self
  }

  pub fn offsets<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.offsets = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for offsets failed".to_string());
    self
  }

  pub fn payloads<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.payloads = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for payloads failed".to_string());
    self
  }

  pub fn positions<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.positions = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for positions failed".to_string());
    self
  }

  pub fn preference<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.preference = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for preference failed".to_string());
    self
  }

  pub fn realtime<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.realtime = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for realtime failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for routing failed".to_string());
    self
  }

  pub fn term_statistics<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.term_statistics = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for term_statistics failed".to_string());
    self
  }

  pub fn version<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.version = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for version failed".to_string());
    self
  }

  pub fn version_type<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::VersionType>, {
    self.version_type = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `VersionType` for version_type failed".to_string());
    self
  }

  ///Sends a `GET` request to `/{index}/_termvectors/{id}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      id,
      field_statistics,
      fields,
      offsets,
      payloads,
      positions,
      preference,
      realtime,
      routing,
      term_statistics,
      version,
      version_type,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let id = id.map_err(Error::InvalidRequest)?;
    let field_statistics = field_statistics.map_err(Error::InvalidRequest)?;
    let fields = fields.map_err(Error::InvalidRequest)?;
    let offsets = offsets.map_err(Error::InvalidRequest)?;
    let payloads = payloads.map_err(Error::InvalidRequest)?;
    let positions = positions.map_err(Error::InvalidRequest)?;
    let preference = preference.map_err(Error::InvalidRequest)?;
    let realtime = realtime.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let term_statistics = term_statistics.map_err(Error::InvalidRequest)?;
    let version = version.map_err(Error::InvalidRequest)?;
    let version_type = version_type.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_termvectors/{}",
      client.baseurl,
      encode_path(&index.to_string()),
      encode_path(&id.to_string()),
    );
    let mut query = Vec::with_capacity(11usize);
    if let Some(v) = &field_statistics {
      query.push(("field_statistics", v.to_string()));
    }
    if let Some(v) = &fields {
      query.push(("fields", v.join(",")));
    }
    if let Some(v) = &offsets {
      query.push(("offsets", v.to_string()));
    }
    if let Some(v) = &payloads {
      query.push(("payloads", v.to_string()));
    }
    if let Some(v) = &positions {
      query.push(("positions", v.to_string()));
    }
    if let Some(v) = &preference {
      query.push(("preference", v.to_string()));
    }
    if let Some(v) = &realtime {
      query.push(("realtime", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.to_string()));
    }
    if let Some(v) = &term_statistics {
      query.push(("term_statistics", v.to_string()));
    }
    if let Some(v) = &version {
      query.push(("version", v.to_string()));
    }
    if let Some(v) = &version_type {
      query.push(("version_type", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::termvectors_post_with_id`]
///
///[`Client::termvectors_post_with_id`]: super::Client::termvectors_post_with_id
#[derive(Debug, Clone)]
pub struct TermvectorsPostWithId<'a> {
  client: &'a super::Client,
  index: Result<types::TermvectorsPostWithIdIndex, String>,
  id: Result<types::TermvectorsPostWithIdId, String>,
  field_statistics: Result<Option<bool>, String>,
  fields: Result<Option<Vec<String>>, String>,
  offsets: Result<Option<bool>, String>,
  payloads: Result<Option<bool>, String>,
  positions: Result<Option<bool>, String>,
  preference: Result<Option<String>, String>,
  realtime: Result<Option<bool>, String>,
  routing: Result<Option<String>, String>,
  term_statistics: Result<Option<bool>, String>,
  version: Result<Option<i32>, String>,
  version_type: Result<Option<types::VersionType>, String>,
  body: Result<types::TermvectorsBodyParams, String>,
}

impl<'a> TermvectorsPostWithId<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      id: Err("id was not initialized".to_string()),
      field_statistics: Ok(None),
      fields: Ok(None),
      offsets: Ok(None),
      payloads: Ok(None),
      positions: Ok(None),
      preference: Ok(None),
      realtime: Ok(None),
      routing: Ok(None),
      term_statistics: Ok(None),
      version: Ok(None),
      version_type: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::TermvectorsPostWithIdIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `TermvectorsPostWithIdIndex` for index failed".to_string());
    self
  }

  pub fn id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::TermvectorsPostWithIdId>, {
    self.id = value
      .try_into()
      .map_err(|_| "conversion to `TermvectorsPostWithIdId` for id failed".to_string());
    self
  }

  pub fn field_statistics<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.field_statistics = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for field_statistics failed".to_string());
    self
  }

  pub fn fields<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.fields = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
    self
  }

  pub fn offsets<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.offsets = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for offsets failed".to_string());
    self
  }

  pub fn payloads<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.payloads = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for payloads failed".to_string());
    self
  }

  pub fn positions<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.positions = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for positions failed".to_string());
    self
  }

  pub fn preference<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.preference = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for preference failed".to_string());
    self
  }

  pub fn realtime<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.realtime = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for realtime failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for routing failed".to_string());
    self
  }

  pub fn term_statistics<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.term_statistics = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for term_statistics failed".to_string());
    self
  }

  pub fn version<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.version = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for version failed".to_string());
    self
  }

  pub fn version_type<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::VersionType>, {
    self.version_type = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `VersionType` for version_type failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::TermvectorsBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `TermvectorsBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/{index}/_termvectors/{id}`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      id,
      field_statistics,
      fields,
      offsets,
      payloads,
      positions,
      preference,
      realtime,
      routing,
      term_statistics,
      version,
      version_type,
      body,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let id = id.map_err(Error::InvalidRequest)?;
    let field_statistics = field_statistics.map_err(Error::InvalidRequest)?;
    let fields = fields.map_err(Error::InvalidRequest)?;
    let offsets = offsets.map_err(Error::InvalidRequest)?;
    let payloads = payloads.map_err(Error::InvalidRequest)?;
    let positions = positions.map_err(Error::InvalidRequest)?;
    let preference = preference.map_err(Error::InvalidRequest)?;
    let realtime = realtime.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let term_statistics = term_statistics.map_err(Error::InvalidRequest)?;
    let version = version.map_err(Error::InvalidRequest)?;
    let version_type = version_type.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_termvectors/{}",
      client.baseurl,
      encode_path(&index.to_string()),
      encode_path(&id.to_string()),
    );
    let mut query = Vec::with_capacity(11usize);
    if let Some(v) = &field_statistics {
      query.push(("field_statistics", v.to_string()));
    }
    if let Some(v) = &fields {
      query.push(("fields", v.join(",")));
    }
    if let Some(v) = &offsets {
      query.push(("offsets", v.to_string()));
    }
    if let Some(v) = &payloads {
      query.push(("payloads", v.to_string()));
    }
    if let Some(v) = &positions {
      query.push(("positions", v.to_string()));
    }
    if let Some(v) = &preference {
      query.push(("preference", v.to_string()));
    }
    if let Some(v) = &realtime {
      query.push(("realtime", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.to_string()));
    }
    if let Some(v) = &term_statistics {
      query.push(("term_statistics", v.to_string()));
    }
    if let Some(v) = &version {
      query.push(("version", v.to_string()));
    }
    if let Some(v) = &version_type {
      query.push(("version_type", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::update`]
///
///[`Client::update`]: super::Client::update
#[derive(Debug, Clone)]
pub struct Update<'a> {
  client: &'a super::Client,
  index: Result<types::UpdateIndex, String>,
  id: Result<types::UpdateId, String>,
  source: Result<Option<Vec<String>>, String>,
  source_excludes: Result<Option<Vec<String>>, String>,
  source_includes: Result<Option<Vec<String>>, String>,
  if_primary_term: Result<Option<i32>, String>,
  if_seq_no: Result<Option<i32>, String>,
  lang: Result<Option<String>, String>,
  refresh: Result<Option<types::RefreshEnum>, String>,
  require_alias: Result<Option<bool>, String>,
  retry_on_conflict: Result<Option<i32>, String>,
  routing: Result<Option<String>, String>,
  timeout: Result<Option<types::UpdateTimeout>, String>,
  wait_for_active_shards: Result<Option<String>, String>,
  body: Result<types::UpdateBodyParams, String>,
}

impl<'a> Update<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      id: Err("id was not initialized".to_string()),
      source: Ok(None),
      source_excludes: Ok(None),
      source_includes: Ok(None),
      if_primary_term: Ok(None),
      if_seq_no: Ok(None),
      lang: Ok(None),
      refresh: Ok(None),
      require_alias: Ok(None),
      retry_on_conflict: Ok(None),
      routing: Ok(None),
      timeout: Ok(None),
      wait_for_active_shards: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::UpdateIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `UpdateIndex` for index failed".to_string());
    self
  }

  pub fn id<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::UpdateId>, {
    self.id = value
      .try_into()
      .map_err(|_| "conversion to `UpdateId` for id failed".to_string());
    self
  }

  pub fn source<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source failed".to_string());
    self
  }

  pub fn source_excludes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source_excludes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source_excludes failed".to_string());
    self
  }

  pub fn source_includes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source_includes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source_includes failed".to_string());
    self
  }

  pub fn if_primary_term<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.if_primary_term = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for if_primary_term failed".to_string());
    self
  }

  pub fn if_seq_no<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.if_seq_no = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for if_seq_no failed".to_string());
    self
  }

  pub fn lang<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.lang = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for lang failed".to_string());
    self
  }

  pub fn refresh<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::RefreshEnum>, {
    self.refresh = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `RefreshEnum` for refresh failed".to_string());
    self
  }

  pub fn require_alias<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.require_alias = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for require_alias failed".to_string());
    self
  }

  pub fn retry_on_conflict<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.retry_on_conflict = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for retry_on_conflict failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for routing failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::UpdateTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `UpdateTimeout` for timeout failed".to_string());
    self
  }

  pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.wait_for_active_shards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for wait_for_active_shards failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::UpdateBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `UpdateBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/{index}/_update/{id}`
  pub async fn send(self) -> Result<ResponseValue<types::IndexResponse>, Error<()>> {
    let Self {
      client,
      index,
      id,
      source,
      source_excludes,
      source_includes,
      if_primary_term,
      if_seq_no,
      lang,
      refresh,
      require_alias,
      retry_on_conflict,
      routing,
      timeout,
      wait_for_active_shards,
      body,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let id = id.map_err(Error::InvalidRequest)?;
    let source = source.map_err(Error::InvalidRequest)?;
    let source_excludes = source_excludes.map_err(Error::InvalidRequest)?;
    let source_includes = source_includes.map_err(Error::InvalidRequest)?;
    let if_primary_term = if_primary_term.map_err(Error::InvalidRequest)?;
    let if_seq_no = if_seq_no.map_err(Error::InvalidRequest)?;
    let lang = lang.map_err(Error::InvalidRequest)?;
    let refresh = refresh.map_err(Error::InvalidRequest)?;
    let require_alias = require_alias.map_err(Error::InvalidRequest)?;
    let retry_on_conflict = retry_on_conflict.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_update/{}",
      client.baseurl,
      encode_path(&index.to_string()),
      encode_path(&id.to_string()),
    );
    let mut query = Vec::with_capacity(12usize);
    if let Some(v) = &source {
      query.push(("_source", v.join(",")));
    }
    if let Some(v) = &source_excludes {
      query.push(("_source_excludes", v.join(",")));
    }
    if let Some(v) = &source_includes {
      query.push(("_source_includes", v.join(",")));
    }
    if let Some(v) = &if_primary_term {
      query.push(("if_primary_term", v.to_string()));
    }
    if let Some(v) = &if_seq_no {
      query.push(("if_seq_no", v.to_string()));
    }
    if let Some(v) = &lang {
      query.push(("lang", v.to_string()));
    }
    if let Some(v) = &refresh {
      query.push(("refresh", v.to_string()));
    }
    if let Some(v) = &require_alias {
      query.push(("require_alias", v.to_string()));
    }
    if let Some(v) = &retry_on_conflict {
      query.push(("retry_on_conflict", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &wait_for_active_shards {
      query.push(("wait_for_active_shards", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => ResponseValue::from_response(response).await,
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::update_by_query`]
///
///[`Client::update_by_query`]: super::Client::update_by_query
#[derive(Debug, Clone)]
pub struct UpdateByQuery<'a> {
  client: &'a super::Client,
  index: Result<types::UpdateByQueryIndex, String>,
  source: Result<Option<Vec<String>>, String>,
  source_excludes: Result<Option<Vec<String>>, String>,
  source_includes: Result<Option<Vec<String>>, String>,
  allow_no_indices: Result<Option<bool>, String>,
  analyze_wildcard: Result<Option<bool>, String>,
  analyzer: Result<Option<String>, String>,
  conflicts: Result<Option<types::Conflicts>, String>,
  default_operator: Result<Option<types::DefaultOperator>, String>,
  df: Result<Option<String>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  from: Result<Option<i32>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  lenient: Result<Option<bool>, String>,
  max_docs: Result<Option<i32>, String>,
  pipeline: Result<Option<String>, String>,
  preference: Result<Option<String>, String>,
  q: Result<Option<String>, String>,
  refresh: Result<Option<bool>, String>,
  request_cache: Result<Option<bool>, String>,
  requests_per_second: Result<Option<i32>, String>,
  routing: Result<Option<Vec<String>>, String>,
  scroll: Result<Option<types::UpdateByQueryScroll>, String>,
  scroll_size: Result<Option<i32>, String>,
  search_timeout: Result<Option<types::UpdateByQuerySearchTimeout>, String>,
  search_type: Result<Option<types::SearchType>, String>,
  size: Result<Option<i32>, String>,
  slices: Result<Option<String>, String>,
  sort: Result<Option<Vec<String>>, String>,
  stats: Result<Option<Vec<String>>, String>,
  terminate_after: Result<Option<i32>, String>,
  timeout: Result<Option<types::UpdateByQueryTimeout>, String>,
  version: Result<Option<bool>, String>,
  wait_for_active_shards: Result<Option<String>, String>,
  wait_for_completion: Result<Option<bool>, String>,
  body: Result<types::UpdateByQueryBodyParams, String>,
}

impl<'a> UpdateByQuery<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      source: Ok(None),
      source_excludes: Ok(None),
      source_includes: Ok(None),
      allow_no_indices: Ok(None),
      analyze_wildcard: Ok(None),
      analyzer: Ok(None),
      conflicts: Ok(None),
      default_operator: Ok(None),
      df: Ok(None),
      expand_wildcards: Ok(None),
      from: Ok(None),
      ignore_unavailable: Ok(None),
      lenient: Ok(None),
      max_docs: Ok(None),
      pipeline: Ok(None),
      preference: Ok(None),
      q: Ok(None),
      refresh: Ok(None),
      request_cache: Ok(None),
      requests_per_second: Ok(None),
      routing: Ok(None),
      scroll: Ok(None),
      scroll_size: Ok(None),
      search_timeout: Ok(None),
      search_type: Ok(None),
      size: Ok(None),
      slices: Ok(None),
      sort: Ok(None),
      stats: Ok(None),
      terminate_after: Ok(None),
      timeout: Ok(None),
      version: Ok(None),
      wait_for_active_shards: Ok(None),
      wait_for_completion: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::UpdateByQueryIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `UpdateByQueryIndex` for index failed".to_string());
    self
  }

  pub fn source<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source failed".to_string());
    self
  }

  pub fn source_excludes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source_excludes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source_excludes failed".to_string());
    self
  }

  pub fn source_includes<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.source_includes = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for source_includes failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn analyze_wildcard<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.analyze_wildcard = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for analyze_wildcard failed".to_string());
    self
  }

  pub fn analyzer<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.analyzer = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for analyzer failed".to_string());
    self
  }

  pub fn conflicts<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::Conflicts>, {
    self.conflicts = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Conflicts` for conflicts failed".to_string());
    self
  }

  pub fn default_operator<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::DefaultOperator>, {
    self.default_operator = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `DefaultOperator` for default_operator failed".to_string());
    self
  }

  pub fn df<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.df = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for df failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn from<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.from = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for from failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn lenient<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.lenient = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for lenient failed".to_string());
    self
  }

  pub fn max_docs<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.max_docs = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for max_docs failed".to_string());
    self
  }

  pub fn pipeline<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.pipeline = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for pipeline failed".to_string());
    self
  }

  pub fn preference<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.preference = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for preference failed".to_string());
    self
  }

  pub fn q<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.q = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for q failed".to_string());
    self
  }

  pub fn refresh<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.refresh = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for refresh failed".to_string());
    self
  }

  pub fn request_cache<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.request_cache = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for request_cache failed".to_string());
    self
  }

  pub fn requests_per_second<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.requests_per_second = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for requests_per_second failed".to_string());
    self
  }

  pub fn routing<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.routing = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for routing failed".to_string());
    self
  }

  pub fn scroll<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::UpdateByQueryScroll>, {
    self.scroll = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `UpdateByQueryScroll` for scroll failed".to_string());
    self
  }

  pub fn scroll_size<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.scroll_size = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for scroll_size failed".to_string());
    self
  }

  pub fn search_timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::UpdateByQuerySearchTimeout>, {
    self.search_timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `UpdateByQuerySearchTimeout` for search_timeout failed".to_string());
    self
  }

  pub fn search_type<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::SearchType>, {
    self.search_type = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `SearchType` for search_type failed".to_string());
    self
  }

  pub fn size<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.size = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for size failed".to_string());
    self
  }

  pub fn slices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.slices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for slices failed".to_string());
    self
  }

  pub fn sort<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.sort = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for sort failed".to_string());
    self
  }

  pub fn stats<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<Vec<String>>, {
    self.stats = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `Vec < String >` for stats failed".to_string());
    self
  }

  pub fn terminate_after<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<i32>, {
    self.terminate_after = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `i32` for terminate_after failed".to_string());
    self
  }

  pub fn timeout<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::UpdateByQueryTimeout>, {
    self.timeout = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `UpdateByQueryTimeout` for timeout failed".to_string());
    self
  }

  pub fn version<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.version = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for version failed".to_string());
    self
  }

  pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.wait_for_active_shards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for wait_for_active_shards failed".to_string());
    self
  }

  pub fn wait_for_completion<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.wait_for_completion = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for wait_for_completion failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::UpdateByQueryBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `UpdateByQueryBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/{index}/_update_by_query`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      source,
      source_excludes,
      source_includes,
      allow_no_indices,
      analyze_wildcard,
      analyzer,
      conflicts,
      default_operator,
      df,
      expand_wildcards,
      from,
      ignore_unavailable,
      lenient,
      max_docs,
      pipeline,
      preference,
      q,
      refresh,
      request_cache,
      requests_per_second,
      routing,
      scroll,
      scroll_size,
      search_timeout,
      search_type,
      size,
      slices,
      sort,
      stats,
      terminate_after,
      timeout,
      version,
      wait_for_active_shards,
      wait_for_completion,
      body,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let source = source.map_err(Error::InvalidRequest)?;
    let source_excludes = source_excludes.map_err(Error::InvalidRequest)?;
    let source_includes = source_includes.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let analyze_wildcard = analyze_wildcard.map_err(Error::InvalidRequest)?;
    let analyzer = analyzer.map_err(Error::InvalidRequest)?;
    let conflicts = conflicts.map_err(Error::InvalidRequest)?;
    let default_operator = default_operator.map_err(Error::InvalidRequest)?;
    let df = df.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let from = from.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let lenient = lenient.map_err(Error::InvalidRequest)?;
    let max_docs = max_docs.map_err(Error::InvalidRequest)?;
    let pipeline = pipeline.map_err(Error::InvalidRequest)?;
    let preference = preference.map_err(Error::InvalidRequest)?;
    let q = q.map_err(Error::InvalidRequest)?;
    let refresh = refresh.map_err(Error::InvalidRequest)?;
    let request_cache = request_cache.map_err(Error::InvalidRequest)?;
    let requests_per_second = requests_per_second.map_err(Error::InvalidRequest)?;
    let routing = routing.map_err(Error::InvalidRequest)?;
    let scroll = scroll.map_err(Error::InvalidRequest)?;
    let scroll_size = scroll_size.map_err(Error::InvalidRequest)?;
    let search_timeout = search_timeout.map_err(Error::InvalidRequest)?;
    let search_type = search_type.map_err(Error::InvalidRequest)?;
    let size = size.map_err(Error::InvalidRequest)?;
    let slices = slices.map_err(Error::InvalidRequest)?;
    let sort = sort.map_err(Error::InvalidRequest)?;
    let stats = stats.map_err(Error::InvalidRequest)?;
    let terminate_after = terminate_after.map_err(Error::InvalidRequest)?;
    let timeout = timeout.map_err(Error::InvalidRequest)?;
    let version = version.map_err(Error::InvalidRequest)?;
    let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
    let wait_for_completion = wait_for_completion.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!(
      "{}/{}/_update_by_query",
      client.baseurl,
      encode_path(&index.to_string()),
    );
    let mut query = Vec::with_capacity(34usize);
    if let Some(v) = &source {
      query.push(("_source", v.join(",")));
    }
    if let Some(v) = &source_excludes {
      query.push(("_source_excludes", v.join(",")));
    }
    if let Some(v) = &source_includes {
      query.push(("_source_includes", v.join(",")));
    }
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &analyze_wildcard {
      query.push(("analyze_wildcard", v.to_string()));
    }
    if let Some(v) = &analyzer {
      query.push(("analyzer", v.to_string()));
    }
    if let Some(v) = &conflicts {
      query.push(("conflicts", v.to_string()));
    }
    if let Some(v) = &default_operator {
      query.push(("default_operator", v.to_string()));
    }
    if let Some(v) = &df {
      query.push(("df", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &from {
      query.push(("from", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &lenient {
      query.push(("lenient", v.to_string()));
    }
    if let Some(v) = &max_docs {
      query.push(("max_docs", v.to_string()));
    }
    if let Some(v) = &pipeline {
      query.push(("pipeline", v.to_string()));
    }
    if let Some(v) = &preference {
      query.push(("preference", v.to_string()));
    }
    if let Some(v) = &q {
      query.push(("q", v.to_string()));
    }
    if let Some(v) = &refresh {
      query.push(("refresh", v.to_string()));
    }
    if let Some(v) = &request_cache {
      query.push(("request_cache", v.to_string()));
    }
    if let Some(v) = &requests_per_second {
      query.push(("requests_per_second", v.to_string()));
    }
    if let Some(v) = &routing {
      query.push(("routing", v.join(",")));
    }
    if let Some(v) = &scroll {
      query.push(("scroll", v.to_string()));
    }
    if let Some(v) = &scroll_size {
      query.push(("scroll_size", v.to_string()));
    }
    if let Some(v) = &search_timeout {
      query.push(("search_timeout", v.to_string()));
    }
    if let Some(v) = &search_type {
      query.push(("search_type", v.to_string()));
    }
    if let Some(v) = &size {
      query.push(("size", v.to_string()));
    }
    if let Some(v) = &slices {
      query.push(("slices", v.to_string()));
    }
    if let Some(v) = &sort {
      query.push(("sort", v.join(",")));
    }
    if let Some(v) = &stats {
      query.push(("stats", v.join(",")));
    }
    if let Some(v) = &terminate_after {
      query.push(("terminate_after", v.to_string()));
    }
    if let Some(v) = &timeout {
      query.push(("timeout", v.to_string()));
    }
    if let Some(v) = &version {
      query.push(("version", v.to_string()));
    }
    if let Some(v) = &wait_for_active_shards {
      query.push(("wait_for_active_shards", v.to_string()));
    }
    if let Some(v) = &wait_for_completion {
      query.push(("wait_for_completion", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_get_upgrade_with_index`]
///
///[`Client::indices_get_upgrade_with_index`]: super::Client::indices_get_upgrade_with_index
#[derive(Debug, Clone)]
pub struct IndicesGetUpgradeWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesGetUpgradeWithIndexIndex, String>,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
}

impl<'a> IndicesGetUpgradeWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      ignore_unavailable: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesGetUpgradeWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesGetUpgradeWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  ///Sends a `GET` request to `/{index}/_upgrade`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      allow_no_indices,
      expand_wildcards,
      ignore_unavailable,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}/_upgrade", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(3usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_upgrade_with_index`]
///
///[`Client::indices_upgrade_with_index`]: super::Client::indices_upgrade_with_index
#[derive(Debug, Clone)]
pub struct IndicesUpgradeWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesUpgradeWithIndexIndex, String>,
  allow_no_indices: Result<Option<bool>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  only_ancient_segments: Result<Option<bool>, String>,
  wait_for_completion: Result<Option<bool>, String>,
}

impl<'a> IndicesUpgradeWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      allow_no_indices: Ok(None),
      expand_wildcards: Ok(None),
      ignore_unavailable: Ok(None),
      only_ancient_segments: Ok(None),
      wait_for_completion: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesUpgradeWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesUpgradeWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn only_ancient_segments<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.only_ancient_segments = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for only_ancient_segments failed".to_string());
    self
  }

  pub fn wait_for_completion<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.wait_for_completion = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for wait_for_completion failed".to_string());
    self
  }

  ///Sends a `POST` request to `/{index}/_upgrade`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      allow_no_indices,
      expand_wildcards,
      ignore_unavailable,
      only_ancient_segments,
      wait_for_completion,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let only_ancient_segments = only_ancient_segments.map_err(Error::InvalidRequest)?;
    let wait_for_completion = wait_for_completion.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}/_upgrade", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(5usize);
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &only_ancient_segments {
      query.push(("only_ancient_segments", v.to_string()));
    }
    if let Some(v) = &wait_for_completion {
      query.push(("wait_for_completion", v.to_string()));
    }
    let request = client.client.post(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_validate_query_get_with_index`]
///
///[`Client::indices_validate_query_get_with_index`]: super::Client::indices_validate_query_get_with_index
#[derive(Debug, Clone)]
pub struct IndicesValidateQueryGetWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesValidateQueryGetWithIndexIndex, String>,
  all_shards: Result<Option<bool>, String>,
  allow_no_indices: Result<Option<bool>, String>,
  analyze_wildcard: Result<Option<bool>, String>,
  analyzer: Result<Option<String>, String>,
  default_operator: Result<Option<types::DefaultOperator>, String>,
  df: Result<Option<String>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  explain: Result<Option<bool>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  lenient: Result<Option<bool>, String>,
  q: Result<Option<String>, String>,
  rewrite: Result<Option<bool>, String>,
}

impl<'a> IndicesValidateQueryGetWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      all_shards: Ok(None),
      allow_no_indices: Ok(None),
      analyze_wildcard: Ok(None),
      analyzer: Ok(None),
      default_operator: Ok(None),
      df: Ok(None),
      expand_wildcards: Ok(None),
      explain: Ok(None),
      ignore_unavailable: Ok(None),
      lenient: Ok(None),
      q: Ok(None),
      rewrite: Ok(None),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesValidateQueryGetWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesValidateQueryGetWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn all_shards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.all_shards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for all_shards failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn analyze_wildcard<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.analyze_wildcard = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for analyze_wildcard failed".to_string());
    self
  }

  pub fn analyzer<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.analyzer = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for analyzer failed".to_string());
    self
  }

  pub fn default_operator<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::DefaultOperator>, {
    self.default_operator = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `DefaultOperator` for default_operator failed".to_string());
    self
  }

  pub fn df<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.df = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for df failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn explain<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.explain = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for explain failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn lenient<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.lenient = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for lenient failed".to_string());
    self
  }

  pub fn q<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.q = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for q failed".to_string());
    self
  }

  pub fn rewrite<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.rewrite = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for rewrite failed".to_string());
    self
  }

  ///Sends a `GET` request to `/{index}/_validate/query`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      all_shards,
      allow_no_indices,
      analyze_wildcard,
      analyzer,
      default_operator,
      df,
      expand_wildcards,
      explain,
      ignore_unavailable,
      lenient,
      q,
      rewrite,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let all_shards = all_shards.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let analyze_wildcard = analyze_wildcard.map_err(Error::InvalidRequest)?;
    let analyzer = analyzer.map_err(Error::InvalidRequest)?;
    let default_operator = default_operator.map_err(Error::InvalidRequest)?;
    let df = df.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let explain = explain.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let lenient = lenient.map_err(Error::InvalidRequest)?;
    let q = q.map_err(Error::InvalidRequest)?;
    let rewrite = rewrite.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}/_validate/query", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(12usize);
    if let Some(v) = &all_shards {
      query.push(("all_shards", v.to_string()));
    }
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &analyze_wildcard {
      query.push(("analyze_wildcard", v.to_string()));
    }
    if let Some(v) = &analyzer {
      query.push(("analyzer", v.to_string()));
    }
    if let Some(v) = &default_operator {
      query.push(("default_operator", v.to_string()));
    }
    if let Some(v) = &df {
      query.push(("df", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &explain {
      query.push(("explain", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &lenient {
      query.push(("lenient", v.to_string()));
    }
    if let Some(v) = &q {
      query.push(("q", v.to_string()));
    }
    if let Some(v) = &rewrite {
      query.push(("rewrite", v.to_string()));
    }
    let request = client.client.get(url).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}

///Builder for [`Client::indices_validate_query_post_with_index`]
///
///[`Client::indices_validate_query_post_with_index`]: super::Client::indices_validate_query_post_with_index
#[derive(Debug, Clone)]
pub struct IndicesValidateQueryPostWithIndex<'a> {
  client: &'a super::Client,
  index: Result<types::IndicesValidateQueryPostWithIndexIndex, String>,
  all_shards: Result<Option<bool>, String>,
  allow_no_indices: Result<Option<bool>, String>,
  analyze_wildcard: Result<Option<bool>, String>,
  analyzer: Result<Option<String>, String>,
  default_operator: Result<Option<types::DefaultOperator>, String>,
  df: Result<Option<String>, String>,
  expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
  explain: Result<Option<bool>, String>,
  ignore_unavailable: Result<Option<bool>, String>,
  lenient: Result<Option<bool>, String>,
  q: Result<Option<String>, String>,
  rewrite: Result<Option<bool>, String>,
  body: Result<types::IndicesValidateQueryBodyParams, String>,
}

impl<'a> IndicesValidateQueryPostWithIndex<'a> {
  pub fn new(client: &'a super::Client) -> Self {
    Self {
      client,
      index: Err("index was not initialized".to_string()),
      all_shards: Ok(None),
      allow_no_indices: Ok(None),
      analyze_wildcard: Ok(None),
      analyzer: Ok(None),
      default_operator: Ok(None),
      df: Ok(None),
      expand_wildcards: Ok(None),
      explain: Ok(None),
      ignore_unavailable: Ok(None),
      lenient: Ok(None),
      q: Ok(None),
      rewrite: Ok(None),
      body: Err("body was not initialized".to_string()),
    }
  }

  pub fn index<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesValidateQueryPostWithIndexIndex>, {
    self.index = value
      .try_into()
      .map_err(|_| "conversion to `IndicesValidateQueryPostWithIndexIndex` for index failed".to_string());
    self
  }

  pub fn all_shards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.all_shards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for all_shards failed".to_string());
    self
  }

  pub fn allow_no_indices<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.allow_no_indices = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
    self
  }

  pub fn analyze_wildcard<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.analyze_wildcard = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for analyze_wildcard failed".to_string());
    self
  }

  pub fn analyzer<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.analyzer = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for analyzer failed".to_string());
    self
  }

  pub fn default_operator<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::DefaultOperator>, {
    self.default_operator = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `DefaultOperator` for default_operator failed".to_string());
    self
  }

  pub fn df<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.df = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for df failed".to_string());
    self
  }

  pub fn expand_wildcards<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::ExpandWildcards>, {
    self.expand_wildcards = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `ExpandWildcards` for expand_wildcards failed".to_string());
    self
  }

  pub fn explain<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.explain = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for explain failed".to_string());
    self
  }

  pub fn ignore_unavailable<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.ignore_unavailable = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
    self
  }

  pub fn lenient<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.lenient = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for lenient failed".to_string());
    self
  }

  pub fn q<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<String>, {
    self.q = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `String` for q failed".to_string());
    self
  }

  pub fn rewrite<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<bool>, {
    self.rewrite = value
      .try_into()
      .map(Some)
      .map_err(|_| "conversion to `bool` for rewrite failed".to_string());
    self
  }

  pub fn body<V>(mut self, value: V) -> Self
  where
    V: std::convert::TryInto<types::IndicesValidateQueryBodyParams>, {
    self.body = value
      .try_into()
      .map_err(|_| "conversion to `IndicesValidateQueryBodyParams` for body failed".to_string());
    self
  }

  ///Sends a `POST` request to `/{index}/_validate/query`
  pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
    let Self {
      client,
      index,
      all_shards,
      allow_no_indices,
      analyze_wildcard,
      analyzer,
      default_operator,
      df,
      expand_wildcards,
      explain,
      ignore_unavailable,
      lenient,
      q,
      rewrite,
      body,
    } = self;
    let index = index.map_err(Error::InvalidRequest)?;
    let all_shards = all_shards.map_err(Error::InvalidRequest)?;
    let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
    let analyze_wildcard = analyze_wildcard.map_err(Error::InvalidRequest)?;
    let analyzer = analyzer.map_err(Error::InvalidRequest)?;
    let default_operator = default_operator.map_err(Error::InvalidRequest)?;
    let df = df.map_err(Error::InvalidRequest)?;
    let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
    let explain = explain.map_err(Error::InvalidRequest)?;
    let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
    let lenient = lenient.map_err(Error::InvalidRequest)?;
    let q = q.map_err(Error::InvalidRequest)?;
    let rewrite = rewrite.map_err(Error::InvalidRequest)?;
    let body = body.map_err(Error::InvalidRequest)?;
    let url = format!("{}/{}/_validate/query", client.baseurl, encode_path(&index.to_string()),);
    let mut query = Vec::with_capacity(12usize);
    if let Some(v) = &all_shards {
      query.push(("all_shards", v.to_string()));
    }
    if let Some(v) = &allow_no_indices {
      query.push(("allow_no_indices", v.to_string()));
    }
    if let Some(v) = &analyze_wildcard {
      query.push(("analyze_wildcard", v.to_string()));
    }
    if let Some(v) = &analyzer {
      query.push(("analyzer", v.to_string()));
    }
    if let Some(v) = &default_operator {
      query.push(("default_operator", v.to_string()));
    }
    if let Some(v) = &df {
      query.push(("df", v.to_string()));
    }
    if let Some(v) = &expand_wildcards {
      query.push(("expand_wildcards", v.to_string()));
    }
    if let Some(v) = &explain {
      query.push(("explain", v.to_string()));
    }
    if let Some(v) = &ignore_unavailable {
      query.push(("ignore_unavailable", v.to_string()));
    }
    if let Some(v) = &lenient {
      query.push(("lenient", v.to_string()));
    }
    if let Some(v) = &q {
      query.push(("q", v.to_string()));
    }
    if let Some(v) = &rewrite {
      query.push(("rewrite", v.to_string()));
    }
    let request = client.client.post(url).json(&body).query(&query).build()?;
    let result = client.client.execute(request).await;
    let response = result?;
    match response.status().as_u16() {
      200u16 => Ok(ResponseValue::empty(response)),
      _ => Err(Error::UnexpectedResponse(response)),
    }
  }
}
