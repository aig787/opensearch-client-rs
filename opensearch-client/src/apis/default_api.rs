/*
 * OpenSearch
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2021-11-23
 *
 * Generated by: https://openapi-generator.tech
 */

use reqwest;

use crate::apis::ResponseContent;
use super::{configuration, Error};

/// struct for typed errors of method [`bulk_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkPostError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bulk_post_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkPostWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bulk_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkPutError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bulk_put_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkPutWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cat_aliases`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CatAliasesError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cat_aliases_with_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CatAliasesWithNameError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cat_all_pit_segments`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CatAllPitSegmentsError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cat_allocation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CatAllocationError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cat_allocation_with_node_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CatAllocationWithNodeIdError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cat_cluster_manager`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CatClusterManagerError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cat_count`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CatCountError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cat_count_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CatCountWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cat_fielddata`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CatFielddataError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cat_fielddata_with_fields`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CatFielddataWithFieldsError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cat_health`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CatHealthError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cat_help`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CatHelpError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cat_indices`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CatIndicesError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cat_indices_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CatIndicesWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cat_master`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CatMasterError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cat_nodeattrs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CatNodeattrsError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cat_nodes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CatNodesError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cat_pending_tasks`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CatPendingTasksError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cat_pit_segments`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CatPitSegmentsError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cat_plugins`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CatPluginsError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cat_recovery`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CatRecoveryError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cat_recovery_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CatRecoveryWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cat_repositories`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CatRepositoriesError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cat_segment_replication`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CatSegmentReplicationError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cat_segment_replication_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CatSegmentReplicationWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cat_segments`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CatSegmentsError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cat_segments_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CatSegmentsWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cat_shards`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CatShardsError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cat_shards_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CatShardsWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cat_snapshots`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CatSnapshotsError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cat_snapshots_with_repository`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CatSnapshotsWithRepositoryError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cat_tasks`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CatTasksError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cat_templates`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CatTemplatesError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cat_templates_with_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CatTemplatesWithNameError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cat_thread_pool`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CatThreadPoolError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method
/// [`cat_thread_pool_with_thread_pool_patterns`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CatThreadPoolWithThreadPoolPatternsError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`change_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChangePasswordError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`clear_scroll`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClearScrollError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`clear_scroll_with_scroll_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClearScrollWithScrollIdError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cluster_allocation_explain_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClusterAllocationExplainGetError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cluster_allocation_explain_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClusterAllocationExplainPostError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cluster_delete_component_template`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClusterDeleteComponentTemplateError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cluster_delete_decommission_awareness`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClusterDeleteDecommissionAwarenessError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method
/// [`cluster_delete_voting_config_exclusions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClusterDeleteVotingConfigExclusionsError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cluster_delete_weighted_routing`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClusterDeleteWeightedRoutingError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cluster_exists_component_template`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClusterExistsComponentTemplateError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cluster_get_component_template`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClusterGetComponentTemplateError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method
/// [`cluster_get_component_template_with_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClusterGetComponentTemplateWithNameError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cluster_get_decommission_awareness`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClusterGetDecommissionAwarenessError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cluster_get_settings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClusterGetSettingsError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cluster_get_weighted_routing`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClusterGetWeightedRoutingError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cluster_health`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClusterHealthError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cluster_health_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClusterHealthWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cluster_pending_tasks`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClusterPendingTasksError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cluster_post_voting_config_exclusions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClusterPostVotingConfigExclusionsError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cluster_put_component_template_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClusterPutComponentTemplatePostError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cluster_put_component_template_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClusterPutComponentTemplatePutError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cluster_put_decommission_awareness`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClusterPutDecommissionAwarenessError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cluster_put_settings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClusterPutSettingsError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cluster_put_weighted_routing`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClusterPutWeightedRoutingError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cluster_remote_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClusterRemoteInfoError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cluster_reroute`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClusterRerouteError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cluster_state`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClusterStateError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cluster_state_with_index_metric`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClusterStateWithIndexMetricError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cluster_state_with_metric`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClusterStateWithMetricError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cluster_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClusterStatsError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cluster_stats_with_node_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClusterStatsWithNodeIdError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`count_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CountGetError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`count_get_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CountGetWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`count_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CountPostError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`count_post_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CountPostWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_action_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateActionGroupError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_pit`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreatePitError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreatePostError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreatePutError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateRoleError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_role_mapping`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateRoleMappingError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_tenant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTenantError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUserError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`dangling_indices_delete_dangling_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DanglingIndicesDeleteDanglingIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`dangling_indices_import_dangling_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DanglingIndicesImportDanglingIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`dangling_indices_list_dangling_indices`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DanglingIndicesListDanglingIndicesError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_action_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteActionGroupError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_all_pits`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAllPitsError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_by_query`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteByQueryError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_by_query_rethrottle`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteByQueryRethrottleError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_distinguished_names`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDistinguishedNamesError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_pit`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeletePitError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRoleError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_role_mapping`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRoleMappingError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_script`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteScriptError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_tenant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteTenantError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUserError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`exists`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExistsError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`exists_source`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExistsSourceError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`explain_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExplainGetError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`explain_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExplainPostError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`field_caps_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FieldCapsGetError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`field_caps_get_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FieldCapsGetWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`field_caps_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FieldCapsPostError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`field_caps_post_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FieldCapsPostWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`flush_cache`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FlushCacheError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account_details`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountDetailsError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_action_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetActionGroupError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_action_groups`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetActionGroupsError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_all_pits`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAllPitsError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_audit_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuditConfigurationError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_certificates`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCertificatesError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetConfigurationError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_distinguished_names`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDistinguishedNamesError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method
/// [`get_distinguished_names_with_cluster_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDistinguishedNamesWithClusterNameError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRoleError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_role_mapping`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRoleMappingError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_role_mappings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRoleMappingsError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_roles`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRolesError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_script`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetScriptError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_script_context`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetScriptContextError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_script_languages`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetScriptLanguagesError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_source`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSourceError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_tenant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTenantError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_tenants`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTenantsError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_users`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUsersError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`index_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndexPostError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`index_post_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndexPostWithIdError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`index_put_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndexPutWithIdError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_add_block`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesAddBlockError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_analyze_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesAnalyzeGetError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_analyze_get_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesAnalyzeGetWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_analyze_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesAnalyzePostError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_analyze_post_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesAnalyzePostWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_clear_cache`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesClearCacheError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_clear_cache_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesClearCacheWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_clone_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesClonePostError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_clone_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesClonePutError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_close`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesCloseError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesCreateError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_create_data_stream`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesCreateDataStreamError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_data_streams_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesDataStreamsStatsError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_data_streams_stats_with_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesDataStreamsStatsWithNameError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesDeleteError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_delete_alias`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesDeleteAliasError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_delete_alias_plural`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesDeleteAliasPluralError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_delete_data_stream`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesDeleteDataStreamError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_delete_index_template`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesDeleteIndexTemplateError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_delete_template`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesDeleteTemplateError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_exists`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesExistsError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_exists_alias`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesExistsAliasError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_exists_alias_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesExistsAliasWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_exists_index_template`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesExistsIndexTemplateError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_exists_template`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesExistsTemplateError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_flush_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesFlushGetError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_flush_get_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesFlushGetWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_flush_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesFlushPostError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_flush_post_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesFlushPostWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_forcemerge`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesForcemergeError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_forcemerge_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesForcemergeWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesGetError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_get_alias`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesGetAliasError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_get_alias_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesGetAliasWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_get_alias_with_index_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesGetAliasWithIndexNameError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_get_alias_with_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesGetAliasWithNameError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_get_data_stream`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesGetDataStreamError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_get_data_stream_with_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesGetDataStreamWithNameError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_get_field_mapping`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesGetFieldMappingError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_get_field_mapping_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesGetFieldMappingWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_get_index_template`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesGetIndexTemplateError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_get_index_template_with_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesGetIndexTemplateWithNameError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_get_mapping`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesGetMappingError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_get_mapping_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesGetMappingWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_get_settings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesGetSettingsError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_get_settings_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesGetSettingsWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_get_settings_with_index_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesGetSettingsWithIndexNameError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_get_settings_with_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesGetSettingsWithNameError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_get_template`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesGetTemplateError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_get_template_with_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesGetTemplateWithNameError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_get_upgrade`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesGetUpgradeError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_get_upgrade_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesGetUpgradeWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_open`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesOpenError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_put_alias_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesPutAliasPostError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_put_alias_post_plural`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesPutAliasPostPluralError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_put_alias_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesPutAliasPutError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_put_alias_put_plural`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesPutAliasPutPluralError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_put_index_template_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesPutIndexTemplatePostError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_put_index_template_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesPutIndexTemplatePutError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_put_mapping_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesPutMappingPostError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_put_mapping_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesPutMappingPutError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_put_settings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesPutSettingsError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_put_settings_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesPutSettingsWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_put_template_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesPutTemplatePostError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_put_template_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesPutTemplatePutError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_recovery`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesRecoveryError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_recovery_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesRecoveryWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_refresh_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesRefreshGetError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_refresh_get_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesRefreshGetWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_refresh_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesRefreshPostError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_refresh_post_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesRefreshPostWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_resolve_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesResolveIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_rollover`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesRolloverError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_rollover_with_new_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesRolloverWithNewIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_segments`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesSegmentsError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_segments_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesSegmentsWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_shard_stores`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesShardStoresError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_shard_stores_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesShardStoresWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_shrink_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesShrinkPostError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_shrink_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesShrinkPutError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_simulate_index_template`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesSimulateIndexTemplateError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_simulate_template`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesSimulateTemplateError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_simulate_template_with_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesSimulateTemplateWithNameError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_split_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesSplitPostError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_split_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesSplitPutError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesStatsError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_stats_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesStatsWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_stats_with_index_metric`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesStatsWithIndexMetricError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_stats_with_metric`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesStatsWithMetricError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_update_aliases`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesUpdateAliasesError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_upgrade`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesUpgradeError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_upgrade_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesUpgradeWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_validate_query_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesValidateQueryGetError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_validate_query_get_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesValidateQueryGetWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_validate_query_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesValidateQueryPostError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indices_validate_query_post_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicesValidateQueryPostWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InfoError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ingest_delete_pipeline`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IngestDeletePipelineError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ingest_get_pipeline`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IngestGetPipelineError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ingest_get_pipeline_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IngestGetPipelineWithIdError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ingest_processor_grok`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IngestProcessorGrokError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ingest_put_pipeline`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IngestPutPipelineError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ingest_simulate_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IngestSimulateGetError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ingest_simulate_get_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IngestSimulateGetWithIdError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ingest_simulate_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IngestSimulatePostError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ingest_simulate_post_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IngestSimulatePostWithIdError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mget_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MgetGetError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mget_get_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MgetGetWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mget_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MgetPostError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mget_post_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MgetPostWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`msearch_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MsearchGetError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`msearch_get_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MsearchGetWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`msearch_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MsearchPostError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`msearch_post_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MsearchPostWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`msearch_template_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MsearchTemplateGetError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`msearch_template_get_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MsearchTemplateGetWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`msearch_template_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MsearchTemplatePostError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`msearch_template_post_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MsearchTemplatePostWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mtermvectors_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MtermvectorsGetError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mtermvectors_get_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MtermvectorsGetWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mtermvectors_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MtermvectorsPostError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mtermvectors_post_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MtermvectorsPostWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`nodes_hot_threads`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NodesHotThreadsError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`nodes_hot_threads_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NodesHotThreadsDeprecatedError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`nodes_hot_threads_deprecated_cluster`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NodesHotThreadsDeprecatedClusterError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`nodes_hot_threads_deprecated_dash`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NodesHotThreadsDeprecatedDashError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`nodes_hot_threads_with_node_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NodesHotThreadsWithNodeIdError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method
/// [`nodes_hot_threads_with_node_id_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NodesHotThreadsWithNodeIdDeprecatedError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method
/// [`nodes_hot_threads_with_node_id_deprecated_cluster`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NodesHotThreadsWithNodeIdDeprecatedClusterError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method
/// [`nodes_hot_threads_with_node_id_deprecated_dash`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NodesHotThreadsWithNodeIdDeprecatedDashError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`nodes_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NodesInfoError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`nodes_info_with_metric_node_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NodesInfoWithMetricNodeIdError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`nodes_info_with_node_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NodesInfoWithNodeIdError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`nodes_reload_secure_settings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NodesReloadSecureSettingsError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method
/// [`nodes_reload_secure_settings_with_node_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NodesReloadSecureSettingsWithNodeIdError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`nodes_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NodesStatsError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`nodes_stats_with_index_metric_metric`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NodesStatsWithIndexMetricMetricError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method
/// [`nodes_stats_with_index_metric_metric_node_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NodesStatsWithIndexMetricMetricNodeIdError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`nodes_stats_with_metric`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NodesStatsWithMetricError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`nodes_stats_with_metric_node_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NodesStatsWithMetricNodeIdError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`nodes_stats_with_node_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NodesStatsWithNodeIdError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`nodes_usage`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NodesUsageError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`nodes_usage_with_metric`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NodesUsageWithMetricError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`nodes_usage_with_metric_node_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NodesUsageWithMetricNodeIdError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`nodes_usage_with_node_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NodesUsageWithNodeIdError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_action_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchActionGroupError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_action_groups`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchActionGroupsError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_audit_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchAuditConfigurationError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchConfigurationError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_distinguished_names`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchDistinguishedNamesError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchRoleError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_role_mapping`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchRoleMappingError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_role_mappings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchRoleMappingsError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_roles`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchRolesError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_tenant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchTenantError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_tenants`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchTenantsError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchUserError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_users`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchUsersError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ping`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PingError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`put_script_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PutScriptPostError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`put_script_post_with_context`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PutScriptPostWithContextError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`put_script_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PutScriptPutError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`put_script_put_with_context`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PutScriptPutWithContextError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rank_eval_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RankEvalGetError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rank_eval_get_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RankEvalGetWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rank_eval_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RankEvalPostError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rank_eval_post_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RankEvalPostWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reindex`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReindexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reindex_rethrottle`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReindexRethrottleError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reload_http_certificates`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReloadHttpCertificatesError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reload_transport_certificates`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReloadTransportCertificatesError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remote_store_restore`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoteStoreRestoreError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`render_search_template_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RenderSearchTemplateGetError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`render_search_template_get_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RenderSearchTemplateGetWithIdError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`render_search_template_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RenderSearchTemplatePostError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`render_search_template_post_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RenderSearchTemplatePostWithIdError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`scripts_painless_execute_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ScriptsPainlessExecuteGetError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`scripts_painless_execute_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ScriptsPainlessExecutePostError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`scroll_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ScrollGetError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`scroll_get_with_scroll_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ScrollGetWithScrollIdError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`scroll_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ScrollPostError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`scroll_post_with_scroll_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ScrollPostWithScrollIdError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchGetError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_get_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchGetWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchPostError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_post_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchPostWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_shards_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchShardsGetError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_shards_get_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchShardsGetWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_shards_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchShardsPostError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_shards_post_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchShardsPostWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_template_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchTemplateGetError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_template_get_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchTemplateGetWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_template_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchTemplatePostError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_template_post_with_index`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchTemplatePostWithIndexError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`security_health`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SecurityHealthError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`snapshot_cleanup_repository`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SnapshotCleanupRepositoryError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`snapshot_clone`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SnapshotCloneError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`snapshot_create_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SnapshotCreatePostError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`snapshot_create_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SnapshotCreatePutError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`snapshot_create_repository_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SnapshotCreateRepositoryPostError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`snapshot_create_repository_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SnapshotCreateRepositoryPutError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`snapshot_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SnapshotDeleteError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`snapshot_delete_repository`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SnapshotDeleteRepositoryError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`snapshot_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SnapshotGetError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`snapshot_get_repository`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SnapshotGetRepositoryError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method
/// [`snapshot_get_repository_with_repository`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SnapshotGetRepositoryWithRepositoryError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`snapshot_restore`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SnapshotRestoreError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`snapshot_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SnapshotStatusError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`snapshot_status_with_repository`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SnapshotStatusWithRepositoryError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method
/// [`snapshot_status_with_repository_snapshot`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SnapshotStatusWithRepositorySnapshotError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`snapshot_verify_repository`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SnapshotVerifyRepositoryError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tasks_cancel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TasksCancelError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tasks_cancel_with_task_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TasksCancelWithTaskIdError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tasks_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TasksGetError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tasks_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TasksListError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`termvectors_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TermvectorsGetError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`termvectors_get_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TermvectorsGetWithIdError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`termvectors_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TermvectorsPostError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`termvectors_post_with_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TermvectorsPostWithIdError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_audit_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateAuditConfigurationError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_by_query`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateByQueryError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_by_query_rethrottle`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateByQueryRethrottleError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateConfigurationError {
  UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_distinguished_names`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDistinguishedNamesError {
  UnknownValue(serde_json::Value),
}

/// Allows to perform multiple index/update/delete operations in a single
/// request.
pub async fn bulk_post(
  configuration: &configuration::Configuration,
  body: serde_json::Value,
  wait_for_active_shards: Option<&str>,
  refresh: Option<RefreshEnum>,
  routing: Option<&str>,
  timeout: Option<&str>,
  r#type: Option<&str>,
  _source: Option<Vec<String>>,
  _source_excludes: Option<Vec<String>>,
  _source_includes: Option<Vec<String>>,
  pipeline: Option<&str>,
  require_alias: Option<bool>,
) -> Result<(), Error<BulkPostError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_bulk", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = wait_for_active_shards {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_active_shards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = refresh {
    local_var_req_builder = local_var_req_builder.query(&[("refresh", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = r#type {
    local_var_req_builder = local_var_req_builder.query(&[("type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = _source {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_excludes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_excludes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_excludes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_includes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_includes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_includes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = pipeline {
    local_var_req_builder = local_var_req_builder.query(&[("pipeline", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = require_alias {
    local_var_req_builder = local_var_req_builder.query(&[("require_alias", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<BulkPostError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows to perform multiple index/update/delete operations in a single
/// request.
pub async fn bulk_post_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  body: serde_json::Value,
  wait_for_active_shards: Option<&str>,
  refresh: Option<RefreshEnum>,
  routing: Option<&str>,
  timeout: Option<&str>,
  r#type: Option<&str>,
  _source: Option<Vec<String>>,
  _source_excludes: Option<Vec<String>>,
  _source_includes: Option<Vec<String>>,
  pipeline: Option<&str>,
  require_alias: Option<bool>,
) -> Result<(), Error<BulkPostWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_bulk",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = wait_for_active_shards {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_active_shards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = refresh {
    local_var_req_builder = local_var_req_builder.query(&[("refresh", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = r#type {
    local_var_req_builder = local_var_req_builder.query(&[("type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = _source {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_excludes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_excludes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_excludes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_includes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_includes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_includes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = pipeline {
    local_var_req_builder = local_var_req_builder.query(&[("pipeline", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = require_alias {
    local_var_req_builder = local_var_req_builder.query(&[("require_alias", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<BulkPostWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows to perform multiple index/update/delete operations in a single
/// request.
pub async fn bulk_put(
  configuration: &configuration::Configuration,
  body: serde_json::Value,
  wait_for_active_shards: Option<&str>,
  refresh: Option<RefreshEnum>,
  routing: Option<&str>,
  timeout: Option<&str>,
  r#type: Option<&str>,
  _source: Option<Vec<String>>,
  _source_excludes: Option<Vec<String>>,
  _source_includes: Option<Vec<String>>,
  pipeline: Option<&str>,
  require_alias: Option<bool>,
) -> Result<(), Error<BulkPutError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_bulk", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = wait_for_active_shards {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_active_shards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = refresh {
    local_var_req_builder = local_var_req_builder.query(&[("refresh", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = r#type {
    local_var_req_builder = local_var_req_builder.query(&[("type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = _source {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_excludes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_excludes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_excludes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_includes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_includes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_includes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = pipeline {
    local_var_req_builder = local_var_req_builder.query(&[("pipeline", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = require_alias {
    local_var_req_builder = local_var_req_builder.query(&[("require_alias", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<BulkPutError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows to perform multiple index/update/delete operations in a single
/// request.
pub async fn bulk_put_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  body: serde_json::Value,
  wait_for_active_shards: Option<&str>,
  refresh: Option<RefreshEnum>,
  routing: Option<&str>,
  timeout: Option<&str>,
  r#type: Option<&str>,
  _source: Option<Vec<String>>,
  _source_excludes: Option<Vec<String>>,
  _source_includes: Option<Vec<String>>,
  pipeline: Option<&str>,
  require_alias: Option<bool>,
) -> Result<(), Error<BulkPutWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_bulk",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = wait_for_active_shards {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_active_shards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = refresh {
    local_var_req_builder = local_var_req_builder.query(&[("refresh", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = r#type {
    local_var_req_builder = local_var_req_builder.query(&[("type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = _source {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_excludes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_excludes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_excludes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_includes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_includes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_includes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = pipeline {
    local_var_req_builder = local_var_req_builder.query(&[("pipeline", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = require_alias {
    local_var_req_builder = local_var_req_builder.query(&[("require_alias", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<BulkPutWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Shows information about currently configured aliases to indices including
/// filter and routing infos.
pub async fn cat_aliases(
  configuration: &configuration::Configuration,
  format: Option<&str>,
  local: Option<bool>,
  h: Option<Vec<String>>,
  help: Option<bool>,
  s: Option<Vec<String>>,
  v: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
) -> Result<(), Error<CatAliasesError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_cat/aliases", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = format {
    local_var_req_builder = local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = h {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("h".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "h",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = help {
    local_var_req_builder = local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = s {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("s".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "s",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = v {
    local_var_req_builder = local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CatAliasesError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Shows information about currently configured aliases to indices including
/// filter and routing infos.
pub async fn cat_aliases_with_name(
  configuration: &configuration::Configuration,
  name: &str,
  format: Option<&str>,
  local: Option<bool>,
  h: Option<Vec<String>>,
  help: Option<bool>,
  s: Option<Vec<String>>,
  v: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
) -> Result<(), Error<CatAliasesWithNameError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_cat/aliases/{name}",
    local_var_configuration.base_path,
    name = crate::apis::urlencode(name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = format {
    local_var_req_builder = local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = h {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("h".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "h",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = help {
    local_var_req_builder = local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = s {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("s".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "s",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = v {
    local_var_req_builder = local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CatAliasesWithNameError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Lists all active point-in-time segments.
pub async fn cat_all_pit_segments(
  configuration: &configuration::Configuration,
) -> Result<crate::models::CatAllPitSegmentsResponseContent, Error<CatAllPitSegmentsError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_cat/pit_segments/_all", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<CatAllPitSegmentsError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Provides a snapshot of how many shards are allocated to each data node and
/// how much disk space they are using.
pub async fn cat_allocation(
  configuration: &configuration::Configuration,
  format: Option<&str>,
  bytes: Option<Bytes>,
  local: Option<bool>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  h: Option<Vec<String>>,
  help: Option<bool>,
  s: Option<Vec<String>>,
  v: Option<bool>,
) -> Result<(), Error<CatAllocationError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_cat/allocation", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = format {
    local_var_req_builder = local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = bytes {
    local_var_req_builder = local_var_req_builder.query(&[("bytes", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = h {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("h".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "h",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = help {
    local_var_req_builder = local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = s {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("s".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "s",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = v {
    local_var_req_builder = local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CatAllocationError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Provides a snapshot of how many shards are allocated to each data node and
/// how much disk space they are using.
pub async fn cat_allocation_with_node_id(
  configuration: &configuration::Configuration,
  node_id: &str,
  format: Option<&str>,
  bytes: Option<Bytes>,
  local: Option<bool>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  h: Option<Vec<String>>,
  help: Option<bool>,
  s: Option<Vec<String>>,
  v: Option<bool>,
) -> Result<(), Error<CatAllocationWithNodeIdError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_cat/allocation/{node_id}",
    local_var_configuration.base_path,
    node_id = crate::apis::urlencode(node_id)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = format {
    local_var_req_builder = local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = bytes {
    local_var_req_builder = local_var_req_builder.query(&[("bytes", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = h {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("h".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "h",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = help {
    local_var_req_builder = local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = s {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("s".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "s",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = v {
    local_var_req_builder = local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CatAllocationWithNodeIdError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about the cluster-manager node.
pub async fn cat_cluster_manager(
  configuration: &configuration::Configuration,
  format: Option<&str>,
  local: Option<bool>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  h: Option<Vec<String>>,
  help: Option<bool>,
  s: Option<Vec<String>>,
  v: Option<bool>,
) -> Result<(), Error<CatClusterManagerError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_cat/cluster_manager", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = format {
    local_var_req_builder = local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = h {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("h".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "h",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = help {
    local_var_req_builder = local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = s {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("s".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "s",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = v {
    local_var_req_builder = local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CatClusterManagerError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Provides quick access to the document count of the entire cluster, or
/// individual indices.
pub async fn cat_count(
  configuration: &configuration::Configuration,
  format: Option<&str>,
  h: Option<Vec<String>>,
  help: Option<bool>,
  s: Option<Vec<String>>,
  v: Option<bool>,
) -> Result<(), Error<CatCountError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_cat/count", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = format {
    local_var_req_builder = local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = h {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("h".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "h",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = help {
    local_var_req_builder = local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = s {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("s".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "s",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = v {
    local_var_req_builder = local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CatCountError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Provides quick access to the document count of the entire cluster, or
/// individual indices.
pub async fn cat_count_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  format: Option<&str>,
  h: Option<Vec<String>>,
  help: Option<bool>,
  s: Option<Vec<String>>,
  v: Option<bool>,
) -> Result<(), Error<CatCountWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_cat/count/{index}",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = format {
    local_var_req_builder = local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = h {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("h".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "h",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = help {
    local_var_req_builder = local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = s {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("s".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "s",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = v {
    local_var_req_builder = local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CatCountWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Shows how much heap memory is currently being used by fielddata on every
/// data node in the cluster.
pub async fn cat_fielddata(
  configuration: &configuration::Configuration,
  format: Option<&str>,
  bytes: Option<Bytes>,
  h: Option<Vec<String>>,
  help: Option<bool>,
  s: Option<Vec<String>>,
  v: Option<bool>,
  fields: Option<Vec<String>>,
) -> Result<(), Error<CatFielddataError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_cat/fielddata", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = format {
    local_var_req_builder = local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = bytes {
    local_var_req_builder = local_var_req_builder.query(&[("bytes", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = h {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("h".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "h",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = help {
    local_var_req_builder = local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = s {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("s".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "s",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = v {
    local_var_req_builder = local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CatFielddataError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Shows how much heap memory is currently being used by fielddata on every
/// data node in the cluster.
pub async fn cat_fielddata_with_fields(
  configuration: &configuration::Configuration,
  fields: &str,
  format: Option<&str>,
  bytes: Option<Bytes>,
  h: Option<Vec<String>>,
  help: Option<bool>,
  s: Option<Vec<String>>,
  v: Option<bool>,
  fields2: Option<Vec<String>>,
) -> Result<(), Error<CatFielddataWithFieldsError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_cat/fielddata/{fields}",
    local_var_configuration.base_path,
    fields = crate::apis::urlencode(fields)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = format {
    local_var_req_builder = local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = bytes {
    local_var_req_builder = local_var_req_builder.query(&[("bytes", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = h {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("h".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "h",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = help {
    local_var_req_builder = local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = s {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("s".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "s",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = v {
    local_var_req_builder = local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = fields2 {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CatFielddataWithFieldsError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns a concise representation of the cluster health.
pub async fn cat_health(
  configuration: &configuration::Configuration,
  format: Option<&str>,
  h: Option<Vec<String>>,
  help: Option<bool>,
  s: Option<Vec<String>>,
  time: Option<Time>,
  ts: Option<bool>,
  v: Option<bool>,
) -> Result<(), Error<CatHealthError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_cat/health", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = format {
    local_var_req_builder = local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = h {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("h".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "h",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = help {
    local_var_req_builder = local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = s {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("s".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "s",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = time {
    local_var_req_builder = local_var_req_builder.query(&[("time", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ts {
    local_var_req_builder = local_var_req_builder.query(&[("ts", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = v {
    local_var_req_builder = local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CatHealthError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns help for the Cat APIs.
pub async fn cat_help(
  configuration: &configuration::Configuration,
  help: Option<bool>,
  s: Option<Vec<String>>,
) -> Result<(), Error<CatHelpError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_cat", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = help {
    local_var_req_builder = local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = s {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("s".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "s",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CatHelpError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about indices: number of primaries and replicas,
/// document counts, disk size, ...
pub async fn cat_indices(
  configuration: &configuration::Configuration,
  format: Option<&str>,
  bytes: Option<Bytes>,
  local: Option<bool>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  h: Option<Vec<String>>,
  health: Option<Health>,
  help: Option<bool>,
  pri: Option<bool>,
  s: Option<Vec<String>>,
  time: Option<Time>,
  v: Option<bool>,
  include_unloaded_segments: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
) -> Result<(), Error<CatIndicesError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_cat/indices", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = format {
    local_var_req_builder = local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = bytes {
    local_var_req_builder = local_var_req_builder.query(&[("bytes", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = h {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("h".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "h",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = health {
    local_var_req_builder = local_var_req_builder.query(&[("health", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = help {
    local_var_req_builder = local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = pri {
    local_var_req_builder = local_var_req_builder.query(&[("pri", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = s {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("s".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "s",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = time {
    local_var_req_builder = local_var_req_builder.query(&[("time", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = v {
    local_var_req_builder = local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = include_unloaded_segments {
    local_var_req_builder = local_var_req_builder.query(&[("include_unloaded_segments", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CatIndicesError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about indices: number of primaries and replicas,
/// document counts, disk size, ...
pub async fn cat_indices_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  format: Option<&str>,
  bytes: Option<Bytes>,
  local: Option<bool>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  h: Option<Vec<String>>,
  health: Option<Health>,
  help: Option<bool>,
  pri: Option<bool>,
  s: Option<Vec<String>>,
  time: Option<Time>,
  v: Option<bool>,
  include_unloaded_segments: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
) -> Result<(), Error<CatIndicesWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_cat/indices/{index}",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = format {
    local_var_req_builder = local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = bytes {
    local_var_req_builder = local_var_req_builder.query(&[("bytes", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = h {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("h".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "h",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = health {
    local_var_req_builder = local_var_req_builder.query(&[("health", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = help {
    local_var_req_builder = local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = pri {
    local_var_req_builder = local_var_req_builder.query(&[("pri", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = s {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("s".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "s",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = time {
    local_var_req_builder = local_var_req_builder.query(&[("time", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = v {
    local_var_req_builder = local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = include_unloaded_segments {
    local_var_req_builder = local_var_req_builder.query(&[("include_unloaded_segments", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CatIndicesWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about the cluster-manager node.
pub async fn cat_master(
  configuration: &configuration::Configuration,
  format: Option<&str>,
  local: Option<bool>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  h: Option<Vec<String>>,
  help: Option<bool>,
  s: Option<Vec<String>>,
  v: Option<bool>,
) -> Result<(), Error<CatMasterError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_cat/master", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = format {
    local_var_req_builder = local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = h {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("h".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "h",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = help {
    local_var_req_builder = local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = s {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("s".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "s",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = v {
    local_var_req_builder = local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CatMasterError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about custom node attributes.
pub async fn cat_nodeattrs(
  configuration: &configuration::Configuration,
  format: Option<&str>,
  local: Option<bool>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  h: Option<Vec<String>>,
  help: Option<bool>,
  s: Option<Vec<String>>,
  v: Option<bool>,
) -> Result<(), Error<CatNodeattrsError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_cat/nodeattrs", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = format {
    local_var_req_builder = local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = h {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("h".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "h",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = help {
    local_var_req_builder = local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = s {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("s".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "s",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = v {
    local_var_req_builder = local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CatNodeattrsError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns basic statistics about performance of cluster nodes.
pub async fn cat_nodes(
  configuration: &configuration::Configuration,
  bytes: Option<Bytes>,
  format: Option<&str>,
  full_id: Option<bool>,
  local: Option<bool>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  h: Option<Vec<String>>,
  help: Option<bool>,
  s: Option<Vec<String>>,
  time: Option<Time>,
  v: Option<bool>,
) -> Result<(), Error<CatNodesError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_cat/nodes", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = bytes {
    local_var_req_builder = local_var_req_builder.query(&[("bytes", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = format {
    local_var_req_builder = local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = full_id {
    local_var_req_builder = local_var_req_builder.query(&[("full_id", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = h {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("h".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "h",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = help {
    local_var_req_builder = local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = s {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("s".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "s",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = time {
    local_var_req_builder = local_var_req_builder.query(&[("time", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = v {
    local_var_req_builder = local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CatNodesError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns a concise representation of the cluster pending tasks.
pub async fn cat_pending_tasks(
  configuration: &configuration::Configuration,
  format: Option<&str>,
  local: Option<bool>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  h: Option<Vec<String>>,
  help: Option<bool>,
  s: Option<Vec<String>>,
  time: Option<Time>,
  v: Option<bool>,
) -> Result<(), Error<CatPendingTasksError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_cat/pending_tasks", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = format {
    local_var_req_builder = local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = h {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("h".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "h",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = help {
    local_var_req_builder = local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = s {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("s".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "s",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = time {
    local_var_req_builder = local_var_req_builder.query(&[("time", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = v {
    local_var_req_builder = local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CatPendingTasksError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// List segments for one or several PITs.
pub async fn cat_pit_segments(
  configuration: &configuration::Configuration,
  cat_pit_segments_body_params: Option<crate::models::CatPitSegmentsBodyParams>,
) -> Result<crate::models::CatPitSegmentsResponseContent, Error<CatPitSegmentsError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_cat/pit_segments", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&cat_pit_segments_body_params);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<CatPitSegmentsError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about installed plugins across nodes node.
pub async fn cat_plugins(
  configuration: &configuration::Configuration,
  format: Option<&str>,
  local: Option<bool>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  h: Option<Vec<String>>,
  help: Option<bool>,
  s: Option<Vec<String>>,
  v: Option<bool>,
) -> Result<(), Error<CatPluginsError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_cat/plugins", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = format {
    local_var_req_builder = local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = h {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("h".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "h",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = help {
    local_var_req_builder = local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = s {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("s".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "s",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = v {
    local_var_req_builder = local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CatPluginsError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about index shard recoveries, both on-going completed.
pub async fn cat_recovery(
  configuration: &configuration::Configuration,
  format: Option<&str>,
  active_only: Option<bool>,
  bytes: Option<Bytes>,
  detailed: Option<bool>,
  h: Option<Vec<String>>,
  help: Option<bool>,
  index: Option<Vec<String>>,
  s: Option<Vec<String>>,
  time: Option<Time>,
  v: Option<bool>,
) -> Result<(), Error<CatRecoveryError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_cat/recovery", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = format {
    local_var_req_builder = local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = active_only {
    local_var_req_builder = local_var_req_builder.query(&[("active_only", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = bytes {
    local_var_req_builder = local_var_req_builder.query(&[("bytes", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = detailed {
    local_var_req_builder = local_var_req_builder.query(&[("detailed", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = h {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("h".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "h",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = help {
    local_var_req_builder = local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = index {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("index".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "index",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = s {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("s".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "s",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = time {
    local_var_req_builder = local_var_req_builder.query(&[("time", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = v {
    local_var_req_builder = local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CatRecoveryError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about index shard recoveries, both on-going completed.
pub async fn cat_recovery_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  format: Option<&str>,
  active_only: Option<bool>,
  bytes: Option<Bytes>,
  detailed: Option<bool>,
  h: Option<Vec<String>>,
  help: Option<bool>,
  index2: Option<Vec<String>>,
  s: Option<Vec<String>>,
  time: Option<Time>,
  v: Option<bool>,
) -> Result<(), Error<CatRecoveryWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_cat/recovery/{index}",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = format {
    local_var_req_builder = local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = active_only {
    local_var_req_builder = local_var_req_builder.query(&[("active_only", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = bytes {
    local_var_req_builder = local_var_req_builder.query(&[("bytes", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = detailed {
    local_var_req_builder = local_var_req_builder.query(&[("detailed", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = h {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("h".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "h",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = help {
    local_var_req_builder = local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = index2 {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("index".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "index",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = s {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("s".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "s",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = time {
    local_var_req_builder = local_var_req_builder.query(&[("time", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = v {
    local_var_req_builder = local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CatRecoveryWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about snapshot repositories registered in the cluster.
pub async fn cat_repositories(
  configuration: &configuration::Configuration,
  format: Option<&str>,
  local: Option<bool>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  h: Option<Vec<String>>,
  help: Option<bool>,
  s: Option<Vec<String>>,
  v: Option<bool>,
) -> Result<(), Error<CatRepositoriesError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_cat/repositories", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = format {
    local_var_req_builder = local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = h {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("h".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "h",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = help {
    local_var_req_builder = local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = s {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("s".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "s",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = v {
    local_var_req_builder = local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CatRepositoriesError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about both on-going and latest completed Segment
/// Replication events.
pub async fn cat_segment_replication(
  configuration: &configuration::Configuration,
  format: Option<&str>,
  active_only: Option<bool>,
  completed_only: Option<bool>,
  bytes: Option<Bytes>,
  detailed: Option<bool>,
  shards: Option<Vec<String>>,
  h: Option<Vec<String>>,
  help: Option<bool>,
  index: Option<Vec<String>>,
  s: Option<Vec<String>>,
  time: Option<Time>,
  v: Option<bool>,
) -> Result<(), Error<CatSegmentReplicationError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_cat/segment_replication", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = format {
    local_var_req_builder = local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = active_only {
    local_var_req_builder = local_var_req_builder.query(&[("active_only", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = completed_only {
    local_var_req_builder = local_var_req_builder.query(&[("completed_only", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = bytes {
    local_var_req_builder = local_var_req_builder.query(&[("bytes", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = detailed {
    local_var_req_builder = local_var_req_builder.query(&[("detailed", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = shards {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("shards".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "shards",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = h {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("h".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "h",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = help {
    local_var_req_builder = local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = index {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("index".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "index",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = s {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("s".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "s",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = time {
    local_var_req_builder = local_var_req_builder.query(&[("time", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = v {
    local_var_req_builder = local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CatSegmentReplicationError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about both on-going and latest completed Segment
/// Replication events.
pub async fn cat_segment_replication_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  format: Option<&str>,
  active_only: Option<bool>,
  completed_only: Option<bool>,
  bytes: Option<Bytes>,
  detailed: Option<bool>,
  shards: Option<Vec<String>>,
  h: Option<Vec<String>>,
  help: Option<bool>,
  index2: Option<Vec<String>>,
  s: Option<Vec<String>>,
  time: Option<Time>,
  v: Option<bool>,
) -> Result<(), Error<CatSegmentReplicationWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_cat/segment_replication/{index}",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = format {
    local_var_req_builder = local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = active_only {
    local_var_req_builder = local_var_req_builder.query(&[("active_only", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = completed_only {
    local_var_req_builder = local_var_req_builder.query(&[("completed_only", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = bytes {
    local_var_req_builder = local_var_req_builder.query(&[("bytes", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = detailed {
    local_var_req_builder = local_var_req_builder.query(&[("detailed", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = shards {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("shards".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "shards",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = h {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("h".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "h",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = help {
    local_var_req_builder = local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = index2 {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("index".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "index",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = s {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("s".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "s",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = time {
    local_var_req_builder = local_var_req_builder.query(&[("time", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = v {
    local_var_req_builder = local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CatSegmentReplicationWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Provides low-level information about the segments in the shards of an index.
pub async fn cat_segments(
  configuration: &configuration::Configuration,
  format: Option<&str>,
  bytes: Option<Bytes>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  h: Option<Vec<String>>,
  help: Option<bool>,
  s: Option<Vec<String>>,
  v: Option<bool>,
) -> Result<(), Error<CatSegmentsError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_cat/segments", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = format {
    local_var_req_builder = local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = bytes {
    local_var_req_builder = local_var_req_builder.query(&[("bytes", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = h {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("h".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "h",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = help {
    local_var_req_builder = local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = s {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("s".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "s",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = v {
    local_var_req_builder = local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CatSegmentsError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Provides low-level information about the segments in the shards of an index.
pub async fn cat_segments_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  format: Option<&str>,
  bytes: Option<Bytes>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  h: Option<Vec<String>>,
  help: Option<bool>,
  s: Option<Vec<String>>,
  v: Option<bool>,
) -> Result<(), Error<CatSegmentsWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_cat/segments/{index}",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = format {
    local_var_req_builder = local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = bytes {
    local_var_req_builder = local_var_req_builder.query(&[("bytes", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = h {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("h".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "h",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = help {
    local_var_req_builder = local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = s {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("s".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "s",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = v {
    local_var_req_builder = local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CatSegmentsWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Provides a detailed view of shard allocation on nodes.
pub async fn cat_shards(
  configuration: &configuration::Configuration,
  format: Option<&str>,
  bytes: Option<Bytes>,
  local: Option<bool>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  h: Option<Vec<String>>,
  help: Option<bool>,
  s: Option<Vec<String>>,
  time: Option<Time>,
  v: Option<bool>,
) -> Result<(), Error<CatShardsError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_cat/shards", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = format {
    local_var_req_builder = local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = bytes {
    local_var_req_builder = local_var_req_builder.query(&[("bytes", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = h {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("h".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "h",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = help {
    local_var_req_builder = local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = s {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("s".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "s",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = time {
    local_var_req_builder = local_var_req_builder.query(&[("time", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = v {
    local_var_req_builder = local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CatShardsError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Provides a detailed view of shard allocation on nodes.
pub async fn cat_shards_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  format: Option<&str>,
  bytes: Option<Bytes>,
  local: Option<bool>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  h: Option<Vec<String>>,
  help: Option<bool>,
  s: Option<Vec<String>>,
  time: Option<Time>,
  v: Option<bool>,
) -> Result<(), Error<CatShardsWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_cat/shards/{index}",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = format {
    local_var_req_builder = local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = bytes {
    local_var_req_builder = local_var_req_builder.query(&[("bytes", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = h {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("h".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "h",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = help {
    local_var_req_builder = local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = s {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("s".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "s",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = time {
    local_var_req_builder = local_var_req_builder.query(&[("time", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = v {
    local_var_req_builder = local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CatShardsWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns all snapshots in a specific repository.
pub async fn cat_snapshots(
  configuration: &configuration::Configuration,
  format: Option<&str>,
  ignore_unavailable: Option<bool>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  h: Option<Vec<String>>,
  help: Option<bool>,
  s: Option<Vec<String>>,
  time: Option<Time>,
  v: Option<bool>,
) -> Result<(), Error<CatSnapshotsError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_cat/snapshots", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = format {
    local_var_req_builder = local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = h {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("h".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "h",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = help {
    local_var_req_builder = local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = s {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("s".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "s",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = time {
    local_var_req_builder = local_var_req_builder.query(&[("time", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = v {
    local_var_req_builder = local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CatSnapshotsError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns all snapshots in a specific repository.
pub async fn cat_snapshots_with_repository(
  configuration: &configuration::Configuration,
  repository: &str,
  format: Option<&str>,
  ignore_unavailable: Option<bool>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  h: Option<Vec<String>>,
  help: Option<bool>,
  s: Option<Vec<String>>,
  time: Option<Time>,
  v: Option<bool>,
) -> Result<(), Error<CatSnapshotsWithRepositoryError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_cat/snapshots/{repository}",
    local_var_configuration.base_path,
    repository = crate::apis::urlencode(repository)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = format {
    local_var_req_builder = local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = h {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("h".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "h",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = help {
    local_var_req_builder = local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = s {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("s".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "s",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = time {
    local_var_req_builder = local_var_req_builder.query(&[("time", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = v {
    local_var_req_builder = local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CatSnapshotsWithRepositoryError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about the tasks currently executing on one or more nodes
/// in the cluster.
pub async fn cat_tasks(
  configuration: &configuration::Configuration,
  format: Option<&str>,
  nodes: Option<Vec<String>>,
  actions: Option<Vec<String>>,
  detailed: Option<bool>,
  parent_task_id: Option<&str>,
  h: Option<Vec<String>>,
  help: Option<bool>,
  s: Option<Vec<String>>,
  time: Option<Time>,
  v: Option<bool>,
) -> Result<(), Error<CatTasksError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_cat/tasks", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = format {
    local_var_req_builder = local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = nodes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("nodes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "nodes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = actions {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("actions".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "actions",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = detailed {
    local_var_req_builder = local_var_req_builder.query(&[("detailed", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = parent_task_id {
    local_var_req_builder = local_var_req_builder.query(&[("parent_task_id", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = h {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("h".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "h",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = help {
    local_var_req_builder = local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = s {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("s".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "s",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = time {
    local_var_req_builder = local_var_req_builder.query(&[("time", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = v {
    local_var_req_builder = local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CatTasksError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about existing templates.
pub async fn cat_templates(
  configuration: &configuration::Configuration,
  format: Option<&str>,
  local: Option<bool>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  h: Option<Vec<String>>,
  help: Option<bool>,
  s: Option<Vec<String>>,
  v: Option<bool>,
) -> Result<(), Error<CatTemplatesError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_cat/templates", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = format {
    local_var_req_builder = local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = h {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("h".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "h",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = help {
    local_var_req_builder = local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = s {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("s".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "s",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = v {
    local_var_req_builder = local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CatTemplatesError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about existing templates.
pub async fn cat_templates_with_name(
  configuration: &configuration::Configuration,
  name: &str,
  format: Option<&str>,
  local: Option<bool>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  h: Option<Vec<String>>,
  help: Option<bool>,
  s: Option<Vec<String>>,
  v: Option<bool>,
) -> Result<(), Error<CatTemplatesWithNameError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_cat/templates/{name}",
    local_var_configuration.base_path,
    name = crate::apis::urlencode(name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = format {
    local_var_req_builder = local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = h {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("h".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "h",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = help {
    local_var_req_builder = local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = s {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("s".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "s",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = v {
    local_var_req_builder = local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CatTemplatesWithNameError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns cluster-wide thread pool statistics per node. By default the active,
/// queue and rejected statistics are returned for all thread pools.
pub async fn cat_thread_pool(
  configuration: &configuration::Configuration,
  format: Option<&str>,
  size: Option<i32>,
  local: Option<bool>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  h: Option<Vec<String>>,
  help: Option<bool>,
  s: Option<Vec<String>>,
  v: Option<bool>,
) -> Result<(), Error<CatThreadPoolError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_cat/thread_pool", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = format {
    local_var_req_builder = local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = size {
    local_var_req_builder = local_var_req_builder.query(&[("size", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = h {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("h".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "h",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = help {
    local_var_req_builder = local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = s {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("s".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "s",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = v {
    local_var_req_builder = local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CatThreadPoolError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns cluster-wide thread pool statistics per node. By default the active,
/// queue and rejected statistics are returned for all thread pools.
pub async fn cat_thread_pool_with_thread_pool_patterns(
  configuration: &configuration::Configuration,
  thread_pool_patterns: &str,
  format: Option<&str>,
  size: Option<i32>,
  local: Option<bool>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  h: Option<Vec<String>>,
  help: Option<bool>,
  s: Option<Vec<String>>,
  v: Option<bool>,
) -> Result<(), Error<CatThreadPoolWithThreadPoolPatternsError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_cat/thread_pool/{thread_pool_patterns}",
    local_var_configuration.base_path,
    thread_pool_patterns = crate::apis::urlencode(thread_pool_patterns)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = format {
    local_var_req_builder = local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = size {
    local_var_req_builder = local_var_req_builder.query(&[("size", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = h {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("h".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "h",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = help {
    local_var_req_builder = local_var_req_builder.query(&[("help", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = s {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("s".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "s",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = v {
    local_var_req_builder = local_var_req_builder.query(&[("v", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CatThreadPoolWithThreadPoolPatternsError> =
      serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Changes the password for the current user.
pub async fn change_password(
  configuration: &configuration::Configuration,
  change_password_request_content: crate::models::ChangePasswordRequestContent,
) -> Result<crate::models::ChangePasswordResponseContent, Error<ChangePasswordError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_plugins/_security/api/account", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&change_password_request_content);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<ChangePasswordError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Explicitly clears the search context for a scroll.
pub async fn clear_scroll(
  configuration: &configuration::Configuration,
  body: Option<serde_json::Value>,
) -> Result<(), Error<ClearScrollError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_search/scroll", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ClearScrollError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Explicitly clears the search context for a scroll.
pub async fn clear_scroll_with_scroll_id(
  configuration: &configuration::Configuration,
  scroll_id: &str,
  body: Option<serde_json::Value>,
) -> Result<(), Error<ClearScrollWithScrollIdError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_search/scroll/{scroll_id}",
    local_var_configuration.base_path,
    scroll_id = crate::apis::urlencode(scroll_id)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ClearScrollWithScrollIdError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Provides explanations for shard allocations in the cluster.
pub async fn cluster_allocation_explain_get(
  configuration: &configuration::Configuration,
  include_yes_decisions: Option<bool>,
  include_disk_info: Option<bool>,
) -> Result<(), Error<ClusterAllocationExplainGetError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_cluster/allocation/explain", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = include_yes_decisions {
    local_var_req_builder = local_var_req_builder.query(&[("include_yes_decisions", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = include_disk_info {
    local_var_req_builder = local_var_req_builder.query(&[("include_disk_info", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ClusterAllocationExplainGetError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Provides explanations for shard allocations in the cluster.
pub async fn cluster_allocation_explain_post(
  configuration: &configuration::Configuration,
  include_yes_decisions: Option<bool>,
  include_disk_info: Option<bool>,
  body: Option<serde_json::Value>,
) -> Result<(), Error<ClusterAllocationExplainPostError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_cluster/allocation/explain", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = include_yes_decisions {
    local_var_req_builder = local_var_req_builder.query(&[("include_yes_decisions", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = include_disk_info {
    local_var_req_builder = local_var_req_builder.query(&[("include_disk_info", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ClusterAllocationExplainPostError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Deletes a component template.
pub async fn cluster_delete_component_template(
  configuration: &configuration::Configuration,
  name: &str,
  timeout: Option<&str>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
) -> Result<(), Error<ClusterDeleteComponentTemplateError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_component_template/{name}",
    local_var_configuration.base_path,
    name = crate::apis::urlencode(name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ClusterDeleteComponentTemplateError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Delete any existing decommission.
pub async fn cluster_delete_decommission_awareness(
  configuration: &configuration::Configuration,
) -> Result<(), Error<ClusterDeleteDecommissionAwarenessError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_cluster/decommission/awareness/", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ClusterDeleteDecommissionAwarenessError> =
      serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Clears cluster voting config exclusions.
pub async fn cluster_delete_voting_config_exclusions(
  configuration: &configuration::Configuration,
  wait_for_removal: Option<bool>,
) -> Result<(), Error<ClusterDeleteVotingConfigExclusionsError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_cluster/voting_config_exclusions",
    local_var_configuration.base_path
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = wait_for_removal {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_removal", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ClusterDeleteVotingConfigExclusionsError> =
      serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Delete weighted shard routing weights.
pub async fn cluster_delete_weighted_routing(
  configuration: &configuration::Configuration,
) -> Result<(), Error<ClusterDeleteWeightedRoutingError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_cluster/routing/awareness/weights",
    local_var_configuration.base_path
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ClusterDeleteWeightedRoutingError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about whether a particular component template exist.
pub async fn cluster_exists_component_template(
  configuration: &configuration::Configuration,
  name: &str,
  master_timeout: Option<&str>,
  local: Option<bool>,
) -> Result<(), Error<ClusterExistsComponentTemplateError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_component_template/{name}",
    local_var_configuration.base_path,
    name = crate::apis::urlencode(name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::HEAD, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ClusterExistsComponentTemplateError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns one or more component templates.
pub async fn cluster_get_component_template(
  configuration: &configuration::Configuration,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  local: Option<bool>,
) -> Result<(), Error<ClusterGetComponentTemplateError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_component_template", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ClusterGetComponentTemplateError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns one or more component templates.
pub async fn cluster_get_component_template_with_name(
  configuration: &configuration::Configuration,
  name: &str,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  local: Option<bool>,
) -> Result<(), Error<ClusterGetComponentTemplateWithNameError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_component_template/{name}",
    local_var_configuration.base_path,
    name = crate::apis::urlencode(name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ClusterGetComponentTemplateWithNameError> =
      serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Get details and status of decommissioned attribute.
pub async fn cluster_get_decommission_awareness(
  configuration: &configuration::Configuration,
  awareness_attribute_name: &str,
) -> Result<(), Error<ClusterGetDecommissionAwarenessError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_cluster/decommission/awareness/{awareness_attribute_name}/_status",
    local_var_configuration.base_path,
    awareness_attribute_name = crate::apis::urlencode(awareness_attribute_name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ClusterGetDecommissionAwarenessError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns cluster settings.
pub async fn cluster_get_settings(
  configuration: &configuration::Configuration,
  flat_settings: Option<bool>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  timeout: Option<&str>,
  include_defaults: Option<bool>,
) -> Result<crate::models::ClusterGetSettingsResponseContent, Error<ClusterGetSettingsError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_cluster/settings", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = flat_settings {
    local_var_req_builder = local_var_req_builder.query(&[("flat_settings", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = include_defaults {
    local_var_req_builder = local_var_req_builder.query(&[("include_defaults", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<ClusterGetSettingsError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Fetches weighted shard routing weights.
pub async fn cluster_get_weighted_routing(
  configuration: &configuration::Configuration,
  attribute: &str,
) -> Result<(), Error<ClusterGetWeightedRoutingError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_cluster/routing/awareness/{attribute}/weights",
    local_var_configuration.base_path,
    attribute = crate::apis::urlencode(attribute)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ClusterGetWeightedRoutingError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns basic information about the health of the cluster.
pub async fn cluster_health(
  configuration: &configuration::Configuration,
  expand_wildcards: Option<ExpandWildcards>,
  level: Option<ClusterHealthLevel>,
  local: Option<bool>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  timeout: Option<&str>,
  wait_for_active_shards: Option<&str>,
  wait_for_nodes: Option<&str>,
  wait_for_events: Option<WaitForEvents>,
  wait_for_no_relocating_shards: Option<bool>,
  wait_for_no_initializing_shards: Option<bool>,
  wait_for_status: Option<WaitForStatus>,
  awareness_attribute: Option<&str>,
  ensure_node_commissioned: Option<bool>,
) -> Result<(), Error<ClusterHealthError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_cluster/health", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = level {
    local_var_req_builder = local_var_req_builder.query(&[("level", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_active_shards {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_active_shards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_nodes {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_nodes", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_events {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_events", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_no_relocating_shards {
    local_var_req_builder =
      local_var_req_builder.query(&[("wait_for_no_relocating_shards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_no_initializing_shards {
    local_var_req_builder =
      local_var_req_builder.query(&[("wait_for_no_initializing_shards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_status {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_status", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = awareness_attribute {
    local_var_req_builder = local_var_req_builder.query(&[("awareness_attribute", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ensure_node_commissioned {
    local_var_req_builder = local_var_req_builder.query(&[("ensure_node_commissioned", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ClusterHealthError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns basic information about the health of the cluster.
pub async fn cluster_health_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  expand_wildcards: Option<ExpandWildcards>,
  level: Option<ClusterHealthLevel>,
  local: Option<bool>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  timeout: Option<&str>,
  wait_for_active_shards: Option<&str>,
  wait_for_nodes: Option<&str>,
  wait_for_events: Option<WaitForEvents>,
  wait_for_no_relocating_shards: Option<bool>,
  wait_for_no_initializing_shards: Option<bool>,
  wait_for_status: Option<WaitForStatus>,
  awareness_attribute: Option<&str>,
  ensure_node_commissioned: Option<bool>,
) -> Result<(), Error<ClusterHealthWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_cluster/health/{index}",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = level {
    local_var_req_builder = local_var_req_builder.query(&[("level", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_active_shards {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_active_shards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_nodes {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_nodes", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_events {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_events", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_no_relocating_shards {
    local_var_req_builder =
      local_var_req_builder.query(&[("wait_for_no_relocating_shards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_no_initializing_shards {
    local_var_req_builder =
      local_var_req_builder.query(&[("wait_for_no_initializing_shards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_status {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_status", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = awareness_attribute {
    local_var_req_builder = local_var_req_builder.query(&[("awareness_attribute", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ensure_node_commissioned {
    local_var_req_builder = local_var_req_builder.query(&[("ensure_node_commissioned", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ClusterHealthWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns a list of any cluster-level changes (e.g. create index, update
/// mapping, allocate or fail shard) which have not yet been executed.
pub async fn cluster_pending_tasks(
  configuration: &configuration::Configuration,
  local: Option<bool>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
) -> Result<(), Error<ClusterPendingTasksError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_cluster/pending_tasks", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ClusterPendingTasksError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Updates the cluster voting config exclusions by node ids or node names.
pub async fn cluster_post_voting_config_exclusions(
  configuration: &configuration::Configuration,
  node_ids: Option<&str>,
  node_names: Option<&str>,
  timeout: Option<&str>,
) -> Result<(), Error<ClusterPostVotingConfigExclusionsError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_cluster/voting_config_exclusions",
    local_var_configuration.base_path
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = node_ids {
    local_var_req_builder = local_var_req_builder.query(&[("node_ids", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = node_names {
    local_var_req_builder = local_var_req_builder.query(&[("node_names", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ClusterPostVotingConfigExclusionsError> =
      serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Creates or updates a component template.
pub async fn cluster_put_component_template_post(
  configuration: &configuration::Configuration,
  name: &str,
  body: serde_json::Value,
  create: Option<bool>,
  timeout: Option<&str>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
) -> Result<(), Error<ClusterPutComponentTemplatePostError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_component_template/{name}",
    local_var_configuration.base_path,
    name = crate::apis::urlencode(name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = create {
    local_var_req_builder = local_var_req_builder.query(&[("create", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ClusterPutComponentTemplatePostError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Creates or updates a component template.
pub async fn cluster_put_component_template_put(
  configuration: &configuration::Configuration,
  name: &str,
  body: serde_json::Value,
  create: Option<bool>,
  timeout: Option<&str>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
) -> Result<(), Error<ClusterPutComponentTemplatePutError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_component_template/{name}",
    local_var_configuration.base_path,
    name = crate::apis::urlencode(name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = create {
    local_var_req_builder = local_var_req_builder.query(&[("create", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ClusterPutComponentTemplatePutError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Decommissions an awareness attribute.
pub async fn cluster_put_decommission_awareness(
  configuration: &configuration::Configuration,
  awareness_attribute_name: &str,
  awareness_attribute_value: &str,
) -> Result<(), Error<ClusterPutDecommissionAwarenessError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_cluster/decommission/awareness/{awareness_attribute_name}/{awareness_attribute_value}",
    local_var_configuration.base_path,
    awareness_attribute_name = crate::apis::urlencode(awareness_attribute_name),
    awareness_attribute_value = crate::apis::urlencode(awareness_attribute_value)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ClusterPutDecommissionAwarenessError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Updates the cluster settings.
pub async fn cluster_put_settings(
  configuration: &configuration::Configuration,
  cluster_put_settings_body_params: crate::models::ClusterPutSettingsBodyParams,
  flat_settings: Option<bool>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  timeout: Option<&str>,
) -> Result<crate::models::ClusterPutSettingsResponseContent, Error<ClusterPutSettingsError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_cluster/settings", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = flat_settings {
    local_var_req_builder = local_var_req_builder.query(&[("flat_settings", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&cluster_put_settings_body_params);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<ClusterPutSettingsError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Updates weighted shard routing weights.
pub async fn cluster_put_weighted_routing(
  configuration: &configuration::Configuration,
  attribute: &str,
) -> Result<(), Error<ClusterPutWeightedRoutingError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_cluster/routing/awareness/{attribute}/weights",
    local_var_configuration.base_path,
    attribute = crate::apis::urlencode(attribute)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ClusterPutWeightedRoutingError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns the information about configured remote clusters.
pub async fn cluster_remote_info(
  configuration: &configuration::Configuration,
) -> Result<(), Error<ClusterRemoteInfoError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_remote/info", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ClusterRemoteInfoError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows to manually change the allocation of individual shards in the
/// cluster.
pub async fn cluster_reroute(
  configuration: &configuration::Configuration,
  dry_run: Option<bool>,
  explain: Option<bool>,
  retry_failed: Option<bool>,
  metric: Option<Vec<crate::models::ClusterRerouteMetricMember>>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  timeout: Option<&str>,
  body: Option<serde_json::Value>,
) -> Result<(), Error<ClusterRerouteError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_cluster/reroute", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = dry_run {
    local_var_req_builder = local_var_req_builder.query(&[("dry_run", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = explain {
    local_var_req_builder = local_var_req_builder.query(&[("explain", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = retry_failed {
    local_var_req_builder = local_var_req_builder.query(&[("retry_failed", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = metric {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("metric".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "metric",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ClusterRerouteError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns a comprehensive information about the state of the cluster.
pub async fn cluster_state(
  configuration: &configuration::Configuration,
  local: Option<bool>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  flat_settings: Option<bool>,
  wait_for_metadata_version: Option<i32>,
  wait_for_timeout: Option<&str>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
) -> Result<(), Error<ClusterStateError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_cluster/state", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = flat_settings {
    local_var_req_builder = local_var_req_builder.query(&[("flat_settings", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_metadata_version {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_metadata_version", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ClusterStateError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns a comprehensive information about the state of the cluster.
pub async fn cluster_state_with_index_metric(
  configuration: &configuration::Configuration,
  index: &str,
  metric: &str,
  local: Option<bool>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  flat_settings: Option<bool>,
  wait_for_metadata_version: Option<i32>,
  wait_for_timeout: Option<&str>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
) -> Result<(), Error<ClusterStateWithIndexMetricError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_cluster/state/{metric}/{index}",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index),
    metric = crate::apis::urlencode(metric)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = flat_settings {
    local_var_req_builder = local_var_req_builder.query(&[("flat_settings", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_metadata_version {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_metadata_version", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ClusterStateWithIndexMetricError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns a comprehensive information about the state of the cluster.
pub async fn cluster_state_with_metric(
  configuration: &configuration::Configuration,
  metric: &str,
  local: Option<bool>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  flat_settings: Option<bool>,
  wait_for_metadata_version: Option<i32>,
  wait_for_timeout: Option<&str>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
) -> Result<(), Error<ClusterStateWithMetricError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_cluster/state/{metric}",
    local_var_configuration.base_path,
    metric = crate::apis::urlencode(metric)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = flat_settings {
    local_var_req_builder = local_var_req_builder.query(&[("flat_settings", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_metadata_version {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_metadata_version", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ClusterStateWithMetricError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns high-level overview of cluster statistics.
pub async fn cluster_stats(
  configuration: &configuration::Configuration,
  flat_settings: Option<bool>,
  timeout: Option<&str>,
) -> Result<(), Error<ClusterStatsError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_cluster/stats", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = flat_settings {
    local_var_req_builder = local_var_req_builder.query(&[("flat_settings", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ClusterStatsError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns high-level overview of cluster statistics.
pub async fn cluster_stats_with_node_id(
  configuration: &configuration::Configuration,
  node_id: &str,
  flat_settings: Option<bool>,
  timeout: Option<&str>,
) -> Result<(), Error<ClusterStatsWithNodeIdError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_cluster/stats/nodes/{node_id}",
    local_var_configuration.base_path,
    node_id = crate::apis::urlencode(node_id)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = flat_settings {
    local_var_req_builder = local_var_req_builder.query(&[("flat_settings", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ClusterStatsWithNodeIdError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns number of documents matching a query.
pub async fn count_get(
  configuration: &configuration::Configuration,
  ignore_unavailable: Option<bool>,
  ignore_throttled: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  min_score: Option<i32>,
  preference: Option<&str>,
  routing: Option<Vec<String>>,
  q: Option<&str>,
  analyzer: Option<&str>,
  analyze_wildcard: Option<bool>,
  default_operator: Option<DefaultOperator>,
  df: Option<&str>,
  lenient: Option<bool>,
  terminate_after: Option<i32>,
) -> Result<(), Error<CountGetError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_count", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_throttled {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_throttled", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = min_score {
    local_var_req_builder = local_var_req_builder.query(&[("min_score", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = preference {
    local_var_req_builder = local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("routing".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "routing",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = q {
    local_var_req_builder = local_var_req_builder.query(&[("q", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = analyzer {
    local_var_req_builder = local_var_req_builder.query(&[("analyzer", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = analyze_wildcard {
    local_var_req_builder = local_var_req_builder.query(&[("analyze_wildcard", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = default_operator {
    local_var_req_builder = local_var_req_builder.query(&[("default_operator", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = df {
    local_var_req_builder = local_var_req_builder.query(&[("df", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = lenient {
    local_var_req_builder = local_var_req_builder.query(&[("lenient", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = terminate_after {
    local_var_req_builder = local_var_req_builder.query(&[("terminate_after", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CountGetError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns number of documents matching a query.
pub async fn count_get_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  ignore_unavailable: Option<bool>,
  ignore_throttled: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  min_score: Option<i32>,
  preference: Option<&str>,
  routing: Option<Vec<String>>,
  q: Option<&str>,
  analyzer: Option<&str>,
  analyze_wildcard: Option<bool>,
  default_operator: Option<DefaultOperator>,
  df: Option<&str>,
  lenient: Option<bool>,
  terminate_after: Option<i32>,
) -> Result<(), Error<CountGetWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_count",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_throttled {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_throttled", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = min_score {
    local_var_req_builder = local_var_req_builder.query(&[("min_score", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = preference {
    local_var_req_builder = local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("routing".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "routing",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = q {
    local_var_req_builder = local_var_req_builder.query(&[("q", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = analyzer {
    local_var_req_builder = local_var_req_builder.query(&[("analyzer", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = analyze_wildcard {
    local_var_req_builder = local_var_req_builder.query(&[("analyze_wildcard", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = default_operator {
    local_var_req_builder = local_var_req_builder.query(&[("default_operator", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = df {
    local_var_req_builder = local_var_req_builder.query(&[("df", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = lenient {
    local_var_req_builder = local_var_req_builder.query(&[("lenient", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = terminate_after {
    local_var_req_builder = local_var_req_builder.query(&[("terminate_after", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CountGetWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns number of documents matching a query.
pub async fn count_post(
  configuration: &configuration::Configuration,
  ignore_unavailable: Option<bool>,
  ignore_throttled: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  min_score: Option<i32>,
  preference: Option<&str>,
  routing: Option<Vec<String>>,
  q: Option<&str>,
  analyzer: Option<&str>,
  analyze_wildcard: Option<bool>,
  default_operator: Option<DefaultOperator>,
  df: Option<&str>,
  lenient: Option<bool>,
  terminate_after: Option<i32>,
  body: Option<serde_json::Value>,
) -> Result<(), Error<CountPostError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_count", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_throttled {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_throttled", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = min_score {
    local_var_req_builder = local_var_req_builder.query(&[("min_score", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = preference {
    local_var_req_builder = local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("routing".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "routing",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = q {
    local_var_req_builder = local_var_req_builder.query(&[("q", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = analyzer {
    local_var_req_builder = local_var_req_builder.query(&[("analyzer", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = analyze_wildcard {
    local_var_req_builder = local_var_req_builder.query(&[("analyze_wildcard", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = default_operator {
    local_var_req_builder = local_var_req_builder.query(&[("default_operator", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = df {
    local_var_req_builder = local_var_req_builder.query(&[("df", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = lenient {
    local_var_req_builder = local_var_req_builder.query(&[("lenient", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = terminate_after {
    local_var_req_builder = local_var_req_builder.query(&[("terminate_after", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CountPostError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns number of documents matching a query.
pub async fn count_post_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  ignore_unavailable: Option<bool>,
  ignore_throttled: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  min_score: Option<i32>,
  preference: Option<&str>,
  routing: Option<Vec<String>>,
  q: Option<&str>,
  analyzer: Option<&str>,
  analyze_wildcard: Option<bool>,
  default_operator: Option<DefaultOperator>,
  df: Option<&str>,
  lenient: Option<bool>,
  terminate_after: Option<i32>,
  body: Option<serde_json::Value>,
) -> Result<(), Error<CountPostWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_count",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_throttled {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_throttled", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = min_score {
    local_var_req_builder = local_var_req_builder.query(&[("min_score", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = preference {
    local_var_req_builder = local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("routing".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "routing",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = q {
    local_var_req_builder = local_var_req_builder.query(&[("q", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = analyzer {
    local_var_req_builder = local_var_req_builder.query(&[("analyzer", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = analyze_wildcard {
    local_var_req_builder = local_var_req_builder.query(&[("analyze_wildcard", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = default_operator {
    local_var_req_builder = local_var_req_builder.query(&[("default_operator", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = df {
    local_var_req_builder = local_var_req_builder.query(&[("df", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = lenient {
    local_var_req_builder = local_var_req_builder.query(&[("lenient", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = terminate_after {
    local_var_req_builder = local_var_req_builder.query(&[("terminate_after", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CountPostWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Creates or replaces the specified action group.
pub async fn create_action_group(
  configuration: &configuration::Configuration,
  action_group: &str,
  action_group2: crate::models::ActionGroup,
) -> Result<crate::models::CreateActionGroupResponseContent, Error<CreateActionGroupError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_plugins/_security/api/actiongroups/{action_group}",
    local_var_configuration.base_path,
    action_group = crate::apis::urlencode(action_group)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&action_group2);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<CreateActionGroupError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Creates point in time context.
pub async fn create_pit(
  configuration: &configuration::Configuration,
  index: &str,
  allow_partial_pit_creation: Option<bool>,
  keep_alive: Option<&str>,
  preference: Option<&str>,
  routing: Option<Vec<String>>,
  expand_wildcards: Option<ExpandWildcards>,
) -> Result<crate::models::CreatePitResponseContent, Error<CreatePitError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_search/point_in_time",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = allow_partial_pit_creation {
    local_var_req_builder = local_var_req_builder.query(&[("allow_partial_pit_creation", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = keep_alive {
    local_var_req_builder = local_var_req_builder.query(&[("keep_alive", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = preference {
    local_var_req_builder = local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("routing".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "routing",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<CreatePitError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Creates a new document in the index.  Returns a 409 response when a document
/// with a same ID already exists in the index.
pub async fn create_post(
  configuration: &configuration::Configuration,
  id: &str,
  index: &str,
  body: serde_json::Value,
  wait_for_active_shards: Option<&str>,
  refresh: Option<RefreshEnum>,
  routing: Option<&str>,
  timeout: Option<&str>,
  version: Option<i32>,
  version_type: Option<VersionType>,
  pipeline: Option<&str>,
) -> Result<(), Error<CreatePostError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_create/{id}",
    local_var_configuration.base_path,
    id = crate::apis::urlencode(id),
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = wait_for_active_shards {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_active_shards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = refresh {
    local_var_req_builder = local_var_req_builder.query(&[("refresh", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = version {
    local_var_req_builder = local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = version_type {
    local_var_req_builder = local_var_req_builder.query(&[("version_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = pipeline {
    local_var_req_builder = local_var_req_builder.query(&[("pipeline", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CreatePostError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Creates a new document in the index.  Returns a 409 response when a document
/// with a same ID already exists in the index.
pub async fn create_put(
  configuration: &configuration::Configuration,
  id: &str,
  index: &str,
  body: serde_json::Value,
  wait_for_active_shards: Option<&str>,
  refresh: Option<RefreshEnum>,
  routing: Option<&str>,
  timeout: Option<&str>,
  version: Option<i32>,
  version_type: Option<VersionType>,
  pipeline: Option<&str>,
) -> Result<(), Error<CreatePutError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_create/{id}",
    local_var_configuration.base_path,
    id = crate::apis::urlencode(id),
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = wait_for_active_shards {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_active_shards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = refresh {
    local_var_req_builder = local_var_req_builder.query(&[("refresh", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = version {
    local_var_req_builder = local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = version_type {
    local_var_req_builder = local_var_req_builder.query(&[("version_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = pipeline {
    local_var_req_builder = local_var_req_builder.query(&[("pipeline", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<CreatePutError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Creates or replaces the specified role.
pub async fn create_role(
  configuration: &configuration::Configuration,
  role: &str,
  role2: crate::models::Role,
) -> Result<crate::models::CreateRoleResponseContent, Error<CreateRoleError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_plugins/_security/api/roles/{role}",
    local_var_configuration.base_path,
    role = crate::apis::urlencode(role)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&role2);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<CreateRoleError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Creates or replaces the specified role mapping.
pub async fn create_role_mapping(
  configuration: &configuration::Configuration,
  role: &str,
  role_mapping: crate::models::RoleMapping,
) -> Result<crate::models::CreateRoleMappingResponseContent, Error<CreateRoleMappingError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_plugins/_security/api/rolesmapping/{role}",
    local_var_configuration.base_path,
    role = crate::apis::urlencode(role)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&role_mapping);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<CreateRoleMappingError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Creates or replaces the specified tenant.
pub async fn create_tenant(
  configuration: &configuration::Configuration,
  tenant: &str,
  create_tenant_params: crate::models::CreateTenantParams,
) -> Result<crate::models::CreateTenantResponseContent, Error<CreateTenantError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_plugins/_security/api/tenants/{tenant}",
    local_var_configuration.base_path,
    tenant = crate::apis::urlencode(tenant)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&create_tenant_params);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<CreateTenantError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Creates or replaces the specified user.
pub async fn create_user(
  configuration: &configuration::Configuration,
  username: &str,
  user: crate::models::User,
) -> Result<crate::models::CreateUserResponseContent, Error<CreateUserError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_plugins/_security/api/internalusers/{username}",
    local_var_configuration.base_path,
    username = crate::apis::urlencode(username)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&user);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<CreateUserError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Deletes the specified dangling index.
pub async fn dangling_indices_delete_dangling_index(
  configuration: &configuration::Configuration,
  index_uuid: &str,
  accept_data_loss: Option<bool>,
  timeout: Option<&str>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
) -> Result<(), Error<DanglingIndicesDeleteDanglingIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_dangling/{index_uuid}",
    local_var_configuration.base_path,
    index_uuid = crate::apis::urlencode(index_uuid)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = accept_data_loss {
    local_var_req_builder = local_var_req_builder.query(&[("accept_data_loss", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<DanglingIndicesDeleteDanglingIndexError> =
      serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Imports the specified dangling index.
pub async fn dangling_indices_import_dangling_index(
  configuration: &configuration::Configuration,
  index_uuid: &str,
  accept_data_loss: Option<bool>,
  timeout: Option<&str>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
) -> Result<(), Error<DanglingIndicesImportDanglingIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_dangling/{index_uuid}",
    local_var_configuration.base_path,
    index_uuid = crate::apis::urlencode(index_uuid)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = accept_data_loss {
    local_var_req_builder = local_var_req_builder.query(&[("accept_data_loss", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<DanglingIndicesImportDanglingIndexError> =
      serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns all dangling indices.
pub async fn dangling_indices_list_dangling_indices(
  configuration: &configuration::Configuration,
) -> Result<(), Error<DanglingIndicesListDanglingIndicesError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_dangling", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<DanglingIndicesListDanglingIndicesError> =
      serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Removes a document from the index.
pub async fn delete(
  configuration: &configuration::Configuration,
  id: &str,
  index: &str,
  wait_for_active_shards: Option<&str>,
  refresh: Option<RefreshEnum>,
  routing: Option<&str>,
  timeout: Option<&str>,
  if_seq_no: Option<i32>,
  if_primary_term: Option<i32>,
  version: Option<i32>,
  version_type: Option<VersionType>,
) -> Result<(), Error<DeleteError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_doc/{id}",
    local_var_configuration.base_path,
    id = crate::apis::urlencode(id),
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = wait_for_active_shards {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_active_shards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = refresh {
    local_var_req_builder = local_var_req_builder.query(&[("refresh", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = if_seq_no {
    local_var_req_builder = local_var_req_builder.query(&[("if_seq_no", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = if_primary_term {
    local_var_req_builder = local_var_req_builder.query(&[("if_primary_term", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = version {
    local_var_req_builder = local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = version_type {
    local_var_req_builder = local_var_req_builder.query(&[("version_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<DeleteError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Delete a specified action group.
pub async fn delete_action_group(
  configuration: &configuration::Configuration,
  action_group: &str,
) -> Result<crate::models::DeleteActionGroupResponseContent, Error<DeleteActionGroupError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_plugins/_security/api/actiongroups/{action_group}",
    local_var_configuration.base_path,
    action_group = crate::apis::urlencode(action_group)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<DeleteActionGroupError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Deletes all active point in time searches.
pub async fn delete_all_pits(
  configuration: &configuration::Configuration,
) -> Result<crate::models::DeleteAllPitsResponseContent, Error<DeleteAllPitsError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_search/point_in_time/_all", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<DeleteAllPitsError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Deletes documents matching the provided query.
pub async fn delete_by_query(
  configuration: &configuration::Configuration,
  index: &str,
  body: serde_json::Value,
  analyzer: Option<&str>,
  analyze_wildcard: Option<bool>,
  default_operator: Option<DefaultOperator>,
  df: Option<&str>,
  from: Option<i32>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  conflicts: Option<Conflicts>,
  expand_wildcards: Option<ExpandWildcards>,
  lenient: Option<bool>,
  preference: Option<&str>,
  q: Option<&str>,
  routing: Option<Vec<String>>,
  scroll: Option<&str>,
  search_type: Option<SearchType>,
  search_timeout: Option<&str>,
  size: Option<i32>,
  max_docs: Option<i32>,
  sort: Option<Vec<String>>,
  _source: Option<Vec<String>>,
  _source_excludes: Option<Vec<String>>,
  _source_includes: Option<Vec<String>>,
  terminate_after: Option<i32>,
  stats: Option<Vec<String>>,
  version: Option<bool>,
  request_cache: Option<bool>,
  refresh: Option<bool>,
  timeout: Option<&str>,
  wait_for_active_shards: Option<&str>,
  scroll_size: Option<i32>,
  wait_for_completion: Option<bool>,
  requests_per_second: Option<i32>,
  slices: Option<&str>,
) -> Result<(), Error<DeleteByQueryError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_delete_by_query",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = analyzer {
    local_var_req_builder = local_var_req_builder.query(&[("analyzer", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = analyze_wildcard {
    local_var_req_builder = local_var_req_builder.query(&[("analyze_wildcard", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = default_operator {
    local_var_req_builder = local_var_req_builder.query(&[("default_operator", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = df {
    local_var_req_builder = local_var_req_builder.query(&[("df", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = from {
    local_var_req_builder = local_var_req_builder.query(&[("from", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = conflicts {
    local_var_req_builder = local_var_req_builder.query(&[("conflicts", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = lenient {
    local_var_req_builder = local_var_req_builder.query(&[("lenient", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = preference {
    local_var_req_builder = local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = q {
    local_var_req_builder = local_var_req_builder.query(&[("q", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("routing".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "routing",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = scroll {
    local_var_req_builder = local_var_req_builder.query(&[("scroll", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = search_type {
    local_var_req_builder = local_var_req_builder.query(&[("search_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = search_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("search_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = size {
    local_var_req_builder = local_var_req_builder.query(&[("size", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = max_docs {
    local_var_req_builder = local_var_req_builder.query(&[("max_docs", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = sort {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("sort".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "sort",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_excludes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_excludes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_excludes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_includes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_includes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_includes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = terminate_after {
    local_var_req_builder = local_var_req_builder.query(&[("terminate_after", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = stats {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("stats".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "stats",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = version {
    local_var_req_builder = local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = request_cache {
    local_var_req_builder = local_var_req_builder.query(&[("request_cache", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = refresh {
    local_var_req_builder = local_var_req_builder.query(&[("refresh", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_active_shards {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_active_shards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = scroll_size {
    local_var_req_builder = local_var_req_builder.query(&[("scroll_size", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_completion {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_completion", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = requests_per_second {
    local_var_req_builder = local_var_req_builder.query(&[("requests_per_second", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = slices {
    local_var_req_builder = local_var_req_builder.query(&[("slices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<DeleteByQueryError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Changes the number of requests per second for a particular Delete By Query
/// operation.
pub async fn delete_by_query_rethrottle(
  configuration: &configuration::Configuration,
  task_id: &str,
  requests_per_second: i32,
) -> Result<(), Error<DeleteByQueryRethrottleError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_delete_by_query/{task_id}/_rethrottle",
    local_var_configuration.base_path,
    task_id = crate::apis::urlencode(task_id)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  local_var_req_builder = local_var_req_builder.query(&[("requests_per_second", &requests_per_second.to_string())]);
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<DeleteByQueryRethrottleError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Deletes all distinguished names in the specified cluster’s or node’s allow
/// list.
pub async fn delete_distinguished_names(
  configuration: &configuration::Configuration,
  cluster_name: &str,
) -> Result<crate::models::DeleteDistinguishedNamesResponseContent, Error<DeleteDistinguishedNamesError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_plugins/_security/api/nodesdn/{cluster_name}",
    local_var_configuration.base_path,
    cluster_name = crate::apis::urlencode(cluster_name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<DeleteDistinguishedNamesError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Deletes one or more point in time searches based on the IDs passed.
pub async fn delete_pit(
  configuration: &configuration::Configuration,
  delete_pit_body_params: Option<crate::models::DeletePitBodyParams>,
) -> Result<crate::models::DeletePitResponseContent, Error<DeletePitError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_search/point_in_time", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&delete_pit_body_params);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<DeletePitError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Delete the specified role.
pub async fn delete_role(
  configuration: &configuration::Configuration,
  role: &str,
) -> Result<crate::models::DeleteRoleResponseContent, Error<DeleteRoleError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_plugins/_security/api/roles/{role}",
    local_var_configuration.base_path,
    role = crate::apis::urlencode(role)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<DeleteRoleError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Deletes the specified role mapping.
pub async fn delete_role_mapping(
  configuration: &configuration::Configuration,
  role: &str,
) -> Result<crate::models::DeleteRoleMappingResponseContent, Error<DeleteRoleMappingError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_plugins/_security/api/rolesmapping/{role}",
    local_var_configuration.base_path,
    role = crate::apis::urlencode(role)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<DeleteRoleMappingError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Deletes a script.
pub async fn delete_script(
  configuration: &configuration::Configuration,
  id: &str,
  timeout: Option<&str>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
) -> Result<(), Error<DeleteScriptError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_scripts/{id}",
    local_var_configuration.base_path,
    id = crate::apis::urlencode(id)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<DeleteScriptError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Delete the specified tenant.
pub async fn delete_tenant(
  configuration: &configuration::Configuration,
  tenant: &str,
) -> Result<crate::models::DeleteTenantResponseContent, Error<DeleteTenantError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_plugins/_security/api/tenants/{tenant}",
    local_var_configuration.base_path,
    tenant = crate::apis::urlencode(tenant)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<DeleteTenantError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Delete the specified user.
pub async fn delete_user(
  configuration: &configuration::Configuration,
  username: &str,
) -> Result<crate::models::DeleteUserResponseContent, Error<DeleteUserError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_plugins/_security/api/internalusers/{username}",
    local_var_configuration.base_path,
    username = crate::apis::urlencode(username)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<DeleteUserError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about whether a document exists in an index.
pub async fn exists(
  configuration: &configuration::Configuration,
  id: &str,
  index: &str,
  stored_fields: Option<Vec<String>>,
  preference: Option<&str>,
  realtime: Option<bool>,
  refresh: Option<bool>,
  routing: Option<&str>,
  _source: Option<Vec<String>>,
  _source_excludes: Option<Vec<String>>,
  _source_includes: Option<Vec<String>>,
  version: Option<i32>,
  version_type: Option<VersionType>,
) -> Result<(), Error<ExistsError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_doc/{id}",
    local_var_configuration.base_path,
    id = crate::apis::urlencode(id),
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::HEAD, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = stored_fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("stored_fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "stored_fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = preference {
    local_var_req_builder = local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = realtime {
    local_var_req_builder = local_var_req_builder.query(&[("realtime", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = refresh {
    local_var_req_builder = local_var_req_builder.query(&[("refresh", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = _source {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_excludes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_excludes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_excludes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_includes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_includes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_includes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = version {
    local_var_req_builder = local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = version_type {
    local_var_req_builder = local_var_req_builder.query(&[("version_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ExistsError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about whether a document source exists in an index.
pub async fn exists_source(
  configuration: &configuration::Configuration,
  id: &str,
  index: &str,
  preference: Option<&str>,
  realtime: Option<bool>,
  refresh: Option<bool>,
  routing: Option<&str>,
  _source: Option<Vec<String>>,
  _source_excludes: Option<Vec<String>>,
  _source_includes: Option<Vec<String>>,
  version: Option<i32>,
  version_type: Option<VersionType>,
) -> Result<(), Error<ExistsSourceError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_source/{id}",
    local_var_configuration.base_path,
    id = crate::apis::urlencode(id),
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::HEAD, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = preference {
    local_var_req_builder = local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = realtime {
    local_var_req_builder = local_var_req_builder.query(&[("realtime", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = refresh {
    local_var_req_builder = local_var_req_builder.query(&[("refresh", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = _source {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_excludes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_excludes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_excludes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_includes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_includes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_includes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = version {
    local_var_req_builder = local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = version_type {
    local_var_req_builder = local_var_req_builder.query(&[("version_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ExistsSourceError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about why a specific matches (or doesn't match) a query.
pub async fn explain_get(
  configuration: &configuration::Configuration,
  id: &str,
  index: &str,
  analyze_wildcard: Option<bool>,
  analyzer: Option<&str>,
  default_operator: Option<DefaultOperator>,
  df: Option<&str>,
  stored_fields: Option<Vec<String>>,
  lenient: Option<bool>,
  preference: Option<&str>,
  q: Option<&str>,
  routing: Option<&str>,
  _source: Option<Vec<String>>,
  _source_excludes: Option<Vec<String>>,
  _source_includes: Option<Vec<String>>,
) -> Result<(), Error<ExplainGetError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_explain/{id}",
    local_var_configuration.base_path,
    id = crate::apis::urlencode(id),
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = analyze_wildcard {
    local_var_req_builder = local_var_req_builder.query(&[("analyze_wildcard", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = analyzer {
    local_var_req_builder = local_var_req_builder.query(&[("analyzer", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = default_operator {
    local_var_req_builder = local_var_req_builder.query(&[("default_operator", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = df {
    local_var_req_builder = local_var_req_builder.query(&[("df", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = stored_fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("stored_fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "stored_fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = lenient {
    local_var_req_builder = local_var_req_builder.query(&[("lenient", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = preference {
    local_var_req_builder = local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = q {
    local_var_req_builder = local_var_req_builder.query(&[("q", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = _source {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_excludes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_excludes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_excludes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_includes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_includes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_includes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ExplainGetError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about why a specific matches (or doesn't match) a query.
pub async fn explain_post(
  configuration: &configuration::Configuration,
  id: &str,
  index: &str,
  analyze_wildcard: Option<bool>,
  analyzer: Option<&str>,
  default_operator: Option<DefaultOperator>,
  df: Option<&str>,
  stored_fields: Option<Vec<String>>,
  lenient: Option<bool>,
  preference: Option<&str>,
  q: Option<&str>,
  routing: Option<&str>,
  _source: Option<Vec<String>>,
  _source_excludes: Option<Vec<String>>,
  _source_includes: Option<Vec<String>>,
  body: Option<serde_json::Value>,
) -> Result<(), Error<ExplainPostError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_explain/{id}",
    local_var_configuration.base_path,
    id = crate::apis::urlencode(id),
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = analyze_wildcard {
    local_var_req_builder = local_var_req_builder.query(&[("analyze_wildcard", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = analyzer {
    local_var_req_builder = local_var_req_builder.query(&[("analyzer", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = default_operator {
    local_var_req_builder = local_var_req_builder.query(&[("default_operator", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = df {
    local_var_req_builder = local_var_req_builder.query(&[("df", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = stored_fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("stored_fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "stored_fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = lenient {
    local_var_req_builder = local_var_req_builder.query(&[("lenient", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = preference {
    local_var_req_builder = local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = q {
    local_var_req_builder = local_var_req_builder.query(&[("q", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = _source {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_excludes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_excludes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_excludes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_includes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_includes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_includes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ExplainPostError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns the information about the capabilities of fields among multiple
/// indices.
pub async fn field_caps_get(
  configuration: &configuration::Configuration,
  fields: Option<Vec<String>>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  include_unmapped: Option<bool>,
) -> Result<(), Error<FieldCapsGetError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_field_caps", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = include_unmapped {
    local_var_req_builder = local_var_req_builder.query(&[("include_unmapped", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<FieldCapsGetError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns the information about the capabilities of fields among multiple
/// indices.
pub async fn field_caps_get_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  fields: Option<Vec<String>>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  include_unmapped: Option<bool>,
) -> Result<(), Error<FieldCapsGetWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_field_caps",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = include_unmapped {
    local_var_req_builder = local_var_req_builder.query(&[("include_unmapped", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<FieldCapsGetWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns the information about the capabilities of fields among multiple
/// indices.
pub async fn field_caps_post(
  configuration: &configuration::Configuration,
  fields: Option<Vec<String>>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  include_unmapped: Option<bool>,
  body: Option<serde_json::Value>,
) -> Result<(), Error<FieldCapsPostError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_field_caps", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = include_unmapped {
    local_var_req_builder = local_var_req_builder.query(&[("include_unmapped", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<FieldCapsPostError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns the information about the capabilities of fields among multiple
/// indices.
pub async fn field_caps_post_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  fields: Option<Vec<String>>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  include_unmapped: Option<bool>,
  body: Option<serde_json::Value>,
) -> Result<(), Error<FieldCapsPostWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_field_caps",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = include_unmapped {
    local_var_req_builder = local_var_req_builder.query(&[("include_unmapped", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<FieldCapsPostWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Flushes the Security plugin user, authentication, and authorization cache.
pub async fn flush_cache(
  configuration: &configuration::Configuration,
) -> Result<crate::models::FlushCacheResponseContent, Error<FlushCacheError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_plugins/_security/api/cache", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<FlushCacheError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns a document.
pub async fn get(
  configuration: &configuration::Configuration,
  id: &str,
  index: &str,
  stored_fields: Option<Vec<String>>,
  preference: Option<&str>,
  realtime: Option<bool>,
  refresh: Option<bool>,
  routing: Option<&str>,
  _source: Option<Vec<String>>,
  _source_excludes: Option<Vec<String>>,
  _source_includes: Option<Vec<String>>,
  version: Option<i32>,
  version_type: Option<VersionType>,
) -> Result<crate::models::GetResponseContent, Error<GetError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_doc/{id}",
    local_var_configuration.base_path,
    id = crate::apis::urlencode(id),
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = stored_fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("stored_fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "stored_fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = preference {
    local_var_req_builder = local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = realtime {
    local_var_req_builder = local_var_req_builder.query(&[("realtime", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = refresh {
    local_var_req_builder = local_var_req_builder.query(&[("refresh", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = _source {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_excludes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_excludes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_excludes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_includes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_includes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_includes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = version {
    local_var_req_builder = local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = version_type {
    local_var_req_builder = local_var_req_builder.query(&[("version_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<GetError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns account details for the current user.
pub async fn get_account_details(
  configuration: &configuration::Configuration,
) -> Result<crate::models::AccountDetails, Error<GetAccountDetailsError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_plugins/_security/api/account", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<GetAccountDetailsError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Retrieves one action group.
pub async fn get_action_group(
  configuration: &configuration::Configuration,
  action_group: &str,
) -> Result<::std::collections::HashMap<String, crate::models::ActionGroup>, Error<GetActionGroupError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_plugins/_security/api/actiongroups/{action_group}",
    local_var_configuration.base_path,
    action_group = crate::apis::urlencode(action_group)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<GetActionGroupError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Retrieves all action groups.
pub async fn get_action_groups(
  configuration: &configuration::Configuration,
) -> Result<::std::collections::HashMap<String, crate::models::ActionGroup>, Error<GetActionGroupsError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_plugins/_security/api/actiongroups/",
    local_var_configuration.base_path
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<GetActionGroupsError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Lists all active point in time searches.
pub async fn get_all_pits(
  configuration: &configuration::Configuration,
) -> Result<crate::models::GetAllPitsResponseContent, Error<GetAllPitsError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_search/point_in_time/_all", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<GetAllPitsError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Retrieves the audit configuration.
pub async fn get_audit_configuration(
  configuration: &configuration::Configuration,
) -> Result<crate::models::AuditConfigWithReadOnly, Error<GetAuditConfigurationError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_plugins/_security/api/audit", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<GetAuditConfigurationError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Retrieves the cluster’s security certificates.
pub async fn get_certificates(
  configuration: &configuration::Configuration,
) -> Result<crate::models::GetCertificatesResponseContent, Error<GetCertificatesError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_plugins/_security/api/ssl/certs", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<GetCertificatesError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns the current Security plugin configuration in JSON format.
pub async fn get_configuration(
  configuration: &configuration::Configuration,
) -> Result<crate::models::DynamicConfig, Error<GetConfigurationError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_plugins/_security/api/securityconfig",
    local_var_configuration.base_path
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<GetConfigurationError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Retrieves all distinguished names in the allow list.
pub async fn get_distinguished_names(
  configuration: &configuration::Configuration,
) -> Result<::std::collections::HashMap<String, crate::models::DistinguishedNames>, Error<GetDistinguishedNamesError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_plugins/_security/api/nodesdn", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<GetDistinguishedNamesError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Retrieve distinguished names of a specified cluster.
pub async fn get_distinguished_names_with_cluster_name(
  configuration: &configuration::Configuration,
  cluster_name: &str,
) -> Result<
  ::std::collections::HashMap<String, crate::models::DistinguishedNames>,
  Error<GetDistinguishedNamesWithClusterNameError>,
> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_plugins/_security/api/nodesdn/{cluster_name}",
    local_var_configuration.base_path,
    cluster_name = crate::apis::urlencode(cluster_name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<GetDistinguishedNamesWithClusterNameError> =
      serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Retrieves one role.
pub async fn get_role(
  configuration: &configuration::Configuration,
  role: &str,
) -> Result<::std::collections::HashMap<String, crate::models::Role>, Error<GetRoleError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_plugins/_security/api/roles/{role}",
    local_var_configuration.base_path,
    role = crate::apis::urlencode(role)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<GetRoleError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Retrieves one role mapping.
pub async fn get_role_mapping(
  configuration: &configuration::Configuration,
  role: &str,
) -> Result<::std::collections::HashMap<String, crate::models::RoleMapping>, Error<GetRoleMappingError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_plugins/_security/api/rolesmapping/{role}",
    local_var_configuration.base_path,
    role = crate::apis::urlencode(role)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<GetRoleMappingError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Retrieves all role mappings.
pub async fn get_role_mappings(
  configuration: &configuration::Configuration,
) -> Result<::std::collections::HashMap<String, crate::models::RoleMapping>, Error<GetRoleMappingsError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_plugins/_security/api/rolesmapping",
    local_var_configuration.base_path
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<GetRoleMappingsError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Retrieves all roles.
pub async fn get_roles(
  configuration: &configuration::Configuration,
) -> Result<::std::collections::HashMap<String, crate::models::Role>, Error<GetRolesError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_plugins/_security/api/roles/", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<GetRolesError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns a script.
pub async fn get_script(
  configuration: &configuration::Configuration,
  id: &str,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
) -> Result<(), Error<GetScriptError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_scripts/{id}",
    local_var_configuration.base_path,
    id = crate::apis::urlencode(id)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<GetScriptError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns all script contexts.
pub async fn get_script_context(
  configuration: &configuration::Configuration,
) -> Result<(), Error<GetScriptContextError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_script_context", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<GetScriptContextError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns available script types, languages and contexts.
pub async fn get_script_languages(
  configuration: &configuration::Configuration,
) -> Result<(), Error<GetScriptLanguagesError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_script_language", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<GetScriptLanguagesError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns the source of a document.
pub async fn get_source(
  configuration: &configuration::Configuration,
  id: &str,
  index: &str,
  preference: Option<&str>,
  realtime: Option<bool>,
  refresh: Option<bool>,
  routing: Option<&str>,
  _source: Option<Vec<String>>,
  _source_excludes: Option<Vec<String>>,
  _source_includes: Option<Vec<String>>,
  version: Option<i32>,
  version_type: Option<VersionType>,
) -> Result<(), Error<GetSourceError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_source/{id}",
    local_var_configuration.base_path,
    id = crate::apis::urlencode(id),
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = preference {
    local_var_req_builder = local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = realtime {
    local_var_req_builder = local_var_req_builder.query(&[("realtime", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = refresh {
    local_var_req_builder = local_var_req_builder.query(&[("refresh", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = _source {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_excludes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_excludes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_excludes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_includes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_includes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_includes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = version {
    local_var_req_builder = local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = version_type {
    local_var_req_builder = local_var_req_builder.query(&[("version_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<GetSourceError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Retrieves one tenant.
pub async fn get_tenant(
  configuration: &configuration::Configuration,
  tenant: &str,
) -> Result<::std::collections::HashMap<String, crate::models::Tenant>, Error<GetTenantError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_plugins/_security/api/tenants/{tenant}",
    local_var_configuration.base_path,
    tenant = crate::apis::urlencode(tenant)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<GetTenantError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Retrieves all tenants.
pub async fn get_tenants(
  configuration: &configuration::Configuration,
) -> Result<::std::collections::HashMap<String, crate::models::Tenant>, Error<GetTenantsError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_plugins/_security/api/tenants/", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<GetTenantsError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Retrieve one internal user.
pub async fn get_user(
  configuration: &configuration::Configuration,
  username: &str,
) -> Result<::std::collections::HashMap<String, crate::models::User>, Error<GetUserError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_plugins/_security/api/internalusers/{username}",
    local_var_configuration.base_path,
    username = crate::apis::urlencode(username)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<GetUserError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Retrieve all internal users.
pub async fn get_users(
  configuration: &configuration::Configuration,
) -> Result<::std::collections::HashMap<String, crate::models::User>, Error<GetUsersError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_plugins/_security/api/internalusers",
    local_var_configuration.base_path
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<GetUsersError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Creates or updates a document in an index.
pub async fn index_post(
  configuration: &configuration::Configuration,
  index: &str,
  body: serde_json::Value,
  wait_for_active_shards: Option<&str>,
  op_type: Option<OpType>,
  refresh: Option<RefreshEnum>,
  routing: Option<&str>,
  timeout: Option<&str>,
  version: Option<i32>,
  version_type: Option<VersionType>,
  if_seq_no: Option<i32>,
  if_primary_term: Option<i32>,
  pipeline: Option<&str>,
  require_alias: Option<bool>,
) -> Result<(), Error<IndexPostError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_doc",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = wait_for_active_shards {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_active_shards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = op_type {
    local_var_req_builder = local_var_req_builder.query(&[("op_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = refresh {
    local_var_req_builder = local_var_req_builder.query(&[("refresh", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = version {
    local_var_req_builder = local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = version_type {
    local_var_req_builder = local_var_req_builder.query(&[("version_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = if_seq_no {
    local_var_req_builder = local_var_req_builder.query(&[("if_seq_no", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = if_primary_term {
    local_var_req_builder = local_var_req_builder.query(&[("if_primary_term", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = pipeline {
    local_var_req_builder = local_var_req_builder.query(&[("pipeline", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = require_alias {
    local_var_req_builder = local_var_req_builder.query(&[("require_alias", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndexPostError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Creates or updates a document in an index.
pub async fn index_post_with_id(
  configuration: &configuration::Configuration,
  id: &str,
  index: &str,
  body: serde_json::Value,
  wait_for_active_shards: Option<&str>,
  op_type: Option<OpType>,
  refresh: Option<RefreshEnum>,
  routing: Option<&str>,
  timeout: Option<&str>,
  version: Option<i32>,
  version_type: Option<VersionType>,
  if_seq_no: Option<i32>,
  if_primary_term: Option<i32>,
  pipeline: Option<&str>,
  require_alias: Option<bool>,
) -> Result<(), Error<IndexPostWithIdError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_doc/{id}",
    local_var_configuration.base_path,
    id = crate::apis::urlencode(id),
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = wait_for_active_shards {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_active_shards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = op_type {
    local_var_req_builder = local_var_req_builder.query(&[("op_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = refresh {
    local_var_req_builder = local_var_req_builder.query(&[("refresh", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = version {
    local_var_req_builder = local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = version_type {
    local_var_req_builder = local_var_req_builder.query(&[("version_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = if_seq_no {
    local_var_req_builder = local_var_req_builder.query(&[("if_seq_no", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = if_primary_term {
    local_var_req_builder = local_var_req_builder.query(&[("if_primary_term", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = pipeline {
    local_var_req_builder = local_var_req_builder.query(&[("pipeline", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = require_alias {
    local_var_req_builder = local_var_req_builder.query(&[("require_alias", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndexPostWithIdError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Creates or updates a document in an index.
pub async fn index_put_with_id(
  configuration: &configuration::Configuration,
  id: &str,
  index: &str,
  body: serde_json::Value,
  wait_for_active_shards: Option<&str>,
  op_type: Option<OpType>,
  refresh: Option<RefreshEnum>,
  routing: Option<&str>,
  timeout: Option<&str>,
  version: Option<i32>,
  version_type: Option<VersionType>,
  if_seq_no: Option<i32>,
  if_primary_term: Option<i32>,
  pipeline: Option<&str>,
  require_alias: Option<bool>,
) -> Result<(), Error<IndexPutWithIdError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_doc/{id}",
    local_var_configuration.base_path,
    id = crate::apis::urlencode(id),
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = wait_for_active_shards {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_active_shards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = op_type {
    local_var_req_builder = local_var_req_builder.query(&[("op_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = refresh {
    local_var_req_builder = local_var_req_builder.query(&[("refresh", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = version {
    local_var_req_builder = local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = version_type {
    local_var_req_builder = local_var_req_builder.query(&[("version_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = if_seq_no {
    local_var_req_builder = local_var_req_builder.query(&[("if_seq_no", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = if_primary_term {
    local_var_req_builder = local_var_req_builder.query(&[("if_primary_term", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = pipeline {
    local_var_req_builder = local_var_req_builder.query(&[("pipeline", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = require_alias {
    local_var_req_builder = local_var_req_builder.query(&[("require_alias", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndexPutWithIdError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Adds a block to an index.
pub async fn indices_add_block(
  configuration: &configuration::Configuration,
  index: &str,
  block: &str,
  timeout: Option<&str>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
) -> Result<(), Error<IndicesAddBlockError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_block/{block}",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index),
    block = crate::apis::urlencode(block)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesAddBlockError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Performs the analysis process on a text and return the tokens breakdown of
/// the text.
pub async fn indices_analyze_get(
  configuration: &configuration::Configuration,
  index: Option<&str>,
) -> Result<(), Error<IndicesAnalyzeGetError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_analyze", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = index {
    local_var_req_builder = local_var_req_builder.query(&[("index", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesAnalyzeGetError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Performs the analysis process on a text and return the tokens breakdown of
/// the text.
pub async fn indices_analyze_get_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  index2: Option<&str>,
) -> Result<(), Error<IndicesAnalyzeGetWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_analyze",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = index2 {
    local_var_req_builder = local_var_req_builder.query(&[("index", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesAnalyzeGetWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Performs the analysis process on a text and return the tokens breakdown of
/// the text.
pub async fn indices_analyze_post(
  configuration: &configuration::Configuration,
  index: Option<&str>,
  body: Option<serde_json::Value>,
) -> Result<(), Error<IndicesAnalyzePostError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_analyze", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = index {
    local_var_req_builder = local_var_req_builder.query(&[("index", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesAnalyzePostError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Performs the analysis process on a text and return the tokens breakdown of
/// the text.
pub async fn indices_analyze_post_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  index2: Option<&str>,
  body: Option<serde_json::Value>,
) -> Result<(), Error<IndicesAnalyzePostWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_analyze",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = index2 {
    local_var_req_builder = local_var_req_builder.query(&[("index", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesAnalyzePostWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Clears all or specific caches for one or more indices.
pub async fn indices_clear_cache(
  configuration: &configuration::Configuration,
  fielddata: Option<bool>,
  fields: Option<Vec<String>>,
  query: Option<bool>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  index: Option<Vec<String>>,
  request: Option<bool>,
) -> Result<(), Error<IndicesClearCacheError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_cache/clear", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = fielddata {
    local_var_req_builder = local_var_req_builder.query(&[("fielddata", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = query {
    local_var_req_builder = local_var_req_builder.query(&[("query", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = index {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("index".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "index",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = request {
    local_var_req_builder = local_var_req_builder.query(&[("request", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesClearCacheError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Clears all or specific caches for one or more indices.
pub async fn indices_clear_cache_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  fielddata: Option<bool>,
  fields: Option<Vec<String>>,
  query: Option<bool>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  index2: Option<Vec<String>>,
  request: Option<bool>,
) -> Result<(), Error<IndicesClearCacheWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_cache/clear",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = fielddata {
    local_var_req_builder = local_var_req_builder.query(&[("fielddata", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = query {
    local_var_req_builder = local_var_req_builder.query(&[("query", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = index2 {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("index".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "index",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = request {
    local_var_req_builder = local_var_req_builder.query(&[("request", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesClearCacheWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Clones an index.
pub async fn indices_clone_post(
  configuration: &configuration::Configuration,
  index: &str,
  target: &str,
  timeout: Option<&str>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  wait_for_active_shards: Option<&str>,
  body: Option<serde_json::Value>,
) -> Result<(), Error<IndicesClonePostError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_clone/{target}",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index),
    target = crate::apis::urlencode(target)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_active_shards {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_active_shards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesClonePostError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Clones an index.
pub async fn indices_clone_put(
  configuration: &configuration::Configuration,
  index: &str,
  target: &str,
  timeout: Option<&str>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  wait_for_active_shards: Option<&str>,
  body: Option<serde_json::Value>,
) -> Result<(), Error<IndicesClonePutError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_clone/{target}",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index),
    target = crate::apis::urlencode(target)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_active_shards {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_active_shards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesClonePutError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Closes an index.
pub async fn indices_close(
  configuration: &configuration::Configuration,
  index: &str,
  timeout: Option<&str>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  wait_for_active_shards: Option<&str>,
) -> Result<(), Error<IndicesCloseError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_close",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_active_shards {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_active_shards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesCloseError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Creates an index with optional settings and mappings.
pub async fn indices_create(
  configuration: &configuration::Configuration,
  index: &str,
  wait_for_active_shards: Option<&str>,
  timeout: Option<&str>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  indices_create_body_params: Option<crate::models::IndicesCreateBodyParams>,
) -> Result<crate::models::IndicesCreateResponseContent, Error<IndicesCreateError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = wait_for_active_shards {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_active_shards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&indices_create_body_params);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<IndicesCreateError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Creates or updates a data stream.
pub async fn indices_create_data_stream(
  configuration: &configuration::Configuration,
  name: &str,
  body: Option<serde_json::Value>,
) -> Result<crate::models::IndicesCreateDataStreamResponseContent, Error<IndicesCreateDataStreamError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_data_stream/{name}",
    local_var_configuration.base_path,
    name = crate::apis::urlencode(name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<IndicesCreateDataStreamError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Provides statistics on operations happening in a data stream.
pub async fn indices_data_streams_stats(
  configuration: &configuration::Configuration,
) -> Result<(), Error<IndicesDataStreamsStatsError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_data_stream/_stats", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesDataStreamsStatsError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Provides statistics on operations happening in a data stream.
pub async fn indices_data_streams_stats_with_name(
  configuration: &configuration::Configuration,
  name: &str,
) -> Result<(), Error<IndicesDataStreamsStatsWithNameError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_data_stream/{name}/_stats",
    local_var_configuration.base_path,
    name = crate::apis::urlencode(name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesDataStreamsStatsWithNameError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Deletes an index.
pub async fn indices_delete(
  configuration: &configuration::Configuration,
  index: &str,
  timeout: Option<&str>,
  master_timeout: Option<&str>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
) -> Result<crate::models::IndicesDeleteResponseContent, Error<IndicesDeleteError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<IndicesDeleteError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Deletes an alias.
pub async fn indices_delete_alias(
  configuration: &configuration::Configuration,
  index: &str,
  name: &str,
  timeout: Option<&str>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
) -> Result<(), Error<IndicesDeleteAliasError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_alias/{name}",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index),
    name = crate::apis::urlencode(name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesDeleteAliasError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Deletes an alias.
pub async fn indices_delete_alias_plural(
  configuration: &configuration::Configuration,
  index: &str,
  name: &str,
  timeout: Option<&str>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
) -> Result<(), Error<IndicesDeleteAliasPluralError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_aliases/{name}",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index),
    name = crate::apis::urlencode(name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesDeleteAliasPluralError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Deletes a data stream.
pub async fn indices_delete_data_stream(
  configuration: &configuration::Configuration,
  name: &str,
) -> Result<crate::models::IndicesDeleteDataStreamResponseContent, Error<IndicesDeleteDataStreamError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_data_stream/{name}",
    local_var_configuration.base_path,
    name = crate::apis::urlencode(name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<IndicesDeleteDataStreamError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Deletes an index template.
pub async fn indices_delete_index_template(
  configuration: &configuration::Configuration,
  name: &str,
  timeout: Option<&str>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
) -> Result<(), Error<IndicesDeleteIndexTemplateError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_index_template/{name}",
    local_var_configuration.base_path,
    name = crate::apis::urlencode(name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesDeleteIndexTemplateError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Deletes an index template.
pub async fn indices_delete_template(
  configuration: &configuration::Configuration,
  name: &str,
  timeout: Option<&str>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
) -> Result<(), Error<IndicesDeleteTemplateError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_template/{name}",
    local_var_configuration.base_path,
    name = crate::apis::urlencode(name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesDeleteTemplateError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about whether a particular index exists.
pub async fn indices_exists(
  configuration: &configuration::Configuration,
  index: &str,
  local: Option<bool>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  flat_settings: Option<bool>,
  include_defaults: Option<bool>,
) -> Result<(), Error<IndicesExistsError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::HEAD, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = flat_settings {
    local_var_req_builder = local_var_req_builder.query(&[("flat_settings", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = include_defaults {
    local_var_req_builder = local_var_req_builder.query(&[("include_defaults", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesExistsError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about whether a particular alias exists.
pub async fn indices_exists_alias(
  configuration: &configuration::Configuration,
  name: &str,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  local: Option<bool>,
) -> Result<(), Error<IndicesExistsAliasError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_alias/{name}",
    local_var_configuration.base_path,
    name = crate::apis::urlencode(name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::HEAD, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesExistsAliasError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about whether a particular alias exists.
pub async fn indices_exists_alias_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  name: &str,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  local: Option<bool>,
) -> Result<(), Error<IndicesExistsAliasWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_alias/{name}",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index),
    name = crate::apis::urlencode(name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::HEAD, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesExistsAliasWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about whether a particular index template exists.
pub async fn indices_exists_index_template(
  configuration: &configuration::Configuration,
  name: &str,
  flat_settings: Option<bool>,
  master_timeout: Option<&str>,
  local: Option<bool>,
) -> Result<(), Error<IndicesExistsIndexTemplateError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_index_template/{name}",
    local_var_configuration.base_path,
    name = crate::apis::urlencode(name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::HEAD, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = flat_settings {
    local_var_req_builder = local_var_req_builder.query(&[("flat_settings", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesExistsIndexTemplateError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about whether a particular index template exists.
pub async fn indices_exists_template(
  configuration: &configuration::Configuration,
  name: &str,
  flat_settings: Option<bool>,
  master_timeout: Option<&str>,
  local: Option<bool>,
) -> Result<(), Error<IndicesExistsTemplateError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_template/{name}",
    local_var_configuration.base_path,
    name = crate::apis::urlencode(name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::HEAD, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = flat_settings {
    local_var_req_builder = local_var_req_builder.query(&[("flat_settings", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesExistsTemplateError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Performs the flush operation on one or more indices.
pub async fn indices_flush_get(
  configuration: &configuration::Configuration,
  force: Option<bool>,
  wait_if_ongoing: Option<bool>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
) -> Result<(), Error<IndicesFlushGetError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_flush", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = force {
    local_var_req_builder = local_var_req_builder.query(&[("force", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_if_ongoing {
    local_var_req_builder = local_var_req_builder.query(&[("wait_if_ongoing", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesFlushGetError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Performs the flush operation on one or more indices.
pub async fn indices_flush_get_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  force: Option<bool>,
  wait_if_ongoing: Option<bool>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
) -> Result<(), Error<IndicesFlushGetWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_flush",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = force {
    local_var_req_builder = local_var_req_builder.query(&[("force", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_if_ongoing {
    local_var_req_builder = local_var_req_builder.query(&[("wait_if_ongoing", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesFlushGetWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Performs the flush operation on one or more indices.
pub async fn indices_flush_post(
  configuration: &configuration::Configuration,
  force: Option<bool>,
  wait_if_ongoing: Option<bool>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
) -> Result<(), Error<IndicesFlushPostError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_flush", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = force {
    local_var_req_builder = local_var_req_builder.query(&[("force", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_if_ongoing {
    local_var_req_builder = local_var_req_builder.query(&[("wait_if_ongoing", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesFlushPostError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Performs the flush operation on one or more indices.
pub async fn indices_flush_post_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  force: Option<bool>,
  wait_if_ongoing: Option<bool>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
) -> Result<(), Error<IndicesFlushPostWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_flush",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = force {
    local_var_req_builder = local_var_req_builder.query(&[("force", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_if_ongoing {
    local_var_req_builder = local_var_req_builder.query(&[("wait_if_ongoing", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesFlushPostWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Performs the force merge operation on one or more indices.
pub async fn indices_forcemerge(
  configuration: &configuration::Configuration,
  flush: Option<bool>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  max_num_segments: Option<i32>,
  only_expunge_deletes: Option<bool>,
) -> Result<(), Error<IndicesForcemergeError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_forcemerge", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = flush {
    local_var_req_builder = local_var_req_builder.query(&[("flush", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = max_num_segments {
    local_var_req_builder = local_var_req_builder.query(&[("max_num_segments", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = only_expunge_deletes {
    local_var_req_builder = local_var_req_builder.query(&[("only_expunge_deletes", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesForcemergeError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Performs the force merge operation on one or more indices.
pub async fn indices_forcemerge_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  flush: Option<bool>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  max_num_segments: Option<i32>,
  only_expunge_deletes: Option<bool>,
) -> Result<(), Error<IndicesForcemergeWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_forcemerge",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = flush {
    local_var_req_builder = local_var_req_builder.query(&[("flush", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = max_num_segments {
    local_var_req_builder = local_var_req_builder.query(&[("max_num_segments", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = only_expunge_deletes {
    local_var_req_builder = local_var_req_builder.query(&[("only_expunge_deletes", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesForcemergeWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about one or more indices.
pub async fn indices_get(
  configuration: &configuration::Configuration,
  index: &str,
  local: Option<bool>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  flat_settings: Option<bool>,
  include_defaults: Option<bool>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
) -> Result<(), Error<IndicesGetError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = flat_settings {
    local_var_req_builder = local_var_req_builder.query(&[("flat_settings", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = include_defaults {
    local_var_req_builder = local_var_req_builder.query(&[("include_defaults", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesGetError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns an alias.
pub async fn indices_get_alias(
  configuration: &configuration::Configuration,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  local: Option<bool>,
) -> Result<(), Error<IndicesGetAliasError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_alias", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesGetAliasError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns an alias.
pub async fn indices_get_alias_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  local: Option<bool>,
) -> Result<(), Error<IndicesGetAliasWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_alias",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesGetAliasWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns an alias.
pub async fn indices_get_alias_with_index_name(
  configuration: &configuration::Configuration,
  index: &str,
  name: &str,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  local: Option<bool>,
) -> Result<(), Error<IndicesGetAliasWithIndexNameError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_alias/{name}",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index),
    name = crate::apis::urlencode(name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesGetAliasWithIndexNameError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns an alias.
pub async fn indices_get_alias_with_name(
  configuration: &configuration::Configuration,
  name: &str,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  local: Option<bool>,
) -> Result<(), Error<IndicesGetAliasWithNameError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_alias/{name}",
    local_var_configuration.base_path,
    name = crate::apis::urlencode(name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesGetAliasWithNameError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns data streams.
pub async fn indices_get_data_stream(
  configuration: &configuration::Configuration,
) -> Result<crate::models::IndicesGetDataStreamResponseContent, Error<IndicesGetDataStreamError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_data_stream", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<IndicesGetDataStreamError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns data streams.
pub async fn indices_get_data_stream_with_name(
  configuration: &configuration::Configuration,
  name: &str,
) -> Result<crate::models::IndicesGetDataStreamWithNameResponseContent, Error<IndicesGetDataStreamWithNameError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_data_stream/{name}",
    local_var_configuration.base_path,
    name = crate::apis::urlencode(name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<IndicesGetDataStreamWithNameError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns mapping for one or more fields.
pub async fn indices_get_field_mapping(
  configuration: &configuration::Configuration,
  fields: &str,
  include_defaults: Option<bool>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  local: Option<bool>,
) -> Result<(), Error<IndicesGetFieldMappingError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_mapping/field/{fields}",
    local_var_configuration.base_path,
    fields = crate::apis::urlencode(fields)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = include_defaults {
    local_var_req_builder = local_var_req_builder.query(&[("include_defaults", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesGetFieldMappingError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns mapping for one or more fields.
pub async fn indices_get_field_mapping_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  fields: &str,
  include_defaults: Option<bool>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  local: Option<bool>,
) -> Result<(), Error<IndicesGetFieldMappingWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_mapping/field/{fields}",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index),
    fields = crate::apis::urlencode(fields)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = include_defaults {
    local_var_req_builder = local_var_req_builder.query(&[("include_defaults", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesGetFieldMappingWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns an index template.
pub async fn indices_get_index_template(
  configuration: &configuration::Configuration,
  flat_settings: Option<bool>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  local: Option<bool>,
) -> Result<(), Error<IndicesGetIndexTemplateError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_index_template", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = flat_settings {
    local_var_req_builder = local_var_req_builder.query(&[("flat_settings", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesGetIndexTemplateError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns an index template.
pub async fn indices_get_index_template_with_name(
  configuration: &configuration::Configuration,
  name: &str,
  flat_settings: Option<bool>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  local: Option<bool>,
) -> Result<(), Error<IndicesGetIndexTemplateWithNameError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_index_template/{name}",
    local_var_configuration.base_path,
    name = crate::apis::urlencode(name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = flat_settings {
    local_var_req_builder = local_var_req_builder.query(&[("flat_settings", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesGetIndexTemplateWithNameError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns mappings for one or more indices.
pub async fn indices_get_mapping(
  configuration: &configuration::Configuration,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  local: Option<bool>,
) -> Result<(), Error<IndicesGetMappingError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_mapping", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesGetMappingError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns mappings for one or more indices.
pub async fn indices_get_mapping_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  local: Option<bool>,
) -> Result<(), Error<IndicesGetMappingWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_mapping",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesGetMappingWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns settings for one or more indices.
pub async fn indices_get_settings(
  configuration: &configuration::Configuration,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  flat_settings: Option<bool>,
  local: Option<bool>,
  include_defaults: Option<bool>,
) -> Result<(), Error<IndicesGetSettingsError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_settings", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = flat_settings {
    local_var_req_builder = local_var_req_builder.query(&[("flat_settings", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = include_defaults {
    local_var_req_builder = local_var_req_builder.query(&[("include_defaults", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesGetSettingsError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns settings for one or more indices.
pub async fn indices_get_settings_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  flat_settings: Option<bool>,
  local: Option<bool>,
  include_defaults: Option<bool>,
) -> Result<(), Error<IndicesGetSettingsWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_settings",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = flat_settings {
    local_var_req_builder = local_var_req_builder.query(&[("flat_settings", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = include_defaults {
    local_var_req_builder = local_var_req_builder.query(&[("include_defaults", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesGetSettingsWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns settings for one or more indices.
pub async fn indices_get_settings_with_index_name(
  configuration: &configuration::Configuration,
  index: &str,
  name: &str,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  flat_settings: Option<bool>,
  local: Option<bool>,
  include_defaults: Option<bool>,
) -> Result<(), Error<IndicesGetSettingsWithIndexNameError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_settings/{name}",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index),
    name = crate::apis::urlencode(name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = flat_settings {
    local_var_req_builder = local_var_req_builder.query(&[("flat_settings", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = include_defaults {
    local_var_req_builder = local_var_req_builder.query(&[("include_defaults", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesGetSettingsWithIndexNameError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns settings for one or more indices.
pub async fn indices_get_settings_with_name(
  configuration: &configuration::Configuration,
  name: &str,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  flat_settings: Option<bool>,
  local: Option<bool>,
  include_defaults: Option<bool>,
) -> Result<(), Error<IndicesGetSettingsWithNameError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_settings/{name}",
    local_var_configuration.base_path,
    name = crate::apis::urlencode(name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = flat_settings {
    local_var_req_builder = local_var_req_builder.query(&[("flat_settings", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = include_defaults {
    local_var_req_builder = local_var_req_builder.query(&[("include_defaults", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesGetSettingsWithNameError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns an index template.
pub async fn indices_get_template(
  configuration: &configuration::Configuration,
  flat_settings: Option<bool>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  local: Option<bool>,
) -> Result<(), Error<IndicesGetTemplateError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_template", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = flat_settings {
    local_var_req_builder = local_var_req_builder.query(&[("flat_settings", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesGetTemplateError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns an index template.
pub async fn indices_get_template_with_name(
  configuration: &configuration::Configuration,
  name: &str,
  flat_settings: Option<bool>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  local: Option<bool>,
) -> Result<(), Error<IndicesGetTemplateWithNameError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_template/{name}",
    local_var_configuration.base_path,
    name = crate::apis::urlencode(name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = flat_settings {
    local_var_req_builder = local_var_req_builder.query(&[("flat_settings", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesGetTemplateWithNameError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// The _upgrade API is no longer useful and will be removed.
pub async fn indices_get_upgrade(
  configuration: &configuration::Configuration,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
) -> Result<(), Error<IndicesGetUpgradeError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_upgrade", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesGetUpgradeError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// The _upgrade API is no longer useful and will be removed.
pub async fn indices_get_upgrade_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
) -> Result<(), Error<IndicesGetUpgradeWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_upgrade",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesGetUpgradeWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Opens an index.
pub async fn indices_open(
  configuration: &configuration::Configuration,
  index: &str,
  timeout: Option<&str>,
  master_timeout: Option<&str>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  wait_for_active_shards: Option<&str>,
) -> Result<(), Error<IndicesOpenError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_open",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_active_shards {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_active_shards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesOpenError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Creates or updates an alias.
pub async fn indices_put_alias_post(
  configuration: &configuration::Configuration,
  index: &str,
  name: &str,
  timeout: Option<&str>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  body: Option<serde_json::Value>,
) -> Result<(), Error<IndicesPutAliasPostError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_alias/{name}",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index),
    name = crate::apis::urlencode(name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesPutAliasPostError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Creates or updates an alias.
pub async fn indices_put_alias_post_plural(
  configuration: &configuration::Configuration,
  index: &str,
  name: &str,
  timeout: Option<&str>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  body: Option<serde_json::Value>,
) -> Result<(), Error<IndicesPutAliasPostPluralError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_aliases/{name}",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index),
    name = crate::apis::urlencode(name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesPutAliasPostPluralError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Creates or updates an alias.
pub async fn indices_put_alias_put(
  configuration: &configuration::Configuration,
  index: &str,
  name: &str,
  timeout: Option<&str>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  body: Option<serde_json::Value>,
) -> Result<(), Error<IndicesPutAliasPutError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_alias/{name}",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index),
    name = crate::apis::urlencode(name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesPutAliasPutError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Creates or updates an alias.
pub async fn indices_put_alias_put_plural(
  configuration: &configuration::Configuration,
  index: &str,
  name: &str,
  timeout: Option<&str>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  body: Option<serde_json::Value>,
) -> Result<(), Error<IndicesPutAliasPutPluralError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_aliases/{name}",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index),
    name = crate::apis::urlencode(name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesPutAliasPutPluralError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Creates or updates an index template.
pub async fn indices_put_index_template_post(
  configuration: &configuration::Configuration,
  name: &str,
  body: serde_json::Value,
  create: Option<bool>,
  cause: Option<&str>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
) -> Result<(), Error<IndicesPutIndexTemplatePostError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_index_template/{name}",
    local_var_configuration.base_path,
    name = crate::apis::urlencode(name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = create {
    local_var_req_builder = local_var_req_builder.query(&[("create", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cause {
    local_var_req_builder = local_var_req_builder.query(&[("cause", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesPutIndexTemplatePostError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Creates or updates an index template.
pub async fn indices_put_index_template_put(
  configuration: &configuration::Configuration,
  name: &str,
  body: serde_json::Value,
  create: Option<bool>,
  cause: Option<&str>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
) -> Result<(), Error<IndicesPutIndexTemplatePutError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_index_template/{name}",
    local_var_configuration.base_path,
    name = crate::apis::urlencode(name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = create {
    local_var_req_builder = local_var_req_builder.query(&[("create", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cause {
    local_var_req_builder = local_var_req_builder.query(&[("cause", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesPutIndexTemplatePutError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Updates the index mappings.
pub async fn indices_put_mapping_post(
  configuration: &configuration::Configuration,
  index: &str,
  body: serde_json::Value,
  timeout: Option<&str>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  write_index_only: Option<bool>,
) -> Result<crate::models::IndicesPutMappingPostResponseContent, Error<IndicesPutMappingPostError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_mapping",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = write_index_only {
    local_var_req_builder = local_var_req_builder.query(&[("write_index_only", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<IndicesPutMappingPostError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Updates the index mappings.
pub async fn indices_put_mapping_put(
  configuration: &configuration::Configuration,
  index: &str,
  body: serde_json::Value,
  timeout: Option<&str>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  write_index_only: Option<bool>,
) -> Result<crate::models::IndicesPutMappingPutResponseContent, Error<IndicesPutMappingPutError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_mapping",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = write_index_only {
    local_var_req_builder = local_var_req_builder.query(&[("write_index_only", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<IndicesPutMappingPutError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Updates the index settings.
pub async fn indices_put_settings(
  configuration: &configuration::Configuration,
  body: serde_json::Value,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  timeout: Option<&str>,
  preserve_existing: Option<bool>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  flat_settings: Option<bool>,
) -> Result<(), Error<IndicesPutSettingsError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_settings", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = preserve_existing {
    local_var_req_builder = local_var_req_builder.query(&[("preserve_existing", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = flat_settings {
    local_var_req_builder = local_var_req_builder.query(&[("flat_settings", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesPutSettingsError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Updates the index settings.
pub async fn indices_put_settings_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  body: serde_json::Value,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  timeout: Option<&str>,
  preserve_existing: Option<bool>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  flat_settings: Option<bool>,
) -> Result<(), Error<IndicesPutSettingsWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_settings",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = preserve_existing {
    local_var_req_builder = local_var_req_builder.query(&[("preserve_existing", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = flat_settings {
    local_var_req_builder = local_var_req_builder.query(&[("flat_settings", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesPutSettingsWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Creates or updates an index template.
pub async fn indices_put_template_post(
  configuration: &configuration::Configuration,
  name: &str,
  body: serde_json::Value,
  order: Option<i32>,
  create: Option<bool>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
) -> Result<(), Error<IndicesPutTemplatePostError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_template/{name}",
    local_var_configuration.base_path,
    name = crate::apis::urlencode(name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = order {
    local_var_req_builder = local_var_req_builder.query(&[("order", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = create {
    local_var_req_builder = local_var_req_builder.query(&[("create", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesPutTemplatePostError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Creates or updates an index template.
pub async fn indices_put_template_put(
  configuration: &configuration::Configuration,
  name: &str,
  body: serde_json::Value,
  order: Option<i32>,
  create: Option<bool>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
) -> Result<(), Error<IndicesPutTemplatePutError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_template/{name}",
    local_var_configuration.base_path,
    name = crate::apis::urlencode(name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = order {
    local_var_req_builder = local_var_req_builder.query(&[("order", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = create {
    local_var_req_builder = local_var_req_builder.query(&[("create", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesPutTemplatePutError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about ongoing index shard recoveries.
pub async fn indices_recovery(
  configuration: &configuration::Configuration,
  detailed: Option<bool>,
  active_only: Option<bool>,
) -> Result<(), Error<IndicesRecoveryError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_recovery", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = detailed {
    local_var_req_builder = local_var_req_builder.query(&[("detailed", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = active_only {
    local_var_req_builder = local_var_req_builder.query(&[("active_only", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesRecoveryError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about ongoing index shard recoveries.
pub async fn indices_recovery_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  detailed: Option<bool>,
  active_only: Option<bool>,
) -> Result<(), Error<IndicesRecoveryWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_recovery",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = detailed {
    local_var_req_builder = local_var_req_builder.query(&[("detailed", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = active_only {
    local_var_req_builder = local_var_req_builder.query(&[("active_only", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesRecoveryWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Performs the refresh operation in one or more indices.
pub async fn indices_refresh_get(
  configuration: &configuration::Configuration,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
) -> Result<(), Error<IndicesRefreshGetError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_refresh", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesRefreshGetError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Performs the refresh operation in one or more indices.
pub async fn indices_refresh_get_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
) -> Result<(), Error<IndicesRefreshGetWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_refresh",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesRefreshGetWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Performs the refresh operation in one or more indices.
pub async fn indices_refresh_post(
  configuration: &configuration::Configuration,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
) -> Result<(), Error<IndicesRefreshPostError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_refresh", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesRefreshPostError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Performs the refresh operation in one or more indices.
pub async fn indices_refresh_post_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
) -> Result<(), Error<IndicesRefreshPostWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_refresh",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesRefreshPostWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about any matching indices, aliases, and data streams.
pub async fn indices_resolve_index(
  configuration: &configuration::Configuration,
  name: &str,
  expand_wildcards: Option<ExpandWildcards>,
) -> Result<(), Error<IndicesResolveIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_resolve/index/{name}",
    local_var_configuration.base_path,
    name = crate::apis::urlencode(name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesResolveIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Updates an alias to point to a new index when the existing index is
/// considered to be too large or too old.
pub async fn indices_rollover(
  configuration: &configuration::Configuration,
  alias: &str,
  timeout: Option<&str>,
  dry_run: Option<bool>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  wait_for_active_shards: Option<&str>,
  body: Option<serde_json::Value>,
) -> Result<(), Error<IndicesRolloverError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{alias}/_rollover",
    local_var_configuration.base_path,
    alias = crate::apis::urlencode(alias)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = dry_run {
    local_var_req_builder = local_var_req_builder.query(&[("dry_run", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_active_shards {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_active_shards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesRolloverError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Updates an alias to point to a new index when the existing index is
/// considered to be too large or too old.
pub async fn indices_rollover_with_new_index(
  configuration: &configuration::Configuration,
  alias: &str,
  new_index: &str,
  timeout: Option<&str>,
  dry_run: Option<bool>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  wait_for_active_shards: Option<&str>,
  body: Option<serde_json::Value>,
) -> Result<(), Error<IndicesRolloverWithNewIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{alias}/_rollover/{new_index}",
    local_var_configuration.base_path,
    alias = crate::apis::urlencode(alias),
    new_index = crate::apis::urlencode(new_index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = dry_run {
    local_var_req_builder = local_var_req_builder.query(&[("dry_run", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_active_shards {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_active_shards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesRolloverWithNewIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Provides low-level information about segments in a Lucene index.
pub async fn indices_segments(
  configuration: &configuration::Configuration,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  verbose: Option<bool>,
) -> Result<(), Error<IndicesSegmentsError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_segments", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = verbose {
    local_var_req_builder = local_var_req_builder.query(&[("verbose", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesSegmentsError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Provides low-level information about segments in a Lucene index.
pub async fn indices_segments_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  verbose: Option<bool>,
) -> Result<(), Error<IndicesSegmentsWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_segments",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = verbose {
    local_var_req_builder = local_var_req_builder.query(&[("verbose", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesSegmentsWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Provides store information for shard copies of indices.
pub async fn indices_shard_stores(
  configuration: &configuration::Configuration,
  status: Option<Vec<crate::models::StatusMember>>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
) -> Result<(), Error<IndicesShardStoresError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_shard_stores", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = status {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("status".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "status",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesShardStoresError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Provides store information for shard copies of indices.
pub async fn indices_shard_stores_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  status: Option<Vec<crate::models::StatusMember>>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
) -> Result<(), Error<IndicesShardStoresWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_shard_stores",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = status {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("status".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "status",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesShardStoresWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allow to shrink an existing index into a new index with fewer primary
/// shards.
pub async fn indices_shrink_post(
  configuration: &configuration::Configuration,
  index: &str,
  target: &str,
  copy_settings: Option<bool>,
  timeout: Option<&str>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  wait_for_active_shards: Option<&str>,
  body: Option<serde_json::Value>,
) -> Result<(), Error<IndicesShrinkPostError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_shrink/{target}",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index),
    target = crate::apis::urlencode(target)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = copy_settings {
    local_var_req_builder = local_var_req_builder.query(&[("copy_settings", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_active_shards {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_active_shards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesShrinkPostError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allow to shrink an existing index into a new index with fewer primary
/// shards.
pub async fn indices_shrink_put(
  configuration: &configuration::Configuration,
  index: &str,
  target: &str,
  copy_settings: Option<bool>,
  timeout: Option<&str>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  wait_for_active_shards: Option<&str>,
  body: Option<serde_json::Value>,
) -> Result<(), Error<IndicesShrinkPutError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_shrink/{target}",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index),
    target = crate::apis::urlencode(target)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = copy_settings {
    local_var_req_builder = local_var_req_builder.query(&[("copy_settings", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_active_shards {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_active_shards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesShrinkPutError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Simulate matching the given index name against the index templates in the
/// system.
pub async fn indices_simulate_index_template(
  configuration: &configuration::Configuration,
  name: &str,
  create: Option<bool>,
  cause: Option<&str>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  body: Option<serde_json::Value>,
) -> Result<(), Error<IndicesSimulateIndexTemplateError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_index_template/_simulate_index/{name}",
    local_var_configuration.base_path,
    name = crate::apis::urlencode(name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = create {
    local_var_req_builder = local_var_req_builder.query(&[("create", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cause {
    local_var_req_builder = local_var_req_builder.query(&[("cause", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesSimulateIndexTemplateError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Simulate resolving the given template name or body.
pub async fn indices_simulate_template(
  configuration: &configuration::Configuration,
  create: Option<bool>,
  cause: Option<&str>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  body: Option<serde_json::Value>,
) -> Result<(), Error<IndicesSimulateTemplateError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_index_template/_simulate", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = create {
    local_var_req_builder = local_var_req_builder.query(&[("create", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cause {
    local_var_req_builder = local_var_req_builder.query(&[("cause", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesSimulateTemplateError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Simulate resolving the given template name or body.
pub async fn indices_simulate_template_with_name(
  configuration: &configuration::Configuration,
  name: &str,
  create: Option<bool>,
  cause: Option<&str>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  body: Option<serde_json::Value>,
) -> Result<(), Error<IndicesSimulateTemplateWithNameError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_index_template/_simulate/{name}",
    local_var_configuration.base_path,
    name = crate::apis::urlencode(name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = create {
    local_var_req_builder = local_var_req_builder.query(&[("create", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cause {
    local_var_req_builder = local_var_req_builder.query(&[("cause", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesSimulateTemplateWithNameError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows you to split an existing index into a new index with more primary
/// shards.
pub async fn indices_split_post(
  configuration: &configuration::Configuration,
  index: &str,
  target: &str,
  copy_settings: Option<bool>,
  timeout: Option<&str>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  wait_for_active_shards: Option<&str>,
  body: Option<serde_json::Value>,
) -> Result<(), Error<IndicesSplitPostError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_split/{target}",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index),
    target = crate::apis::urlencode(target)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = copy_settings {
    local_var_req_builder = local_var_req_builder.query(&[("copy_settings", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_active_shards {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_active_shards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesSplitPostError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows you to split an existing index into a new index with more primary
/// shards.
pub async fn indices_split_put(
  configuration: &configuration::Configuration,
  index: &str,
  target: &str,
  copy_settings: Option<bool>,
  timeout: Option<&str>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  wait_for_active_shards: Option<&str>,
  body: Option<serde_json::Value>,
) -> Result<(), Error<IndicesSplitPutError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_split/{target}",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index),
    target = crate::apis::urlencode(target)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = copy_settings {
    local_var_req_builder = local_var_req_builder.query(&[("copy_settings", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_active_shards {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_active_shards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesSplitPutError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Provides statistics on operations happening in an index.
pub async fn indices_stats(
  configuration: &configuration::Configuration,
  completion_fields: Option<Vec<String>>,
  fielddata_fields: Option<Vec<String>>,
  fields: Option<Vec<String>>,
  groups: Option<Vec<String>>,
  level: Option<IndiciesStatLevel>,
  include_segment_file_sizes: Option<bool>,
  include_unloaded_segments: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  forbid_closed_indices: Option<bool>,
) -> Result<(), Error<IndicesStatsError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_stats", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = completion_fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("completion_fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "completion_fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = fielddata_fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("fielddata_fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "fielddata_fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = groups {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("groups".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "groups",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = level {
    local_var_req_builder = local_var_req_builder.query(&[("level", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = include_segment_file_sizes {
    local_var_req_builder = local_var_req_builder.query(&[("include_segment_file_sizes", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = include_unloaded_segments {
    local_var_req_builder = local_var_req_builder.query(&[("include_unloaded_segments", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = forbid_closed_indices {
    local_var_req_builder = local_var_req_builder.query(&[("forbid_closed_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesStatsError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Provides statistics on operations happening in an index.
pub async fn indices_stats_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  completion_fields: Option<Vec<String>>,
  fielddata_fields: Option<Vec<String>>,
  fields: Option<Vec<String>>,
  groups: Option<Vec<String>>,
  level: Option<IndiciesStatLevel>,
  include_segment_file_sizes: Option<bool>,
  include_unloaded_segments: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  forbid_closed_indices: Option<bool>,
) -> Result<(), Error<IndicesStatsWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_stats",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = completion_fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("completion_fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "completion_fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = fielddata_fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("fielddata_fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "fielddata_fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = groups {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("groups".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "groups",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = level {
    local_var_req_builder = local_var_req_builder.query(&[("level", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = include_segment_file_sizes {
    local_var_req_builder = local_var_req_builder.query(&[("include_segment_file_sizes", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = include_unloaded_segments {
    local_var_req_builder = local_var_req_builder.query(&[("include_unloaded_segments", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = forbid_closed_indices {
    local_var_req_builder = local_var_req_builder.query(&[("forbid_closed_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesStatsWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Provides statistics on operations happening in an index.
pub async fn indices_stats_with_index_metric(
  configuration: &configuration::Configuration,
  index: &str,
  metric: &str,
  completion_fields: Option<Vec<String>>,
  fielddata_fields: Option<Vec<String>>,
  fields: Option<Vec<String>>,
  groups: Option<Vec<String>>,
  level: Option<IndiciesStatLevel>,
  include_segment_file_sizes: Option<bool>,
  include_unloaded_segments: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  forbid_closed_indices: Option<bool>,
) -> Result<(), Error<IndicesStatsWithIndexMetricError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_stats/{metric}",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index),
    metric = crate::apis::urlencode(metric)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = completion_fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("completion_fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "completion_fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = fielddata_fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("fielddata_fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "fielddata_fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = groups {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("groups".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "groups",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = level {
    local_var_req_builder = local_var_req_builder.query(&[("level", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = include_segment_file_sizes {
    local_var_req_builder = local_var_req_builder.query(&[("include_segment_file_sizes", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = include_unloaded_segments {
    local_var_req_builder = local_var_req_builder.query(&[("include_unloaded_segments", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = forbid_closed_indices {
    local_var_req_builder = local_var_req_builder.query(&[("forbid_closed_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesStatsWithIndexMetricError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Provides statistics on operations happening in an index.
pub async fn indices_stats_with_metric(
  configuration: &configuration::Configuration,
  metric: &str,
  completion_fields: Option<Vec<String>>,
  fielddata_fields: Option<Vec<String>>,
  fields: Option<Vec<String>>,
  groups: Option<Vec<String>>,
  level: Option<IndiciesStatLevel>,
  include_segment_file_sizes: Option<bool>,
  include_unloaded_segments: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  forbid_closed_indices: Option<bool>,
) -> Result<(), Error<IndicesStatsWithMetricError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_stats/{metric}",
    local_var_configuration.base_path,
    metric = crate::apis::urlencode(metric)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = completion_fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("completion_fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "completion_fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = fielddata_fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("fielddata_fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "fielddata_fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = groups {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("groups".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "groups",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = level {
    local_var_req_builder = local_var_req_builder.query(&[("level", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = include_segment_file_sizes {
    local_var_req_builder = local_var_req_builder.query(&[("include_segment_file_sizes", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = include_unloaded_segments {
    local_var_req_builder = local_var_req_builder.query(&[("include_unloaded_segments", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = forbid_closed_indices {
    local_var_req_builder = local_var_req_builder.query(&[("forbid_closed_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesStatsWithMetricError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Updates index aliases.
pub async fn indices_update_aliases(
  configuration: &configuration::Configuration,
  indices_update_aliases_body_params: crate::models::IndicesUpdateAliasesBodyParams,
  timeout: Option<&str>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
) -> Result<crate::models::IndicesUpdateAliasesResponseContent, Error<IndicesUpdateAliasesError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_aliases", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&indices_update_aliases_body_params);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<IndicesUpdateAliasesError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// The _upgrade API is no longer useful and will be removed.
pub async fn indices_upgrade(
  configuration: &configuration::Configuration,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  ignore_unavailable: Option<bool>,
  wait_for_completion: Option<bool>,
  only_ancient_segments: Option<bool>,
) -> Result<(), Error<IndicesUpgradeError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_upgrade", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_completion {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_completion", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = only_ancient_segments {
    local_var_req_builder = local_var_req_builder.query(&[("only_ancient_segments", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesUpgradeError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// The _upgrade API is no longer useful and will be removed.
pub async fn indices_upgrade_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  ignore_unavailable: Option<bool>,
  wait_for_completion: Option<bool>,
  only_ancient_segments: Option<bool>,
) -> Result<(), Error<IndicesUpgradeWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_upgrade",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_completion {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_completion", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = only_ancient_segments {
    local_var_req_builder = local_var_req_builder.query(&[("only_ancient_segments", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesUpgradeWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows a user to validate a potentially expensive query without executing
/// it.
pub async fn indices_validate_query_get(
  configuration: &configuration::Configuration,
  explain: Option<bool>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  q: Option<&str>,
  analyzer: Option<&str>,
  analyze_wildcard: Option<bool>,
  default_operator: Option<DefaultOperator>,
  df: Option<&str>,
  lenient: Option<bool>,
  rewrite: Option<bool>,
  all_shards: Option<bool>,
) -> Result<(), Error<IndicesValidateQueryGetError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_validate/query", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = explain {
    local_var_req_builder = local_var_req_builder.query(&[("explain", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = q {
    local_var_req_builder = local_var_req_builder.query(&[("q", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = analyzer {
    local_var_req_builder = local_var_req_builder.query(&[("analyzer", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = analyze_wildcard {
    local_var_req_builder = local_var_req_builder.query(&[("analyze_wildcard", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = default_operator {
    local_var_req_builder = local_var_req_builder.query(&[("default_operator", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = df {
    local_var_req_builder = local_var_req_builder.query(&[("df", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = lenient {
    local_var_req_builder = local_var_req_builder.query(&[("lenient", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = rewrite {
    local_var_req_builder = local_var_req_builder.query(&[("rewrite", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = all_shards {
    local_var_req_builder = local_var_req_builder.query(&[("all_shards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesValidateQueryGetError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows a user to validate a potentially expensive query without executing
/// it.
pub async fn indices_validate_query_get_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  explain: Option<bool>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  q: Option<&str>,
  analyzer: Option<&str>,
  analyze_wildcard: Option<bool>,
  default_operator: Option<DefaultOperator>,
  df: Option<&str>,
  lenient: Option<bool>,
  rewrite: Option<bool>,
  all_shards: Option<bool>,
) -> Result<(), Error<IndicesValidateQueryGetWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_validate/query",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = explain {
    local_var_req_builder = local_var_req_builder.query(&[("explain", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = q {
    local_var_req_builder = local_var_req_builder.query(&[("q", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = analyzer {
    local_var_req_builder = local_var_req_builder.query(&[("analyzer", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = analyze_wildcard {
    local_var_req_builder = local_var_req_builder.query(&[("analyze_wildcard", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = default_operator {
    local_var_req_builder = local_var_req_builder.query(&[("default_operator", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = df {
    local_var_req_builder = local_var_req_builder.query(&[("df", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = lenient {
    local_var_req_builder = local_var_req_builder.query(&[("lenient", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = rewrite {
    local_var_req_builder = local_var_req_builder.query(&[("rewrite", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = all_shards {
    local_var_req_builder = local_var_req_builder.query(&[("all_shards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesValidateQueryGetWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows a user to validate a potentially expensive query without executing
/// it.
pub async fn indices_validate_query_post(
  configuration: &configuration::Configuration,
  explain: Option<bool>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  q: Option<&str>,
  analyzer: Option<&str>,
  analyze_wildcard: Option<bool>,
  default_operator: Option<DefaultOperator>,
  df: Option<&str>,
  lenient: Option<bool>,
  rewrite: Option<bool>,
  all_shards: Option<bool>,
  body: Option<serde_json::Value>,
) -> Result<(), Error<IndicesValidateQueryPostError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_validate/query", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = explain {
    local_var_req_builder = local_var_req_builder.query(&[("explain", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = q {
    local_var_req_builder = local_var_req_builder.query(&[("q", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = analyzer {
    local_var_req_builder = local_var_req_builder.query(&[("analyzer", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = analyze_wildcard {
    local_var_req_builder = local_var_req_builder.query(&[("analyze_wildcard", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = default_operator {
    local_var_req_builder = local_var_req_builder.query(&[("default_operator", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = df {
    local_var_req_builder = local_var_req_builder.query(&[("df", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = lenient {
    local_var_req_builder = local_var_req_builder.query(&[("lenient", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = rewrite {
    local_var_req_builder = local_var_req_builder.query(&[("rewrite", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = all_shards {
    local_var_req_builder = local_var_req_builder.query(&[("all_shards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesValidateQueryPostError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows a user to validate a potentially expensive query without executing
/// it.
pub async fn indices_validate_query_post_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  explain: Option<bool>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  q: Option<&str>,
  analyzer: Option<&str>,
  analyze_wildcard: Option<bool>,
  default_operator: Option<DefaultOperator>,
  df: Option<&str>,
  lenient: Option<bool>,
  rewrite: Option<bool>,
  all_shards: Option<bool>,
  body: Option<serde_json::Value>,
) -> Result<(), Error<IndicesValidateQueryPostWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_validate/query",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = explain {
    local_var_req_builder = local_var_req_builder.query(&[("explain", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = q {
    local_var_req_builder = local_var_req_builder.query(&[("q", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = analyzer {
    local_var_req_builder = local_var_req_builder.query(&[("analyzer", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = analyze_wildcard {
    local_var_req_builder = local_var_req_builder.query(&[("analyze_wildcard", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = default_operator {
    local_var_req_builder = local_var_req_builder.query(&[("default_operator", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = df {
    local_var_req_builder = local_var_req_builder.query(&[("df", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = lenient {
    local_var_req_builder = local_var_req_builder.query(&[("lenient", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = rewrite {
    local_var_req_builder = local_var_req_builder.query(&[("rewrite", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = all_shards {
    local_var_req_builder = local_var_req_builder.query(&[("all_shards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IndicesValidateQueryPostWithIndexError> =
      serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns basic information about the cluster.
pub async fn info(
  configuration: &configuration::Configuration,
) -> Result<crate::models::InfoResponseContent, Error<InfoError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<InfoError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Deletes a pipeline.
pub async fn ingest_delete_pipeline(
  configuration: &configuration::Configuration,
  id: &str,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  timeout: Option<&str>,
) -> Result<(), Error<IngestDeletePipelineError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_ingest/pipeline/{id}",
    local_var_configuration.base_path,
    id = crate::apis::urlencode(id)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IngestDeletePipelineError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns a pipeline.
pub async fn ingest_get_pipeline(
  configuration: &configuration::Configuration,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
) -> Result<(), Error<IngestGetPipelineError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_ingest/pipeline", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IngestGetPipelineError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns a pipeline.
pub async fn ingest_get_pipeline_with_id(
  configuration: &configuration::Configuration,
  id: &str,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
) -> Result<(), Error<IngestGetPipelineWithIdError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_ingest/pipeline/{id}",
    local_var_configuration.base_path,
    id = crate::apis::urlencode(id)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IngestGetPipelineWithIdError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns a list of the built-in patterns.
pub async fn ingest_processor_grok(
  configuration: &configuration::Configuration,
) -> Result<(), Error<IngestProcessorGrokError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_ingest/processor/grok", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IngestProcessorGrokError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Creates or updates a pipeline.
pub async fn ingest_put_pipeline(
  configuration: &configuration::Configuration,
  id: &str,
  body: serde_json::Value,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  timeout: Option<&str>,
) -> Result<(), Error<IngestPutPipelineError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_ingest/pipeline/{id}",
    local_var_configuration.base_path,
    id = crate::apis::urlencode(id)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IngestPutPipelineError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows to simulate a pipeline with example documents.
pub async fn ingest_simulate_get(
  configuration: &configuration::Configuration,
  verbose: Option<bool>,
) -> Result<(), Error<IngestSimulateGetError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_ingest/pipeline/_simulate", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = verbose {
    local_var_req_builder = local_var_req_builder.query(&[("verbose", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IngestSimulateGetError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows to simulate a pipeline with example documents.
pub async fn ingest_simulate_get_with_id(
  configuration: &configuration::Configuration,
  id: &str,
  verbose: Option<bool>,
) -> Result<(), Error<IngestSimulateGetWithIdError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_ingest/pipeline/{id}/_simulate",
    local_var_configuration.base_path,
    id = crate::apis::urlencode(id)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = verbose {
    local_var_req_builder = local_var_req_builder.query(&[("verbose", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IngestSimulateGetWithIdError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows to simulate a pipeline with example documents.
pub async fn ingest_simulate_post(
  configuration: &configuration::Configuration,
  body: serde_json::Value,
  verbose: Option<bool>,
) -> Result<(), Error<IngestSimulatePostError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_ingest/pipeline/_simulate", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = verbose {
    local_var_req_builder = local_var_req_builder.query(&[("verbose", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IngestSimulatePostError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows to simulate a pipeline with example documents.
pub async fn ingest_simulate_post_with_id(
  configuration: &configuration::Configuration,
  id: &str,
  body: serde_json::Value,
  verbose: Option<bool>,
) -> Result<(), Error<IngestSimulatePostWithIdError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_ingest/pipeline/{id}/_simulate",
    local_var_configuration.base_path,
    id = crate::apis::urlencode(id)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = verbose {
    local_var_req_builder = local_var_req_builder.query(&[("verbose", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<IngestSimulatePostWithIdError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows to get multiple documents in one request.
pub async fn mget_get(
  configuration: &configuration::Configuration,
  stored_fields: Option<Vec<String>>,
  preference: Option<&str>,
  realtime: Option<bool>,
  refresh: Option<bool>,
  routing: Option<&str>,
  _source: Option<Vec<String>>,
  _source_excludes: Option<Vec<String>>,
  _source_includes: Option<Vec<String>>,
) -> Result<(), Error<MgetGetError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_mget", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = stored_fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("stored_fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "stored_fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = preference {
    local_var_req_builder = local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = realtime {
    local_var_req_builder = local_var_req_builder.query(&[("realtime", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = refresh {
    local_var_req_builder = local_var_req_builder.query(&[("refresh", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = _source {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_excludes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_excludes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_excludes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_includes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_includes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_includes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<MgetGetError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows to get multiple documents in one request.
pub async fn mget_get_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  stored_fields: Option<Vec<String>>,
  preference: Option<&str>,
  realtime: Option<bool>,
  refresh: Option<bool>,
  routing: Option<&str>,
  _source: Option<Vec<String>>,
  _source_excludes: Option<Vec<String>>,
  _source_includes: Option<Vec<String>>,
) -> Result<(), Error<MgetGetWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_mget",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = stored_fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("stored_fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "stored_fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = preference {
    local_var_req_builder = local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = realtime {
    local_var_req_builder = local_var_req_builder.query(&[("realtime", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = refresh {
    local_var_req_builder = local_var_req_builder.query(&[("refresh", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = _source {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_excludes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_excludes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_excludes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_includes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_includes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_includes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<MgetGetWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows to get multiple documents in one request.
pub async fn mget_post(
  configuration: &configuration::Configuration,
  body: serde_json::Value,
  stored_fields: Option<Vec<String>>,
  preference: Option<&str>,
  realtime: Option<bool>,
  refresh: Option<bool>,
  routing: Option<&str>,
  _source: Option<Vec<String>>,
  _source_excludes: Option<Vec<String>>,
  _source_includes: Option<Vec<String>>,
) -> Result<(), Error<MgetPostError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_mget", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = stored_fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("stored_fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "stored_fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = preference {
    local_var_req_builder = local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = realtime {
    local_var_req_builder = local_var_req_builder.query(&[("realtime", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = refresh {
    local_var_req_builder = local_var_req_builder.query(&[("refresh", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = _source {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_excludes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_excludes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_excludes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_includes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_includes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_includes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<MgetPostError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows to get multiple documents in one request.
pub async fn mget_post_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  body: serde_json::Value,
  stored_fields: Option<Vec<String>>,
  preference: Option<&str>,
  realtime: Option<bool>,
  refresh: Option<bool>,
  routing: Option<&str>,
  _source: Option<Vec<String>>,
  _source_excludes: Option<Vec<String>>,
  _source_includes: Option<Vec<String>>,
) -> Result<(), Error<MgetPostWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_mget",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = stored_fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("stored_fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "stored_fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = preference {
    local_var_req_builder = local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = realtime {
    local_var_req_builder = local_var_req_builder.query(&[("realtime", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = refresh {
    local_var_req_builder = local_var_req_builder.query(&[("refresh", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = _source {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_excludes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_excludes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_excludes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_includes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_includes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_includes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<MgetPostWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows to execute several search operations in one request.
pub async fn msearch_get(
  configuration: &configuration::Configuration,
  search_type: Option<SearchTypeMulti>,
  max_concurrent_searches: Option<i32>,
  typed_keys: Option<bool>,
  pre_filter_shard_size: Option<i32>,
  max_concurrent_shard_requests: Option<i32>,
  rest_total_hits_as_int: Option<bool>,
  ccs_minimize_roundtrips: Option<bool>,
) -> Result<(), Error<MsearchGetError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_msearch", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = search_type {
    local_var_req_builder = local_var_req_builder.query(&[("search_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = max_concurrent_searches {
    local_var_req_builder = local_var_req_builder.query(&[("max_concurrent_searches", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = typed_keys {
    local_var_req_builder = local_var_req_builder.query(&[("typed_keys", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = pre_filter_shard_size {
    local_var_req_builder = local_var_req_builder.query(&[("pre_filter_shard_size", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = max_concurrent_shard_requests {
    local_var_req_builder =
      local_var_req_builder.query(&[("max_concurrent_shard_requests", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = rest_total_hits_as_int {
    local_var_req_builder = local_var_req_builder.query(&[("rest_total_hits_as_int", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ccs_minimize_roundtrips {
    local_var_req_builder = local_var_req_builder.query(&[("ccs_minimize_roundtrips", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<MsearchGetError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows to execute several search operations in one request.
pub async fn msearch_get_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  search_type: Option<SearchTypeMulti>,
  max_concurrent_searches: Option<i32>,
  typed_keys: Option<bool>,
  pre_filter_shard_size: Option<i32>,
  max_concurrent_shard_requests: Option<i32>,
  rest_total_hits_as_int: Option<bool>,
  ccs_minimize_roundtrips: Option<bool>,
) -> Result<(), Error<MsearchGetWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_msearch",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = search_type {
    local_var_req_builder = local_var_req_builder.query(&[("search_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = max_concurrent_searches {
    local_var_req_builder = local_var_req_builder.query(&[("max_concurrent_searches", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = typed_keys {
    local_var_req_builder = local_var_req_builder.query(&[("typed_keys", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = pre_filter_shard_size {
    local_var_req_builder = local_var_req_builder.query(&[("pre_filter_shard_size", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = max_concurrent_shard_requests {
    local_var_req_builder =
      local_var_req_builder.query(&[("max_concurrent_shard_requests", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = rest_total_hits_as_int {
    local_var_req_builder = local_var_req_builder.query(&[("rest_total_hits_as_int", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ccs_minimize_roundtrips {
    local_var_req_builder = local_var_req_builder.query(&[("ccs_minimize_roundtrips", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<MsearchGetWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows to execute several search operations in one request.
pub async fn msearch_post(
  configuration: &configuration::Configuration,
  body: serde_json::Value,
  search_type: Option<SearchTypeMulti>,
  max_concurrent_searches: Option<i32>,
  typed_keys: Option<bool>,
  pre_filter_shard_size: Option<i32>,
  max_concurrent_shard_requests: Option<i32>,
  rest_total_hits_as_int: Option<bool>,
  ccs_minimize_roundtrips: Option<bool>,
) -> Result<(), Error<MsearchPostError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_msearch", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = search_type {
    local_var_req_builder = local_var_req_builder.query(&[("search_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = max_concurrent_searches {
    local_var_req_builder = local_var_req_builder.query(&[("max_concurrent_searches", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = typed_keys {
    local_var_req_builder = local_var_req_builder.query(&[("typed_keys", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = pre_filter_shard_size {
    local_var_req_builder = local_var_req_builder.query(&[("pre_filter_shard_size", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = max_concurrent_shard_requests {
    local_var_req_builder =
      local_var_req_builder.query(&[("max_concurrent_shard_requests", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = rest_total_hits_as_int {
    local_var_req_builder = local_var_req_builder.query(&[("rest_total_hits_as_int", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ccs_minimize_roundtrips {
    local_var_req_builder = local_var_req_builder.query(&[("ccs_minimize_roundtrips", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<MsearchPostError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows to execute several search operations in one request.
pub async fn msearch_post_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  body: serde_json::Value,
  search_type: Option<SearchTypeMulti>,
  max_concurrent_searches: Option<i32>,
  typed_keys: Option<bool>,
  pre_filter_shard_size: Option<i32>,
  max_concurrent_shard_requests: Option<i32>,
  rest_total_hits_as_int: Option<bool>,
  ccs_minimize_roundtrips: Option<bool>,
) -> Result<(), Error<MsearchPostWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_msearch",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = search_type {
    local_var_req_builder = local_var_req_builder.query(&[("search_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = max_concurrent_searches {
    local_var_req_builder = local_var_req_builder.query(&[("max_concurrent_searches", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = typed_keys {
    local_var_req_builder = local_var_req_builder.query(&[("typed_keys", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = pre_filter_shard_size {
    local_var_req_builder = local_var_req_builder.query(&[("pre_filter_shard_size", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = max_concurrent_shard_requests {
    local_var_req_builder =
      local_var_req_builder.query(&[("max_concurrent_shard_requests", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = rest_total_hits_as_int {
    local_var_req_builder = local_var_req_builder.query(&[("rest_total_hits_as_int", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ccs_minimize_roundtrips {
    local_var_req_builder = local_var_req_builder.query(&[("ccs_minimize_roundtrips", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<MsearchPostWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows to execute several search template operations in one request.
pub async fn msearch_template_get(
  configuration: &configuration::Configuration,
  search_type: Option<SearchTypeMulti>,
  typed_keys: Option<bool>,
  max_concurrent_searches: Option<i32>,
  rest_total_hits_as_int: Option<bool>,
  ccs_minimize_roundtrips: Option<bool>,
) -> Result<(), Error<MsearchTemplateGetError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_msearch/template", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = search_type {
    local_var_req_builder = local_var_req_builder.query(&[("search_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = typed_keys {
    local_var_req_builder = local_var_req_builder.query(&[("typed_keys", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = max_concurrent_searches {
    local_var_req_builder = local_var_req_builder.query(&[("max_concurrent_searches", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = rest_total_hits_as_int {
    local_var_req_builder = local_var_req_builder.query(&[("rest_total_hits_as_int", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ccs_minimize_roundtrips {
    local_var_req_builder = local_var_req_builder.query(&[("ccs_minimize_roundtrips", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<MsearchTemplateGetError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows to execute several search template operations in one request.
pub async fn msearch_template_get_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  search_type: Option<SearchTypeMulti>,
  typed_keys: Option<bool>,
  max_concurrent_searches: Option<i32>,
  rest_total_hits_as_int: Option<bool>,
  ccs_minimize_roundtrips: Option<bool>,
) -> Result<(), Error<MsearchTemplateGetWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_msearch/template",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = search_type {
    local_var_req_builder = local_var_req_builder.query(&[("search_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = typed_keys {
    local_var_req_builder = local_var_req_builder.query(&[("typed_keys", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = max_concurrent_searches {
    local_var_req_builder = local_var_req_builder.query(&[("max_concurrent_searches", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = rest_total_hits_as_int {
    local_var_req_builder = local_var_req_builder.query(&[("rest_total_hits_as_int", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ccs_minimize_roundtrips {
    local_var_req_builder = local_var_req_builder.query(&[("ccs_minimize_roundtrips", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<MsearchTemplateGetWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows to execute several search template operations in one request.
pub async fn msearch_template_post(
  configuration: &configuration::Configuration,
  body: serde_json::Value,
  search_type: Option<SearchTypeMulti>,
  typed_keys: Option<bool>,
  max_concurrent_searches: Option<i32>,
  rest_total_hits_as_int: Option<bool>,
  ccs_minimize_roundtrips: Option<bool>,
) -> Result<(), Error<MsearchTemplatePostError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_msearch/template", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = search_type {
    local_var_req_builder = local_var_req_builder.query(&[("search_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = typed_keys {
    local_var_req_builder = local_var_req_builder.query(&[("typed_keys", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = max_concurrent_searches {
    local_var_req_builder = local_var_req_builder.query(&[("max_concurrent_searches", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = rest_total_hits_as_int {
    local_var_req_builder = local_var_req_builder.query(&[("rest_total_hits_as_int", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ccs_minimize_roundtrips {
    local_var_req_builder = local_var_req_builder.query(&[("ccs_minimize_roundtrips", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<MsearchTemplatePostError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows to execute several search template operations in one request.
pub async fn msearch_template_post_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  body: serde_json::Value,
  search_type: Option<SearchTypeMulti>,
  typed_keys: Option<bool>,
  max_concurrent_searches: Option<i32>,
  rest_total_hits_as_int: Option<bool>,
  ccs_minimize_roundtrips: Option<bool>,
) -> Result<(), Error<MsearchTemplatePostWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_msearch/template",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = search_type {
    local_var_req_builder = local_var_req_builder.query(&[("search_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = typed_keys {
    local_var_req_builder = local_var_req_builder.query(&[("typed_keys", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = max_concurrent_searches {
    local_var_req_builder = local_var_req_builder.query(&[("max_concurrent_searches", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = rest_total_hits_as_int {
    local_var_req_builder = local_var_req_builder.query(&[("rest_total_hits_as_int", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ccs_minimize_roundtrips {
    local_var_req_builder = local_var_req_builder.query(&[("ccs_minimize_roundtrips", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<MsearchTemplatePostWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns multiple termvectors in one request.
pub async fn mtermvectors_get(
  configuration: &configuration::Configuration,
  ids: Option<Vec<String>>,
  term_statistics: Option<bool>,
  field_statistics: Option<bool>,
  fields: Option<Vec<String>>,
  offsets: Option<bool>,
  positions: Option<bool>,
  payloads: Option<bool>,
  preference: Option<&str>,
  routing: Option<&str>,
  realtime: Option<bool>,
  version: Option<i32>,
  version_type: Option<VersionType>,
) -> Result<(), Error<MtermvectorsGetError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_mtermvectors", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = ids {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("ids".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "ids",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = term_statistics {
    local_var_req_builder = local_var_req_builder.query(&[("term_statistics", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = field_statistics {
    local_var_req_builder = local_var_req_builder.query(&[("field_statistics", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = offsets {
    local_var_req_builder = local_var_req_builder.query(&[("offsets", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = positions {
    local_var_req_builder = local_var_req_builder.query(&[("positions", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = payloads {
    local_var_req_builder = local_var_req_builder.query(&[("payloads", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = preference {
    local_var_req_builder = local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = realtime {
    local_var_req_builder = local_var_req_builder.query(&[("realtime", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = version {
    local_var_req_builder = local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = version_type {
    local_var_req_builder = local_var_req_builder.query(&[("version_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<MtermvectorsGetError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns multiple termvectors in one request.
pub async fn mtermvectors_get_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  ids: Option<Vec<String>>,
  term_statistics: Option<bool>,
  field_statistics: Option<bool>,
  fields: Option<Vec<String>>,
  offsets: Option<bool>,
  positions: Option<bool>,
  payloads: Option<bool>,
  preference: Option<&str>,
  routing: Option<&str>,
  realtime: Option<bool>,
  version: Option<i32>,
  version_type: Option<VersionType>,
) -> Result<(), Error<MtermvectorsGetWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_mtermvectors",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = ids {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("ids".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "ids",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = term_statistics {
    local_var_req_builder = local_var_req_builder.query(&[("term_statistics", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = field_statistics {
    local_var_req_builder = local_var_req_builder.query(&[("field_statistics", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = offsets {
    local_var_req_builder = local_var_req_builder.query(&[("offsets", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = positions {
    local_var_req_builder = local_var_req_builder.query(&[("positions", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = payloads {
    local_var_req_builder = local_var_req_builder.query(&[("payloads", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = preference {
    local_var_req_builder = local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = realtime {
    local_var_req_builder = local_var_req_builder.query(&[("realtime", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = version {
    local_var_req_builder = local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = version_type {
    local_var_req_builder = local_var_req_builder.query(&[("version_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<MtermvectorsGetWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns multiple termvectors in one request.
pub async fn mtermvectors_post(
  configuration: &configuration::Configuration,
  ids: Option<Vec<String>>,
  term_statistics: Option<bool>,
  field_statistics: Option<bool>,
  fields: Option<Vec<String>>,
  offsets: Option<bool>,
  positions: Option<bool>,
  payloads: Option<bool>,
  preference: Option<&str>,
  routing: Option<&str>,
  realtime: Option<bool>,
  version: Option<i32>,
  version_type: Option<VersionType>,
  body: Option<serde_json::Value>,
) -> Result<(), Error<MtermvectorsPostError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_mtermvectors", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = ids {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("ids".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "ids",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = term_statistics {
    local_var_req_builder = local_var_req_builder.query(&[("term_statistics", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = field_statistics {
    local_var_req_builder = local_var_req_builder.query(&[("field_statistics", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = offsets {
    local_var_req_builder = local_var_req_builder.query(&[("offsets", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = positions {
    local_var_req_builder = local_var_req_builder.query(&[("positions", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = payloads {
    local_var_req_builder = local_var_req_builder.query(&[("payloads", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = preference {
    local_var_req_builder = local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = realtime {
    local_var_req_builder = local_var_req_builder.query(&[("realtime", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = version {
    local_var_req_builder = local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = version_type {
    local_var_req_builder = local_var_req_builder.query(&[("version_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<MtermvectorsPostError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns multiple termvectors in one request.
pub async fn mtermvectors_post_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  ids: Option<Vec<String>>,
  term_statistics: Option<bool>,
  field_statistics: Option<bool>,
  fields: Option<Vec<String>>,
  offsets: Option<bool>,
  positions: Option<bool>,
  payloads: Option<bool>,
  preference: Option<&str>,
  routing: Option<&str>,
  realtime: Option<bool>,
  version: Option<i32>,
  version_type: Option<VersionType>,
  body: Option<serde_json::Value>,
) -> Result<(), Error<MtermvectorsPostWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_mtermvectors",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = ids {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("ids".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "ids",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = term_statistics {
    local_var_req_builder = local_var_req_builder.query(&[("term_statistics", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = field_statistics {
    local_var_req_builder = local_var_req_builder.query(&[("field_statistics", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = offsets {
    local_var_req_builder = local_var_req_builder.query(&[("offsets", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = positions {
    local_var_req_builder = local_var_req_builder.query(&[("positions", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = payloads {
    local_var_req_builder = local_var_req_builder.query(&[("payloads", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = preference {
    local_var_req_builder = local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = realtime {
    local_var_req_builder = local_var_req_builder.query(&[("realtime", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = version {
    local_var_req_builder = local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = version_type {
    local_var_req_builder = local_var_req_builder.query(&[("version_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<MtermvectorsPostWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about hot threads on each node in the cluster.
pub async fn nodes_hot_threads(
  configuration: &configuration::Configuration,
  interval: Option<&str>,
  snapshots: Option<i32>,
  threads: Option<i32>,
  ignore_idle_threads: Option<bool>,
  r#type: Option<SampleType>,
  timeout: Option<&str>,
) -> Result<(), Error<NodesHotThreadsError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_nodes/hot_threads", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = interval {
    local_var_req_builder = local_var_req_builder.query(&[("interval", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = snapshots {
    local_var_req_builder = local_var_req_builder.query(&[("snapshots", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = threads {
    local_var_req_builder = local_var_req_builder.query(&[("threads", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_idle_threads {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_idle_threads", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = r#type {
    local_var_req_builder = local_var_req_builder.query(&[("type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<NodesHotThreadsError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about hot threads on each node in the cluster.
pub async fn nodes_hot_threads_deprecated(
  configuration: &configuration::Configuration,
  interval: Option<&str>,
  snapshots: Option<i32>,
  threads: Option<i32>,
  ignore_idle_threads: Option<bool>,
  r#type: Option<SampleType>,
  timeout: Option<&str>,
) -> Result<(), Error<NodesHotThreadsDeprecatedError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_nodes/hotthreads", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = interval {
    local_var_req_builder = local_var_req_builder.query(&[("interval", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = snapshots {
    local_var_req_builder = local_var_req_builder.query(&[("snapshots", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = threads {
    local_var_req_builder = local_var_req_builder.query(&[("threads", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_idle_threads {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_idle_threads", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = r#type {
    local_var_req_builder = local_var_req_builder.query(&[("type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<NodesHotThreadsDeprecatedError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about hot threads on each node in the cluster.
pub async fn nodes_hot_threads_deprecated_cluster(
  configuration: &configuration::Configuration,
  interval: Option<&str>,
  snapshots: Option<i32>,
  threads: Option<i32>,
  ignore_idle_threads: Option<bool>,
  r#type: Option<SampleType>,
  timeout: Option<&str>,
) -> Result<(), Error<NodesHotThreadsDeprecatedClusterError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_cluster/nodes/hotthreads", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = interval {
    local_var_req_builder = local_var_req_builder.query(&[("interval", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = snapshots {
    local_var_req_builder = local_var_req_builder.query(&[("snapshots", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = threads {
    local_var_req_builder = local_var_req_builder.query(&[("threads", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_idle_threads {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_idle_threads", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = r#type {
    local_var_req_builder = local_var_req_builder.query(&[("type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<NodesHotThreadsDeprecatedClusterError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about hot threads on each node in the cluster.
pub async fn nodes_hot_threads_deprecated_dash(
  configuration: &configuration::Configuration,
  interval: Option<&str>,
  snapshots: Option<i32>,
  threads: Option<i32>,
  ignore_idle_threads: Option<bool>,
  r#type: Option<SampleType>,
  timeout: Option<&str>,
) -> Result<(), Error<NodesHotThreadsDeprecatedDashError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_cluster/nodes/hot_threads", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = interval {
    local_var_req_builder = local_var_req_builder.query(&[("interval", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = snapshots {
    local_var_req_builder = local_var_req_builder.query(&[("snapshots", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = threads {
    local_var_req_builder = local_var_req_builder.query(&[("threads", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_idle_threads {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_idle_threads", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = r#type {
    local_var_req_builder = local_var_req_builder.query(&[("type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<NodesHotThreadsDeprecatedDashError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about hot threads on each node in the cluster.
pub async fn nodes_hot_threads_with_node_id(
  configuration: &configuration::Configuration,
  node_id: &str,
  interval: Option<&str>,
  snapshots: Option<i32>,
  threads: Option<i32>,
  ignore_idle_threads: Option<bool>,
  r#type: Option<SampleType>,
  timeout: Option<&str>,
) -> Result<(), Error<NodesHotThreadsWithNodeIdError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_nodes/{node_id}/hot_threads",
    local_var_configuration.base_path,
    node_id = crate::apis::urlencode(node_id)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = interval {
    local_var_req_builder = local_var_req_builder.query(&[("interval", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = snapshots {
    local_var_req_builder = local_var_req_builder.query(&[("snapshots", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = threads {
    local_var_req_builder = local_var_req_builder.query(&[("threads", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_idle_threads {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_idle_threads", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = r#type {
    local_var_req_builder = local_var_req_builder.query(&[("type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<NodesHotThreadsWithNodeIdError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about hot threads on each node in the cluster.
pub async fn nodes_hot_threads_with_node_id_deprecated(
  configuration: &configuration::Configuration,
  node_id: &str,
  interval: Option<&str>,
  snapshots: Option<i32>,
  threads: Option<i32>,
  ignore_idle_threads: Option<bool>,
  r#type: Option<SampleType>,
  timeout: Option<&str>,
) -> Result<(), Error<NodesHotThreadsWithNodeIdDeprecatedError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_nodes/{node_id}/hotthreads",
    local_var_configuration.base_path,
    node_id = crate::apis::urlencode(node_id)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = interval {
    local_var_req_builder = local_var_req_builder.query(&[("interval", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = snapshots {
    local_var_req_builder = local_var_req_builder.query(&[("snapshots", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = threads {
    local_var_req_builder = local_var_req_builder.query(&[("threads", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_idle_threads {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_idle_threads", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = r#type {
    local_var_req_builder = local_var_req_builder.query(&[("type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<NodesHotThreadsWithNodeIdDeprecatedError> =
      serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about hot threads on each node in the cluster.
pub async fn nodes_hot_threads_with_node_id_deprecated_cluster(
  configuration: &configuration::Configuration,
  node_id: &str,
  interval: Option<&str>,
  snapshots: Option<i32>,
  threads: Option<i32>,
  ignore_idle_threads: Option<bool>,
  r#type: Option<SampleType>,
  timeout: Option<&str>,
) -> Result<(), Error<NodesHotThreadsWithNodeIdDeprecatedClusterError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_cluster/nodes/{node_id}/hotthreads",
    local_var_configuration.base_path,
    node_id = crate::apis::urlencode(node_id)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = interval {
    local_var_req_builder = local_var_req_builder.query(&[("interval", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = snapshots {
    local_var_req_builder = local_var_req_builder.query(&[("snapshots", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = threads {
    local_var_req_builder = local_var_req_builder.query(&[("threads", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_idle_threads {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_idle_threads", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = r#type {
    local_var_req_builder = local_var_req_builder.query(&[("type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<NodesHotThreadsWithNodeIdDeprecatedClusterError> =
      serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about hot threads on each node in the cluster.
pub async fn nodes_hot_threads_with_node_id_deprecated_dash(
  configuration: &configuration::Configuration,
  node_id: &str,
  interval: Option<&str>,
  snapshots: Option<i32>,
  threads: Option<i32>,
  ignore_idle_threads: Option<bool>,
  r#type: Option<SampleType>,
  timeout: Option<&str>,
) -> Result<(), Error<NodesHotThreadsWithNodeIdDeprecatedDashError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_cluster/nodes/{node_id}/hot_threads",
    local_var_configuration.base_path,
    node_id = crate::apis::urlencode(node_id)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = interval {
    local_var_req_builder = local_var_req_builder.query(&[("interval", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = snapshots {
    local_var_req_builder = local_var_req_builder.query(&[("snapshots", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = threads {
    local_var_req_builder = local_var_req_builder.query(&[("threads", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_idle_threads {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_idle_threads", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = r#type {
    local_var_req_builder = local_var_req_builder.query(&[("type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<NodesHotThreadsWithNodeIdDeprecatedDashError> =
      serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about nodes in the cluster.
pub async fn nodes_info(
  configuration: &configuration::Configuration,
  flat_settings: Option<bool>,
  timeout: Option<&str>,
) -> Result<(), Error<NodesInfoError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_nodes", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = flat_settings {
    local_var_req_builder = local_var_req_builder.query(&[("flat_settings", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<NodesInfoError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about nodes in the cluster.
pub async fn nodes_info_with_metric_node_id(
  configuration: &configuration::Configuration,
  node_id: &str,
  metric: &str,
  flat_settings: Option<bool>,
  timeout: Option<&str>,
) -> Result<(), Error<NodesInfoWithMetricNodeIdError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_nodes/{node_id}/{metric}",
    local_var_configuration.base_path,
    node_id = crate::apis::urlencode(node_id),
    metric = crate::apis::urlencode(metric)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = flat_settings {
    local_var_req_builder = local_var_req_builder.query(&[("flat_settings", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<NodesInfoWithMetricNodeIdError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about nodes in the cluster.
pub async fn nodes_info_with_node_id(
  configuration: &configuration::Configuration,
  node_id: &str,
  flat_settings: Option<bool>,
  timeout: Option<&str>,
) -> Result<(), Error<NodesInfoWithNodeIdError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_nodes/{node_id}",
    local_var_configuration.base_path,
    node_id = crate::apis::urlencode(node_id)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = flat_settings {
    local_var_req_builder = local_var_req_builder.query(&[("flat_settings", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<NodesInfoWithNodeIdError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Reloads secure settings.
pub async fn nodes_reload_secure_settings(
  configuration: &configuration::Configuration,
  timeout: Option<&str>,
  body: Option<serde_json::Value>,
) -> Result<(), Error<NodesReloadSecureSettingsError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_nodes/reload_secure_settings", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<NodesReloadSecureSettingsError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Reloads secure settings.
pub async fn nodes_reload_secure_settings_with_node_id(
  configuration: &configuration::Configuration,
  node_id: &str,
  timeout: Option<&str>,
  body: Option<serde_json::Value>,
) -> Result<(), Error<NodesReloadSecureSettingsWithNodeIdError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_nodes/{node_id}/reload_secure_settings",
    local_var_configuration.base_path,
    node_id = crate::apis::urlencode(node_id)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<NodesReloadSecureSettingsWithNodeIdError> =
      serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns statistical information about nodes in the cluster.
pub async fn nodes_stats(
  configuration: &configuration::Configuration,
  completion_fields: Option<Vec<String>>,
  fielddata_fields: Option<Vec<String>>,
  fields: Option<Vec<String>>,
  groups: Option<Vec<String>>,
  level: Option<NodesStatLevel>,
  types: Option<Vec<String>>,
  timeout: Option<&str>,
  include_segment_file_sizes: Option<bool>,
) -> Result<(), Error<NodesStatsError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_nodes/stats", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = completion_fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("completion_fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "completion_fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = fielddata_fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("fielddata_fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "fielddata_fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = groups {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("groups".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "groups",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = level {
    local_var_req_builder = local_var_req_builder.query(&[("level", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = types {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("types".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "types",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = include_segment_file_sizes {
    local_var_req_builder = local_var_req_builder.query(&[("include_segment_file_sizes", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<NodesStatsError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns statistical information about nodes in the cluster.
pub async fn nodes_stats_with_index_metric_metric(
  configuration: &configuration::Configuration,
  metric: &str,
  index_metric: &str,
  completion_fields: Option<Vec<String>>,
  fielddata_fields: Option<Vec<String>>,
  fields: Option<Vec<String>>,
  groups: Option<Vec<String>>,
  level: Option<NodesStatLevel>,
  types: Option<Vec<String>>,
  timeout: Option<&str>,
  include_segment_file_sizes: Option<bool>,
) -> Result<(), Error<NodesStatsWithIndexMetricMetricError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_nodes/stats/{metric}/{index_metric}",
    local_var_configuration.base_path,
    metric = crate::apis::urlencode(metric),
    index_metric = crate::apis::urlencode(index_metric)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = completion_fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("completion_fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "completion_fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = fielddata_fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("fielddata_fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "fielddata_fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = groups {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("groups".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "groups",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = level {
    local_var_req_builder = local_var_req_builder.query(&[("level", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = types {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("types".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "types",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = include_segment_file_sizes {
    local_var_req_builder = local_var_req_builder.query(&[("include_segment_file_sizes", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<NodesStatsWithIndexMetricMetricError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns statistical information about nodes in the cluster.
pub async fn nodes_stats_with_index_metric_metric_node_id(
  configuration: &configuration::Configuration,
  metric: &str,
  index_metric: &str,
  node_id: &str,
  completion_fields: Option<Vec<String>>,
  fielddata_fields: Option<Vec<String>>,
  fields: Option<Vec<String>>,
  groups: Option<Vec<String>>,
  level: Option<NodesStatLevel>,
  types: Option<Vec<String>>,
  timeout: Option<&str>,
  include_segment_file_sizes: Option<bool>,
) -> Result<(), Error<NodesStatsWithIndexMetricMetricNodeIdError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_nodes/{node_id}/stats/{metric}/{index_metric}",
    local_var_configuration.base_path,
    metric = crate::apis::urlencode(metric),
    index_metric = crate::apis::urlencode(index_metric),
    node_id = crate::apis::urlencode(node_id)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = completion_fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("completion_fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "completion_fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = fielddata_fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("fielddata_fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "fielddata_fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = groups {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("groups".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "groups",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = level {
    local_var_req_builder = local_var_req_builder.query(&[("level", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = types {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("types".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "types",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = include_segment_file_sizes {
    local_var_req_builder = local_var_req_builder.query(&[("include_segment_file_sizes", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<NodesStatsWithIndexMetricMetricNodeIdError> =
      serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns statistical information about nodes in the cluster.
pub async fn nodes_stats_with_metric(
  configuration: &configuration::Configuration,
  metric: &str,
  completion_fields: Option<Vec<String>>,
  fielddata_fields: Option<Vec<String>>,
  fields: Option<Vec<String>>,
  groups: Option<Vec<String>>,
  level: Option<NodesStatLevel>,
  types: Option<Vec<String>>,
  timeout: Option<&str>,
  include_segment_file_sizes: Option<bool>,
) -> Result<(), Error<NodesStatsWithMetricError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_nodes/stats/{metric}",
    local_var_configuration.base_path,
    metric = crate::apis::urlencode(metric)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = completion_fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("completion_fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "completion_fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = fielddata_fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("fielddata_fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "fielddata_fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = groups {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("groups".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "groups",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = level {
    local_var_req_builder = local_var_req_builder.query(&[("level", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = types {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("types".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "types",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = include_segment_file_sizes {
    local_var_req_builder = local_var_req_builder.query(&[("include_segment_file_sizes", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<NodesStatsWithMetricError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns statistical information about nodes in the cluster.
pub async fn nodes_stats_with_metric_node_id(
  configuration: &configuration::Configuration,
  metric: &str,
  node_id: &str,
  completion_fields: Option<Vec<String>>,
  fielddata_fields: Option<Vec<String>>,
  fields: Option<Vec<String>>,
  groups: Option<Vec<String>>,
  level: Option<NodesStatLevel>,
  types: Option<Vec<String>>,
  timeout: Option<&str>,
  include_segment_file_sizes: Option<bool>,
) -> Result<(), Error<NodesStatsWithMetricNodeIdError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_nodes/{node_id}/stats/{metric}",
    local_var_configuration.base_path,
    metric = crate::apis::urlencode(metric),
    node_id = crate::apis::urlencode(node_id)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = completion_fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("completion_fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "completion_fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = fielddata_fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("fielddata_fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "fielddata_fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = groups {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("groups".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "groups",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = level {
    local_var_req_builder = local_var_req_builder.query(&[("level", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = types {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("types".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "types",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = include_segment_file_sizes {
    local_var_req_builder = local_var_req_builder.query(&[("include_segment_file_sizes", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<NodesStatsWithMetricNodeIdError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns statistical information about nodes in the cluster.
pub async fn nodes_stats_with_node_id(
  configuration: &configuration::Configuration,
  node_id: &str,
  completion_fields: Option<Vec<String>>,
  fielddata_fields: Option<Vec<String>>,
  fields: Option<Vec<String>>,
  groups: Option<Vec<String>>,
  level: Option<NodesStatLevel>,
  types: Option<Vec<String>>,
  timeout: Option<&str>,
  include_segment_file_sizes: Option<bool>,
) -> Result<(), Error<NodesStatsWithNodeIdError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_nodes/{node_id}/stats",
    local_var_configuration.base_path,
    node_id = crate::apis::urlencode(node_id)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = completion_fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("completion_fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "completion_fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = fielddata_fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("fielddata_fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "fielddata_fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = groups {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("groups".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "groups",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = level {
    local_var_req_builder = local_var_req_builder.query(&[("level", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = types {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("types".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "types",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = include_segment_file_sizes {
    local_var_req_builder = local_var_req_builder.query(&[("include_segment_file_sizes", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<NodesStatsWithNodeIdError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns low-level information about REST actions usage on nodes.
pub async fn nodes_usage(
  configuration: &configuration::Configuration,
  timeout: Option<&str>,
) -> Result<(), Error<NodesUsageError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_nodes/usage", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<NodesUsageError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns low-level information about REST actions usage on nodes.
pub async fn nodes_usage_with_metric(
  configuration: &configuration::Configuration,
  metric: &str,
  timeout: Option<&str>,
) -> Result<(), Error<NodesUsageWithMetricError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_nodes/usage/{metric}",
    local_var_configuration.base_path,
    metric = crate::apis::urlencode(metric)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<NodesUsageWithMetricError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns low-level information about REST actions usage on nodes.
pub async fn nodes_usage_with_metric_node_id(
  configuration: &configuration::Configuration,
  metric: &str,
  node_id: &str,
  timeout: Option<&str>,
) -> Result<(), Error<NodesUsageWithMetricNodeIdError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_nodes/{node_id}/usage/{metric}",
    local_var_configuration.base_path,
    metric = crate::apis::urlencode(metric),
    node_id = crate::apis::urlencode(node_id)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<NodesUsageWithMetricNodeIdError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns low-level information about REST actions usage on nodes.
pub async fn nodes_usage_with_node_id(
  configuration: &configuration::Configuration,
  node_id: &str,
  timeout: Option<&str>,
) -> Result<(), Error<NodesUsageWithNodeIdError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_nodes/{node_id}/usage",
    local_var_configuration.base_path,
    node_id = crate::apis::urlencode(node_id)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<NodesUsageWithNodeIdError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Updates individual attributes of an action group.
pub async fn patch_action_group(
  configuration: &configuration::Configuration,
  action_group: &str,
  patch_operation: Vec<crate::models::PatchOperation>,
) -> Result<crate::models::PatchActionGroupResponseContent, Error<PatchActionGroupError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_plugins/_security/api/actiongroups/{action_group}",
    local_var_configuration.base_path,
    action_group = crate::apis::urlencode(action_group)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&patch_operation);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<PatchActionGroupError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Creates, updates, or deletes multiple action groups in a single call.
pub async fn patch_action_groups(
  configuration: &configuration::Configuration,
  patch_operation: Vec<crate::models::PatchOperation>,
) -> Result<crate::models::PatchActionGroupsResponseContent, Error<PatchActionGroupsError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_plugins/_security/api/actiongroups",
    local_var_configuration.base_path
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&patch_operation);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<PatchActionGroupsError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// A PATCH call is used to update specified fields in the audit configuration.
pub async fn patch_audit_configuration(
  configuration: &configuration::Configuration,
  patch_operation: Vec<crate::models::PatchOperation>,
) -> Result<(), Error<PatchAuditConfigurationError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_plugins/_security/api/audit", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&patch_operation);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<PatchAuditConfigurationError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// A PATCH call is used to update the existing configuration using the REST
/// API.
pub async fn patch_configuration(
  configuration: &configuration::Configuration,
  patch_operation: Vec<crate::models::PatchOperation>,
) -> Result<crate::models::PatchConfigurationResponseContent, Error<PatchConfigurationError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_plugins/_security/api/securityconfig",
    local_var_configuration.base_path
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&patch_operation);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<PatchConfigurationError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Bulk update of distinguished names.
pub async fn patch_distinguished_names(
  configuration: &configuration::Configuration,
  patch_operation: Vec<crate::models::PatchOperation>,
) -> Result<crate::models::PatchDistinguishedNamesResponseContent, Error<PatchDistinguishedNamesError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_plugins/_security/api/nodesdn", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&patch_operation);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<PatchDistinguishedNamesError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Updates individual attributes of a role.
pub async fn patch_role(
  configuration: &configuration::Configuration,
  role: &str,
  patch_operation: Vec<crate::models::PatchOperation>,
) -> Result<crate::models::PatchRoleResponseContent, Error<PatchRoleError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_plugins/_security/api/roles/{role}",
    local_var_configuration.base_path,
    role = crate::apis::urlencode(role)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&patch_operation);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<PatchRoleError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Updates individual attributes of a role mapping.
pub async fn patch_role_mapping(
  configuration: &configuration::Configuration,
  role: &str,
  patch_operation: Vec<crate::models::PatchOperation>,
) -> Result<crate::models::PatchRoleMappingResponseContent, Error<PatchRoleMappingError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_plugins/_security/api/rolesmapping/{role}",
    local_var_configuration.base_path,
    role = crate::apis::urlencode(role)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&patch_operation);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<PatchRoleMappingError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Creates or updates multiple role mappings in a single call.
pub async fn patch_role_mappings(
  configuration: &configuration::Configuration,
  patch_operation: Vec<crate::models::PatchOperation>,
) -> Result<crate::models::PatchRoleMappingsResponseContent, Error<PatchRoleMappingsError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_plugins/_security/api/rolesmapping",
    local_var_configuration.base_path
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&patch_operation);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<PatchRoleMappingsError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Creates, updates, or deletes multiple roles in a single call.
pub async fn patch_roles(
  configuration: &configuration::Configuration,
  patch_operation: Vec<crate::models::PatchOperation>,
) -> Result<crate::models::PatchRolesResponseContent, Error<PatchRolesError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_plugins/_security/api/roles", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&patch_operation);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<PatchRolesError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Add, delete, or modify a single tenant.
pub async fn patch_tenant(
  configuration: &configuration::Configuration,
  tenant: &str,
  patch_operation: Vec<crate::models::PatchOperation>,
) -> Result<crate::models::PatchTenantResponseContent, Error<PatchTenantError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_plugins/_security/api/tenants/{tenant}",
    local_var_configuration.base_path,
    tenant = crate::apis::urlencode(tenant)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&patch_operation);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<PatchTenantError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Add, delete, or modify multiple tenants in a single call.
pub async fn patch_tenants(
  configuration: &configuration::Configuration,
  patch_operation: Vec<crate::models::PatchOperation>,
) -> Result<crate::models::PatchTenantsResponseContent, Error<PatchTenantsError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_plugins/_security/api/tenants/", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&patch_operation);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<PatchTenantsError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Updates individual attributes of an internal user.
pub async fn patch_user(
  configuration: &configuration::Configuration,
  username: &str,
  patch_operation: Vec<crate::models::PatchOperation>,
) -> Result<crate::models::PatchUserResponseContent, Error<PatchUserError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_plugins/_security/api/internalusers/{username}",
    local_var_configuration.base_path,
    username = crate::apis::urlencode(username)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&patch_operation);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<PatchUserError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Creates, updates, or deletes multiple internal users in a single call.
pub async fn patch_users(
  configuration: &configuration::Configuration,
  patch_operation: Vec<crate::models::PatchOperation>,
) -> Result<crate::models::PatchUsersResponseContent, Error<PatchUsersError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_plugins/_security/api/internalusers",
    local_var_configuration.base_path
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&patch_operation);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<PatchUsersError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns whether the cluster is running.
pub async fn ping(configuration: &configuration::Configuration) -> Result<(), Error<PingError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::HEAD, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<PingError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Creates or updates a script.
pub async fn put_script_post(
  configuration: &configuration::Configuration,
  id: &str,
  body: serde_json::Value,
  timeout: Option<&str>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
) -> Result<(), Error<PutScriptPostError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_scripts/{id}",
    local_var_configuration.base_path,
    id = crate::apis::urlencode(id)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<PutScriptPostError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Creates or updates a script.
pub async fn put_script_post_with_context(
  configuration: &configuration::Configuration,
  id: &str,
  context: &str,
  body: serde_json::Value,
  timeout: Option<&str>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
) -> Result<(), Error<PutScriptPostWithContextError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_scripts/{id}/{context}",
    local_var_configuration.base_path,
    id = crate::apis::urlencode(id),
    context = crate::apis::urlencode(context)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<PutScriptPostWithContextError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Creates or updates a script.
pub async fn put_script_put(
  configuration: &configuration::Configuration,
  id: &str,
  body: serde_json::Value,
  timeout: Option<&str>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
) -> Result<(), Error<PutScriptPutError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_scripts/{id}",
    local_var_configuration.base_path,
    id = crate::apis::urlencode(id)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<PutScriptPutError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Creates or updates a script.
pub async fn put_script_put_with_context(
  configuration: &configuration::Configuration,
  id: &str,
  context: &str,
  body: serde_json::Value,
  timeout: Option<&str>,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
) -> Result<(), Error<PutScriptPutWithContextError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_scripts/{id}/{context}",
    local_var_configuration.base_path,
    id = crate::apis::urlencode(id),
    context = crate::apis::urlencode(context)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<PutScriptPutWithContextError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows to evaluate the quality of ranked search results over a set of
/// typical search queries.
pub async fn rank_eval_get(
  configuration: &configuration::Configuration,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  search_type: Option<SearchType>,
) -> Result<(), Error<RankEvalGetError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_rank_eval", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = search_type {
    local_var_req_builder = local_var_req_builder.query(&[("search_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<RankEvalGetError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows to evaluate the quality of ranked search results over a set of
/// typical search queries.
pub async fn rank_eval_get_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  search_type: Option<SearchType>,
) -> Result<(), Error<RankEvalGetWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_rank_eval",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = search_type {
    local_var_req_builder = local_var_req_builder.query(&[("search_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<RankEvalGetWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows to evaluate the quality of ranked search results over a set of
/// typical search queries.
pub async fn rank_eval_post(
  configuration: &configuration::Configuration,
  body: serde_json::Value,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  search_type: Option<SearchType>,
) -> Result<(), Error<RankEvalPostError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_rank_eval", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = search_type {
    local_var_req_builder = local_var_req_builder.query(&[("search_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<RankEvalPostError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows to evaluate the quality of ranked search results over a set of
/// typical search queries.
pub async fn rank_eval_post_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  body: serde_json::Value,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  search_type: Option<SearchType>,
) -> Result<(), Error<RankEvalPostWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_rank_eval",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = search_type {
    local_var_req_builder = local_var_req_builder.query(&[("search_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<RankEvalPostWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows to copy documents from one index to another, optionally filtering the
/// source documents by a query, changing the destination index settings, or
/// fetching the documents from a remote cluster.
pub async fn reindex(
  configuration: &configuration::Configuration,
  body: serde_json::Value,
  refresh: Option<bool>,
  timeout: Option<&str>,
  wait_for_active_shards: Option<&str>,
  wait_for_completion: Option<bool>,
  requests_per_second: Option<i32>,
  scroll: Option<&str>,
  slices: Option<&str>,
  max_docs: Option<i32>,
) -> Result<(), Error<ReindexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_reindex", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = refresh {
    local_var_req_builder = local_var_req_builder.query(&[("refresh", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_active_shards {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_active_shards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_completion {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_completion", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = requests_per_second {
    local_var_req_builder = local_var_req_builder.query(&[("requests_per_second", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = scroll {
    local_var_req_builder = local_var_req_builder.query(&[("scroll", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = slices {
    local_var_req_builder = local_var_req_builder.query(&[("slices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = max_docs {
    local_var_req_builder = local_var_req_builder.query(&[("max_docs", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ReindexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Changes the number of requests per second for a particular Reindex
/// operation.
pub async fn reindex_rethrottle(
  configuration: &configuration::Configuration,
  task_id: &str,
  requests_per_second: i32,
) -> Result<(), Error<ReindexRethrottleError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_reindex/{task_id}/_rethrottle",
    local_var_configuration.base_path,
    task_id = crate::apis::urlencode(task_id)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  local_var_req_builder = local_var_req_builder.query(&[("requests_per_second", &requests_per_second.to_string())]);
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ReindexRethrottleError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Reload HTTP layer communication certificates.
pub async fn reload_http_certificates(
  configuration: &configuration::Configuration,
) -> Result<crate::models::ReloadHttpCertificatesResponseContent, Error<ReloadHttpCertificatesError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_plugins/_security/api/ssl/http/reloadcerts",
    local_var_configuration.base_path
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<ReloadHttpCertificatesError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Reload transport layer communication certificates.
pub async fn reload_transport_certificates(
  configuration: &configuration::Configuration,
) -> Result<crate::models::ReloadTransportCertificatesResponseContent, Error<ReloadTransportCertificatesError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_plugins/_security/api/ssl/transport/reloadcerts",
    local_var_configuration.base_path
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<ReloadTransportCertificatesError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Restores from remote store.
pub async fn remote_store_restore(
  configuration: &configuration::Configuration,
  remote_store_restore_body_params: crate::models::RemoteStoreRestoreBodyParams,
  cluster_manager_timeout: Option<&str>,
  wait_for_completion: Option<bool>,
) -> Result<crate::models::RemoteStoreRestoreResponseContent, Error<RemoteStoreRestoreError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_remotestore/_restore", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_completion {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_completion", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&remote_store_restore_body_params);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<RemoteStoreRestoreError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows to use the Mustache language to pre-render a search definition.
pub async fn render_search_template_get(
  configuration: &configuration::Configuration,
) -> Result<(), Error<RenderSearchTemplateGetError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_render/template", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<RenderSearchTemplateGetError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows to use the Mustache language to pre-render a search definition.
pub async fn render_search_template_get_with_id(
  configuration: &configuration::Configuration,
  id: &str,
) -> Result<(), Error<RenderSearchTemplateGetWithIdError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_render/template/{id}",
    local_var_configuration.base_path,
    id = crate::apis::urlencode(id)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<RenderSearchTemplateGetWithIdError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows to use the Mustache language to pre-render a search definition.
pub async fn render_search_template_post(
  configuration: &configuration::Configuration,
  body: Option<serde_json::Value>,
) -> Result<(), Error<RenderSearchTemplatePostError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_render/template", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<RenderSearchTemplatePostError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows to use the Mustache language to pre-render a search definition.
pub async fn render_search_template_post_with_id(
  configuration: &configuration::Configuration,
  id: &str,
  body: Option<serde_json::Value>,
) -> Result<(), Error<RenderSearchTemplatePostWithIdError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_render/template/{id}",
    local_var_configuration.base_path,
    id = crate::apis::urlencode(id)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<RenderSearchTemplatePostWithIdError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows an arbitrary script to be executed and a result to be returned.
pub async fn scripts_painless_execute_get(
  configuration: &configuration::Configuration,
) -> Result<(), Error<ScriptsPainlessExecuteGetError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_scripts/painless/_execute", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ScriptsPainlessExecuteGetError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows an arbitrary script to be executed and a result to be returned.
pub async fn scripts_painless_execute_post(
  configuration: &configuration::Configuration,
  body: Option<serde_json::Value>,
) -> Result<(), Error<ScriptsPainlessExecutePostError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_scripts/painless/_execute", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ScriptsPainlessExecutePostError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows to retrieve a large numbers of results from a single search request.
pub async fn scroll_get(
  configuration: &configuration::Configuration,
  scroll: Option<&str>,
  scroll_id: Option<&str>,
  rest_total_hits_as_int: Option<bool>,
) -> Result<(), Error<ScrollGetError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_search/scroll", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = scroll {
    local_var_req_builder = local_var_req_builder.query(&[("scroll", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = scroll_id {
    local_var_req_builder = local_var_req_builder.query(&[("scroll_id", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = rest_total_hits_as_int {
    local_var_req_builder = local_var_req_builder.query(&[("rest_total_hits_as_int", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ScrollGetError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows to retrieve a large numbers of results from a single search request.
pub async fn scroll_get_with_scroll_id(
  configuration: &configuration::Configuration,
  scroll_id: &str,
  scroll: Option<&str>,
  scroll_id2: Option<&str>,
  rest_total_hits_as_int: Option<bool>,
) -> Result<(), Error<ScrollGetWithScrollIdError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_search/scroll/{scroll_id}",
    local_var_configuration.base_path,
    scroll_id = crate::apis::urlencode(scroll_id)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = scroll {
    local_var_req_builder = local_var_req_builder.query(&[("scroll", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = scroll_id2 {
    local_var_req_builder = local_var_req_builder.query(&[("scroll_id", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = rest_total_hits_as_int {
    local_var_req_builder = local_var_req_builder.query(&[("rest_total_hits_as_int", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ScrollGetWithScrollIdError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows to retrieve a large numbers of results from a single search request.
pub async fn scroll_post(
  configuration: &configuration::Configuration,
  scroll: Option<&str>,
  scroll_id: Option<&str>,
  rest_total_hits_as_int: Option<bool>,
  body: Option<serde_json::Value>,
) -> Result<(), Error<ScrollPostError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_search/scroll", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = scroll {
    local_var_req_builder = local_var_req_builder.query(&[("scroll", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = scroll_id {
    local_var_req_builder = local_var_req_builder.query(&[("scroll_id", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = rest_total_hits_as_int {
    local_var_req_builder = local_var_req_builder.query(&[("rest_total_hits_as_int", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ScrollPostError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows to retrieve a large numbers of results from a single search request.
pub async fn scroll_post_with_scroll_id(
  configuration: &configuration::Configuration,
  scroll_id: &str,
  scroll: Option<&str>,
  scroll_id2: Option<&str>,
  rest_total_hits_as_int: Option<bool>,
  body: Option<serde_json::Value>,
) -> Result<(), Error<ScrollPostWithScrollIdError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_search/scroll/{scroll_id}",
    local_var_configuration.base_path,
    scroll_id = crate::apis::urlencode(scroll_id)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = scroll {
    local_var_req_builder = local_var_req_builder.query(&[("scroll", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = scroll_id2 {
    local_var_req_builder = local_var_req_builder.query(&[("scroll_id", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = rest_total_hits_as_int {
    local_var_req_builder = local_var_req_builder.query(&[("rest_total_hits_as_int", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<ScrollPostWithScrollIdError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns results matching a query.
pub async fn search_get(
  configuration: &configuration::Configuration,
  analyzer: Option<&str>,
  analyze_wildcard: Option<bool>,
  ccs_minimize_roundtrips: Option<bool>,
  default_operator: Option<DefaultOperator>,
  df: Option<&str>,
  explain: Option<bool>,
  stored_fields: Option<Vec<String>>,
  docvalue_fields: Option<Vec<String>>,
  from: Option<i32>,
  ignore_unavailable: Option<bool>,
  ignore_throttled: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  lenient: Option<bool>,
  preference: Option<&str>,
  q: Option<&str>,
  routing: Option<Vec<String>>,
  scroll: Option<&str>,
  search_type: Option<SearchType>,
  size: Option<i32>,
  sort: Option<Vec<String>>,
  _source: Option<Vec<String>>,
  _source_excludes: Option<Vec<String>>,
  _source_includes: Option<Vec<String>>,
  terminate_after: Option<i32>,
  stats: Option<Vec<String>>,
  suggest_field: Option<&str>,
  suggest_mode: Option<SuggestMode>,
  suggest_size: Option<i32>,
  suggest_text: Option<&str>,
  timeout: Option<&str>,
  track_scores: Option<bool>,
  track_total_hits: Option<bool>,
  allow_partial_search_results: Option<bool>,
  typed_keys: Option<bool>,
  version: Option<bool>,
  seq_no_primary_term: Option<bool>,
  request_cache: Option<bool>,
  batched_reduce_size: Option<i32>,
  max_concurrent_shard_requests: Option<i32>,
  pre_filter_shard_size: Option<i32>,
  rest_total_hits_as_int: Option<bool>,
) -> Result<crate::models::SearchGetResponseContent, Error<SearchGetError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_search", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = analyzer {
    local_var_req_builder = local_var_req_builder.query(&[("analyzer", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = analyze_wildcard {
    local_var_req_builder = local_var_req_builder.query(&[("analyze_wildcard", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ccs_minimize_roundtrips {
    local_var_req_builder = local_var_req_builder.query(&[("ccs_minimize_roundtrips", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = default_operator {
    local_var_req_builder = local_var_req_builder.query(&[("default_operator", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = df {
    local_var_req_builder = local_var_req_builder.query(&[("df", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = explain {
    local_var_req_builder = local_var_req_builder.query(&[("explain", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = stored_fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("stored_fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "stored_fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = docvalue_fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("docvalue_fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "docvalue_fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = from {
    local_var_req_builder = local_var_req_builder.query(&[("from", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_throttled {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_throttled", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = lenient {
    local_var_req_builder = local_var_req_builder.query(&[("lenient", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = preference {
    local_var_req_builder = local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = q {
    local_var_req_builder = local_var_req_builder.query(&[("q", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("routing".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "routing",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = scroll {
    local_var_req_builder = local_var_req_builder.query(&[("scroll", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = search_type {
    local_var_req_builder = local_var_req_builder.query(&[("search_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = size {
    local_var_req_builder = local_var_req_builder.query(&[("size", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = sort {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("sort".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "sort",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_excludes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_excludes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_excludes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_includes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_includes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_includes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = terminate_after {
    local_var_req_builder = local_var_req_builder.query(&[("terminate_after", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = stats {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("stats".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "stats",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = suggest_field {
    local_var_req_builder = local_var_req_builder.query(&[("suggest_field", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = suggest_mode {
    local_var_req_builder = local_var_req_builder.query(&[("suggest_mode", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = suggest_size {
    local_var_req_builder = local_var_req_builder.query(&[("suggest_size", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = suggest_text {
    local_var_req_builder = local_var_req_builder.query(&[("suggest_text", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = track_scores {
    local_var_req_builder = local_var_req_builder.query(&[("track_scores", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = track_total_hits {
    local_var_req_builder = local_var_req_builder.query(&[("track_total_hits", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_partial_search_results {
    local_var_req_builder =
      local_var_req_builder.query(&[("allow_partial_search_results", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = typed_keys {
    local_var_req_builder = local_var_req_builder.query(&[("typed_keys", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = version {
    local_var_req_builder = local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = seq_no_primary_term {
    local_var_req_builder = local_var_req_builder.query(&[("seq_no_primary_term", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = request_cache {
    local_var_req_builder = local_var_req_builder.query(&[("request_cache", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = batched_reduce_size {
    local_var_req_builder = local_var_req_builder.query(&[("batched_reduce_size", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = max_concurrent_shard_requests {
    local_var_req_builder =
      local_var_req_builder.query(&[("max_concurrent_shard_requests", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = pre_filter_shard_size {
    local_var_req_builder = local_var_req_builder.query(&[("pre_filter_shard_size", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = rest_total_hits_as_int {
    local_var_req_builder = local_var_req_builder.query(&[("rest_total_hits_as_int", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<SearchGetError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns results matching a query.
pub async fn search_get_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  analyzer: Option<&str>,
  analyze_wildcard: Option<bool>,
  ccs_minimize_roundtrips: Option<bool>,
  default_operator: Option<DefaultOperator>,
  df: Option<&str>,
  explain: Option<bool>,
  stored_fields: Option<Vec<String>>,
  docvalue_fields: Option<Vec<String>>,
  from: Option<i32>,
  ignore_unavailable: Option<bool>,
  ignore_throttled: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  lenient: Option<bool>,
  preference: Option<&str>,
  q: Option<&str>,
  routing: Option<Vec<String>>,
  scroll: Option<&str>,
  search_type: Option<SearchType>,
  size: Option<i32>,
  sort: Option<Vec<String>>,
  _source: Option<Vec<String>>,
  _source_excludes: Option<Vec<String>>,
  _source_includes: Option<Vec<String>>,
  terminate_after: Option<i32>,
  stats: Option<Vec<String>>,
  suggest_field: Option<&str>,
  suggest_mode: Option<SuggestMode>,
  suggest_size: Option<i32>,
  suggest_text: Option<&str>,
  timeout: Option<&str>,
  track_scores: Option<bool>,
  track_total_hits: Option<bool>,
  allow_partial_search_results: Option<bool>,
  typed_keys: Option<bool>,
  version: Option<bool>,
  seq_no_primary_term: Option<bool>,
  request_cache: Option<bool>,
  batched_reduce_size: Option<i32>,
  max_concurrent_shard_requests: Option<i32>,
  pre_filter_shard_size: Option<i32>,
  rest_total_hits_as_int: Option<bool>,
) -> Result<crate::models::SearchGetWithIndexResponseContent, Error<SearchGetWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_search",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = analyzer {
    local_var_req_builder = local_var_req_builder.query(&[("analyzer", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = analyze_wildcard {
    local_var_req_builder = local_var_req_builder.query(&[("analyze_wildcard", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ccs_minimize_roundtrips {
    local_var_req_builder = local_var_req_builder.query(&[("ccs_minimize_roundtrips", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = default_operator {
    local_var_req_builder = local_var_req_builder.query(&[("default_operator", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = df {
    local_var_req_builder = local_var_req_builder.query(&[("df", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = explain {
    local_var_req_builder = local_var_req_builder.query(&[("explain", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = stored_fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("stored_fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "stored_fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = docvalue_fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("docvalue_fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "docvalue_fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = from {
    local_var_req_builder = local_var_req_builder.query(&[("from", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_throttled {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_throttled", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = lenient {
    local_var_req_builder = local_var_req_builder.query(&[("lenient", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = preference {
    local_var_req_builder = local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = q {
    local_var_req_builder = local_var_req_builder.query(&[("q", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("routing".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "routing",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = scroll {
    local_var_req_builder = local_var_req_builder.query(&[("scroll", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = search_type {
    local_var_req_builder = local_var_req_builder.query(&[("search_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = size {
    local_var_req_builder = local_var_req_builder.query(&[("size", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = sort {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("sort".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "sort",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_excludes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_excludes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_excludes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_includes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_includes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_includes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = terminate_after {
    local_var_req_builder = local_var_req_builder.query(&[("terminate_after", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = stats {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("stats".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "stats",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = suggest_field {
    local_var_req_builder = local_var_req_builder.query(&[("suggest_field", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = suggest_mode {
    local_var_req_builder = local_var_req_builder.query(&[("suggest_mode", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = suggest_size {
    local_var_req_builder = local_var_req_builder.query(&[("suggest_size", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = suggest_text {
    local_var_req_builder = local_var_req_builder.query(&[("suggest_text", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = track_scores {
    local_var_req_builder = local_var_req_builder.query(&[("track_scores", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = track_total_hits {
    local_var_req_builder = local_var_req_builder.query(&[("track_total_hits", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_partial_search_results {
    local_var_req_builder =
      local_var_req_builder.query(&[("allow_partial_search_results", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = typed_keys {
    local_var_req_builder = local_var_req_builder.query(&[("typed_keys", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = version {
    local_var_req_builder = local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = seq_no_primary_term {
    local_var_req_builder = local_var_req_builder.query(&[("seq_no_primary_term", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = request_cache {
    local_var_req_builder = local_var_req_builder.query(&[("request_cache", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = batched_reduce_size {
    local_var_req_builder = local_var_req_builder.query(&[("batched_reduce_size", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = max_concurrent_shard_requests {
    local_var_req_builder =
      local_var_req_builder.query(&[("max_concurrent_shard_requests", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = pre_filter_shard_size {
    local_var_req_builder = local_var_req_builder.query(&[("pre_filter_shard_size", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = rest_total_hits_as_int {
    local_var_req_builder = local_var_req_builder.query(&[("rest_total_hits_as_int", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<SearchGetWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns results matching a query.
pub async fn search_post(
  configuration: &configuration::Configuration,
  analyzer: Option<&str>,
  analyze_wildcard: Option<bool>,
  ccs_minimize_roundtrips: Option<bool>,
  default_operator: Option<DefaultOperator>,
  df: Option<&str>,
  explain: Option<bool>,
  stored_fields: Option<Vec<String>>,
  docvalue_fields: Option<Vec<String>>,
  from: Option<i32>,
  ignore_unavailable: Option<bool>,
  ignore_throttled: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  lenient: Option<bool>,
  preference: Option<&str>,
  q: Option<&str>,
  routing: Option<Vec<String>>,
  scroll: Option<&str>,
  search_type: Option<SearchType>,
  size: Option<i32>,
  sort: Option<Vec<String>>,
  _source: Option<Vec<String>>,
  _source_excludes: Option<Vec<String>>,
  _source_includes: Option<Vec<String>>,
  terminate_after: Option<i32>,
  stats: Option<Vec<String>>,
  suggest_field: Option<&str>,
  suggest_mode: Option<SuggestMode>,
  suggest_size: Option<i32>,
  suggest_text: Option<&str>,
  timeout: Option<&str>,
  track_scores: Option<bool>,
  track_total_hits: Option<bool>,
  allow_partial_search_results: Option<bool>,
  typed_keys: Option<bool>,
  version: Option<bool>,
  seq_no_primary_term: Option<bool>,
  request_cache: Option<bool>,
  batched_reduce_size: Option<i32>,
  max_concurrent_shard_requests: Option<i32>,
  pre_filter_shard_size: Option<i32>,
  rest_total_hits_as_int: Option<bool>,
  search_body_params: Option<crate::models::SearchBodyParams>,
) -> Result<crate::models::SearchPostResponseContent, Error<SearchPostError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_search", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = analyzer {
    local_var_req_builder = local_var_req_builder.query(&[("analyzer", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = analyze_wildcard {
    local_var_req_builder = local_var_req_builder.query(&[("analyze_wildcard", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ccs_minimize_roundtrips {
    local_var_req_builder = local_var_req_builder.query(&[("ccs_minimize_roundtrips", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = default_operator {
    local_var_req_builder = local_var_req_builder.query(&[("default_operator", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = df {
    local_var_req_builder = local_var_req_builder.query(&[("df", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = explain {
    local_var_req_builder = local_var_req_builder.query(&[("explain", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = stored_fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("stored_fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "stored_fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = docvalue_fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("docvalue_fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "docvalue_fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = from {
    local_var_req_builder = local_var_req_builder.query(&[("from", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_throttled {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_throttled", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = lenient {
    local_var_req_builder = local_var_req_builder.query(&[("lenient", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = preference {
    local_var_req_builder = local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = q {
    local_var_req_builder = local_var_req_builder.query(&[("q", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("routing".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "routing",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = scroll {
    local_var_req_builder = local_var_req_builder.query(&[("scroll", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = search_type {
    local_var_req_builder = local_var_req_builder.query(&[("search_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = size {
    local_var_req_builder = local_var_req_builder.query(&[("size", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = sort {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("sort".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "sort",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_excludes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_excludes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_excludes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_includes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_includes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_includes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = terminate_after {
    local_var_req_builder = local_var_req_builder.query(&[("terminate_after", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = stats {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("stats".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "stats",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = suggest_field {
    local_var_req_builder = local_var_req_builder.query(&[("suggest_field", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = suggest_mode {
    local_var_req_builder = local_var_req_builder.query(&[("suggest_mode", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = suggest_size {
    local_var_req_builder = local_var_req_builder.query(&[("suggest_size", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = suggest_text {
    local_var_req_builder = local_var_req_builder.query(&[("suggest_text", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = track_scores {
    local_var_req_builder = local_var_req_builder.query(&[("track_scores", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = track_total_hits {
    local_var_req_builder = local_var_req_builder.query(&[("track_total_hits", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_partial_search_results {
    local_var_req_builder =
      local_var_req_builder.query(&[("allow_partial_search_results", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = typed_keys {
    local_var_req_builder = local_var_req_builder.query(&[("typed_keys", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = version {
    local_var_req_builder = local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = seq_no_primary_term {
    local_var_req_builder = local_var_req_builder.query(&[("seq_no_primary_term", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = request_cache {
    local_var_req_builder = local_var_req_builder.query(&[("request_cache", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = batched_reduce_size {
    local_var_req_builder = local_var_req_builder.query(&[("batched_reduce_size", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = max_concurrent_shard_requests {
    local_var_req_builder =
      local_var_req_builder.query(&[("max_concurrent_shard_requests", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = pre_filter_shard_size {
    local_var_req_builder = local_var_req_builder.query(&[("pre_filter_shard_size", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = rest_total_hits_as_int {
    local_var_req_builder = local_var_req_builder.query(&[("rest_total_hits_as_int", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&search_body_params);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<SearchPostError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns results matching a query.
pub async fn search_post_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  analyzer: Option<&str>,
  analyze_wildcard: Option<bool>,
  ccs_minimize_roundtrips: Option<bool>,
  default_operator: Option<DefaultOperator>,
  df: Option<&str>,
  explain: Option<bool>,
  stored_fields: Option<Vec<String>>,
  docvalue_fields: Option<Vec<String>>,
  from: Option<i32>,
  ignore_unavailable: Option<bool>,
  ignore_throttled: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  lenient: Option<bool>,
  preference: Option<&str>,
  q: Option<&str>,
  routing: Option<Vec<String>>,
  scroll: Option<&str>,
  search_type: Option<SearchType>,
  size: Option<i32>,
  sort: Option<Vec<String>>,
  _source: Option<Vec<String>>,
  _source_excludes: Option<Vec<String>>,
  _source_includes: Option<Vec<String>>,
  terminate_after: Option<i32>,
  stats: Option<Vec<String>>,
  suggest_field: Option<&str>,
  suggest_mode: Option<SuggestMode>,
  suggest_size: Option<i32>,
  suggest_text: Option<&str>,
  timeout: Option<&str>,
  track_scores: Option<bool>,
  track_total_hits: Option<bool>,
  allow_partial_search_results: Option<bool>,
  typed_keys: Option<bool>,
  version: Option<bool>,
  seq_no_primary_term: Option<bool>,
  request_cache: Option<bool>,
  batched_reduce_size: Option<i32>,
  max_concurrent_shard_requests: Option<i32>,
  pre_filter_shard_size: Option<i32>,
  rest_total_hits_as_int: Option<bool>,
  search_body_params: Option<crate::models::SearchBodyParams>,
) -> Result<crate::models::SearchPostWithIndexResponseContent, Error<SearchPostWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_search",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = analyzer {
    local_var_req_builder = local_var_req_builder.query(&[("analyzer", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = analyze_wildcard {
    local_var_req_builder = local_var_req_builder.query(&[("analyze_wildcard", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ccs_minimize_roundtrips {
    local_var_req_builder = local_var_req_builder.query(&[("ccs_minimize_roundtrips", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = default_operator {
    local_var_req_builder = local_var_req_builder.query(&[("default_operator", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = df {
    local_var_req_builder = local_var_req_builder.query(&[("df", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = explain {
    local_var_req_builder = local_var_req_builder.query(&[("explain", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = stored_fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("stored_fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "stored_fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = docvalue_fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("docvalue_fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "docvalue_fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = from {
    local_var_req_builder = local_var_req_builder.query(&[("from", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_throttled {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_throttled", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = lenient {
    local_var_req_builder = local_var_req_builder.query(&[("lenient", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = preference {
    local_var_req_builder = local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = q {
    local_var_req_builder = local_var_req_builder.query(&[("q", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("routing".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "routing",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = scroll {
    local_var_req_builder = local_var_req_builder.query(&[("scroll", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = search_type {
    local_var_req_builder = local_var_req_builder.query(&[("search_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = size {
    local_var_req_builder = local_var_req_builder.query(&[("size", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = sort {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("sort".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "sort",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_excludes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_excludes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_excludes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_includes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_includes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_includes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = terminate_after {
    local_var_req_builder = local_var_req_builder.query(&[("terminate_after", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = stats {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("stats".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "stats",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = suggest_field {
    local_var_req_builder = local_var_req_builder.query(&[("suggest_field", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = suggest_mode {
    local_var_req_builder = local_var_req_builder.query(&[("suggest_mode", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = suggest_size {
    local_var_req_builder = local_var_req_builder.query(&[("suggest_size", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = suggest_text {
    local_var_req_builder = local_var_req_builder.query(&[("suggest_text", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = track_scores {
    local_var_req_builder = local_var_req_builder.query(&[("track_scores", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = track_total_hits {
    local_var_req_builder = local_var_req_builder.query(&[("track_total_hits", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_partial_search_results {
    local_var_req_builder =
      local_var_req_builder.query(&[("allow_partial_search_results", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = typed_keys {
    local_var_req_builder = local_var_req_builder.query(&[("typed_keys", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = version {
    local_var_req_builder = local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = seq_no_primary_term {
    local_var_req_builder = local_var_req_builder.query(&[("seq_no_primary_term", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = request_cache {
    local_var_req_builder = local_var_req_builder.query(&[("request_cache", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = batched_reduce_size {
    local_var_req_builder = local_var_req_builder.query(&[("batched_reduce_size", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = max_concurrent_shard_requests {
    local_var_req_builder =
      local_var_req_builder.query(&[("max_concurrent_shard_requests", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = pre_filter_shard_size {
    local_var_req_builder = local_var_req_builder.query(&[("pre_filter_shard_size", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = rest_total_hits_as_int {
    local_var_req_builder = local_var_req_builder.query(&[("rest_total_hits_as_int", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&search_body_params);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<SearchPostWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about the indices and shards that a search request would
/// be executed against.
pub async fn search_shards_get(
  configuration: &configuration::Configuration,
  preference: Option<&str>,
  routing: Option<&str>,
  local: Option<bool>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
) -> Result<(), Error<SearchShardsGetError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_search_shards", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = preference {
    local_var_req_builder = local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<SearchShardsGetError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about the indices and shards that a search request would
/// be executed against.
pub async fn search_shards_get_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  preference: Option<&str>,
  routing: Option<&str>,
  local: Option<bool>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
) -> Result<(), Error<SearchShardsGetWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_search_shards",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = preference {
    local_var_req_builder = local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<SearchShardsGetWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about the indices and shards that a search request would
/// be executed against.
pub async fn search_shards_post(
  configuration: &configuration::Configuration,
  preference: Option<&str>,
  routing: Option<&str>,
  local: Option<bool>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
) -> Result<(), Error<SearchShardsPostError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_search_shards", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = preference {
    local_var_req_builder = local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<SearchShardsPostError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about the indices and shards that a search request would
/// be executed against.
pub async fn search_shards_post_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  preference: Option<&str>,
  routing: Option<&str>,
  local: Option<bool>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
) -> Result<(), Error<SearchShardsPostWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_search_shards",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = preference {
    local_var_req_builder = local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<SearchShardsPostWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows to use the Mustache language to pre-render a search definition.
pub async fn search_template_get(
  configuration: &configuration::Configuration,
  ignore_unavailable: Option<bool>,
  ignore_throttled: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  preference: Option<&str>,
  routing: Option<Vec<String>>,
  scroll: Option<&str>,
  search_type: Option<SearchTypeMulti>,
  explain: Option<bool>,
  profile: Option<bool>,
  typed_keys: Option<bool>,
  rest_total_hits_as_int: Option<bool>,
  ccs_minimize_roundtrips: Option<bool>,
) -> Result<(), Error<SearchTemplateGetError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_search/template", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_throttled {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_throttled", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = preference {
    local_var_req_builder = local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("routing".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "routing",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = scroll {
    local_var_req_builder = local_var_req_builder.query(&[("scroll", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = search_type {
    local_var_req_builder = local_var_req_builder.query(&[("search_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = explain {
    local_var_req_builder = local_var_req_builder.query(&[("explain", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = profile {
    local_var_req_builder = local_var_req_builder.query(&[("profile", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = typed_keys {
    local_var_req_builder = local_var_req_builder.query(&[("typed_keys", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = rest_total_hits_as_int {
    local_var_req_builder = local_var_req_builder.query(&[("rest_total_hits_as_int", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ccs_minimize_roundtrips {
    local_var_req_builder = local_var_req_builder.query(&[("ccs_minimize_roundtrips", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<SearchTemplateGetError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows to use the Mustache language to pre-render a search definition.
pub async fn search_template_get_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  ignore_unavailable: Option<bool>,
  ignore_throttled: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  preference: Option<&str>,
  routing: Option<Vec<String>>,
  scroll: Option<&str>,
  search_type: Option<SearchTypeMulti>,
  explain: Option<bool>,
  profile: Option<bool>,
  typed_keys: Option<bool>,
  rest_total_hits_as_int: Option<bool>,
  ccs_minimize_roundtrips: Option<bool>,
) -> Result<(), Error<SearchTemplateGetWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_search/template",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_throttled {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_throttled", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = preference {
    local_var_req_builder = local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("routing".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "routing",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = scroll {
    local_var_req_builder = local_var_req_builder.query(&[("scroll", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = search_type {
    local_var_req_builder = local_var_req_builder.query(&[("search_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = explain {
    local_var_req_builder = local_var_req_builder.query(&[("explain", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = profile {
    local_var_req_builder = local_var_req_builder.query(&[("profile", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = typed_keys {
    local_var_req_builder = local_var_req_builder.query(&[("typed_keys", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = rest_total_hits_as_int {
    local_var_req_builder = local_var_req_builder.query(&[("rest_total_hits_as_int", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ccs_minimize_roundtrips {
    local_var_req_builder = local_var_req_builder.query(&[("ccs_minimize_roundtrips", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<SearchTemplateGetWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows to use the Mustache language to pre-render a search definition.
pub async fn search_template_post(
  configuration: &configuration::Configuration,
  body: serde_json::Value,
  ignore_unavailable: Option<bool>,
  ignore_throttled: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  preference: Option<&str>,
  routing: Option<Vec<String>>,
  scroll: Option<&str>,
  search_type: Option<SearchTypeMulti>,
  explain: Option<bool>,
  profile: Option<bool>,
  typed_keys: Option<bool>,
  rest_total_hits_as_int: Option<bool>,
  ccs_minimize_roundtrips: Option<bool>,
) -> Result<(), Error<SearchTemplatePostError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_search/template", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_throttled {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_throttled", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = preference {
    local_var_req_builder = local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("routing".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "routing",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = scroll {
    local_var_req_builder = local_var_req_builder.query(&[("scroll", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = search_type {
    local_var_req_builder = local_var_req_builder.query(&[("search_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = explain {
    local_var_req_builder = local_var_req_builder.query(&[("explain", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = profile {
    local_var_req_builder = local_var_req_builder.query(&[("profile", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = typed_keys {
    local_var_req_builder = local_var_req_builder.query(&[("typed_keys", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = rest_total_hits_as_int {
    local_var_req_builder = local_var_req_builder.query(&[("rest_total_hits_as_int", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ccs_minimize_roundtrips {
    local_var_req_builder = local_var_req_builder.query(&[("ccs_minimize_roundtrips", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<SearchTemplatePostError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Allows to use the Mustache language to pre-render a search definition.
pub async fn search_template_post_with_index(
  configuration: &configuration::Configuration,
  index: &str,
  body: serde_json::Value,
  ignore_unavailable: Option<bool>,
  ignore_throttled: Option<bool>,
  allow_no_indices: Option<bool>,
  expand_wildcards: Option<ExpandWildcards>,
  preference: Option<&str>,
  routing: Option<Vec<String>>,
  scroll: Option<&str>,
  search_type: Option<SearchTypeMulti>,
  explain: Option<bool>,
  profile: Option<bool>,
  typed_keys: Option<bool>,
  rest_total_hits_as_int: Option<bool>,
  ccs_minimize_roundtrips: Option<bool>,
) -> Result<(), Error<SearchTemplatePostWithIndexError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_search/template",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_throttled {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_throttled", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = preference {
    local_var_req_builder = local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("routing".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "routing",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = scroll {
    local_var_req_builder = local_var_req_builder.query(&[("scroll", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = search_type {
    local_var_req_builder = local_var_req_builder.query(&[("search_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = explain {
    local_var_req_builder = local_var_req_builder.query(&[("explain", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = profile {
    local_var_req_builder = local_var_req_builder.query(&[("profile", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = typed_keys {
    local_var_req_builder = local_var_req_builder.query(&[("typed_keys", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = rest_total_hits_as_int {
    local_var_req_builder = local_var_req_builder.query(&[("rest_total_hits_as_int", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ccs_minimize_roundtrips {
    local_var_req_builder = local_var_req_builder.query(&[("ccs_minimize_roundtrips", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<SearchTemplatePostWithIndexError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Checks to see if the Security plugin is up and running.
pub async fn security_health(
  configuration: &configuration::Configuration,
) -> Result<crate::models::SecurityHealthResponseContent, Error<SecurityHealthError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_plugins/_security/health", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<SecurityHealthError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Removes stale data from repository.
pub async fn snapshot_cleanup_repository(
  configuration: &configuration::Configuration,
  repository: &str,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  timeout: Option<&str>,
) -> Result<(), Error<SnapshotCleanupRepositoryError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_snapshot/{repository}/_cleanup",
    local_var_configuration.base_path,
    repository = crate::apis::urlencode(repository)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<SnapshotCleanupRepositoryError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Clones indices from one snapshot into another snapshot in the same
/// repository.
pub async fn snapshot_clone(
  configuration: &configuration::Configuration,
  repository: &str,
  snapshot: &str,
  target_snapshot: &str,
  body: serde_json::Value,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
) -> Result<(), Error<SnapshotCloneError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_snapshot/{repository}/{snapshot}/_clone/{target_snapshot}",
    local_var_configuration.base_path,
    repository = crate::apis::urlencode(repository),
    snapshot = crate::apis::urlencode(snapshot),
    target_snapshot = crate::apis::urlencode(target_snapshot)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<SnapshotCloneError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Creates a snapshot in a repository.
pub async fn snapshot_create_post(
  configuration: &configuration::Configuration,
  repository: &str,
  snapshot: &str,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  wait_for_completion: Option<bool>,
  body: Option<serde_json::Value>,
) -> Result<(), Error<SnapshotCreatePostError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_snapshot/{repository}/{snapshot}",
    local_var_configuration.base_path,
    repository = crate::apis::urlencode(repository),
    snapshot = crate::apis::urlencode(snapshot)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_completion {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_completion", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<SnapshotCreatePostError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Creates a snapshot in a repository.
pub async fn snapshot_create_put(
  configuration: &configuration::Configuration,
  repository: &str,
  snapshot: &str,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  wait_for_completion: Option<bool>,
  body: Option<serde_json::Value>,
) -> Result<(), Error<SnapshotCreatePutError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_snapshot/{repository}/{snapshot}",
    local_var_configuration.base_path,
    repository = crate::apis::urlencode(repository),
    snapshot = crate::apis::urlencode(snapshot)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_completion {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_completion", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<SnapshotCreatePutError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Creates a repository.
pub async fn snapshot_create_repository_post(
  configuration: &configuration::Configuration,
  repository: &str,
  body: serde_json::Value,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  timeout: Option<&str>,
  verify: Option<bool>,
) -> Result<(), Error<SnapshotCreateRepositoryPostError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_snapshot/{repository}",
    local_var_configuration.base_path,
    repository = crate::apis::urlencode(repository)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = verify {
    local_var_req_builder = local_var_req_builder.query(&[("verify", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<SnapshotCreateRepositoryPostError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Creates a repository.
pub async fn snapshot_create_repository_put(
  configuration: &configuration::Configuration,
  repository: &str,
  body: serde_json::Value,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  timeout: Option<&str>,
  verify: Option<bool>,
) -> Result<(), Error<SnapshotCreateRepositoryPutError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_snapshot/{repository}",
    local_var_configuration.base_path,
    repository = crate::apis::urlencode(repository)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = verify {
    local_var_req_builder = local_var_req_builder.query(&[("verify", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<SnapshotCreateRepositoryPutError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Deletes a snapshot.
pub async fn snapshot_delete(
  configuration: &configuration::Configuration,
  repository: &str,
  snapshot: &str,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
) -> Result<(), Error<SnapshotDeleteError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_snapshot/{repository}/{snapshot}",
    local_var_configuration.base_path,
    repository = crate::apis::urlencode(repository),
    snapshot = crate::apis::urlencode(snapshot)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<SnapshotDeleteError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Deletes a repository.
pub async fn snapshot_delete_repository(
  configuration: &configuration::Configuration,
  repository: &str,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  timeout: Option<&str>,
) -> Result<(), Error<SnapshotDeleteRepositoryError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_snapshot/{repository}",
    local_var_configuration.base_path,
    repository = crate::apis::urlencode(repository)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<SnapshotDeleteRepositoryError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about a snapshot.
pub async fn snapshot_get(
  configuration: &configuration::Configuration,
  repository: &str,
  snapshot: &str,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  ignore_unavailable: Option<bool>,
  verbose: Option<bool>,
) -> Result<(), Error<SnapshotGetError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_snapshot/{repository}/{snapshot}",
    local_var_configuration.base_path,
    repository = crate::apis::urlencode(repository),
    snapshot = crate::apis::urlencode(snapshot)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = verbose {
    local_var_req_builder = local_var_req_builder.query(&[("verbose", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<SnapshotGetError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about a repository.
pub async fn snapshot_get_repository(
  configuration: &configuration::Configuration,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  local: Option<bool>,
) -> Result<(), Error<SnapshotGetRepositoryError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_snapshot", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<SnapshotGetRepositoryError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about a repository.
pub async fn snapshot_get_repository_with_repository(
  configuration: &configuration::Configuration,
  repository: &str,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  local: Option<bool>,
) -> Result<(), Error<SnapshotGetRepositoryWithRepositoryError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_snapshot/{repository}",
    local_var_configuration.base_path,
    repository = crate::apis::urlencode(repository)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = local {
    local_var_req_builder = local_var_req_builder.query(&[("local", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<SnapshotGetRepositoryWithRepositoryError> =
      serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Restores a snapshot.
pub async fn snapshot_restore(
  configuration: &configuration::Configuration,
  repository: &str,
  snapshot: &str,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  wait_for_completion: Option<bool>,
  body: Option<serde_json::Value>,
) -> Result<(), Error<SnapshotRestoreError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_snapshot/{repository}/{snapshot}/_restore",
    local_var_configuration.base_path,
    repository = crate::apis::urlencode(repository),
    snapshot = crate::apis::urlencode(snapshot)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_completion {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_completion", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<SnapshotRestoreError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about the status of a snapshot.
pub async fn snapshot_status(
  configuration: &configuration::Configuration,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  ignore_unavailable: Option<bool>,
) -> Result<(), Error<SnapshotStatusError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_snapshot/_status", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<SnapshotStatusError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about the status of a snapshot.
pub async fn snapshot_status_with_repository(
  configuration: &configuration::Configuration,
  repository: &str,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  ignore_unavailable: Option<bool>,
) -> Result<(), Error<SnapshotStatusWithRepositoryError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_snapshot/{repository}/_status",
    local_var_configuration.base_path,
    repository = crate::apis::urlencode(repository)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<SnapshotStatusWithRepositoryError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about the status of a snapshot.
pub async fn snapshot_status_with_repository_snapshot(
  configuration: &configuration::Configuration,
  repository: &str,
  snapshot: &str,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  ignore_unavailable: Option<bool>,
) -> Result<(), Error<SnapshotStatusWithRepositorySnapshotError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_snapshot/{repository}/{snapshot}/_status",
    local_var_configuration.base_path,
    repository = crate::apis::urlencode(repository),
    snapshot = crate::apis::urlencode(snapshot)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<SnapshotStatusWithRepositorySnapshotError> =
      serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Verifies a repository.
pub async fn snapshot_verify_repository(
  configuration: &configuration::Configuration,
  repository: &str,
  master_timeout: Option<&str>,
  cluster_manager_timeout: Option<&str>,
  timeout: Option<&str>,
) -> Result<(), Error<SnapshotVerifyRepositoryError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_snapshot/{repository}/_verify",
    local_var_configuration.base_path,
    repository = crate::apis::urlencode(repository)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = master_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("master_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = cluster_manager_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("cluster_manager_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<SnapshotVerifyRepositoryError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Cancels a task, if it can be cancelled through an API.
pub async fn tasks_cancel(
  configuration: &configuration::Configuration,
  nodes: Option<Vec<String>>,
  actions: Option<Vec<String>>,
  parent_task_id: Option<&str>,
  wait_for_completion: Option<bool>,
) -> Result<(), Error<TasksCancelError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_tasks/_cancel", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = nodes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("nodes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "nodes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = actions {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("actions".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "actions",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = parent_task_id {
    local_var_req_builder = local_var_req_builder.query(&[("parent_task_id", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_completion {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_completion", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<TasksCancelError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Cancels a task, if it can be cancelled through an API.
pub async fn tasks_cancel_with_task_id(
  configuration: &configuration::Configuration,
  task_id: &str,
  nodes: Option<Vec<String>>,
  actions: Option<Vec<String>>,
  parent_task_id: Option<&str>,
  wait_for_completion: Option<bool>,
) -> Result<(), Error<TasksCancelWithTaskIdError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_tasks/{task_id}/_cancel",
    local_var_configuration.base_path,
    task_id = crate::apis::urlencode(task_id)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = nodes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("nodes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "nodes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = actions {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("actions".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "actions",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = parent_task_id {
    local_var_req_builder = local_var_req_builder.query(&[("parent_task_id", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_completion {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_completion", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<TasksCancelWithTaskIdError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information about a task.
pub async fn tasks_get(
  configuration: &configuration::Configuration,
  task_id: &str,
  wait_for_completion: Option<bool>,
  timeout: Option<&str>,
) -> Result<(), Error<TasksGetError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_tasks/{task_id}",
    local_var_configuration.base_path,
    task_id = crate::apis::urlencode(task_id)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = wait_for_completion {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_completion", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<TasksGetError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns a list of tasks.
pub async fn tasks_list(
  configuration: &configuration::Configuration,
  nodes: Option<Vec<String>>,
  actions: Option<Vec<String>>,
  detailed: Option<bool>,
  parent_task_id: Option<&str>,
  wait_for_completion: Option<bool>,
  group_by: Option<GroupBy>,
  timeout: Option<&str>,
) -> Result<(), Error<TasksListError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!("{}/_tasks", local_var_configuration.base_path);
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = nodes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("nodes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "nodes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = actions {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("actions".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "actions",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = detailed {
    local_var_req_builder = local_var_req_builder.query(&[("detailed", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = parent_task_id {
    local_var_req_builder = local_var_req_builder.query(&[("parent_task_id", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_completion {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_completion", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = group_by {
    local_var_req_builder = local_var_req_builder.query(&[("group_by", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<TasksListError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information and statistics about terms in the fields of a particular
/// document.
pub async fn termvectors_get(
  configuration: &configuration::Configuration,
  index: &str,
  term_statistics: Option<bool>,
  field_statistics: Option<bool>,
  fields: Option<Vec<String>>,
  offsets: Option<bool>,
  positions: Option<bool>,
  payloads: Option<bool>,
  preference: Option<&str>,
  routing: Option<&str>,
  realtime: Option<bool>,
  version: Option<i32>,
  version_type: Option<VersionType>,
) -> Result<(), Error<TermvectorsGetError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_termvectors",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = term_statistics {
    local_var_req_builder = local_var_req_builder.query(&[("term_statistics", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = field_statistics {
    local_var_req_builder = local_var_req_builder.query(&[("field_statistics", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = offsets {
    local_var_req_builder = local_var_req_builder.query(&[("offsets", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = positions {
    local_var_req_builder = local_var_req_builder.query(&[("positions", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = payloads {
    local_var_req_builder = local_var_req_builder.query(&[("payloads", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = preference {
    local_var_req_builder = local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = realtime {
    local_var_req_builder = local_var_req_builder.query(&[("realtime", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = version {
    local_var_req_builder = local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = version_type {
    local_var_req_builder = local_var_req_builder.query(&[("version_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<TermvectorsGetError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information and statistics about terms in the fields of a particular
/// document.
pub async fn termvectors_get_with_id(
  configuration: &configuration::Configuration,
  index: &str,
  id: &str,
  term_statistics: Option<bool>,
  field_statistics: Option<bool>,
  fields: Option<Vec<String>>,
  offsets: Option<bool>,
  positions: Option<bool>,
  payloads: Option<bool>,
  preference: Option<&str>,
  routing: Option<&str>,
  realtime: Option<bool>,
  version: Option<i32>,
  version_type: Option<VersionType>,
) -> Result<(), Error<TermvectorsGetWithIdError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_termvectors/{id}",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index),
    id = crate::apis::urlencode(id)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = term_statistics {
    local_var_req_builder = local_var_req_builder.query(&[("term_statistics", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = field_statistics {
    local_var_req_builder = local_var_req_builder.query(&[("field_statistics", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = offsets {
    local_var_req_builder = local_var_req_builder.query(&[("offsets", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = positions {
    local_var_req_builder = local_var_req_builder.query(&[("positions", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = payloads {
    local_var_req_builder = local_var_req_builder.query(&[("payloads", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = preference {
    local_var_req_builder = local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = realtime {
    local_var_req_builder = local_var_req_builder.query(&[("realtime", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = version {
    local_var_req_builder = local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = version_type {
    local_var_req_builder = local_var_req_builder.query(&[("version_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<TermvectorsGetWithIdError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information and statistics about terms in the fields of a particular
/// document.
pub async fn termvectors_post(
  configuration: &configuration::Configuration,
  index: &str,
  term_statistics: Option<bool>,
  field_statistics: Option<bool>,
  fields: Option<Vec<String>>,
  offsets: Option<bool>,
  positions: Option<bool>,
  payloads: Option<bool>,
  preference: Option<&str>,
  routing: Option<&str>,
  realtime: Option<bool>,
  version: Option<i32>,
  version_type: Option<VersionType>,
  body: Option<serde_json::Value>,
) -> Result<(), Error<TermvectorsPostError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_termvectors",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = term_statistics {
    local_var_req_builder = local_var_req_builder.query(&[("term_statistics", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = field_statistics {
    local_var_req_builder = local_var_req_builder.query(&[("field_statistics", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = offsets {
    local_var_req_builder = local_var_req_builder.query(&[("offsets", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = positions {
    local_var_req_builder = local_var_req_builder.query(&[("positions", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = payloads {
    local_var_req_builder = local_var_req_builder.query(&[("payloads", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = preference {
    local_var_req_builder = local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = realtime {
    local_var_req_builder = local_var_req_builder.query(&[("realtime", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = version {
    local_var_req_builder = local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = version_type {
    local_var_req_builder = local_var_req_builder.query(&[("version_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<TermvectorsPostError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Returns information and statistics about terms in the fields of a particular
/// document.
pub async fn termvectors_post_with_id(
  configuration: &configuration::Configuration,
  index: &str,
  id: &str,
  term_statistics: Option<bool>,
  field_statistics: Option<bool>,
  fields: Option<Vec<String>>,
  offsets: Option<bool>,
  positions: Option<bool>,
  payloads: Option<bool>,
  preference: Option<&str>,
  routing: Option<&str>,
  realtime: Option<bool>,
  version: Option<i32>,
  version_type: Option<VersionType>,
  body: Option<serde_json::Value>,
) -> Result<(), Error<TermvectorsPostWithIdError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_termvectors/{id}",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index),
    id = crate::apis::urlencode(id)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = term_statistics {
    local_var_req_builder = local_var_req_builder.query(&[("term_statistics", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = field_statistics {
    local_var_req_builder = local_var_req_builder.query(&[("field_statistics", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = fields {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("fields".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "fields",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = offsets {
    local_var_req_builder = local_var_req_builder.query(&[("offsets", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = positions {
    local_var_req_builder = local_var_req_builder.query(&[("positions", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = payloads {
    local_var_req_builder = local_var_req_builder.query(&[("payloads", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = preference {
    local_var_req_builder = local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = realtime {
    local_var_req_builder = local_var_req_builder.query(&[("realtime", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = version {
    local_var_req_builder = local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = version_type {
    local_var_req_builder = local_var_req_builder.query(&[("version_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<TermvectorsPostWithIdError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Updates a document with a script or partial document.
pub async fn update(
  configuration: &configuration::Configuration,
  id: &str,
  index: &str,
  body: serde_json::Value,
  wait_for_active_shards: Option<&str>,
  _source: Option<Vec<String>>,
  _source_excludes: Option<Vec<String>>,
  _source_includes: Option<Vec<String>>,
  lang: Option<&str>,
  refresh: Option<RefreshEnum>,
  retry_on_conflict: Option<i32>,
  routing: Option<&str>,
  timeout: Option<&str>,
  if_seq_no: Option<i32>,
  if_primary_term: Option<i32>,
  require_alias: Option<bool>,
) -> Result<(), Error<UpdateError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_update/{id}",
    local_var_configuration.base_path,
    id = crate::apis::urlencode(id),
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = wait_for_active_shards {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_active_shards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = _source {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_excludes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_excludes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_excludes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_includes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_includes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_includes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = lang {
    local_var_req_builder = local_var_req_builder.query(&[("lang", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = refresh {
    local_var_req_builder = local_var_req_builder.query(&[("refresh", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = retry_on_conflict {
    local_var_req_builder = local_var_req_builder.query(&[("retry_on_conflict", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = local_var_req_builder.query(&[("routing", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = if_seq_no {
    local_var_req_builder = local_var_req_builder.query(&[("if_seq_no", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = if_primary_term {
    local_var_req_builder = local_var_req_builder.query(&[("if_primary_term", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = require_alias {
    local_var_req_builder = local_var_req_builder.query(&[("require_alias", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<UpdateError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Updates the audit configuration.
pub async fn update_audit_configuration(
  configuration: &configuration::Configuration,
  audit_config: crate::models::AuditConfig,
) -> Result<crate::models::UpdateAuditConfigurationResponseContent, Error<UpdateAuditConfigurationError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_plugins/_security/api/audit/config",
    local_var_configuration.base_path
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&audit_config);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<UpdateAuditConfigurationError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Performs an update on every document in the index without changing the
/// source, for example to pick up a mapping change.
pub async fn update_by_query(
  configuration: &configuration::Configuration,
  index: &str,
  analyzer: Option<&str>,
  analyze_wildcard: Option<bool>,
  default_operator: Option<DefaultOperator>,
  df: Option<&str>,
  from: Option<i32>,
  ignore_unavailable: Option<bool>,
  allow_no_indices: Option<bool>,
  conflicts: Option<Conflicts>,
  expand_wildcards: Option<ExpandWildcards>,
  lenient: Option<bool>,
  pipeline: Option<&str>,
  preference: Option<&str>,
  q: Option<&str>,
  routing: Option<Vec<String>>,
  scroll: Option<&str>,
  search_type: Option<SearchType>,
  search_timeout: Option<&str>,
  size: Option<i32>,
  max_docs: Option<i32>,
  sort: Option<Vec<String>>,
  _source: Option<Vec<String>>,
  _source_excludes: Option<Vec<String>>,
  _source_includes: Option<Vec<String>>,
  terminate_after: Option<i32>,
  stats: Option<Vec<String>>,
  version: Option<bool>,
  request_cache: Option<bool>,
  refresh: Option<bool>,
  timeout: Option<&str>,
  wait_for_active_shards: Option<&str>,
  scroll_size: Option<i32>,
  wait_for_completion: Option<bool>,
  requests_per_second: Option<i32>,
  slices: Option<&str>,
  body: Option<serde_json::Value>,
) -> Result<(), Error<UpdateByQueryError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/{index}/_update_by_query",
    local_var_configuration.base_path,
    index = crate::apis::urlencode(index)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  if let Some(ref local_var_str) = analyzer {
    local_var_req_builder = local_var_req_builder.query(&[("analyzer", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = analyze_wildcard {
    local_var_req_builder = local_var_req_builder.query(&[("analyze_wildcard", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = default_operator {
    local_var_req_builder = local_var_req_builder.query(&[("default_operator", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = df {
    local_var_req_builder = local_var_req_builder.query(&[("df", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = from {
    local_var_req_builder = local_var_req_builder.query(&[("from", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = ignore_unavailable {
    local_var_req_builder = local_var_req_builder.query(&[("ignore_unavailable", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = allow_no_indices {
    local_var_req_builder = local_var_req_builder.query(&[("allow_no_indices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = conflicts {
    local_var_req_builder = local_var_req_builder.query(&[("conflicts", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = expand_wildcards {
    local_var_req_builder = local_var_req_builder.query(&[("expand_wildcards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = lenient {
    local_var_req_builder = local_var_req_builder.query(&[("lenient", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = pipeline {
    local_var_req_builder = local_var_req_builder.query(&[("pipeline", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = preference {
    local_var_req_builder = local_var_req_builder.query(&[("preference", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = q {
    local_var_req_builder = local_var_req_builder.query(&[("q", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = routing {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("routing".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "routing",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = scroll {
    local_var_req_builder = local_var_req_builder.query(&[("scroll", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = search_type {
    local_var_req_builder = local_var_req_builder.query(&[("search_type", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = search_timeout {
    local_var_req_builder = local_var_req_builder.query(&[("search_timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = size {
    local_var_req_builder = local_var_req_builder.query(&[("size", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = max_docs {
    local_var_req_builder = local_var_req_builder.query(&[("max_docs", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = sort {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("sort".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "sort",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_excludes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_excludes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_excludes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = _source_includes {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("_source_includes".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "_source_includes",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = terminate_after {
    local_var_req_builder = local_var_req_builder.query(&[("terminate_after", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = stats {
    local_var_req_builder = match "multi" {
      "multi" => {
        local_var_req_builder.query(
          &local_var_str
            .into_iter()
            .map(|p| ("stats".to_owned(), p.to_string()))
            .collect::<Vec<(std::string::String, std::string::String)>>(),
        )
      }
      _ => {
        local_var_req_builder.query(&[(
          "stats",
          &local_var_str
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
        )])
      }
    };
  }
  if let Some(ref local_var_str) = version {
    local_var_req_builder = local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = request_cache {
    local_var_req_builder = local_var_req_builder.query(&[("request_cache", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = refresh {
    local_var_req_builder = local_var_req_builder.query(&[("refresh", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = timeout {
    local_var_req_builder = local_var_req_builder.query(&[("timeout", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_active_shards {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_active_shards", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = scroll_size {
    local_var_req_builder = local_var_req_builder.query(&[("scroll_size", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = wait_for_completion {
    local_var_req_builder = local_var_req_builder.query(&[("wait_for_completion", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = requests_per_second {
    local_var_req_builder = local_var_req_builder.query(&[("requests_per_second", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_str) = slices {
    local_var_req_builder = local_var_req_builder.query(&[("slices", &local_var_str.to_string())]);
  }
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&body);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<UpdateByQueryError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Changes the number of requests per second for a particular Update By Query
/// operation.
pub async fn update_by_query_rethrottle(
  configuration: &configuration::Configuration,
  task_id: &str,
  requests_per_second: i32,
) -> Result<(), Error<UpdateByQueryRethrottleError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_update_by_query/{task_id}/_rethrottle",
    local_var_configuration.base_path,
    task_id = crate::apis::urlencode(task_id)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

  local_var_req_builder = local_var_req_builder.query(&[("requests_per_second", &requests_per_second.to_string())]);
  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    Ok(())
  } else {
    let local_var_entity: Option<UpdateByQueryRethrottleError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Adds or updates the existing configuration using the REST API.
pub async fn update_configuration(
  configuration: &configuration::Configuration,
  dynamic_config: crate::models::DynamicConfig,
) -> Result<crate::models::UpdateConfigurationResponseContent, Error<UpdateConfigurationError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_plugins/_security/api/securityconfig/config",
    local_var_configuration.base_path
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&dynamic_config);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<UpdateConfigurationError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}

/// Adds or updates the specified distinguished names in the cluster’s or node’s
/// allow list.
pub async fn update_distinguished_names(
  configuration: &configuration::Configuration,
  cluster_name: &str,
  distinguished_names: Option<crate::models::DistinguishedNames>,
) -> Result<crate::models::UpdateDistinguishedNamesResponseContent, Error<UpdateDistinguishedNamesError>> {
  let local_var_configuration = configuration;

  let local_var_client = &local_var_configuration.client;

  let local_var_uri_str = format!(
    "{}/_plugins/_security/api/nodesdn/{cluster_name}",
    local_var_configuration.base_path,
    cluster_name = crate::apis::urlencode(cluster_name)
  );
  let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

  if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
    local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
  }
  if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
    local_var_req_builder =
      local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
  };
  local_var_req_builder = local_var_req_builder.json(&distinguished_names);

  let local_var_req = local_var_req_builder.build()?;
  let local_var_resp = local_var_client.execute(local_var_req).await?;

  let local_var_status = local_var_resp.status();
  let local_var_content = local_var_resp.text().await?;

  if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
    serde_json::from_str(&local_var_content).map_err(Error::from)
  } else {
    let local_var_entity: Option<UpdateDistinguishedNamesError> = serde_json::from_str(&local_var_content).ok();
    let local_var_error = ResponseContent {
      status: local_var_status,
      content: local_var_content,
      entity: local_var_entity,
    };
    Err(Error::ResponseError(local_var_error))
  }
}
