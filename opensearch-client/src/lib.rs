mod progenitor_client;

#[allow(unused_imports)]
use progenitor_client::{encode_path, RequestBuilderExt};
pub use progenitor_client::{ByteStream, Error, ResponseValue};
#[allow(unused_imports)]
use reqwest::header::{HeaderMap, HeaderValue};
pub mod types;
#[derive(Clone, Debug)]
///Client for OpenSearch
///
///Version: 2021-11-23
pub struct Client {
    pub(crate) baseurl: String,
    pub(crate) client: reqwest::Client,
}

impl Client {
    /// Create a new client.
    ///
    /// `baseurl` is the base URL provided to the internal
    /// `reqwest::Client`, and should include a scheme and hostname,
    /// as well as port and a path stem if applicable.
    pub fn new(baseurl: &str) -> Self {
        #[cfg(not(target_arch = "wasm32"))]
        let client = {
            let dur = std::time::Duration::from_secs(15);
            reqwest::ClientBuilder::new()
                .connect_timeout(dur)
                .timeout(dur)
        };
        #[cfg(target_arch = "wasm32")]
        let client = reqwest::ClientBuilder::new();
        Self::new_with_client(baseurl, client.build().unwrap())
    }

    /// Construct a new client with an existing `reqwest::Client`,
    /// allowing more control over its configuration.
    ///
    /// `baseurl` is the base URL provided to the internal
    /// `reqwest::Client`, and should include a scheme and hostname,
    /// as well as port and a path stem if applicable.
    pub fn new_with_client(baseurl: &str, client: reqwest::Client) -> Self {
        Self {
            baseurl: baseurl.to_string(),
            client,
        }
    }

    /// Get the base URL to which requests are made.
    pub fn baseurl(&self) -> &String {
        &self.baseurl
    }

    /// Get the internal `reqwest::Client` used to make requests.
    pub fn client(&self) -> &reqwest::Client {
        &self.client
    }

    /// Get the version of this API.
    ///
    /// This string is pulled directly from the source OpenAPI
    /// document and may be in any format the API selects.
    pub fn api_version(&self) -> &'static str {
        "2021-11-23"
    }
}

impl Client {
    ///Returns basic information about the cluster.
    ///
    ///Sends a `GET` request to `/`
    ///
    ///```ignore
    /// let response = client.info()
    ///    .send()
    ///    .await;
    /// ```
    pub fn info(&self) -> builder::Info {
        builder::Info::new(self)
    }

    ///Returns whether the cluster is running.
    ///
    ///Sends a `HEAD` request to `/`
    ///
    ///```ignore
    /// let response = client.ping()
    ///    .send()
    ///    .await;
    /// ```
    pub fn ping(&self) -> builder::Ping {
        builder::Ping::new(self)
    }

    ///Returns an alias.
    ///
    ///Sends a `GET` request to `/_alias`
    ///
    ///Arguments:
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    ///```ignore
    /// let response = client.indices_get_alias()
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .local(local)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_get_alias(&self) -> builder::IndicesGetAlias {
        builder::IndicesGetAlias::new(self)
    }

    ///Returns an alias.
    ///
    ///Sends a `GET` request to `/_alias/{name}`
    ///
    ///Arguments:
    /// - `name`: Comma-separated list of alias names.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    ///```ignore
    /// let response = client.indices_get_alias_with_name()
    ///    .name(name)
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .local(local)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_get_alias_with_name(&self) -> builder::IndicesGetAliasWithName {
        builder::IndicesGetAliasWithName::new(self)
    }

    ///Returns information about whether a particular alias exists.
    ///
    ///Sends a `HEAD` request to `/_alias/{name}`
    ///
    ///Arguments:
    /// - `name`: Comma-separated list of alias names.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    ///```ignore
    /// let response = client.indices_exists_alias()
    ///    .name(name)
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .local(local)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_exists_alias(&self) -> builder::IndicesExistsAlias {
        builder::IndicesExistsAlias::new(self)
    }

    ///Updates index aliases.
    ///
    ///Sends a `POST` request to `/_aliases`
    ///
    ///Arguments:
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    /// - `body`
    ///```ignore
    /// let response = client.indices_update_aliases()
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_update_aliases(&self) -> builder::IndicesUpdateAliases {
        builder::IndicesUpdateAliases::new(self)
    }

    ///Performs the analysis process on a text and return the tokens breakdown
    /// of the text.
    ///
    ///Sends a `GET` request to `/_analyze`
    ///
    ///Arguments:
    /// - `index`: The name of the index to scope the operation.
    ///```ignore
    /// let response = client.indices_analyze_get()
    ///    .index(index)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_analyze_get(&self) -> builder::IndicesAnalyzeGet {
        builder::IndicesAnalyzeGet::new(self)
    }

    ///Performs the analysis process on a text and return the tokens breakdown
    /// of the text.
    ///
    ///Sends a `POST` request to `/_analyze`
    ///
    ///Arguments:
    /// - `index`: The name of the index to scope the operation.
    /// - `body`
    ///```ignore
    /// let response = client.indices_analyze_post()
    ///    .index(index)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_analyze_post(&self) -> builder::IndicesAnalyzePost {
        builder::IndicesAnalyzePost::new(self)
    }

    ///Allows to perform multiple index/update/delete operations in a single
    /// request.
    ///
    ///Sends a `PUT` request to `/_bulk`
    ///
    ///Arguments:
    /// - `source`: True or false to return the _source field or not, or default
    ///   list of fields to return, can be overridden on each sub-request.
    /// - `source_excludes`: Default list of fields to exclude from the returned
    ///   _source field, can be overridden on each sub-request.
    /// - `source_includes`: Default list of fields to extract and return from
    ///   the _source field, can be overridden on each sub-request.
    /// - `pipeline`: The pipeline id to preprocess incoming documents with.
    /// - `refresh`: If `true` then refresh the affected shards to make this
    ///   operation visible to search, if `wait_for` then wait for a refresh to
    ///   make this operation visible to search, if `false` (the default) then
    ///   do nothing with refreshes.
    /// - `require_alias`: Sets require_alias for all incoming documents.
    /// - `routing`: Routing value.
    /// - `timeout`: Operation timeout.
    /// - `type_`: Default document type for items which don't provide one.
    /// - `wait_for_active_shards`: Sets the number of shard copies that must be
    ///   active before proceeding with the operation. Defaults to 1, meaning
    ///   the primary shard only. Set to `all` for all shard copies, otherwise
    ///   set to any non-negative value less than or equal to the total number
    ///   of copies for the shard (number of replicas + 1).
    /// - `body`
    ///```ignore
    /// let response = client.bulk_put()
    ///    .source(source)
    ///    .source_excludes(source_excludes)
    ///    .source_includes(source_includes)
    ///    .pipeline(pipeline)
    ///    .refresh(refresh)
    ///    .require_alias(require_alias)
    ///    .routing(routing)
    ///    .timeout(timeout)
    ///    .type_(type_)
    ///    .wait_for_active_shards(wait_for_active_shards)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn bulk_put(&self) -> builder::BulkPut {
        builder::BulkPut::new(self)
    }

    ///Allows to perform multiple index/update/delete operations in a single
    /// request.
    ///
    ///Sends a `POST` request to `/_bulk`
    ///
    ///Arguments:
    /// - `source`: True or false to return the _source field or not, or default
    ///   list of fields to return, can be overridden on each sub-request.
    /// - `source_excludes`: Default list of fields to exclude from the returned
    ///   _source field, can be overridden on each sub-request.
    /// - `source_includes`: Default list of fields to extract and return from
    ///   the _source field, can be overridden on each sub-request.
    /// - `pipeline`: The pipeline id to preprocess incoming documents with.
    /// - `refresh`: If `true` then refresh the affected shards to make this
    ///   operation visible to search, if `wait_for` then wait for a refresh to
    ///   make this operation visible to search, if `false` (the default) then
    ///   do nothing with refreshes.
    /// - `require_alias`: Sets require_alias for all incoming documents.
    /// - `routing`: Routing value.
    /// - `timeout`: Operation timeout.
    /// - `type_`: Default document type for items which don't provide one.
    /// - `wait_for_active_shards`: Sets the number of shard copies that must be
    ///   active before proceeding with the operation. Defaults to 1, meaning
    ///   the primary shard only. Set to `all` for all shard copies, otherwise
    ///   set to any non-negative value less than or equal to the total number
    ///   of copies for the shard (number of replicas + 1).
    /// - `body`
    ///```ignore
    /// let response = client.bulk_post()
    ///    .source(source)
    ///    .source_excludes(source_excludes)
    ///    .source_includes(source_includes)
    ///    .pipeline(pipeline)
    ///    .refresh(refresh)
    ///    .require_alias(require_alias)
    ///    .routing(routing)
    ///    .timeout(timeout)
    ///    .type_(type_)
    ///    .wait_for_active_shards(wait_for_active_shards)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn bulk_post(&self) -> builder::BulkPost {
        builder::BulkPost::new(self)
    }

    ///Clears all or specific caches for one or more indices.
    ///
    ///Sends a `POST` request to `/_cache/clear`
    ///
    ///Arguments:
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `fielddata`: Clear field data.
    /// - `fields`: Comma-separated list of fields to clear when using the
    ///   `fielddata` parameter (default: all).
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `query`: Clear query caches.
    /// - `request`: Clear request cache.
    ///```ignore
    /// let response = client.indices_clear_cache()
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .fielddata(fielddata)
    ///    .fields(fields)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .index(index)
    ///    .query(query)
    ///    .request(request)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_clear_cache(&self) -> builder::IndicesClearCache {
        builder::IndicesClearCache::new(self)
    }

    ///Returns help for the Cat APIs.
    ///
    ///Sends a `GET` request to `/_cat`
    ///
    ///Arguments:
    /// - `help`: Return help information.
    /// - `s`: Comma-separated list of column names or column aliases to sort
    ///   by.
    ///```ignore
    /// let response = client.cat_help()
    ///    .help(help)
    ///    .s(s)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cat_help(&self) -> builder::CatHelp {
        builder::CatHelp::new(self)
    }

    ///Shows information about currently configured aliases to indices
    /// including filter and routing infos.
    ///
    ///Sends a `GET` request to `/_cat/aliases`
    ///
    ///Arguments:
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `format`: A short version of the Accept header, e.g. json, yaml.
    /// - `h`: Comma-separated list of column names to display.
    /// - `help`: Return help information.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `s`: Comma-separated list of column names or column aliases to sort
    ///   by.
    /// - `v`: Verbose mode. Display column headers.
    ///```ignore
    /// let response = client.cat_aliases()
    ///    .expand_wildcards(expand_wildcards)
    ///    .format(format)
    ///    .h(h)
    ///    .help(help)
    ///    .local(local)
    ///    .s(s)
    ///    .v(v)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cat_aliases(&self) -> builder::CatAliases {
        builder::CatAliases::new(self)
    }

    ///Shows information about currently configured aliases to indices
    /// including filter and routing infos.
    ///
    ///Sends a `GET` request to `/_cat/aliases/{name}`
    ///
    ///Arguments:
    /// - `name`: Comma-separated list of alias names.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `format`: A short version of the Accept header, e.g. json, yaml.
    /// - `h`: Comma-separated list of column names to display.
    /// - `help`: Return help information.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `s`: Comma-separated list of column names or column aliases to sort
    ///   by.
    /// - `v`: Verbose mode. Display column headers.
    ///```ignore
    /// let response = client.cat_aliases_with_name()
    ///    .name(name)
    ///    .expand_wildcards(expand_wildcards)
    ///    .format(format)
    ///    .h(h)
    ///    .help(help)
    ///    .local(local)
    ///    .s(s)
    ///    .v(v)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cat_aliases_with_name(&self) -> builder::CatAliasesWithName {
        builder::CatAliasesWithName::new(self)
    }

    ///Provides a snapshot of how many shards are allocated to each data node
    /// and how much disk space they are using.
    ///
    ///Sends a `GET` request to `/_cat/allocation`
    ///
    ///Arguments:
    /// - `bytes`: The unit in which to display byte values.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `format`: A short version of the Accept header, e.g. json, yaml.
    /// - `h`: Comma-separated list of column names to display.
    /// - `help`: Return help information.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `s`: Comma-separated list of column names or column aliases to sort
    ///   by.
    /// - `v`: Verbose mode. Display column headers.
    ///```ignore
    /// let response = client.cat_allocation()
    ///    .bytes(bytes)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .format(format)
    ///    .h(h)
    ///    .help(help)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .s(s)
    ///    .v(v)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cat_allocation(&self) -> builder::CatAllocation {
        builder::CatAllocation::new(self)
    }

    ///Provides a snapshot of how many shards are allocated to each data node
    /// and how much disk space they are using.
    ///
    ///Sends a `GET` request to `/_cat/allocation/{node_id}`
    ///
    ///Arguments:
    /// - `node_id`: Comma-separated list of node IDs or names to limit the
    ///   returned information.
    /// - `bytes`: The unit in which to display byte values.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `format`: A short version of the Accept header, e.g. json, yaml.
    /// - `h`: Comma-separated list of column names to display.
    /// - `help`: Return help information.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `s`: Comma-separated list of column names or column aliases to sort
    ///   by.
    /// - `v`: Verbose mode. Display column headers.
    ///```ignore
    /// let response = client.cat_allocation_with_node_id()
    ///    .node_id(node_id)
    ///    .bytes(bytes)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .format(format)
    ///    .h(h)
    ///    .help(help)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .s(s)
    ///    .v(v)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cat_allocation_with_node_id(&self) -> builder::CatAllocationWithNodeId {
        builder::CatAllocationWithNodeId::new(self)
    }

    ///Returns information about the cluster-manager node.
    ///
    ///Sends a `GET` request to `/_cat/cluster_manager`
    ///
    ///Arguments:
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `format`: A short version of the Accept header, e.g. json, yaml.
    /// - `h`: Comma-separated list of column names to display.
    /// - `help`: Return help information.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `s`: Comma-separated list of column names or column aliases to sort
    ///   by.
    /// - `v`: Verbose mode. Display column headers.
    ///```ignore
    /// let response = client.cat_cluster_manager()
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .format(format)
    ///    .h(h)
    ///    .help(help)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .s(s)
    ///    .v(v)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cat_cluster_manager(&self) -> builder::CatClusterManager {
        builder::CatClusterManager::new(self)
    }

    ///Provides quick access to the document count of the entire cluster, or
    /// individual indices.
    ///
    ///Sends a `GET` request to `/_cat/count`
    ///
    ///Arguments:
    /// - `format`: A short version of the Accept header, e.g. json, yaml.
    /// - `h`: Comma-separated list of column names to display.
    /// - `help`: Return help information.
    /// - `s`: Comma-separated list of column names or column aliases to sort
    ///   by.
    /// - `v`: Verbose mode. Display column headers.
    ///```ignore
    /// let response = client.cat_count()
    ///    .format(format)
    ///    .h(h)
    ///    .help(help)
    ///    .s(s)
    ///    .v(v)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cat_count(&self) -> builder::CatCount {
        builder::CatCount::new(self)
    }

    ///Provides quick access to the document count of the entire cluster, or
    /// individual indices.
    ///
    ///Sends a `GET` request to `/_cat/count/{index}`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices to limit the returned
    ///   information.
    /// - `format`: A short version of the Accept header, e.g. json, yaml.
    /// - `h`: Comma-separated list of column names to display.
    /// - `help`: Return help information.
    /// - `s`: Comma-separated list of column names or column aliases to sort
    ///   by.
    /// - `v`: Verbose mode. Display column headers.
    ///```ignore
    /// let response = client.cat_count_with_index()
    ///    .index(index)
    ///    .format(format)
    ///    .h(h)
    ///    .help(help)
    ///    .s(s)
    ///    .v(v)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cat_count_with_index(&self) -> builder::CatCountWithIndex {
        builder::CatCountWithIndex::new(self)
    }

    ///Shows how much heap memory is currently being used by fielddata on every
    /// data node in the cluster.
    ///
    ///Sends a `GET` request to `/_cat/fielddata`
    ///
    ///Arguments:
    /// - `bytes`: The unit in which to display byte values.
    /// - `fields`: Comma-separated list of fields to return in the output.
    /// - `format`: A short version of the Accept header, e.g. json, yaml.
    /// - `h`: Comma-separated list of column names to display.
    /// - `help`: Return help information.
    /// - `s`: Comma-separated list of column names or column aliases to sort
    ///   by.
    /// - `v`: Verbose mode. Display column headers.
    ///```ignore
    /// let response = client.cat_fielddata()
    ///    .bytes(bytes)
    ///    .fields(fields)
    ///    .format(format)
    ///    .h(h)
    ///    .help(help)
    ///    .s(s)
    ///    .v(v)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cat_fielddata(&self) -> builder::CatFielddata {
        builder::CatFielddata::new(self)
    }

    ///Shows how much heap memory is currently being used by fielddata on every
    /// data node in the cluster.
    ///
    ///Sends a `GET` request to `/_cat/fielddata/{fields}`
    ///
    ///Arguments:
    /// - `bytes`: The unit in which to display byte values.
    /// - `fields`: Comma-separated list of fields to return in the output.
    /// - `format`: A short version of the Accept header, e.g. json, yaml.
    /// - `h`: Comma-separated list of column names to display.
    /// - `help`: Return help information.
    /// - `s`: Comma-separated list of column names or column aliases to sort
    ///   by.
    /// - `v`: Verbose mode. Display column headers.
    ///```ignore
    /// let response = client.cat_fielddata_with_fields()
    ///    .bytes(bytes)
    ///    .fields(fields)
    ///    .format(format)
    ///    .h(h)
    ///    .help(help)
    ///    .s(s)
    ///    .v(v)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cat_fielddata_with_fields(&self) -> builder::CatFielddataWithFields {
        builder::CatFielddataWithFields::new(self)
    }

    ///Returns a concise representation of the cluster health.
    ///
    ///Sends a `GET` request to `/_cat/health`
    ///
    ///Arguments:
    /// - `format`: A short version of the Accept header, e.g. json, yaml.
    /// - `h`: Comma-separated list of column names to display.
    /// - `help`: Return help information.
    /// - `s`: Comma-separated list of column names or column aliases to sort
    ///   by.
    /// - `time`: The unit in which to display time values.
    /// - `ts`: Set to false to disable timestamping.
    /// - `v`: Verbose mode. Display column headers.
    ///```ignore
    /// let response = client.cat_health()
    ///    .format(format)
    ///    .h(h)
    ///    .help(help)
    ///    .s(s)
    ///    .time(time)
    ///    .ts(ts)
    ///    .v(v)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cat_health(&self) -> builder::CatHealth {
        builder::CatHealth::new(self)
    }

    ///Returns information about indices: number of primaries and replicas,
    /// document counts, disk size, ...
    ///
    ///Sends a `GET` request to `/_cat/indices`
    ///
    ///Arguments:
    /// - `bytes`: The unit in which to display byte values.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `format`: A short version of the Accept header, e.g. json, yaml.
    /// - `h`: Comma-separated list of column names to display.
    /// - `health`: Health status ('green', 'yellow', or 'red') to filter only
    ///   indices matching the specified health status.
    /// - `help`: Return help information.
    /// - `include_unloaded_segments`: If set to true segment stats will include
    ///   stats for segments that are not currently loaded into memory.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `pri`: Set to true to return stats only for primary shards.
    /// - `s`: Comma-separated list of column names or column aliases to sort
    ///   by.
    /// - `time`: The unit in which to display time values.
    /// - `v`: Verbose mode. Display column headers.
    ///```ignore
    /// let response = client.cat_indices()
    ///    .bytes(bytes)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .expand_wildcards(expand_wildcards)
    ///    .format(format)
    ///    .h(h)
    ///    .health(health)
    ///    .help(help)
    ///    .include_unloaded_segments(include_unloaded_segments)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .pri(pri)
    ///    .s(s)
    ///    .time(time)
    ///    .v(v)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cat_indices(&self) -> builder::CatIndices {
        builder::CatIndices::new(self)
    }

    ///Returns information about indices: number of primaries and replicas,
    /// document counts, disk size, ...
    ///
    ///Sends a `GET` request to `/_cat/indices/{index}`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices to limit the returned
    ///   information.
    /// - `bytes`: The unit in which to display byte values.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `format`: A short version of the Accept header, e.g. json, yaml.
    /// - `h`: Comma-separated list of column names to display.
    /// - `health`: Health status ('green', 'yellow', or 'red') to filter only
    ///   indices matching the specified health status.
    /// - `help`: Return help information.
    /// - `include_unloaded_segments`: If set to true segment stats will include
    ///   stats for segments that are not currently loaded into memory.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `pri`: Set to true to return stats only for primary shards.
    /// - `s`: Comma-separated list of column names or column aliases to sort
    ///   by.
    /// - `time`: The unit in which to display time values.
    /// - `v`: Verbose mode. Display column headers.
    ///```ignore
    /// let response = client.cat_indices_with_index()
    ///    .index(index)
    ///    .bytes(bytes)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .expand_wildcards(expand_wildcards)
    ///    .format(format)
    ///    .h(h)
    ///    .health(health)
    ///    .help(help)
    ///    .include_unloaded_segments(include_unloaded_segments)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .pri(pri)
    ///    .s(s)
    ///    .time(time)
    ///    .v(v)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cat_indices_with_index(&self) -> builder::CatIndicesWithIndex {
        builder::CatIndicesWithIndex::new(self)
    }

    ///Returns information about the cluster-manager node.
    ///
    ///Sends a `GET` request to `/_cat/master`
    ///
    ///Arguments:
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `format`: A short version of the Accept header, e.g. json, yaml.
    /// - `h`: Comma-separated list of column names to display.
    /// - `help`: Return help information.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `s`: Comma-separated list of column names or column aliases to sort
    ///   by.
    /// - `v`: Verbose mode. Display column headers.
    ///```ignore
    /// let response = client.cat_master()
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .format(format)
    ///    .h(h)
    ///    .help(help)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .s(s)
    ///    .v(v)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cat_master(&self) -> builder::CatMaster {
        builder::CatMaster::new(self)
    }

    ///Returns information about custom node attributes.
    ///
    ///Sends a `GET` request to `/_cat/nodeattrs`
    ///
    ///Arguments:
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `format`: A short version of the Accept header, e.g. json, yaml.
    /// - `h`: Comma-separated list of column names to display.
    /// - `help`: Return help information.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `s`: Comma-separated list of column names or column aliases to sort
    ///   by.
    /// - `v`: Verbose mode. Display column headers.
    ///```ignore
    /// let response = client.cat_nodeattrs()
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .format(format)
    ///    .h(h)
    ///    .help(help)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .s(s)
    ///    .v(v)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cat_nodeattrs(&self) -> builder::CatNodeattrs {
        builder::CatNodeattrs::new(self)
    }

    ///Returns basic statistics about performance of cluster nodes.
    ///
    ///Sends a `GET` request to `/_cat/nodes`
    ///
    ///Arguments:
    /// - `bytes`: The unit in which to display byte values.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `format`: A short version of the Accept header, e.g. json, yaml.
    /// - `full_id`: Return the full node ID instead of the shortened version.
    /// - `h`: Comma-separated list of column names to display.
    /// - `help`: Return help information.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `s`: Comma-separated list of column names or column aliases to sort
    ///   by.
    /// - `time`: The unit in which to display time values.
    /// - `v`: Verbose mode. Display column headers.
    ///```ignore
    /// let response = client.cat_nodes()
    ///    .bytes(bytes)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .format(format)
    ///    .full_id(full_id)
    ///    .h(h)
    ///    .help(help)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .s(s)
    ///    .time(time)
    ///    .v(v)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cat_nodes(&self) -> builder::CatNodes {
        builder::CatNodes::new(self)
    }

    ///Returns a concise representation of the cluster pending tasks.
    ///
    ///Sends a `GET` request to `/_cat/pending_tasks`
    ///
    ///Arguments:
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `format`: A short version of the Accept header, e.g. json, yaml.
    /// - `h`: Comma-separated list of column names to display.
    /// - `help`: Return help information.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `s`: Comma-separated list of column names or column aliases to sort
    ///   by.
    /// - `time`: The unit in which to display time values.
    /// - `v`: Verbose mode. Display column headers.
    ///```ignore
    /// let response = client.cat_pending_tasks()
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .format(format)
    ///    .h(h)
    ///    .help(help)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .s(s)
    ///    .time(time)
    ///    .v(v)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cat_pending_tasks(&self) -> builder::CatPendingTasks {
        builder::CatPendingTasks::new(self)
    }

    ///List segments for one or several PITs.
    ///
    ///Sends a `GET` request to `/_cat/pit_segments`
    ///
    ///```ignore
    /// let response = client.cat_pit_segments()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cat_pit_segments(&self) -> builder::CatPitSegments {
        builder::CatPitSegments::new(self)
    }

    ///Lists all active point-in-time segments.
    ///
    ///Sends a `GET` request to `/_cat/pit_segments/_all`
    ///
    ///```ignore
    /// let response = client.cat_all_pit_segments()
    ///    .send()
    ///    .await;
    /// ```
    pub fn cat_all_pit_segments(&self) -> builder::CatAllPitSegments {
        builder::CatAllPitSegments::new(self)
    }

    ///Returns information about installed plugins across nodes node.
    ///
    ///Sends a `GET` request to `/_cat/plugins`
    ///
    ///Arguments:
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `format`: A short version of the Accept header, e.g. json, yaml.
    /// - `h`: Comma-separated list of column names to display.
    /// - `help`: Return help information.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `s`: Comma-separated list of column names or column aliases to sort
    ///   by.
    /// - `v`: Verbose mode. Display column headers.
    ///```ignore
    /// let response = client.cat_plugins()
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .format(format)
    ///    .h(h)
    ///    .help(help)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .s(s)
    ///    .v(v)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cat_plugins(&self) -> builder::CatPlugins {
        builder::CatPlugins::new(self)
    }

    ///Returns information about index shard recoveries, both on-going
    /// completed.
    ///
    ///Sends a `GET` request to `/_cat/recovery`
    ///
    ///Arguments:
    /// - `active_only`: If `true`, the response only includes ongoing shard
    ///   recoveries.
    /// - `bytes`: The unit in which to display byte values.
    /// - `detailed`: If `true`, the response includes detailed information
    ///   about shard recoveries.
    /// - `format`: A short version of the Accept header, e.g. json, yaml.
    /// - `h`: Comma-separated list of column names to display.
    /// - `help`: Return help information.
    /// - `index`: Comma-separated list or wildcard expression of index names to
    ///   limit the returned information.
    /// - `s`: Comma-separated list of column names or column aliases to sort
    ///   by.
    /// - `time`: The unit in which to display time values.
    /// - `v`: Verbose mode. Display column headers.
    ///```ignore
    /// let response = client.cat_recovery()
    ///    .active_only(active_only)
    ///    .bytes(bytes)
    ///    .detailed(detailed)
    ///    .format(format)
    ///    .h(h)
    ///    .help(help)
    ///    .index(index)
    ///    .s(s)
    ///    .time(time)
    ///    .v(v)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cat_recovery(&self) -> builder::CatRecovery {
        builder::CatRecovery::new(self)
    }

    ///Returns information about index shard recoveries, both on-going
    /// completed.
    ///
    ///Sends a `GET` request to `/_cat/recovery/{index}`
    ///
    ///Arguments:
    /// - `active_only`: If `true`, the response only includes ongoing shard
    ///   recoveries.
    /// - `bytes`: The unit in which to display byte values.
    /// - `detailed`: If `true`, the response includes detailed information
    ///   about shard recoveries.
    /// - `format`: A short version of the Accept header, e.g. json, yaml.
    /// - `h`: Comma-separated list of column names to display.
    /// - `help`: Return help information.
    /// - `index`: Comma-separated list or wildcard expression of index names to
    ///   limit the returned information.
    /// - `s`: Comma-separated list of column names or column aliases to sort
    ///   by.
    /// - `time`: The unit in which to display time values.
    /// - `v`: Verbose mode. Display column headers.
    ///```ignore
    /// let response = client.cat_recovery_with_index()
    ///    .active_only(active_only)
    ///    .bytes(bytes)
    ///    .detailed(detailed)
    ///    .format(format)
    ///    .h(h)
    ///    .help(help)
    ///    .index(index)
    ///    .s(s)
    ///    .time(time)
    ///    .v(v)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cat_recovery_with_index(&self) -> builder::CatRecoveryWithIndex {
        builder::CatRecoveryWithIndex::new(self)
    }

    ///Returns information about snapshot repositories registered in the
    /// cluster.
    ///
    ///Sends a `GET` request to `/_cat/repositories`
    ///
    ///Arguments:
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `format`: A short version of the Accept header, e.g. json, yaml.
    /// - `h`: Comma-separated list of column names to display.
    /// - `help`: Return help information.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `s`: Comma-separated list of column names or column aliases to sort
    ///   by.
    /// - `v`: Verbose mode. Display column headers.
    ///```ignore
    /// let response = client.cat_repositories()
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .format(format)
    ///    .h(h)
    ///    .help(help)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .s(s)
    ///    .v(v)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cat_repositories(&self) -> builder::CatRepositories {
        builder::CatRepositories::new(self)
    }

    ///Returns information about both on-going and latest completed Segment
    /// Replication events.
    ///
    ///Sends a `GET` request to `/_cat/segment_replication`
    ///
    ///Arguments:
    /// - `active_only`: If `true`, the response only includes ongoing segment
    ///   replication events.
    /// - `bytes`: The unit in which to display byte values.
    /// - `completed_only`: If `true`, the response only includes latest
    ///   completed segment replication events.
    /// - `detailed`: If `true`, the response includes detailed information
    ///   about segment replications.
    /// - `format`: A short version of the Accept header, e.g. json, yaml.
    /// - `h`: Comma-separated list of column names to display.
    /// - `help`: Return help information.
    /// - `index`: Comma-separated list or wildcard expression of index names to
    ///   limit the returned information.
    /// - `s`: Comma-separated list of column names or column aliases to sort
    ///   by.
    /// - `shards`: Comma-separated list of shards to display.
    /// - `time`: The unit in which to display time values.
    /// - `v`: Verbose mode. Display column headers.
    ///```ignore
    /// let response = client.cat_segment_replication()
    ///    .active_only(active_only)
    ///    .bytes(bytes)
    ///    .completed_only(completed_only)
    ///    .detailed(detailed)
    ///    .format(format)
    ///    .h(h)
    ///    .help(help)
    ///    .index(index)
    ///    .s(s)
    ///    .shards(shards)
    ///    .time(time)
    ///    .v(v)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cat_segment_replication(&self) -> builder::CatSegmentReplication {
        builder::CatSegmentReplication::new(self)
    }

    ///Returns information about both on-going and latest completed Segment
    /// Replication events.
    ///
    ///Sends a `GET` request to `/_cat/segment_replication/{index}`
    ///
    ///Arguments:
    /// - `active_only`: If `true`, the response only includes ongoing segment
    ///   replication events.
    /// - `bytes`: The unit in which to display byte values.
    /// - `completed_only`: If `true`, the response only includes latest
    ///   completed segment replication events.
    /// - `detailed`: If `true`, the response includes detailed information
    ///   about segment replications.
    /// - `format`: A short version of the Accept header, e.g. json, yaml.
    /// - `h`: Comma-separated list of column names to display.
    /// - `help`: Return help information.
    /// - `index`: Comma-separated list or wildcard expression of index names to
    ///   limit the returned information.
    /// - `s`: Comma-separated list of column names or column aliases to sort
    ///   by.
    /// - `shards`: Comma-separated list of shards to display.
    /// - `time`: The unit in which to display time values.
    /// - `v`: Verbose mode. Display column headers.
    ///```ignore
    /// let response = client.cat_segment_replication_with_index()
    ///    .active_only(active_only)
    ///    .bytes(bytes)
    ///    .completed_only(completed_only)
    ///    .detailed(detailed)
    ///    .format(format)
    ///    .h(h)
    ///    .help(help)
    ///    .index(index)
    ///    .s(s)
    ///    .shards(shards)
    ///    .time(time)
    ///    .v(v)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cat_segment_replication_with_index(&self) -> builder::CatSegmentReplicationWithIndex {
        builder::CatSegmentReplicationWithIndex::new(self)
    }

    ///Provides low-level information about the segments in the shards of an
    /// index.
    ///
    ///Sends a `GET` request to `/_cat/segments`
    ///
    ///Arguments:
    /// - `bytes`: The unit in which to display byte values.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `format`: A short version of the Accept header, e.g. json, yaml.
    /// - `h`: Comma-separated list of column names to display.
    /// - `help`: Return help information.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `s`: Comma-separated list of column names or column aliases to sort
    ///   by.
    /// - `v`: Verbose mode. Display column headers.
    ///```ignore
    /// let response = client.cat_segments()
    ///    .bytes(bytes)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .format(format)
    ///    .h(h)
    ///    .help(help)
    ///    .master_timeout(master_timeout)
    ///    .s(s)
    ///    .v(v)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cat_segments(&self) -> builder::CatSegments {
        builder::CatSegments::new(self)
    }

    ///Provides low-level information about the segments in the shards of an
    /// index.
    ///
    ///Sends a `GET` request to `/_cat/segments/{index}`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices to limit the returned
    ///   information.
    /// - `bytes`: The unit in which to display byte values.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `format`: A short version of the Accept header, e.g. json, yaml.
    /// - `h`: Comma-separated list of column names to display.
    /// - `help`: Return help information.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `s`: Comma-separated list of column names or column aliases to sort
    ///   by.
    /// - `v`: Verbose mode. Display column headers.
    ///```ignore
    /// let response = client.cat_segments_with_index()
    ///    .index(index)
    ///    .bytes(bytes)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .format(format)
    ///    .h(h)
    ///    .help(help)
    ///    .master_timeout(master_timeout)
    ///    .s(s)
    ///    .v(v)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cat_segments_with_index(&self) -> builder::CatSegmentsWithIndex {
        builder::CatSegmentsWithIndex::new(self)
    }

    ///Provides a detailed view of shard allocation on nodes.
    ///
    ///Sends a `GET` request to `/_cat/shards`
    ///
    ///Arguments:
    /// - `bytes`: The unit in which to display byte values.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `format`: A short version of the Accept header, e.g. json, yaml.
    /// - `h`: Comma-separated list of column names to display.
    /// - `help`: Return help information.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `s`: Comma-separated list of column names or column aliases to sort
    ///   by.
    /// - `time`: The unit in which to display time values.
    /// - `v`: Verbose mode. Display column headers.
    ///```ignore
    /// let response = client.cat_shards()
    ///    .bytes(bytes)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .format(format)
    ///    .h(h)
    ///    .help(help)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .s(s)
    ///    .time(time)
    ///    .v(v)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cat_shards(&self) -> builder::CatShards {
        builder::CatShards::new(self)
    }

    ///Provides a detailed view of shard allocation on nodes.
    ///
    ///Sends a `GET` request to `/_cat/shards/{index}`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices to limit the returned
    ///   information.
    /// - `bytes`: The unit in which to display byte values.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `format`: A short version of the Accept header, e.g. json, yaml.
    /// - `h`: Comma-separated list of column names to display.
    /// - `help`: Return help information.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `s`: Comma-separated list of column names or column aliases to sort
    ///   by.
    /// - `time`: The unit in which to display time values.
    /// - `v`: Verbose mode. Display column headers.
    ///```ignore
    /// let response = client.cat_shards_with_index()
    ///    .index(index)
    ///    .bytes(bytes)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .format(format)
    ///    .h(h)
    ///    .help(help)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .s(s)
    ///    .time(time)
    ///    .v(v)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cat_shards_with_index(&self) -> builder::CatShardsWithIndex {
        builder::CatShardsWithIndex::new(self)
    }

    ///Returns all snapshots in a specific repository.
    ///
    ///Sends a `GET` request to `/_cat/snapshots`
    ///
    ///Arguments:
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `format`: A short version of the Accept header, e.g. json, yaml.
    /// - `h`: Comma-separated list of column names to display.
    /// - `help`: Return help information.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `s`: Comma-separated list of column names or column aliases to sort
    ///   by.
    /// - `time`: The unit in which to display time values.
    /// - `v`: Verbose mode. Display column headers.
    ///```ignore
    /// let response = client.cat_snapshots()
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .format(format)
    ///    .h(h)
    ///    .help(help)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .master_timeout(master_timeout)
    ///    .s(s)
    ///    .time(time)
    ///    .v(v)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cat_snapshots(&self) -> builder::CatSnapshots {
        builder::CatSnapshots::new(self)
    }

    ///Returns all snapshots in a specific repository.
    ///
    ///Sends a `GET` request to `/_cat/snapshots/{repository}`
    ///
    ///Arguments:
    /// - `repository`: Comma-separated list of repository names.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `format`: A short version of the Accept header, e.g. json, yaml.
    /// - `h`: Comma-separated list of column names to display.
    /// - `help`: Return help information.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `s`: Comma-separated list of column names or column aliases to sort
    ///   by.
    /// - `time`: The unit in which to display time values.
    /// - `v`: Verbose mode. Display column headers.
    ///```ignore
    /// let response = client.cat_snapshots_with_repository()
    ///    .repository(repository)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .format(format)
    ///    .h(h)
    ///    .help(help)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .master_timeout(master_timeout)
    ///    .s(s)
    ///    .time(time)
    ///    .v(v)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cat_snapshots_with_repository(&self) -> builder::CatSnapshotsWithRepository {
        builder::CatSnapshotsWithRepository::new(self)
    }

    ///Returns information about the tasks currently executing on one or more
    /// nodes in the cluster.
    ///
    ///Sends a `GET` request to `/_cat/tasks`
    ///
    ///Arguments:
    /// - `actions`: Comma-separated list of actions that should be returned.
    ///   Leave empty to return all.
    /// - `detailed`: Return detailed task information.
    /// - `format`: A short version of the Accept header, e.g. json, yaml.
    /// - `h`: Comma-separated list of column names to display.
    /// - `help`: Return help information.
    /// - `nodes`: Comma-separated list of node IDs or names to limit the
    ///   returned information; use `_local` to return information from the node
    ///   you're connecting to, leave empty to get information from all nodes.
    /// - `parent_task_id`: Return tasks with specified parent task id
    ///   (node_id:task_number). Set to -1 to return all.
    /// - `s`: Comma-separated list of column names or column aliases to sort
    ///   by.
    /// - `time`: The unit in which to display time values.
    /// - `v`: Verbose mode. Display column headers.
    ///```ignore
    /// let response = client.cat_tasks()
    ///    .actions(actions)
    ///    .detailed(detailed)
    ///    .format(format)
    ///    .h(h)
    ///    .help(help)
    ///    .nodes(nodes)
    ///    .parent_task_id(parent_task_id)
    ///    .s(s)
    ///    .time(time)
    ///    .v(v)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cat_tasks(&self) -> builder::CatTasks {
        builder::CatTasks::new(self)
    }

    ///Returns information about existing templates.
    ///
    ///Sends a `GET` request to `/_cat/templates`
    ///
    ///Arguments:
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `format`: A short version of the Accept header, e.g. json, yaml.
    /// - `h`: Comma-separated list of column names to display.
    /// - `help`: Return help information.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `s`: Comma-separated list of column names or column aliases to sort
    ///   by.
    /// - `v`: Verbose mode. Display column headers.
    ///```ignore
    /// let response = client.cat_templates()
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .format(format)
    ///    .h(h)
    ///    .help(help)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .s(s)
    ///    .v(v)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cat_templates(&self) -> builder::CatTemplates {
        builder::CatTemplates::new(self)
    }

    ///Returns information about existing templates.
    ///
    ///Sends a `GET` request to `/_cat/templates/{name}`
    ///
    ///Arguments:
    /// - `name`: The name of the template.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `format`: A short version of the Accept header, e.g. json, yaml.
    /// - `h`: Comma-separated list of column names to display.
    /// - `help`: Return help information.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `s`: Comma-separated list of column names or column aliases to sort
    ///   by.
    /// - `v`: Verbose mode. Display column headers.
    ///```ignore
    /// let response = client.cat_templates_with_name()
    ///    .name(name)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .format(format)
    ///    .h(h)
    ///    .help(help)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .s(s)
    ///    .v(v)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cat_templates_with_name(&self) -> builder::CatTemplatesWithName {
        builder::CatTemplatesWithName::new(self)
    }

    ///Returns cluster-wide thread pool statistics per node.
    ///By default the active, queue and rejected statistics are returned for
    /// all thread pools.
    ///
    ///Sends a `GET` request to `/_cat/thread_pool`
    ///
    ///Arguments:
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `format`: A short version of the Accept header, e.g. json, yaml.
    /// - `h`: Comma-separated list of column names to display.
    /// - `help`: Return help information.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `s`: Comma-separated list of column names or column aliases to sort
    ///   by.
    /// - `size`: The multiplier in which to display values.
    /// - `v`: Verbose mode. Display column headers.
    ///```ignore
    /// let response = client.cat_thread_pool()
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .format(format)
    ///    .h(h)
    ///    .help(help)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .s(s)
    ///    .size(size)
    ///    .v(v)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cat_thread_pool(&self) -> builder::CatThreadPool {
        builder::CatThreadPool::new(self)
    }

    ///Returns cluster-wide thread pool statistics per node.
    ///By default the active, queue and rejected statistics are returned for
    /// all thread pools.
    ///
    ///Sends a `GET` request to `/_cat/thread_pool/{thread_pool_patterns}`
    ///
    ///Arguments:
    /// - `thread_pool_patterns`: Comma-separated list of regular-expressions to
    ///   filter the thread pools in the output.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `format`: A short version of the Accept header, e.g. json, yaml.
    /// - `h`: Comma-separated list of column names to display.
    /// - `help`: Return help information.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `s`: Comma-separated list of column names or column aliases to sort
    ///   by.
    /// - `size`: The multiplier in which to display values.
    /// - `v`: Verbose mode. Display column headers.
    ///```ignore
    /// let response = client.cat_thread_pool_with_thread_pool_patterns()
    ///    .thread_pool_patterns(thread_pool_patterns)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .format(format)
    ///    .h(h)
    ///    .help(help)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .s(s)
    ///    .size(size)
    ///    .v(v)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cat_thread_pool_with_thread_pool_patterns(
        &self,
    ) -> builder::CatThreadPoolWithThreadPoolPatterns {
        builder::CatThreadPoolWithThreadPoolPatterns::new(self)
    }

    ///Provides explanations for shard allocations in the cluster.
    ///
    ///Sends a `GET` request to `/_cluster/allocation/explain`
    ///
    ///Arguments:
    /// - `include_disk_info`: Return information about disk usage and shard
    ///   sizes.
    /// - `include_yes_decisions`: Return 'YES' decisions in explanation.
    ///```ignore
    /// let response = client.cluster_allocation_explain_get()
    ///    .include_disk_info(include_disk_info)
    ///    .include_yes_decisions(include_yes_decisions)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cluster_allocation_explain_get(&self) -> builder::ClusterAllocationExplainGet {
        builder::ClusterAllocationExplainGet::new(self)
    }

    ///Provides explanations for shard allocations in the cluster.
    ///
    ///Sends a `POST` request to `/_cluster/allocation/explain`
    ///
    ///Arguments:
    /// - `include_disk_info`: Return information about disk usage and shard
    ///   sizes.
    /// - `include_yes_decisions`: Return 'YES' decisions in explanation.
    /// - `body`
    ///```ignore
    /// let response = client.cluster_allocation_explain_post()
    ///    .include_disk_info(include_disk_info)
    ///    .include_yes_decisions(include_yes_decisions)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cluster_allocation_explain_post(&self) -> builder::ClusterAllocationExplainPost {
        builder::ClusterAllocationExplainPost::new(self)
    }

    ///Delete any existing decommission.
    ///
    ///Sends a `DELETE` request to `/_cluster/decommission/awareness/`
    ///
    ///```ignore
    /// let response = client.cluster_delete_decommission_awareness()
    ///    .send()
    ///    .await;
    /// ```
    pub fn cluster_delete_decommission_awareness(
        &self,
    ) -> builder::ClusterDeleteDecommissionAwareness {
        builder::ClusterDeleteDecommissionAwareness::new(self)
    }

    ///Get details and status of decommissioned attribute.
    ///
    ///Sends a `GET` request to
    /// `/_cluster/decommission/awareness/{awareness_attribute_name}/_status`
    ///
    ///Arguments:
    /// - `awareness_attribute_name`: Awareness attribute name.
    ///```ignore
    /// let response = client.cluster_get_decommission_awareness()
    ///    .awareness_attribute_name(awareness_attribute_name)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cluster_get_decommission_awareness(&self) -> builder::ClusterGetDecommissionAwareness {
        builder::ClusterGetDecommissionAwareness::new(self)
    }

    ///Decommissions an awareness attribute.
    ///
    ///Sends a `PUT` request to
    /// `/_cluster/decommission/awareness/{awareness_attribute_name}/
    /// {awareness_attribute_value}`
    ///
    ///Arguments:
    /// - `awareness_attribute_name`: Awareness attribute name.
    /// - `awareness_attribute_value`: Awareness attribute value.
    ///```ignore
    /// let response = client.cluster_put_decommission_awareness()
    ///    .awareness_attribute_name(awareness_attribute_name)
    ///    .awareness_attribute_value(awareness_attribute_value)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cluster_put_decommission_awareness(&self) -> builder::ClusterPutDecommissionAwareness {
        builder::ClusterPutDecommissionAwareness::new(self)
    }

    ///Returns basic information about the health of the cluster.
    ///
    ///Sends a `GET` request to `/_cluster/health`
    ///
    ///Arguments:
    /// - `awareness_attribute`: The awareness attribute for which the health is
    ///   required.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `ensure_node_commissioned`: Checks whether local node is commissioned
    ///   or not. If set to true on a local call it will throw exception if node
    ///   is decommissioned.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `level`: Specify the level of detail for returned information.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    /// - `wait_for_active_shards`: Wait until the specified number of shards is
    ///   active.
    /// - `wait_for_events`: Wait until all currently queued events with the
    ///   given priority are processed.
    /// - `wait_for_no_initializing_shards`: Whether to wait until there are no
    ///   initializing shards in the cluster.
    /// - `wait_for_no_relocating_shards`: Whether to wait until there are no
    ///   relocating shards in the cluster.
    /// - `wait_for_nodes`: Wait until the specified number of nodes is
    ///   available.
    /// - `wait_for_status`: Wait until cluster is in a specific state.
    ///```ignore
    /// let response = client.cluster_health()
    ///    .awareness_attribute(awareness_attribute)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .ensure_node_commissioned(ensure_node_commissioned)
    ///    .expand_wildcards(expand_wildcards)
    ///    .level(level)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .wait_for_active_shards(wait_for_active_shards)
    ///    .wait_for_events(wait_for_events)
    ///    .wait_for_no_initializing_shards(wait_for_no_initializing_shards)
    ///    .wait_for_no_relocating_shards(wait_for_no_relocating_shards)
    ///    .wait_for_nodes(wait_for_nodes)
    ///    .wait_for_status(wait_for_status)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cluster_health(&self) -> builder::ClusterHealth {
        builder::ClusterHealth::new(self)
    }

    ///Returns basic information about the health of the cluster.
    ///
    ///Sends a `GET` request to `/_cluster/health/{index}`
    ///
    ///Arguments:
    /// - `index`: Limit the information returned to specific indicies.
    /// - `awareness_attribute`: The awareness attribute for which the health is
    ///   required.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `ensure_node_commissioned`: Checks whether local node is commissioned
    ///   or not. If set to true on a local call it will throw exception if node
    ///   is decommissioned.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `level`: Specify the level of detail for returned information.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    /// - `wait_for_active_shards`: Wait until the specified number of shards is
    ///   active.
    /// - `wait_for_events`: Wait until all currently queued events with the
    ///   given priority are processed.
    /// - `wait_for_no_initializing_shards`: Whether to wait until there are no
    ///   initializing shards in the cluster.
    /// - `wait_for_no_relocating_shards`: Whether to wait until there are no
    ///   relocating shards in the cluster.
    /// - `wait_for_nodes`: Wait until the specified number of nodes is
    ///   available.
    /// - `wait_for_status`: Wait until cluster is in a specific state.
    ///```ignore
    /// let response = client.cluster_health_with_index()
    ///    .index(index)
    ///    .awareness_attribute(awareness_attribute)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .ensure_node_commissioned(ensure_node_commissioned)
    ///    .expand_wildcards(expand_wildcards)
    ///    .level(level)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .wait_for_active_shards(wait_for_active_shards)
    ///    .wait_for_events(wait_for_events)
    ///    .wait_for_no_initializing_shards(wait_for_no_initializing_shards)
    ///    .wait_for_no_relocating_shards(wait_for_no_relocating_shards)
    ///    .wait_for_nodes(wait_for_nodes)
    ///    .wait_for_status(wait_for_status)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cluster_health_with_index(&self) -> builder::ClusterHealthWithIndex {
        builder::ClusterHealthWithIndex::new(self)
    }

    ///Returns information about hot threads on each node in the cluster.
    ///
    ///Sends a `GET` request to `/_cluster/nodes/hot_threads`
    ///
    ///Arguments:
    /// - `ignore_idle_threads`: Don't show threads that are in known-idle
    ///   places, such as waiting on a socket select or pulling from an empty
    ///   task queue.
    /// - `interval`: The interval for the second sampling of threads.
    /// - `snapshots`: Number of samples of thread stacktrace.
    /// - `threads`: Specify the number of threads to provide information for.
    /// - `timeout`: Operation timeout.
    /// - `type_`: The type to sample.
    ///```ignore
    /// let response = client.nodes_hot_threads_deprecated_dash()
    ///    .ignore_idle_threads(ignore_idle_threads)
    ///    .interval(interval)
    ///    .snapshots(snapshots)
    ///    .threads(threads)
    ///    .timeout(timeout)
    ///    .type_(type_)
    ///    .send()
    ///    .await;
    /// ```
    pub fn nodes_hot_threads_deprecated_dash(&self) -> builder::NodesHotThreadsDeprecatedDash {
        builder::NodesHotThreadsDeprecatedDash::new(self)
    }

    ///Returns information about hot threads on each node in the cluster.
    ///
    ///Sends a `GET` request to `/_cluster/nodes/hotthreads`
    ///
    ///Arguments:
    /// - `ignore_idle_threads`: Don't show threads that are in known-idle
    ///   places, such as waiting on a socket select or pulling from an empty
    ///   task queue.
    /// - `interval`: The interval for the second sampling of threads.
    /// - `snapshots`: Number of samples of thread stacktrace.
    /// - `threads`: Specify the number of threads to provide information for.
    /// - `timeout`: Operation timeout.
    /// - `type_`: The type to sample.
    ///```ignore
    /// let response = client.nodes_hot_threads_deprecated_cluster()
    ///    .ignore_idle_threads(ignore_idle_threads)
    ///    .interval(interval)
    ///    .snapshots(snapshots)
    ///    .threads(threads)
    ///    .timeout(timeout)
    ///    .type_(type_)
    ///    .send()
    ///    .await;
    /// ```
    pub fn nodes_hot_threads_deprecated_cluster(
        &self,
    ) -> builder::NodesHotThreadsDeprecatedCluster {
        builder::NodesHotThreadsDeprecatedCluster::new(self)
    }

    ///Returns information about hot threads on each node in the cluster.
    ///
    ///Sends a `GET` request to `/_cluster/nodes/{node_id}/hot_threads`
    ///
    ///Arguments:
    /// - `node_id`: Comma-separated list of node IDs or names to limit the
    ///   returned information; use `_local` to return information from the node
    ///   you're connecting to, leave empty to get information from all nodes.
    /// - `ignore_idle_threads`: Don't show threads that are in known-idle
    ///   places, such as waiting on a socket select or pulling from an empty
    ///   task queue.
    /// - `interval`: The interval for the second sampling of threads.
    /// - `snapshots`: Number of samples of thread stacktrace.
    /// - `threads`: Specify the number of threads to provide information for.
    /// - `timeout`: Operation timeout.
    /// - `type_`: The type to sample.
    ///```ignore
    /// let response = client.nodes_hot_threads_with_node_id_deprecated_dash()
    ///    .node_id(node_id)
    ///    .ignore_idle_threads(ignore_idle_threads)
    ///    .interval(interval)
    ///    .snapshots(snapshots)
    ///    .threads(threads)
    ///    .timeout(timeout)
    ///    .type_(type_)
    ///    .send()
    ///    .await;
    /// ```
    pub fn nodes_hot_threads_with_node_id_deprecated_dash(
        &self,
    ) -> builder::NodesHotThreadsWithNodeIdDeprecatedDash {
        builder::NodesHotThreadsWithNodeIdDeprecatedDash::new(self)
    }

    ///Returns information about hot threads on each node in the cluster.
    ///
    ///Sends a `GET` request to `/_cluster/nodes/{node_id}/hotthreads`
    ///
    ///Arguments:
    /// - `node_id`: Comma-separated list of node IDs or names to limit the
    ///   returned information; use `_local` to return information from the node
    ///   you're connecting to, leave empty to get information from all nodes.
    /// - `ignore_idle_threads`: Don't show threads that are in known-idle
    ///   places, such as waiting on a socket select or pulling from an empty
    ///   task queue.
    /// - `interval`: The interval for the second sampling of threads.
    /// - `snapshots`: Number of samples of thread stacktrace.
    /// - `threads`: Specify the number of threads to provide information for.
    /// - `timeout`: Operation timeout.
    /// - `type_`: The type to sample.
    ///```ignore
    /// let response = client.nodes_hot_threads_with_node_id_deprecated_cluster()
    ///    .node_id(node_id)
    ///    .ignore_idle_threads(ignore_idle_threads)
    ///    .interval(interval)
    ///    .snapshots(snapshots)
    ///    .threads(threads)
    ///    .timeout(timeout)
    ///    .type_(type_)
    ///    .send()
    ///    .await;
    /// ```
    pub fn nodes_hot_threads_with_node_id_deprecated_cluster(
        &self,
    ) -> builder::NodesHotThreadsWithNodeIdDeprecatedCluster {
        builder::NodesHotThreadsWithNodeIdDeprecatedCluster::new(self)
    }

    ///Returns a list of any cluster-level changes (e.g. create index, update
    /// mapping, allocate or fail shard) which have not yet been executed.
    ///
    ///Sends a `GET` request to `/_cluster/pending_tasks`
    ///
    ///Arguments:
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    ///```ignore
    /// let response = client.cluster_pending_tasks()
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cluster_pending_tasks(&self) -> builder::ClusterPendingTasks {
        builder::ClusterPendingTasks::new(self)
    }

    ///Allows to manually change the allocation of individual shards in the
    /// cluster.
    ///
    ///Sends a `POST` request to `/_cluster/reroute`
    ///
    ///Arguments:
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `dry_run`: Simulate the operation only and return the resulting state.
    /// - `explain`: Return an explanation of why the commands can or cannot be
    ///   executed.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `metric`: Limit the information returned to the specified metrics.
    ///   Defaults to all but metadata.
    /// - `retry_failed`: Retries allocation of shards that are blocked due to
    ///   too many subsequent allocation failures.
    /// - `timeout`: Operation timeout.
    /// - `body`
    ///```ignore
    /// let response = client.cluster_reroute()
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .dry_run(dry_run)
    ///    .explain(explain)
    ///    .master_timeout(master_timeout)
    ///    .metric(metric)
    ///    .retry_failed(retry_failed)
    ///    .timeout(timeout)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cluster_reroute(&self) -> builder::ClusterReroute {
        builder::ClusterReroute::new(self)
    }

    ///Delete weighted shard routing weights.
    ///
    ///Sends a `DELETE` request to `/_cluster/routing/awareness/weights`
    ///
    ///```ignore
    /// let response = client.cluster_delete_weighted_routing()
    ///    .send()
    ///    .await;
    /// ```
    pub fn cluster_delete_weighted_routing(&self) -> builder::ClusterDeleteWeightedRouting {
        builder::ClusterDeleteWeightedRouting::new(self)
    }

    ///Fetches weighted shard routing weights.
    ///
    ///Sends a `GET` request to
    /// `/_cluster/routing/awareness/{attribute}/weights`
    ///
    ///Arguments:
    /// - `attribute`: Awareness attribute name.
    ///```ignore
    /// let response = client.cluster_get_weighted_routing()
    ///    .attribute(attribute)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cluster_get_weighted_routing(&self) -> builder::ClusterGetWeightedRouting {
        builder::ClusterGetWeightedRouting::new(self)
    }

    ///Updates weighted shard routing weights.
    ///
    ///Sends a `PUT` request to
    /// `/_cluster/routing/awareness/{attribute}/weights`
    ///
    ///Arguments:
    /// - `attribute`: Awareness attribute name.
    ///```ignore
    /// let response = client.cluster_put_weighted_routing()
    ///    .attribute(attribute)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cluster_put_weighted_routing(&self) -> builder::ClusterPutWeightedRouting {
        builder::ClusterPutWeightedRouting::new(self)
    }

    ///Returns cluster settings.
    ///
    ///Sends a `GET` request to `/_cluster/settings`
    ///
    ///Arguments:
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `flat_settings`: Return settings in flat format.
    /// - `include_defaults`: Whether to return all default clusters setting.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    ///```ignore
    /// let response = client.cluster_get_settings()
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .flat_settings(flat_settings)
    ///    .include_defaults(include_defaults)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cluster_get_settings(&self) -> builder::ClusterGetSettings {
        builder::ClusterGetSettings::new(self)
    }

    ///Updates the cluster settings.
    ///
    ///Sends a `PUT` request to `/_cluster/settings`
    ///
    ///Arguments:
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `flat_settings`: Return settings in flat format.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    /// - `body`
    ///```ignore
    /// let response = client.cluster_put_settings()
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .flat_settings(flat_settings)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cluster_put_settings(&self) -> builder::ClusterPutSettings {
        builder::ClusterPutSettings::new(self)
    }

    ///Returns a comprehensive information about the state of the cluster.
    ///
    ///Sends a `GET` request to `/_cluster/state`
    ///
    ///Arguments:
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `flat_settings`: Return settings in flat format.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `wait_for_metadata_version`: Wait for the metadata version to be equal
    ///   or greater than the specified metadata version.
    /// - `wait_for_timeout`: The maximum time to wait for
    ///   wait_for_metadata_version before timing out.
    ///```ignore
    /// let response = client.cluster_state()
    ///    .allow_no_indices(allow_no_indices)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .expand_wildcards(expand_wildcards)
    ///    .flat_settings(flat_settings)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .wait_for_metadata_version(wait_for_metadata_version)
    ///    .wait_for_timeout(wait_for_timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cluster_state(&self) -> builder::ClusterState {
        builder::ClusterState::new(self)
    }

    ///Returns a comprehensive information about the state of the cluster.
    ///
    ///Sends a `GET` request to `/_cluster/state/{metric}`
    ///
    ///Arguments:
    /// - `metric`: Limit the information returned to the specified metrics.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `flat_settings`: Return settings in flat format.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `wait_for_metadata_version`: Wait for the metadata version to be equal
    ///   or greater than the specified metadata version.
    /// - `wait_for_timeout`: The maximum time to wait for
    ///   wait_for_metadata_version before timing out.
    ///```ignore
    /// let response = client.cluster_state_with_metric()
    ///    .metric(metric)
    ///    .allow_no_indices(allow_no_indices)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .expand_wildcards(expand_wildcards)
    ///    .flat_settings(flat_settings)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .wait_for_metadata_version(wait_for_metadata_version)
    ///    .wait_for_timeout(wait_for_timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cluster_state_with_metric(&self) -> builder::ClusterStateWithMetric {
        builder::ClusterStateWithMetric::new(self)
    }

    ///Returns a comprehensive information about the state of the cluster.
    ///
    ///Sends a `GET` request to `/_cluster/state/{metric}/{index}`
    ///
    ///Arguments:
    /// - `metric`: Limit the information returned to the specified metrics.
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `flat_settings`: Return settings in flat format.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `wait_for_metadata_version`: Wait for the metadata version to be equal
    ///   or greater than the specified metadata version.
    /// - `wait_for_timeout`: The maximum time to wait for
    ///   wait_for_metadata_version before timing out.
    ///```ignore
    /// let response = client.cluster_state_with_index_metric()
    ///    .metric(metric)
    ///    .index(index)
    ///    .allow_no_indices(allow_no_indices)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .expand_wildcards(expand_wildcards)
    ///    .flat_settings(flat_settings)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .wait_for_metadata_version(wait_for_metadata_version)
    ///    .wait_for_timeout(wait_for_timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cluster_state_with_index_metric(&self) -> builder::ClusterStateWithIndexMetric {
        builder::ClusterStateWithIndexMetric::new(self)
    }

    ///Returns high-level overview of cluster statistics.
    ///
    ///Sends a `GET` request to `/_cluster/stats`
    ///
    ///Arguments:
    /// - `flat_settings`: Return settings in flat format.
    /// - `timeout`: Operation timeout.
    ///```ignore
    /// let response = client.cluster_stats()
    ///    .flat_settings(flat_settings)
    ///    .timeout(timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cluster_stats(&self) -> builder::ClusterStats {
        builder::ClusterStats::new(self)
    }

    ///Returns high-level overview of cluster statistics.
    ///
    ///Sends a `GET` request to `/_cluster/stats/nodes/{node_id}`
    ///
    ///Arguments:
    /// - `node_id`: Comma-separated list of node IDs or names to limit the
    ///   returned information; use `_local` to return information from the node
    ///   you're connecting to, leave empty to get information from all nodes.
    /// - `flat_settings`: Return settings in flat format.
    /// - `timeout`: Operation timeout.
    ///```ignore
    /// let response = client.cluster_stats_with_node_id()
    ///    .node_id(node_id)
    ///    .flat_settings(flat_settings)
    ///    .timeout(timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cluster_stats_with_node_id(&self) -> builder::ClusterStatsWithNodeId {
        builder::ClusterStatsWithNodeId::new(self)
    }

    ///Updates the cluster voting config exclusions by node ids or node names.
    ///
    ///Sends a `POST` request to `/_cluster/voting_config_exclusions`
    ///
    ///Arguments:
    /// - `node_ids`: Comma-separated list of the persistent ids of the nodes to
    ///   exclude from the voting configuration. If specified, you may not also
    ///   specify ?node_names.
    /// - `node_names`: Comma-separated list of the names of the nodes to
    ///   exclude from the voting configuration. If specified, you may not also
    ///   specify ?node_ids.
    /// - `timeout`: Operation timeout.
    ///```ignore
    /// let response = client.cluster_post_voting_config_exclusions()
    ///    .node_ids(node_ids)
    ///    .node_names(node_names)
    ///    .timeout(timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cluster_post_voting_config_exclusions(
        &self,
    ) -> builder::ClusterPostVotingConfigExclusions {
        builder::ClusterPostVotingConfigExclusions::new(self)
    }

    ///Clears cluster voting config exclusions.
    ///
    ///Sends a `DELETE` request to `/_cluster/voting_config_exclusions`
    ///
    ///Arguments:
    /// - `wait_for_removal`: Specifies whether to wait for all excluded nodes
    ///   to be removed from the cluster before clearing the voting
    ///   configuration exclusions list.
    ///```ignore
    /// let response = client.cluster_delete_voting_config_exclusions()
    ///    .wait_for_removal(wait_for_removal)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cluster_delete_voting_config_exclusions(
        &self,
    ) -> builder::ClusterDeleteVotingConfigExclusions {
        builder::ClusterDeleteVotingConfigExclusions::new(self)
    }

    ///Returns one or more component templates.
    ///
    ///Sends a `GET` request to `/_component_template`
    ///
    ///Arguments:
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    ///```ignore
    /// let response = client.cluster_get_component_template()
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cluster_get_component_template(&self) -> builder::ClusterGetComponentTemplate {
        builder::ClusterGetComponentTemplate::new(self)
    }

    ///Returns one or more component templates.
    ///
    ///Sends a `GET` request to `/_component_template/{name}`
    ///
    ///Arguments:
    /// - `name`: The Comma-separated names of the component templates.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    ///```ignore
    /// let response = client.cluster_get_component_template_with_name()
    ///    .name(name)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cluster_get_component_template_with_name(
        &self,
    ) -> builder::ClusterGetComponentTemplateWithName {
        builder::ClusterGetComponentTemplateWithName::new(self)
    }

    ///Creates or updates a component template.
    ///
    ///Sends a `PUT` request to `/_component_template/{name}`
    ///
    ///Arguments:
    /// - `name`: The name of the template.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `create`: Whether the index template should only be added if new or
    ///   can also replace an existing one.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    /// - `body`
    ///```ignore
    /// let response = client.cluster_put_component_template_put()
    ///    .name(name)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .create(create)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cluster_put_component_template_put(&self) -> builder::ClusterPutComponentTemplatePut {
        builder::ClusterPutComponentTemplatePut::new(self)
    }

    ///Creates or updates a component template.
    ///
    ///Sends a `POST` request to `/_component_template/{name}`
    ///
    ///Arguments:
    /// - `name`: The name of the template.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `create`: Whether the index template should only be added if new or
    ///   can also replace an existing one.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    /// - `body`
    ///```ignore
    /// let response = client.cluster_put_component_template_post()
    ///    .name(name)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .create(create)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cluster_put_component_template_post(&self) -> builder::ClusterPutComponentTemplatePost {
        builder::ClusterPutComponentTemplatePost::new(self)
    }

    ///Deletes a component template.
    ///
    ///Sends a `DELETE` request to `/_component_template/{name}`
    ///
    ///Arguments:
    /// - `name`: The name of the template.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    ///```ignore
    /// let response = client.cluster_delete_component_template()
    ///    .name(name)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cluster_delete_component_template(&self) -> builder::ClusterDeleteComponentTemplate {
        builder::ClusterDeleteComponentTemplate::new(self)
    }

    ///Returns information about whether a particular component template exist.
    ///
    ///Sends a `HEAD` request to `/_component_template/{name}`
    ///
    ///Arguments:
    /// - `name`: The name of the template.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    ///```ignore
    /// let response = client.cluster_exists_component_template()
    ///    .name(name)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn cluster_exists_component_template(&self) -> builder::ClusterExistsComponentTemplate {
        builder::ClusterExistsComponentTemplate::new(self)
    }

    ///Returns number of documents matching a query.
    ///
    ///Sends a `GET` request to `/_count`
    ///
    ///Arguments:
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `analyze_wildcard`: Specify whether wildcard and prefix queries should
    ///   be analyzed.
    /// - `analyzer`: The analyzer to use for the query string.
    /// - `default_operator`: The default operator for query string query (AND
    ///   or OR).
    /// - `df`: The field to use as default where no field prefix is given in
    ///   the query string.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_throttled`: Whether specified concrete, expanded or aliased
    ///   indices should be ignored when throttled.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `lenient`: Specify whether format-based query failures (such as
    ///   providing text to a numeric field) should be ignored.
    /// - `min_score`: Include only documents with a specific `_score` value in
    ///   the result.
    /// - `preference`: Specify the node or shard the operation should be
    ///   performed on.
    /// - `q`: Query in the Lucene query string syntax.
    /// - `routing`: Comma-separated list of specific routing values.
    /// - `terminate_after`: The maximum number of documents to collect for each
    ///   shard, upon reaching which the query execution will terminate early.
    ///```ignore
    /// let response = client.count_get()
    ///    .allow_no_indices(allow_no_indices)
    ///    .analyze_wildcard(analyze_wildcard)
    ///    .analyzer(analyzer)
    ///    .default_operator(default_operator)
    ///    .df(df)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_throttled(ignore_throttled)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .lenient(lenient)
    ///    .min_score(min_score)
    ///    .preference(preference)
    ///    .q(q)
    ///    .routing(routing)
    ///    .terminate_after(terminate_after)
    ///    .send()
    ///    .await;
    /// ```
    pub fn count_get(&self) -> builder::CountGet {
        builder::CountGet::new(self)
    }

    ///Returns number of documents matching a query.
    ///
    ///Sends a `POST` request to `/_count`
    ///
    ///Arguments:
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `analyze_wildcard`: Specify whether wildcard and prefix queries should
    ///   be analyzed.
    /// - `analyzer`: The analyzer to use for the query string.
    /// - `default_operator`: The default operator for query string query (AND
    ///   or OR).
    /// - `df`: The field to use as default where no field prefix is given in
    ///   the query string.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_throttled`: Whether specified concrete, expanded or aliased
    ///   indices should be ignored when throttled.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `lenient`: Specify whether format-based query failures (such as
    ///   providing text to a numeric field) should be ignored.
    /// - `min_score`: Include only documents with a specific `_score` value in
    ///   the result.
    /// - `preference`: Specify the node or shard the operation should be
    ///   performed on.
    /// - `q`: Query in the Lucene query string syntax.
    /// - `routing`: Comma-separated list of specific routing values.
    /// - `terminate_after`: The maximum number of documents to collect for each
    ///   shard, upon reaching which the query execution will terminate early.
    /// - `body`
    ///```ignore
    /// let response = client.count_post()
    ///    .allow_no_indices(allow_no_indices)
    ///    .analyze_wildcard(analyze_wildcard)
    ///    .analyzer(analyzer)
    ///    .default_operator(default_operator)
    ///    .df(df)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_throttled(ignore_throttled)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .lenient(lenient)
    ///    .min_score(min_score)
    ///    .preference(preference)
    ///    .q(q)
    ///    .routing(routing)
    ///    .terminate_after(terminate_after)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn count_post(&self) -> builder::CountPost {
        builder::CountPost::new(self)
    }

    ///Returns all dangling indices.
    ///
    ///Sends a `GET` request to `/_dangling`
    ///
    ///```ignore
    /// let response = client.dangling_indices_list_dangling_indices()
    ///    .send()
    ///    .await;
    /// ```
    pub fn dangling_indices_list_dangling_indices(
        &self,
    ) -> builder::DanglingIndicesListDanglingIndices {
        builder::DanglingIndicesListDanglingIndices::new(self)
    }

    ///Imports the specified dangling index.
    ///
    ///Sends a `POST` request to `/_dangling/{index_uuid}`
    ///
    ///Arguments:
    /// - `index_uuid`: The UUID of the dangling index.
    /// - `accept_data_loss`: Must be set to true in order to import the
    ///   dangling index.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    ///```ignore
    /// let response = client.dangling_indices_import_dangling_index()
    ///    .index_uuid(index_uuid)
    ///    .accept_data_loss(accept_data_loss)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn dangling_indices_import_dangling_index(
        &self,
    ) -> builder::DanglingIndicesImportDanglingIndex {
        builder::DanglingIndicesImportDanglingIndex::new(self)
    }

    ///Deletes the specified dangling index.
    ///
    ///Sends a `DELETE` request to `/_dangling/{index_uuid}`
    ///
    ///Arguments:
    /// - `index_uuid`: The UUID of the dangling index.
    /// - `accept_data_loss`: Must be set to true in order to delete the
    ///   dangling index.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    ///```ignore
    /// let response = client.dangling_indices_delete_dangling_index()
    ///    .index_uuid(index_uuid)
    ///    .accept_data_loss(accept_data_loss)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn dangling_indices_delete_dangling_index(
        &self,
    ) -> builder::DanglingIndicesDeleteDanglingIndex {
        builder::DanglingIndicesDeleteDanglingIndex::new(self)
    }

    ///Returns data streams.
    ///
    ///Sends a `GET` request to `/_data_stream`
    ///
    ///```ignore
    /// let response = client.indices_get_data_stream()
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_get_data_stream(&self) -> builder::IndicesGetDataStream {
        builder::IndicesGetDataStream::new(self)
    }

    ///Provides statistics on operations happening in a data stream.
    ///
    ///Sends a `GET` request to `/_data_stream/_stats`
    ///
    ///```ignore
    /// let response = client.indices_data_streams_stats()
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_data_streams_stats(&self) -> builder::IndicesDataStreamsStats {
        builder::IndicesDataStreamsStats::new(self)
    }

    ///Returns data streams.
    ///
    ///Sends a `GET` request to `/_data_stream/{name}`
    ///
    ///Arguments:
    /// - `name`: Comma-separated list of data streams; use `_all` or empty
    ///   string to perform the operation on all data streams.
    ///```ignore
    /// let response = client.indices_get_data_stream_with_name()
    ///    .name(name)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_get_data_stream_with_name(&self) -> builder::IndicesGetDataStreamWithName {
        builder::IndicesGetDataStreamWithName::new(self)
    }

    ///Creates or updates a data stream.
    ///
    ///Sends a `PUT` request to `/_data_stream/{name}`
    ///
    ///Arguments:
    /// - `name`: The name of the data stream.
    /// - `body`
    ///```ignore
    /// let response = client.indices_create_data_stream()
    ///    .name(name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_create_data_stream(&self) -> builder::IndicesCreateDataStream {
        builder::IndicesCreateDataStream::new(self)
    }

    ///Deletes a data stream.
    ///
    ///Sends a `DELETE` request to `/_data_stream/{name}`
    ///
    ///Arguments:
    /// - `name`: Comma-separated list of data streams; use `_all` or empty
    ///   string to perform the operation on all data streams.
    ///```ignore
    /// let response = client.indices_delete_data_stream()
    ///    .name(name)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_delete_data_stream(&self) -> builder::IndicesDeleteDataStream {
        builder::IndicesDeleteDataStream::new(self)
    }

    ///Provides statistics on operations happening in a data stream.
    ///
    ///Sends a `GET` request to `/_data_stream/{name}/_stats`
    ///
    ///Arguments:
    /// - `name`: Comma-separated list of data streams; use `_all` or empty
    ///   string to perform the operation on all data streams.
    ///```ignore
    /// let response = client.indices_data_streams_stats_with_name()
    ///    .name(name)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_data_streams_stats_with_name(&self) -> builder::IndicesDataStreamsStatsWithName {
        builder::IndicesDataStreamsStatsWithName::new(self)
    }

    ///Changes the number of requests per second for a particular Delete By
    /// Query operation.
    ///
    ///Sends a `POST` request to `/_delete_by_query/{task_id}/_rethrottle`
    ///
    ///Arguments:
    /// - `task_id`: The task id to rethrottle.
    /// - `requests_per_second`: The throttle for this request in sub-requests
    ///   per second. -1 means no throttle.
    ///```ignore
    /// let response = client.delete_by_query_rethrottle()
    ///    .task_id(task_id)
    ///    .requests_per_second(requests_per_second)
    ///    .send()
    ///    .await;
    /// ```
    pub fn delete_by_query_rethrottle(&self) -> builder::DeleteByQueryRethrottle {
        builder::DeleteByQueryRethrottle::new(self)
    }

    ///Returns the information about the capabilities of fields among multiple
    /// indices.
    ///
    ///Sends a `GET` request to `/_field_caps`
    ///
    ///Arguments:
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `fields`: Comma-separated list of field names.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `include_unmapped`: Indicates whether unmapped fields should be
    ///   included in the response.
    ///```ignore
    /// let response = client.field_caps_get()
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .fields(fields)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .include_unmapped(include_unmapped)
    ///    .send()
    ///    .await;
    /// ```
    pub fn field_caps_get(&self) -> builder::FieldCapsGet {
        builder::FieldCapsGet::new(self)
    }

    ///Returns the information about the capabilities of fields among multiple
    /// indices.
    ///
    ///Sends a `POST` request to `/_field_caps`
    ///
    ///Arguments:
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `fields`: Comma-separated list of field names.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `include_unmapped`: Indicates whether unmapped fields should be
    ///   included in the response.
    /// - `body`
    ///```ignore
    /// let response = client.field_caps_post()
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .fields(fields)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .include_unmapped(include_unmapped)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn field_caps_post(&self) -> builder::FieldCapsPost {
        builder::FieldCapsPost::new(self)
    }

    ///Performs the flush operation on one or more indices.
    ///
    ///Sends a `GET` request to `/_flush`
    ///
    ///Arguments:
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `force`: Whether a flush should be forced even if it is not
    ///   necessarily needed ie. if no changes will be committed to the index.
    ///   This is useful if transaction log IDs should be incremented even if no
    ///   uncommitted changes are present. (This setting can be considered as
    ///   internal).
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `wait_if_ongoing`: If set to true the flush operation will block until
    ///   the flush can be executed if another flush operation is already
    ///   executing. If set to false the flush will be skipped iff if another
    ///   flush operation is already running.
    ///```ignore
    /// let response = client.indices_flush_get()
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .force(force)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .wait_if_ongoing(wait_if_ongoing)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_flush_get(&self) -> builder::IndicesFlushGet {
        builder::IndicesFlushGet::new(self)
    }

    ///Performs the flush operation on one or more indices.
    ///
    ///Sends a `POST` request to `/_flush`
    ///
    ///Arguments:
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `force`: Whether a flush should be forced even if it is not
    ///   necessarily needed ie. if no changes will be committed to the index.
    ///   This is useful if transaction log IDs should be incremented even if no
    ///   uncommitted changes are present. (This setting can be considered as
    ///   internal).
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `wait_if_ongoing`: If set to true the flush operation will block until
    ///   the flush can be executed if another flush operation is already
    ///   executing. If set to false the flush will be skipped iff if another
    ///   flush operation is already running.
    ///```ignore
    /// let response = client.indices_flush_post()
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .force(force)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .wait_if_ongoing(wait_if_ongoing)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_flush_post(&self) -> builder::IndicesFlushPost {
        builder::IndicesFlushPost::new(self)
    }

    ///Performs the force merge operation on one or more indices.
    ///
    ///Sends a `POST` request to `/_forcemerge`
    ///
    ///Arguments:
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `flush`: Specify whether the index should be flushed after performing
    ///   the operation.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `max_num_segments`: The number of segments the index should be merged
    ///   into (default: dynamic).
    /// - `only_expunge_deletes`: Specify whether the operation should only
    ///   expunge deleted documents.
    ///```ignore
    /// let response = client.indices_forcemerge()
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .flush(flush)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .max_num_segments(max_num_segments)
    ///    .only_expunge_deletes(only_expunge_deletes)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_forcemerge(&self) -> builder::IndicesForcemerge {
        builder::IndicesForcemerge::new(self)
    }

    ///Returns an index template.
    ///
    ///Sends a `GET` request to `/_index_template`
    ///
    ///Arguments:
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `flat_settings`: Return settings in flat format.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    ///```ignore
    /// let response = client.indices_get_index_template()
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .flat_settings(flat_settings)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_get_index_template(&self) -> builder::IndicesGetIndexTemplate {
        builder::IndicesGetIndexTemplate::new(self)
    }

    ///Simulate resolving the given template name or body.
    ///
    ///Sends a `POST` request to `/_index_template/_simulate`
    ///
    ///Arguments:
    /// - `cause`: User defined reason for dry-run creating the new template for
    ///   simulation purposes.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `create`: Whether the index template we optionally defined in the body
    ///   should only be dry-run added if new or can also replace an existing
    ///   one.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `body`
    ///```ignore
    /// let response = client.indices_simulate_template()
    ///    .cause(cause)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .create(create)
    ///    .master_timeout(master_timeout)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_simulate_template(&self) -> builder::IndicesSimulateTemplate {
        builder::IndicesSimulateTemplate::new(self)
    }

    ///Simulate resolving the given template name or body.
    ///
    ///Sends a `POST` request to `/_index_template/_simulate/{name}`
    ///
    ///Arguments:
    /// - `name`: The name of the template.
    /// - `cause`: User defined reason for dry-run creating the new template for
    ///   simulation purposes.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `create`: Whether the index template we optionally defined in the body
    ///   should only be dry-run added if new or can also replace an existing
    ///   one.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `body`
    ///```ignore
    /// let response = client.indices_simulate_template_with_name()
    ///    .name(name)
    ///    .cause(cause)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .create(create)
    ///    .master_timeout(master_timeout)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_simulate_template_with_name(&self) -> builder::IndicesSimulateTemplateWithName {
        builder::IndicesSimulateTemplateWithName::new(self)
    }

    ///Simulate matching the given index name against the index templates in
    /// the system.
    ///
    ///Sends a `POST` request to `/_index_template/_simulate_index/{name}`
    ///
    ///Arguments:
    /// - `name`: The name of the index (it must be a concrete index name).
    /// - `cause`: User defined reason for dry-run creating the new template for
    ///   simulation purposes.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `create`: Whether the index template we optionally defined in the body
    ///   should only be dry-run added if new or can also replace an existing
    ///   one.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `body`
    ///```ignore
    /// let response = client.indices_simulate_index_template()
    ///    .name(name)
    ///    .cause(cause)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .create(create)
    ///    .master_timeout(master_timeout)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_simulate_index_template(&self) -> builder::IndicesSimulateIndexTemplate {
        builder::IndicesSimulateIndexTemplate::new(self)
    }

    ///Returns an index template.
    ///
    ///Sends a `GET` request to `/_index_template/{name}`
    ///
    ///Arguments:
    /// - `name`: Comma-separated names of the index templates.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `flat_settings`: Return settings in flat format.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    ///```ignore
    /// let response = client.indices_get_index_template_with_name()
    ///    .name(name)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .flat_settings(flat_settings)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_get_index_template_with_name(&self) -> builder::IndicesGetIndexTemplateWithName {
        builder::IndicesGetIndexTemplateWithName::new(self)
    }

    ///Creates or updates an index template.
    ///
    ///Sends a `PUT` request to `/_index_template/{name}`
    ///
    ///Arguments:
    /// - `name`: The name of the template.
    /// - `cause`: User defined reason for creating/updating the index template.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `create`: Whether the index template should only be added if new or
    ///   can also replace an existing one.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `body`
    ///```ignore
    /// let response = client.indices_put_index_template_put()
    ///    .name(name)
    ///    .cause(cause)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .create(create)
    ///    .master_timeout(master_timeout)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_put_index_template_put(&self) -> builder::IndicesPutIndexTemplatePut {
        builder::IndicesPutIndexTemplatePut::new(self)
    }

    ///Creates or updates an index template.
    ///
    ///Sends a `POST` request to `/_index_template/{name}`
    ///
    ///Arguments:
    /// - `name`: The name of the template.
    /// - `cause`: User defined reason for creating/updating the index template.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `create`: Whether the index template should only be added if new or
    ///   can also replace an existing one.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `body`
    ///```ignore
    /// let response = client.indices_put_index_template_post()
    ///    .name(name)
    ///    .cause(cause)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .create(create)
    ///    .master_timeout(master_timeout)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_put_index_template_post(&self) -> builder::IndicesPutIndexTemplatePost {
        builder::IndicesPutIndexTemplatePost::new(self)
    }

    ///Deletes an index template.
    ///
    ///Sends a `DELETE` request to `/_index_template/{name}`
    ///
    ///Arguments:
    /// - `name`: The name of the template.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    ///```ignore
    /// let response = client.indices_delete_index_template()
    ///    .name(name)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_delete_index_template(&self) -> builder::IndicesDeleteIndexTemplate {
        builder::IndicesDeleteIndexTemplate::new(self)
    }

    ///Returns information about whether a particular index template exists.
    ///
    ///Sends a `HEAD` request to `/_index_template/{name}`
    ///
    ///Arguments:
    /// - `name`: The name of the template.
    /// - `flat_settings`: Return settings in flat format.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    ///```ignore
    /// let response = client.indices_exists_index_template()
    ///    .name(name)
    ///    .flat_settings(flat_settings)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_exists_index_template(&self) -> builder::IndicesExistsIndexTemplate {
        builder::IndicesExistsIndexTemplate::new(self)
    }

    ///Returns a pipeline.
    ///
    ///Sends a `GET` request to `/_ingest/pipeline`
    ///
    ///Arguments:
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    ///```ignore
    /// let response = client.ingest_get_pipeline()
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .master_timeout(master_timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn ingest_get_pipeline(&self) -> builder::IngestGetPipeline {
        builder::IngestGetPipeline::new(self)
    }

    ///Allows to simulate a pipeline with example documents.
    ///
    ///Sends a `GET` request to `/_ingest/pipeline/_simulate`
    ///
    ///Arguments:
    /// - `verbose`: Verbose mode. Display data output for each processor in
    ///   executed pipeline.
    ///```ignore
    /// let response = client.ingest_simulate_get()
    ///    .verbose(verbose)
    ///    .send()
    ///    .await;
    /// ```
    pub fn ingest_simulate_get(&self) -> builder::IngestSimulateGet {
        builder::IngestSimulateGet::new(self)
    }

    ///Allows to simulate a pipeline with example documents.
    ///
    ///Sends a `POST` request to `/_ingest/pipeline/_simulate`
    ///
    ///Arguments:
    /// - `verbose`: Verbose mode. Display data output for each processor in
    ///   executed pipeline.
    /// - `body`
    ///```ignore
    /// let response = client.ingest_simulate_post()
    ///    .verbose(verbose)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn ingest_simulate_post(&self) -> builder::IngestSimulatePost {
        builder::IngestSimulatePost::new(self)
    }

    ///Returns a pipeline.
    ///
    ///Sends a `GET` request to `/_ingest/pipeline/{id}`
    ///
    ///Arguments:
    /// - `id`: Comma-separated list of pipeline ids. Wildcards supported.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    ///```ignore
    /// let response = client.ingest_get_pipeline_with_id()
    ///    .id(id)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .master_timeout(master_timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn ingest_get_pipeline_with_id(&self) -> builder::IngestGetPipelineWithId {
        builder::IngestGetPipelineWithId::new(self)
    }

    ///Creates or updates a pipeline.
    ///
    ///Sends a `PUT` request to `/_ingest/pipeline/{id}`
    ///
    ///Arguments:
    /// - `id`: Pipeline ID.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    /// - `body`
    ///```ignore
    /// let response = client.ingest_put_pipeline()
    ///    .id(id)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn ingest_put_pipeline(&self) -> builder::IngestPutPipeline {
        builder::IngestPutPipeline::new(self)
    }

    ///Deletes a pipeline.
    ///
    ///Sends a `DELETE` request to `/_ingest/pipeline/{id}`
    ///
    ///Arguments:
    /// - `id`: Pipeline ID.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    ///```ignore
    /// let response = client.ingest_delete_pipeline()
    ///    .id(id)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn ingest_delete_pipeline(&self) -> builder::IngestDeletePipeline {
        builder::IngestDeletePipeline::new(self)
    }

    ///Allows to simulate a pipeline with example documents.
    ///
    ///Sends a `GET` request to `/_ingest/pipeline/{id}/_simulate`
    ///
    ///Arguments:
    /// - `id`: Pipeline ID.
    /// - `verbose`: Verbose mode. Display data output for each processor in
    ///   executed pipeline.
    ///```ignore
    /// let response = client.ingest_simulate_get_with_id()
    ///    .id(id)
    ///    .verbose(verbose)
    ///    .send()
    ///    .await;
    /// ```
    pub fn ingest_simulate_get_with_id(&self) -> builder::IngestSimulateGetWithId {
        builder::IngestSimulateGetWithId::new(self)
    }

    ///Allows to simulate a pipeline with example documents.
    ///
    ///Sends a `POST` request to `/_ingest/pipeline/{id}/_simulate`
    ///
    ///Arguments:
    /// - `id`: Pipeline ID.
    /// - `verbose`: Verbose mode. Display data output for each processor in
    ///   executed pipeline.
    /// - `body`
    ///```ignore
    /// let response = client.ingest_simulate_post_with_id()
    ///    .id(id)
    ///    .verbose(verbose)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn ingest_simulate_post_with_id(&self) -> builder::IngestSimulatePostWithId {
        builder::IngestSimulatePostWithId::new(self)
    }

    ///Returns a list of the built-in patterns.
    ///
    ///Sends a `GET` request to `/_ingest/processor/grok`
    ///
    ///```ignore
    /// let response = client.ingest_processor_grok()
    ///    .send()
    ///    .await;
    /// ```
    pub fn ingest_processor_grok(&self) -> builder::IngestProcessorGrok {
        builder::IngestProcessorGrok::new(self)
    }

    ///Returns mappings for one or more indices.
    ///
    ///Sends a `GET` request to `/_mapping`
    ///
    ///Arguments:
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    ///```ignore
    /// let response = client.indices_get_mapping()
    ///    .allow_no_indices(allow_no_indices)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_get_mapping(&self) -> builder::IndicesGetMapping {
        builder::IndicesGetMapping::new(self)
    }

    ///Returns mapping for one or more fields.
    ///
    ///Sends a `GET` request to `/_mapping/field/{fields}`
    ///
    ///Arguments:
    /// - `fields`: Comma-separated list of fields.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `include_defaults`: Whether the default mapping values should be
    ///   returned as well.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    ///```ignore
    /// let response = client.indices_get_field_mapping()
    ///    .fields(fields)
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .include_defaults(include_defaults)
    ///    .local(local)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_get_field_mapping(&self) -> builder::IndicesGetFieldMapping {
        builder::IndicesGetFieldMapping::new(self)
    }

    ///Allows to get multiple documents in one request.
    ///
    ///Sends a `GET` request to `/_mget`
    ///
    ///Arguments:
    /// - `source`: True or false to return the _source field or not, or a list
    ///   of fields to return.
    /// - `source_excludes`: List of fields to exclude from the returned _source
    ///   field.
    /// - `source_includes`: List of fields to extract and return from the
    ///   _source field.
    /// - `preference`: Specify the node or shard the operation should be
    ///   performed on.
    /// - `realtime`: Specify whether to perform the operation in realtime or
    ///   search mode.
    /// - `refresh`: Refresh the shard containing the document before performing
    ///   the operation.
    /// - `routing`: Routing value.
    /// - `stored_fields`: Comma-separated list of stored fields to return.
    ///```ignore
    /// let response = client.mget_get()
    ///    .source(source)
    ///    .source_excludes(source_excludes)
    ///    .source_includes(source_includes)
    ///    .preference(preference)
    ///    .realtime(realtime)
    ///    .refresh(refresh)
    ///    .routing(routing)
    ///    .stored_fields(stored_fields)
    ///    .send()
    ///    .await;
    /// ```
    pub fn mget_get(&self) -> builder::MgetGet {
        builder::MgetGet::new(self)
    }

    ///Allows to get multiple documents in one request.
    ///
    ///Sends a `POST` request to `/_mget`
    ///
    ///Arguments:
    /// - `source`: True or false to return the _source field or not, or a list
    ///   of fields to return.
    /// - `source_excludes`: List of fields to exclude from the returned _source
    ///   field.
    /// - `source_includes`: List of fields to extract and return from the
    ///   _source field.
    /// - `preference`: Specify the node or shard the operation should be
    ///   performed on.
    /// - `realtime`: Specify whether to perform the operation in realtime or
    ///   search mode.
    /// - `refresh`: Refresh the shard containing the document before performing
    ///   the operation.
    /// - `routing`: Routing value.
    /// - `stored_fields`: Comma-separated list of stored fields to return.
    /// - `body`
    ///```ignore
    /// let response = client.mget_post()
    ///    .source(source)
    ///    .source_excludes(source_excludes)
    ///    .source_includes(source_includes)
    ///    .preference(preference)
    ///    .realtime(realtime)
    ///    .refresh(refresh)
    ///    .routing(routing)
    ///    .stored_fields(stored_fields)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn mget_post(&self) -> builder::MgetPost {
        builder::MgetPost::new(self)
    }

    ///Allows to execute several search operations in one request.
    ///
    ///Sends a `GET` request to `/_msearch`
    ///
    ///Arguments:
    /// - `ccs_minimize_roundtrips`: Indicates whether network round-trips
    ///   should be minimized as part of cross-cluster search requests
    ///   execution.
    /// - `max_concurrent_searches`: Controls the maximum number of concurrent
    ///   searches the multi search api will execute.
    /// - `max_concurrent_shard_requests`: The number of concurrent shard
    ///   requests each sub search executes concurrently per node. This value
    ///   should be used to limit the impact of the search on the cluster in
    ///   order to limit the number of concurrent shard requests.
    /// - `pre_filter_shard_size`: Threshold that enforces a pre-filter
    ///   round-trip to prefilter search shards based on query rewriting if the
    ///   number of shards the search request expands to exceeds the threshold.
    ///   This filter round-trip can limit the number of shards significantly if
    ///   for instance a shard can not match any documents based on its rewrite
    ///   method ie. if date filters are mandatory to match but the shard bounds
    ///   and the query are disjoint.
    /// - `rest_total_hits_as_int`: Indicates whether hits.total should be
    ///   rendered as an integer or an object in the rest search response.
    /// - `search_type`: Search operation type.
    /// - `typed_keys`: Specify whether aggregation and suggester names should
    ///   be prefixed by their respective types in the response.
    ///```ignore
    /// let response = client.msearch_get()
    ///    .ccs_minimize_roundtrips(ccs_minimize_roundtrips)
    ///    .max_concurrent_searches(max_concurrent_searches)
    ///    .max_concurrent_shard_requests(max_concurrent_shard_requests)
    ///    .pre_filter_shard_size(pre_filter_shard_size)
    ///    .rest_total_hits_as_int(rest_total_hits_as_int)
    ///    .search_type(search_type)
    ///    .typed_keys(typed_keys)
    ///    .send()
    ///    .await;
    /// ```
    pub fn msearch_get(&self) -> builder::MsearchGet {
        builder::MsearchGet::new(self)
    }

    ///Allows to execute several search operations in one request.
    ///
    ///Sends a `POST` request to `/_msearch`
    ///
    ///Arguments:
    /// - `ccs_minimize_roundtrips`: Indicates whether network round-trips
    ///   should be minimized as part of cross-cluster search requests
    ///   execution.
    /// - `max_concurrent_searches`: Controls the maximum number of concurrent
    ///   searches the multi search api will execute.
    /// - `max_concurrent_shard_requests`: The number of concurrent shard
    ///   requests each sub search executes concurrently per node. This value
    ///   should be used to limit the impact of the search on the cluster in
    ///   order to limit the number of concurrent shard requests.
    /// - `pre_filter_shard_size`: Threshold that enforces a pre-filter
    ///   round-trip to prefilter search shards based on query rewriting if the
    ///   number of shards the search request expands to exceeds the threshold.
    ///   This filter round-trip can limit the number of shards significantly if
    ///   for instance a shard can not match any documents based on its rewrite
    ///   method ie. if date filters are mandatory to match but the shard bounds
    ///   and the query are disjoint.
    /// - `rest_total_hits_as_int`: Indicates whether hits.total should be
    ///   rendered as an integer or an object in the rest search response.
    /// - `search_type`: Search operation type.
    /// - `typed_keys`: Specify whether aggregation and suggester names should
    ///   be prefixed by their respective types in the response.
    /// - `body`
    ///```ignore
    /// let response = client.msearch_post()
    ///    .ccs_minimize_roundtrips(ccs_minimize_roundtrips)
    ///    .max_concurrent_searches(max_concurrent_searches)
    ///    .max_concurrent_shard_requests(max_concurrent_shard_requests)
    ///    .pre_filter_shard_size(pre_filter_shard_size)
    ///    .rest_total_hits_as_int(rest_total_hits_as_int)
    ///    .search_type(search_type)
    ///    .typed_keys(typed_keys)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn msearch_post(&self) -> builder::MsearchPost {
        builder::MsearchPost::new(self)
    }

    ///Allows to execute several search template operations in one request.
    ///
    ///Sends a `GET` request to `/_msearch/template`
    ///
    ///Arguments:
    /// - `ccs_minimize_roundtrips`: Indicates whether network round-trips
    ///   should be minimized as part of cross-cluster search requests
    ///   execution.
    /// - `max_concurrent_searches`: Controls the maximum number of concurrent
    ///   searches the multi search api will execute.
    /// - `rest_total_hits_as_int`: Indicates whether hits.total should be
    ///   rendered as an integer or an object in the rest search response.
    /// - `search_type`: Search operation type.
    /// - `typed_keys`: Specify whether aggregation and suggester names should
    ///   be prefixed by their respective types in the response.
    ///```ignore
    /// let response = client.msearch_template_get()
    ///    .ccs_minimize_roundtrips(ccs_minimize_roundtrips)
    ///    .max_concurrent_searches(max_concurrent_searches)
    ///    .rest_total_hits_as_int(rest_total_hits_as_int)
    ///    .search_type(search_type)
    ///    .typed_keys(typed_keys)
    ///    .send()
    ///    .await;
    /// ```
    pub fn msearch_template_get(&self) -> builder::MsearchTemplateGet {
        builder::MsearchTemplateGet::new(self)
    }

    ///Allows to execute several search template operations in one request.
    ///
    ///Sends a `POST` request to `/_msearch/template`
    ///
    ///Arguments:
    /// - `ccs_minimize_roundtrips`: Indicates whether network round-trips
    ///   should be minimized as part of cross-cluster search requests
    ///   execution.
    /// - `max_concurrent_searches`: Controls the maximum number of concurrent
    ///   searches the multi search api will execute.
    /// - `rest_total_hits_as_int`: Indicates whether hits.total should be
    ///   rendered as an integer or an object in the rest search response.
    /// - `search_type`: Search operation type.
    /// - `typed_keys`: Specify whether aggregation and suggester names should
    ///   be prefixed by their respective types in the response.
    /// - `body`
    ///```ignore
    /// let response = client.msearch_template_post()
    ///    .ccs_minimize_roundtrips(ccs_minimize_roundtrips)
    ///    .max_concurrent_searches(max_concurrent_searches)
    ///    .rest_total_hits_as_int(rest_total_hits_as_int)
    ///    .search_type(search_type)
    ///    .typed_keys(typed_keys)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn msearch_template_post(&self) -> builder::MsearchTemplatePost {
        builder::MsearchTemplatePost::new(self)
    }

    ///Returns multiple termvectors in one request.
    ///
    ///Sends a `GET` request to `/_mtermvectors`
    ///
    ///Arguments:
    /// - `field_statistics`: Specifies if document count, sum of document
    ///   frequencies and sum of total term frequencies should be returned.
    ///   Applies to all returned documents unless otherwise specified in body
    ///   'params' or 'docs'.
    /// - `fields`: Comma-separated list of fields to return. Applies to all
    ///   returned documents unless otherwise specified in body 'params' or
    ///   'docs'.
    /// - `ids`: Comma-separated list of documents ids. You must define ids as
    ///   parameter or set 'ids' or 'docs' in the request body.
    /// - `offsets`: Specifies if term offsets should be returned. Applies to
    ///   all returned documents unless otherwise specified in body 'params' or
    ///   'docs'.
    /// - `payloads`: Specifies if term payloads should be returned. Applies to
    ///   all returned documents unless otherwise specified in body 'params' or
    ///   'docs'.
    /// - `positions`: Specifies if term positions should be returned. Applies
    ///   to all returned documents unless otherwise specified in body 'params'
    ///   or 'docs'.
    /// - `preference`: Specify the node or shard the operation should be
    ///   performed on. Applies to all returned documents unless otherwise
    ///   specified in body 'params' or 'docs'.
    /// - `realtime`: Specifies if requests are real-time as opposed to
    ///   near-real-time.
    /// - `routing`: Routing value. Applies to all returned documents unless
    ///   otherwise specified in body 'params' or 'docs'.
    /// - `term_statistics`: Specifies if total term frequency and document
    ///   frequency should be returned. Applies to all returned documents unless
    ///   otherwise specified in body 'params' or 'docs'.
    /// - `version`: Explicit version number for concurrency control.
    /// - `version_type`: Specific version type.
    ///```ignore
    /// let response = client.mtermvectors_get()
    ///    .field_statistics(field_statistics)
    ///    .fields(fields)
    ///    .ids(ids)
    ///    .offsets(offsets)
    ///    .payloads(payloads)
    ///    .positions(positions)
    ///    .preference(preference)
    ///    .realtime(realtime)
    ///    .routing(routing)
    ///    .term_statistics(term_statistics)
    ///    .version(version)
    ///    .version_type(version_type)
    ///    .send()
    ///    .await;
    /// ```
    pub fn mtermvectors_get(&self) -> builder::MtermvectorsGet {
        builder::MtermvectorsGet::new(self)
    }

    ///Returns multiple termvectors in one request.
    ///
    ///Sends a `POST` request to `/_mtermvectors`
    ///
    ///Arguments:
    /// - `field_statistics`: Specifies if document count, sum of document
    ///   frequencies and sum of total term frequencies should be returned.
    ///   Applies to all returned documents unless otherwise specified in body
    ///   'params' or 'docs'.
    /// - `fields`: Comma-separated list of fields to return. Applies to all
    ///   returned documents unless otherwise specified in body 'params' or
    ///   'docs'.
    /// - `ids`: Comma-separated list of documents ids. You must define ids as
    ///   parameter or set 'ids' or 'docs' in the request body.
    /// - `offsets`: Specifies if term offsets should be returned. Applies to
    ///   all returned documents unless otherwise specified in body 'params' or
    ///   'docs'.
    /// - `payloads`: Specifies if term payloads should be returned. Applies to
    ///   all returned documents unless otherwise specified in body 'params' or
    ///   'docs'.
    /// - `positions`: Specifies if term positions should be returned. Applies
    ///   to all returned documents unless otherwise specified in body 'params'
    ///   or 'docs'.
    /// - `preference`: Specify the node or shard the operation should be
    ///   performed on. Applies to all returned documents unless otherwise
    ///   specified in body 'params' or 'docs'.
    /// - `realtime`: Specifies if requests are real-time as opposed to
    ///   near-real-time.
    /// - `routing`: Routing value. Applies to all returned documents unless
    ///   otherwise specified in body 'params' or 'docs'.
    /// - `term_statistics`: Specifies if total term frequency and document
    ///   frequency should be returned. Applies to all returned documents unless
    ///   otherwise specified in body 'params' or 'docs'.
    /// - `version`: Explicit version number for concurrency control.
    /// - `version_type`: Specific version type.
    /// - `body`
    ///```ignore
    /// let response = client.mtermvectors_post()
    ///    .field_statistics(field_statistics)
    ///    .fields(fields)
    ///    .ids(ids)
    ///    .offsets(offsets)
    ///    .payloads(payloads)
    ///    .positions(positions)
    ///    .preference(preference)
    ///    .realtime(realtime)
    ///    .routing(routing)
    ///    .term_statistics(term_statistics)
    ///    .version(version)
    ///    .version_type(version_type)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn mtermvectors_post(&self) -> builder::MtermvectorsPost {
        builder::MtermvectorsPost::new(self)
    }

    ///Returns information about nodes in the cluster.
    ///
    ///Sends a `GET` request to `/_nodes`
    ///
    ///Arguments:
    /// - `flat_settings`: Return settings in flat format.
    /// - `timeout`: Operation timeout.
    ///```ignore
    /// let response = client.nodes_info()
    ///    .flat_settings(flat_settings)
    ///    .timeout(timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn nodes_info(&self) -> builder::NodesInfo {
        builder::NodesInfo::new(self)
    }

    ///Returns information about hot threads on each node in the cluster.
    ///
    ///Sends a `GET` request to `/_nodes/hot_threads`
    ///
    ///Arguments:
    /// - `ignore_idle_threads`: Don't show threads that are in known-idle
    ///   places, such as waiting on a socket select or pulling from an empty
    ///   task queue.
    /// - `interval`: The interval for the second sampling of threads.
    /// - `snapshots`: Number of samples of thread stacktrace.
    /// - `threads`: Specify the number of threads to provide information for.
    /// - `timeout`: Operation timeout.
    /// - `type_`: The type to sample.
    ///```ignore
    /// let response = client.nodes_hot_threads()
    ///    .ignore_idle_threads(ignore_idle_threads)
    ///    .interval(interval)
    ///    .snapshots(snapshots)
    ///    .threads(threads)
    ///    .timeout(timeout)
    ///    .type_(type_)
    ///    .send()
    ///    .await;
    /// ```
    pub fn nodes_hot_threads(&self) -> builder::NodesHotThreads {
        builder::NodesHotThreads::new(self)
    }

    ///Returns information about hot threads on each node in the cluster.
    ///
    ///Sends a `GET` request to `/_nodes/hotthreads`
    ///
    ///Arguments:
    /// - `ignore_idle_threads`: Don't show threads that are in known-idle
    ///   places, such as waiting on a socket select or pulling from an empty
    ///   task queue.
    /// - `interval`: The interval for the second sampling of threads.
    /// - `snapshots`: Number of samples of thread stacktrace.
    /// - `threads`: Specify the number of threads to provide information for.
    /// - `timeout`: Operation timeout.
    /// - `type_`: The type to sample.
    ///```ignore
    /// let response = client.nodes_hot_threads_deprecated()
    ///    .ignore_idle_threads(ignore_idle_threads)
    ///    .interval(interval)
    ///    .snapshots(snapshots)
    ///    .threads(threads)
    ///    .timeout(timeout)
    ///    .type_(type_)
    ///    .send()
    ///    .await;
    /// ```
    pub fn nodes_hot_threads_deprecated(&self) -> builder::NodesHotThreadsDeprecated {
        builder::NodesHotThreadsDeprecated::new(self)
    }

    ///Reloads secure settings.
    ///
    ///Sends a `POST` request to `/_nodes/reload_secure_settings`
    ///
    ///Arguments:
    /// - `timeout`: Operation timeout.
    /// - `body`
    ///```ignore
    /// let response = client.nodes_reload_secure_settings()
    ///    .timeout(timeout)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn nodes_reload_secure_settings(&self) -> builder::NodesReloadSecureSettings {
        builder::NodesReloadSecureSettings::new(self)
    }

    ///Returns statistical information about nodes in the cluster.
    ///
    ///Sends a `GET` request to `/_nodes/stats`
    ///
    ///Arguments:
    /// - `completion_fields`: Comma-separated list of fields for `fielddata`
    ///   and `suggest` index metric (supports wildcards).
    /// - `fielddata_fields`: Comma-separated list of fields for `fielddata`
    ///   index metric (supports wildcards).
    /// - `fields`: Comma-separated list of fields for `fielddata` and
    ///   `completion` index metric (supports wildcards).
    /// - `groups`: Comma-separated list of search groups for `search` index
    ///   metric.
    /// - `include_segment_file_sizes`: Whether to report the aggregated disk
    ///   usage of each one of the Lucene index files (only applies if segment
    ///   stats are requested).
    /// - `level`: Return indices stats aggregated at index, node or shard
    ///   level.
    /// - `timeout`: Operation timeout.
    /// - `types`: Comma-separated list of document types for the `indexing`
    ///   index metric.
    ///```ignore
    /// let response = client.nodes_stats()
    ///    .completion_fields(completion_fields)
    ///    .fielddata_fields(fielddata_fields)
    ///    .fields(fields)
    ///    .groups(groups)
    ///    .include_segment_file_sizes(include_segment_file_sizes)
    ///    .level(level)
    ///    .timeout(timeout)
    ///    .types(types)
    ///    .send()
    ///    .await;
    /// ```
    pub fn nodes_stats(&self) -> builder::NodesStats {
        builder::NodesStats::new(self)
    }

    ///Returns statistical information about nodes in the cluster.
    ///
    ///Sends a `GET` request to `/_nodes/stats/{metric}`
    ///
    ///Arguments:
    /// - `metric`: Limit the information returned to the specified metrics.
    /// - `completion_fields`: Comma-separated list of fields for `fielddata`
    ///   and `suggest` index metric (supports wildcards).
    /// - `fielddata_fields`: Comma-separated list of fields for `fielddata`
    ///   index metric (supports wildcards).
    /// - `fields`: Comma-separated list of fields for `fielddata` and
    ///   `completion` index metric (supports wildcards).
    /// - `groups`: Comma-separated list of search groups for `search` index
    ///   metric.
    /// - `include_segment_file_sizes`: Whether to report the aggregated disk
    ///   usage of each one of the Lucene index files (only applies if segment
    ///   stats are requested).
    /// - `level`: Return indices stats aggregated at index, node or shard
    ///   level.
    /// - `timeout`: Operation timeout.
    /// - `types`: Comma-separated list of document types for the `indexing`
    ///   index metric.
    ///```ignore
    /// let response = client.nodes_stats_with_metric()
    ///    .metric(metric)
    ///    .completion_fields(completion_fields)
    ///    .fielddata_fields(fielddata_fields)
    ///    .fields(fields)
    ///    .groups(groups)
    ///    .include_segment_file_sizes(include_segment_file_sizes)
    ///    .level(level)
    ///    .timeout(timeout)
    ///    .types(types)
    ///    .send()
    ///    .await;
    /// ```
    pub fn nodes_stats_with_metric(&self) -> builder::NodesStatsWithMetric {
        builder::NodesStatsWithMetric::new(self)
    }

    ///Returns statistical information about nodes in the cluster.
    ///
    ///Sends a `GET` request to `/_nodes/stats/{metric}/{index_metric}`
    ///
    ///Arguments:
    /// - `metric`: Limit the information returned to the specified metrics.
    /// - `index_metric`: Limit the information returned for `indices` metric to
    ///   the specific index metrics. Isn't used if `indices` (or `all`) metric
    ///   isn't specified.
    /// - `completion_fields`: Comma-separated list of fields for `fielddata`
    ///   and `suggest` index metric (supports wildcards).
    /// - `fielddata_fields`: Comma-separated list of fields for `fielddata`
    ///   index metric (supports wildcards).
    /// - `fields`: Comma-separated list of fields for `fielddata` and
    ///   `completion` index metric (supports wildcards).
    /// - `groups`: Comma-separated list of search groups for `search` index
    ///   metric.
    /// - `include_segment_file_sizes`: Whether to report the aggregated disk
    ///   usage of each one of the Lucene index files (only applies if segment
    ///   stats are requested).
    /// - `level`: Return indices stats aggregated at index, node or shard
    ///   level.
    /// - `timeout`: Operation timeout.
    /// - `types`: Comma-separated list of document types for the `indexing`
    ///   index metric.
    ///```ignore
    /// let response = client.nodes_stats_with_index_metric_metric()
    ///    .metric(metric)
    ///    .index_metric(index_metric)
    ///    .completion_fields(completion_fields)
    ///    .fielddata_fields(fielddata_fields)
    ///    .fields(fields)
    ///    .groups(groups)
    ///    .include_segment_file_sizes(include_segment_file_sizes)
    ///    .level(level)
    ///    .timeout(timeout)
    ///    .types(types)
    ///    .send()
    ///    .await;
    /// ```
    pub fn nodes_stats_with_index_metric_metric(&self) -> builder::NodesStatsWithIndexMetricMetric {
        builder::NodesStatsWithIndexMetricMetric::new(self)
    }

    ///Returns low-level information about REST actions usage on nodes.
    ///
    ///Sends a `GET` request to `/_nodes/usage`
    ///
    ///Arguments:
    /// - `timeout`: Operation timeout.
    ///```ignore
    /// let response = client.nodes_usage()
    ///    .timeout(timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn nodes_usage(&self) -> builder::NodesUsage {
        builder::NodesUsage::new(self)
    }

    ///Returns low-level information about REST actions usage on nodes.
    ///
    ///Sends a `GET` request to `/_nodes/usage/{metric}`
    ///
    ///Arguments:
    /// - `metric`: Limit the information returned to the specified metrics.
    /// - `timeout`: Operation timeout.
    ///```ignore
    /// let response = client.nodes_usage_with_metric()
    ///    .metric(metric)
    ///    .timeout(timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn nodes_usage_with_metric(&self) -> builder::NodesUsageWithMetric {
        builder::NodesUsageWithMetric::new(self)
    }

    ///Returns information about nodes in the cluster.
    ///
    ///Sends a `GET` request to `/_nodes/{node_id}`
    ///
    ///Arguments:
    /// - `node_id`: Comma-separated list of node IDs or names to limit the
    ///   returned information; use `_local` to return information from the node
    ///   you're connecting to, leave empty to get information from all nodes.
    /// - `flat_settings`: Return settings in flat format.
    /// - `timeout`: Operation timeout.
    ///```ignore
    /// let response = client.nodes_info_with_node_id()
    ///    .node_id(node_id)
    ///    .flat_settings(flat_settings)
    ///    .timeout(timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn nodes_info_with_node_id(&self) -> builder::NodesInfoWithNodeId {
        builder::NodesInfoWithNodeId::new(self)
    }

    ///Returns information about hot threads on each node in the cluster.
    ///
    ///Sends a `GET` request to `/_nodes/{node_id}/hot_threads`
    ///
    ///Arguments:
    /// - `node_id`: Comma-separated list of node IDs or names to limit the
    ///   returned information; use `_local` to return information from the node
    ///   you're connecting to, leave empty to get information from all nodes.
    /// - `ignore_idle_threads`: Don't show threads that are in known-idle
    ///   places, such as waiting on a socket select or pulling from an empty
    ///   task queue.
    /// - `interval`: The interval for the second sampling of threads.
    /// - `snapshots`: Number of samples of thread stacktrace.
    /// - `threads`: Specify the number of threads to provide information for.
    /// - `timeout`: Operation timeout.
    /// - `type_`: The type to sample.
    ///```ignore
    /// let response = client.nodes_hot_threads_with_node_id()
    ///    .node_id(node_id)
    ///    .ignore_idle_threads(ignore_idle_threads)
    ///    .interval(interval)
    ///    .snapshots(snapshots)
    ///    .threads(threads)
    ///    .timeout(timeout)
    ///    .type_(type_)
    ///    .send()
    ///    .await;
    /// ```
    pub fn nodes_hot_threads_with_node_id(&self) -> builder::NodesHotThreadsWithNodeId {
        builder::NodesHotThreadsWithNodeId::new(self)
    }

    ///Returns information about hot threads on each node in the cluster.
    ///
    ///Sends a `GET` request to `/_nodes/{node_id}/hotthreads`
    ///
    ///Arguments:
    /// - `node_id`: Comma-separated list of node IDs or names to limit the
    ///   returned information; use `_local` to return information from the node
    ///   you're connecting to, leave empty to get information from all nodes.
    /// - `ignore_idle_threads`: Don't show threads that are in known-idle
    ///   places, such as waiting on a socket select or pulling from an empty
    ///   task queue.
    /// - `interval`: The interval for the second sampling of threads.
    /// - `snapshots`: Number of samples of thread stacktrace.
    /// - `threads`: Specify the number of threads to provide information for.
    /// - `timeout`: Operation timeout.
    /// - `type_`: The type to sample.
    ///```ignore
    /// let response = client.nodes_hot_threads_with_node_id_deprecated()
    ///    .node_id(node_id)
    ///    .ignore_idle_threads(ignore_idle_threads)
    ///    .interval(interval)
    ///    .snapshots(snapshots)
    ///    .threads(threads)
    ///    .timeout(timeout)
    ///    .type_(type_)
    ///    .send()
    ///    .await;
    /// ```
    pub fn nodes_hot_threads_with_node_id_deprecated(
        &self,
    ) -> builder::NodesHotThreadsWithNodeIdDeprecated {
        builder::NodesHotThreadsWithNodeIdDeprecated::new(self)
    }

    ///Reloads secure settings.
    ///
    ///Sends a `POST` request to `/_nodes/{node_id}/reload_secure_settings`
    ///
    ///Arguments:
    /// - `node_id`: Comma-separated list of node IDs to span the reload/reinit
    ///   call. Should stay empty because reloading usually involves all cluster
    ///   nodes.
    /// - `timeout`: Operation timeout.
    /// - `body`
    ///```ignore
    /// let response = client.nodes_reload_secure_settings_with_node_id()
    ///    .node_id(node_id)
    ///    .timeout(timeout)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn nodes_reload_secure_settings_with_node_id(
        &self,
    ) -> builder::NodesReloadSecureSettingsWithNodeId {
        builder::NodesReloadSecureSettingsWithNodeId::new(self)
    }

    ///Returns statistical information about nodes in the cluster.
    ///
    ///Sends a `GET` request to `/_nodes/{node_id}/stats`
    ///
    ///Arguments:
    /// - `node_id`: Comma-separated list of node IDs or names to limit the
    ///   returned information; use `_local` to return information from the node
    ///   you're connecting to, leave empty to get information from all nodes.
    /// - `completion_fields`: Comma-separated list of fields for `fielddata`
    ///   and `suggest` index metric (supports wildcards).
    /// - `fielddata_fields`: Comma-separated list of fields for `fielddata`
    ///   index metric (supports wildcards).
    /// - `fields`: Comma-separated list of fields for `fielddata` and
    ///   `completion` index metric (supports wildcards).
    /// - `groups`: Comma-separated list of search groups for `search` index
    ///   metric.
    /// - `include_segment_file_sizes`: Whether to report the aggregated disk
    ///   usage of each one of the Lucene index files (only applies if segment
    ///   stats are requested).
    /// - `level`: Return indices stats aggregated at index, node or shard
    ///   level.
    /// - `timeout`: Operation timeout.
    /// - `types`: Comma-separated list of document types for the `indexing`
    ///   index metric.
    ///```ignore
    /// let response = client.nodes_stats_with_node_id()
    ///    .node_id(node_id)
    ///    .completion_fields(completion_fields)
    ///    .fielddata_fields(fielddata_fields)
    ///    .fields(fields)
    ///    .groups(groups)
    ///    .include_segment_file_sizes(include_segment_file_sizes)
    ///    .level(level)
    ///    .timeout(timeout)
    ///    .types(types)
    ///    .send()
    ///    .await;
    /// ```
    pub fn nodes_stats_with_node_id(&self) -> builder::NodesStatsWithNodeId {
        builder::NodesStatsWithNodeId::new(self)
    }

    ///Returns statistical information about nodes in the cluster.
    ///
    ///Sends a `GET` request to `/_nodes/{node_id}/stats/{metric}`
    ///
    ///Arguments:
    /// - `node_id`: Comma-separated list of node IDs or names to limit the
    ///   returned information; use `_local` to return information from the node
    ///   you're connecting to, leave empty to get information from all nodes.
    /// - `metric`: Limit the information returned to the specified metrics.
    /// - `completion_fields`: Comma-separated list of fields for `fielddata`
    ///   and `suggest` index metric (supports wildcards).
    /// - `fielddata_fields`: Comma-separated list of fields for `fielddata`
    ///   index metric (supports wildcards).
    /// - `fields`: Comma-separated list of fields for `fielddata` and
    ///   `completion` index metric (supports wildcards).
    /// - `groups`: Comma-separated list of search groups for `search` index
    ///   metric.
    /// - `include_segment_file_sizes`: Whether to report the aggregated disk
    ///   usage of each one of the Lucene index files (only applies if segment
    ///   stats are requested).
    /// - `level`: Return indices stats aggregated at index, node or shard
    ///   level.
    /// - `timeout`: Operation timeout.
    /// - `types`: Comma-separated list of document types for the `indexing`
    ///   index metric.
    ///```ignore
    /// let response = client.nodes_stats_with_metric_node_id()
    ///    .node_id(node_id)
    ///    .metric(metric)
    ///    .completion_fields(completion_fields)
    ///    .fielddata_fields(fielddata_fields)
    ///    .fields(fields)
    ///    .groups(groups)
    ///    .include_segment_file_sizes(include_segment_file_sizes)
    ///    .level(level)
    ///    .timeout(timeout)
    ///    .types(types)
    ///    .send()
    ///    .await;
    /// ```
    pub fn nodes_stats_with_metric_node_id(&self) -> builder::NodesStatsWithMetricNodeId {
        builder::NodesStatsWithMetricNodeId::new(self)
    }

    ///Returns statistical information about nodes in the cluster.
    ///
    ///Sends a `GET` request to
    /// `/_nodes/{node_id}/stats/{metric}/{index_metric}`
    ///
    ///Arguments:
    /// - `node_id`: Comma-separated list of node IDs or names to limit the
    ///   returned information; use `_local` to return information from the node
    ///   you're connecting to, leave empty to get information from all nodes.
    /// - `metric`: Limit the information returned to the specified metrics.
    /// - `index_metric`: Limit the information returned for `indices` metric to
    ///   the specific index metrics. Isn't used if `indices` (or `all`) metric
    ///   isn't specified.
    /// - `completion_fields`: Comma-separated list of fields for `fielddata`
    ///   and `suggest` index metric (supports wildcards).
    /// - `fielddata_fields`: Comma-separated list of fields for `fielddata`
    ///   index metric (supports wildcards).
    /// - `fields`: Comma-separated list of fields for `fielddata` and
    ///   `completion` index metric (supports wildcards).
    /// - `groups`: Comma-separated list of search groups for `search` index
    ///   metric.
    /// - `include_segment_file_sizes`: Whether to report the aggregated disk
    ///   usage of each one of the Lucene index files (only applies if segment
    ///   stats are requested).
    /// - `level`: Return indices stats aggregated at index, node or shard
    ///   level.
    /// - `timeout`: Operation timeout.
    /// - `types`: Comma-separated list of document types for the `indexing`
    ///   index metric.
    ///```ignore
    /// let response = client.nodes_stats_with_index_metric_metric_node_id()
    ///    .node_id(node_id)
    ///    .metric(metric)
    ///    .index_metric(index_metric)
    ///    .completion_fields(completion_fields)
    ///    .fielddata_fields(fielddata_fields)
    ///    .fields(fields)
    ///    .groups(groups)
    ///    .include_segment_file_sizes(include_segment_file_sizes)
    ///    .level(level)
    ///    .timeout(timeout)
    ///    .types(types)
    ///    .send()
    ///    .await;
    /// ```
    pub fn nodes_stats_with_index_metric_metric_node_id(
        &self,
    ) -> builder::NodesStatsWithIndexMetricMetricNodeId {
        builder::NodesStatsWithIndexMetricMetricNodeId::new(self)
    }

    ///Returns low-level information about REST actions usage on nodes.
    ///
    ///Sends a `GET` request to `/_nodes/{node_id}/usage`
    ///
    ///Arguments:
    /// - `node_id`: Comma-separated list of node IDs or names to limit the
    ///   returned information; use `_local` to return information from the node
    ///   you're connecting to, leave empty to get information from all nodes.
    /// - `timeout`: Operation timeout.
    ///```ignore
    /// let response = client.nodes_usage_with_node_id()
    ///    .node_id(node_id)
    ///    .timeout(timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn nodes_usage_with_node_id(&self) -> builder::NodesUsageWithNodeId {
        builder::NodesUsageWithNodeId::new(self)
    }

    ///Returns low-level information about REST actions usage on nodes.
    ///
    ///Sends a `GET` request to `/_nodes/{node_id}/usage/{metric}`
    ///
    ///Arguments:
    /// - `node_id`: Comma-separated list of node IDs or names to limit the
    ///   returned information; use `_local` to return information from the node
    ///   you're connecting to, leave empty to get information from all nodes.
    /// - `metric`: Limit the information returned to the specified metrics.
    /// - `timeout`: Operation timeout.
    ///```ignore
    /// let response = client.nodes_usage_with_metric_node_id()
    ///    .node_id(node_id)
    ///    .metric(metric)
    ///    .timeout(timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn nodes_usage_with_metric_node_id(&self) -> builder::NodesUsageWithMetricNodeId {
        builder::NodesUsageWithMetricNodeId::new(self)
    }

    ///Returns information about nodes in the cluster.
    ///
    ///Sends a `GET` request to `/_nodes/{node_id}/{metric}`
    ///
    ///Arguments:
    /// - `node_id`: Comma-separated list of node IDs or names to limit the
    ///   returned information; use `_local` to return information from the node
    ///   you're connecting to, leave empty to get information from all nodes.
    /// - `metric`: Comma-separated list of metrics you wish returned. Leave
    ///   empty to return all.
    /// - `flat_settings`: Return settings in flat format.
    /// - `timeout`: Operation timeout.
    ///```ignore
    /// let response = client.nodes_info_with_metric_node_id()
    ///    .node_id(node_id)
    ///    .metric(metric)
    ///    .flat_settings(flat_settings)
    ///    .timeout(timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn nodes_info_with_metric_node_id(&self) -> builder::NodesInfoWithMetricNodeId {
        builder::NodesInfoWithMetricNodeId::new(self)
    }

    ///Returns account details for the current user.
    ///
    ///Sends a `GET` request to `/_plugins/_security/api/account`
    ///
    ///```ignore
    /// let response = client.get_account_details()
    ///    .send()
    ///    .await;
    /// ```
    pub fn get_account_details(&self) -> builder::GetAccountDetails {
        builder::GetAccountDetails::new(self)
    }

    ///Changes the password for the current user.
    ///
    ///Sends a `PUT` request to `/_plugins/_security/api/account`
    ///
    ///```ignore
    /// let response = client.change_password()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn change_password(&self) -> builder::ChangePassword {
        builder::ChangePassword::new(self)
    }

    ///Creates, updates, or deletes multiple action groups in a single call.
    ///
    ///Sends a `PATCH` request to `/_plugins/_security/api/actiongroups`
    ///
    ///```ignore
    /// let response = client.patch_action_groups()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn patch_action_groups(&self) -> builder::PatchActionGroups {
        builder::PatchActionGroups::new(self)
    }

    ///Retrieves all action groups.
    ///
    ///Sends a `GET` request to `/_plugins/_security/api/actiongroups/`
    ///
    ///```ignore
    /// let response = client.get_action_groups()
    ///    .send()
    ///    .await;
    /// ```
    pub fn get_action_groups(&self) -> builder::GetActionGroups {
        builder::GetActionGroups::new(self)
    }

    ///Retrieves one action group.
    ///
    ///Sends a `GET` request to
    /// `/_plugins/_security/api/actiongroups/{action_group}`
    ///
    ///Arguments:
    /// - `action_group`: Action group to retrieve.
    ///```ignore
    /// let response = client.get_action_group()
    ///    .action_group(action_group)
    ///    .send()
    ///    .await;
    /// ```
    pub fn get_action_group(&self) -> builder::GetActionGroup {
        builder::GetActionGroup::new(self)
    }

    ///Creates or replaces the specified action group.
    ///
    ///Sends a `PUT` request to
    /// `/_plugins/_security/api/actiongroups/{action_group}`
    ///
    ///Arguments:
    /// - `action_group`: The name of the action group to create or replace
    /// - `body`
    ///```ignore
    /// let response = client.create_action_group()
    ///    .action_group(action_group)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn create_action_group(&self) -> builder::CreateActionGroup {
        builder::CreateActionGroup::new(self)
    }

    ///Delete a specified action group.
    ///
    ///Sends a `DELETE` request to
    /// `/_plugins/_security/api/actiongroups/{action_group}`
    ///
    ///Arguments:
    /// - `action_group`: Action group to delete.
    ///```ignore
    /// let response = client.delete_action_group()
    ///    .action_group(action_group)
    ///    .send()
    ///    .await;
    /// ```
    pub fn delete_action_group(&self) -> builder::DeleteActionGroup {
        builder::DeleteActionGroup::new(self)
    }

    ///Updates individual attributes of an action group.
    ///
    ///Sends a `PATCH` request to
    /// `/_plugins/_security/api/actiongroups/{action_group}`
    ///
    ///```ignore
    /// let response = client.patch_action_group()
    ///    .action_group(action_group)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn patch_action_group(&self) -> builder::PatchActionGroup {
        builder::PatchActionGroup::new(self)
    }

    ///Retrieves the audit configuration.
    ///
    ///Sends a `GET` request to `/_plugins/_security/api/audit`
    ///
    ///```ignore
    /// let response = client.get_audit_configuration()
    ///    .send()
    ///    .await;
    /// ```
    pub fn get_audit_configuration(&self) -> builder::GetAuditConfiguration {
        builder::GetAuditConfiguration::new(self)
    }

    ///A PATCH call is used to update specified fields in the audit
    /// configuration.
    ///
    ///Sends a `PATCH` request to `/_plugins/_security/api/audit`
    ///
    ///```ignore
    /// let response = client.patch_audit_configuration()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn patch_audit_configuration(&self) -> builder::PatchAuditConfiguration {
        builder::PatchAuditConfiguration::new(self)
    }

    ///Updates the audit configuration.
    ///
    ///Sends a `PUT` request to `/_plugins/_security/api/audit/config`
    ///
    ///```ignore
    /// let response = client.update_audit_configuration()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn update_audit_configuration(&self) -> builder::UpdateAuditConfiguration {
        builder::UpdateAuditConfiguration::new(self)
    }

    ///Flushes the Security plugin user, authentication, and authorization
    /// cache.
    ///
    ///Sends a `DELETE` request to `/_plugins/_security/api/cache`
    ///
    ///```ignore
    /// let response = client.flush_cache()
    ///    .send()
    ///    .await;
    /// ```
    pub fn flush_cache(&self) -> builder::FlushCache {
        builder::FlushCache::new(self)
    }

    ///Retrieve all internal users.
    ///
    ///Sends a `GET` request to `/_plugins/_security/api/internalusers`
    ///
    ///```ignore
    /// let response = client.get_users()
    ///    .send()
    ///    .await;
    /// ```
    pub fn get_users(&self) -> builder::GetUsers {
        builder::GetUsers::new(self)
    }

    ///Creates, updates, or deletes multiple internal users in a single call.
    ///
    ///Sends a `PATCH` request to `/_plugins/_security/api/internalusers`
    ///
    ///```ignore
    /// let response = client.patch_users()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn patch_users(&self) -> builder::PatchUsers {
        builder::PatchUsers::new(self)
    }

    ///Retrieve one internal user.
    ///
    ///Sends a `GET` request to
    /// `/_plugins/_security/api/internalusers/{username}`
    ///
    ///```ignore
    /// let response = client.get_user()
    ///    .username(username)
    ///    .send()
    ///    .await;
    /// ```
    pub fn get_user(&self) -> builder::GetUser {
        builder::GetUser::new(self)
    }

    ///Creates or replaces the specified user.
    ///
    ///Sends a `PUT` request to
    /// `/_plugins/_security/api/internalusers/{username}`
    ///
    ///```ignore
    /// let response = client.create_user()
    ///    .username(username)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn create_user(&self) -> builder::CreateUser {
        builder::CreateUser::new(self)
    }

    ///Delete the specified user.
    ///
    ///Sends a `DELETE` request to
    /// `/_plugins/_security/api/internalusers/{username}`
    ///
    ///```ignore
    /// let response = client.delete_user()
    ///    .username(username)
    ///    .send()
    ///    .await;
    /// ```
    pub fn delete_user(&self) -> builder::DeleteUser {
        builder::DeleteUser::new(self)
    }

    ///Updates individual attributes of an internal user.
    ///
    ///Sends a `PATCH` request to
    /// `/_plugins/_security/api/internalusers/{username}`
    ///
    ///```ignore
    /// let response = client.patch_user()
    ///    .username(username)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn patch_user(&self) -> builder::PatchUser {
        builder::PatchUser::new(self)
    }

    ///Retrieves all distinguished names in the allow list.
    ///
    ///Sends a `GET` request to `/_plugins/_security/api/nodesdn`
    ///
    ///```ignore
    /// let response = client.get_distinguished_names()
    ///    .send()
    ///    .await;
    /// ```
    pub fn get_distinguished_names(&self) -> builder::GetDistinguishedNames {
        builder::GetDistinguishedNames::new(self)
    }

    ///Bulk update of distinguished names.
    ///
    ///Sends a `PATCH` request to `/_plugins/_security/api/nodesdn`
    ///
    ///```ignore
    /// let response = client.patch_distinguished_names()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn patch_distinguished_names(&self) -> builder::PatchDistinguishedNames {
        builder::PatchDistinguishedNames::new(self)
    }

    ///Retrieve distinguished names of a specified cluster.
    ///
    ///Sends a `GET` request to
    /// `/_plugins/_security/api/nodesdn/{cluster_name}`
    ///
    ///```ignore
    /// let response = client.get_distinguished_names_with_cluster_name()
    ///    .cluster_name(cluster_name)
    ///    .send()
    ///    .await;
    /// ```
    pub fn get_distinguished_names_with_cluster_name(
        &self,
    ) -> builder::GetDistinguishedNamesWithClusterName {
        builder::GetDistinguishedNamesWithClusterName::new(self)
    }

    ///Adds or updates the specified distinguished names in the cluster’s or
    /// node’s allow list.
    ///
    ///Sends a `PUT` request to
    /// `/_plugins/_security/api/nodesdn/{cluster_name}`
    ///
    ///```ignore
    /// let response = client.update_distinguished_names()
    ///    .cluster_name(cluster_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn update_distinguished_names(&self) -> builder::UpdateDistinguishedNames {
        builder::UpdateDistinguishedNames::new(self)
    }

    ///Deletes all distinguished names in the specified cluster’s or node’s
    /// allow list.
    ///
    ///Sends a `DELETE` request to
    /// `/_plugins/_security/api/nodesdn/{cluster_name}`
    ///
    ///```ignore
    /// let response = client.delete_distinguished_names()
    ///    .cluster_name(cluster_name)
    ///    .send()
    ///    .await;
    /// ```
    pub fn delete_distinguished_names(&self) -> builder::DeleteDistinguishedNames {
        builder::DeleteDistinguishedNames::new(self)
    }

    ///Creates, updates, or deletes multiple roles in a single call.
    ///
    ///Sends a `PATCH` request to `/_plugins/_security/api/roles`
    ///
    ///```ignore
    /// let response = client.patch_roles()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn patch_roles(&self) -> builder::PatchRoles {
        builder::PatchRoles::new(self)
    }

    ///Retrieves all roles.
    ///
    ///Sends a `GET` request to `/_plugins/_security/api/roles/`
    ///
    ///```ignore
    /// let response = client.get_roles()
    ///    .send()
    ///    .await;
    /// ```
    pub fn get_roles(&self) -> builder::GetRoles {
        builder::GetRoles::new(self)
    }

    ///Retrieves one role.
    ///
    ///Sends a `GET` request to `/_plugins/_security/api/roles/{role}`
    ///
    ///```ignore
    /// let response = client.get_role()
    ///    .role(role)
    ///    .send()
    ///    .await;
    /// ```
    pub fn get_role(&self) -> builder::GetRole {
        builder::GetRole::new(self)
    }

    ///Creates or replaces the specified role.
    ///
    ///Sends a `PUT` request to `/_plugins/_security/api/roles/{role}`
    ///
    ///```ignore
    /// let response = client.create_role()
    ///    .role(role)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn create_role(&self) -> builder::CreateRole {
        builder::CreateRole::new(self)
    }

    ///Delete the specified role.
    ///
    ///Sends a `DELETE` request to `/_plugins/_security/api/roles/{role}`
    ///
    ///```ignore
    /// let response = client.delete_role()
    ///    .role(role)
    ///    .send()
    ///    .await;
    /// ```
    pub fn delete_role(&self) -> builder::DeleteRole {
        builder::DeleteRole::new(self)
    }

    ///Updates individual attributes of a role.
    ///
    ///Sends a `PATCH` request to `/_plugins/_security/api/roles/{role}`
    ///
    ///```ignore
    /// let response = client.patch_role()
    ///    .role(role)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn patch_role(&self) -> builder::PatchRole {
        builder::PatchRole::new(self)
    }

    ///Retrieves all role mappings.
    ///
    ///Sends a `GET` request to `/_plugins/_security/api/rolesmapping`
    ///
    ///```ignore
    /// let response = client.get_role_mappings()
    ///    .send()
    ///    .await;
    /// ```
    pub fn get_role_mappings(&self) -> builder::GetRoleMappings {
        builder::GetRoleMappings::new(self)
    }

    ///Creates or updates multiple role mappings in a single call.
    ///
    ///Sends a `PATCH` request to `/_plugins/_security/api/rolesmapping`
    ///
    ///```ignore
    /// let response = client.patch_role_mappings()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn patch_role_mappings(&self) -> builder::PatchRoleMappings {
        builder::PatchRoleMappings::new(self)
    }

    ///Retrieves one role mapping.
    ///
    ///Sends a `GET` request to `/_plugins/_security/api/rolesmapping/{role}`
    ///
    ///```ignore
    /// let response = client.get_role_mapping()
    ///    .role(role)
    ///    .send()
    ///    .await;
    /// ```
    pub fn get_role_mapping(&self) -> builder::GetRoleMapping {
        builder::GetRoleMapping::new(self)
    }

    ///Creates or replaces the specified role mapping.
    ///
    ///Sends a `PUT` request to `/_plugins/_security/api/rolesmapping/{role}`
    ///
    ///```ignore
    /// let response = client.create_role_mapping()
    ///    .role(role)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn create_role_mapping(&self) -> builder::CreateRoleMapping {
        builder::CreateRoleMapping::new(self)
    }

    ///Deletes the specified role mapping.
    ///
    ///Sends a `DELETE` request to
    /// `/_plugins/_security/api/rolesmapping/{role}`
    ///
    ///```ignore
    /// let response = client.delete_role_mapping()
    ///    .role(role)
    ///    .send()
    ///    .await;
    /// ```
    pub fn delete_role_mapping(&self) -> builder::DeleteRoleMapping {
        builder::DeleteRoleMapping::new(self)
    }

    ///Updates individual attributes of a role mapping.
    ///
    ///Sends a `PATCH` request to `/_plugins/_security/api/rolesmapping/{role}`
    ///
    ///```ignore
    /// let response = client.patch_role_mapping()
    ///    .role(role)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn patch_role_mapping(&self) -> builder::PatchRoleMapping {
        builder::PatchRoleMapping::new(self)
    }

    ///Returns the current Security plugin configuration in JSON format.
    ///
    ///Sends a `GET` request to `/_plugins/_security/api/securityconfig`
    ///
    ///```ignore
    /// let response = client.get_configuration()
    ///    .send()
    ///    .await;
    /// ```
    pub fn get_configuration(&self) -> builder::GetConfiguration {
        builder::GetConfiguration::new(self)
    }

    ///A PATCH call is used to update the existing configuration using the REST
    /// API.
    ///
    ///Sends a `PATCH` request to `/_plugins/_security/api/securityconfig`
    ///
    ///```ignore
    /// let response = client.patch_configuration()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn patch_configuration(&self) -> builder::PatchConfiguration {
        builder::PatchConfiguration::new(self)
    }

    ///Adds or updates the existing configuration using the REST API.
    ///
    ///Sends a `PUT` request to `/_plugins/_security/api/securityconfig/config`
    ///
    ///```ignore
    /// let response = client.update_configuration()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn update_configuration(&self) -> builder::UpdateConfiguration {
        builder::UpdateConfiguration::new(self)
    }

    ///Retrieves the cluster’s security certificates.
    ///
    ///Sends a `GET` request to `/_plugins/_security/api/ssl/certs`
    ///
    ///```ignore
    /// let response = client.get_certificates()
    ///    .send()
    ///    .await;
    /// ```
    pub fn get_certificates(&self) -> builder::GetCertificates {
        builder::GetCertificates::new(self)
    }

    ///Reload HTTP layer communication certificates.
    ///
    ///Sends a `PUT` request to `/_plugins/_security/api/ssl/http/reloadcerts`
    ///
    ///```ignore
    /// let response = client.reload_http_certificates()
    ///    .send()
    ///    .await;
    /// ```
    pub fn reload_http_certificates(&self) -> builder::ReloadHttpCertificates {
        builder::ReloadHttpCertificates::new(self)
    }

    ///Reload transport layer communication certificates.
    ///
    ///Sends a `PUT` request to
    /// `/_plugins/_security/api/ssl/transport/reloadcerts`
    ///
    ///```ignore
    /// let response = client.reload_transport_certificates()
    ///    .send()
    ///    .await;
    /// ```
    pub fn reload_transport_certificates(&self) -> builder::ReloadTransportCertificates {
        builder::ReloadTransportCertificates::new(self)
    }

    ///Retrieves all tenants.
    ///
    ///Sends a `GET` request to `/_plugins/_security/api/tenants/`
    ///
    ///```ignore
    /// let response = client.get_tenants()
    ///    .send()
    ///    .await;
    /// ```
    pub fn get_tenants(&self) -> builder::GetTenants {
        builder::GetTenants::new(self)
    }

    ///Add, delete, or modify multiple tenants in a single call.
    ///
    ///Sends a `PATCH` request to `/_plugins/_security/api/tenants/`
    ///
    ///```ignore
    /// let response = client.patch_tenants()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn patch_tenants(&self) -> builder::PatchTenants {
        builder::PatchTenants::new(self)
    }

    ///Retrieves one tenant.
    ///
    ///Sends a `GET` request to `/_plugins/_security/api/tenants/{tenant}`
    ///
    ///```ignore
    /// let response = client.get_tenant()
    ///    .tenant(tenant)
    ///    .send()
    ///    .await;
    /// ```
    pub fn get_tenant(&self) -> builder::GetTenant {
        builder::GetTenant::new(self)
    }

    ///Creates or replaces the specified tenant.
    ///
    ///Sends a `PUT` request to `/_plugins/_security/api/tenants/{tenant}`
    ///
    ///```ignore
    /// let response = client.create_tenant()
    ///    .tenant(tenant)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn create_tenant(&self) -> builder::CreateTenant {
        builder::CreateTenant::new(self)
    }

    ///Delete the specified tenant.
    ///
    ///Sends a `DELETE` request to `/_plugins/_security/api/tenants/{tenant}`
    ///
    ///```ignore
    /// let response = client.delete_tenant()
    ///    .tenant(tenant)
    ///    .send()
    ///    .await;
    /// ```
    pub fn delete_tenant(&self) -> builder::DeleteTenant {
        builder::DeleteTenant::new(self)
    }

    ///Add, delete, or modify a single tenant.
    ///
    ///Sends a `PATCH` request to `/_plugins/_security/api/tenants/{tenant}`
    ///
    ///```ignore
    /// let response = client.patch_tenant()
    ///    .tenant(tenant)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn patch_tenant(&self) -> builder::PatchTenant {
        builder::PatchTenant::new(self)
    }

    ///Checks to see if the Security plugin is up and running.
    ///
    ///Sends a `GET` request to `/_plugins/_security/health`
    ///
    ///```ignore
    /// let response = client.security_health()
    ///    .send()
    ///    .await;
    /// ```
    pub fn security_health(&self) -> builder::SecurityHealth {
        builder::SecurityHealth::new(self)
    }

    ///Allows to evaluate the quality of ranked search results over a set of
    /// typical search queries.
    ///
    ///Sends a `GET` request to `/_rank_eval`
    ///
    ///Arguments:
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `search_type`: Search operation type.
    ///```ignore
    /// let response = client.rank_eval_get()
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .search_type(search_type)
    ///    .send()
    ///    .await;
    /// ```
    pub fn rank_eval_get(&self) -> builder::RankEvalGet {
        builder::RankEvalGet::new(self)
    }

    ///Allows to evaluate the quality of ranked search results over a set of
    /// typical search queries.
    ///
    ///Sends a `POST` request to `/_rank_eval`
    ///
    ///Arguments:
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `search_type`: Search operation type.
    /// - `body`
    ///```ignore
    /// let response = client.rank_eval_post()
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .search_type(search_type)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn rank_eval_post(&self) -> builder::RankEvalPost {
        builder::RankEvalPost::new(self)
    }

    ///Returns information about ongoing index shard recoveries.
    ///
    ///Sends a `GET` request to `/_recovery`
    ///
    ///Arguments:
    /// - `active_only`: Display only those recoveries that are currently
    ///   on-going.
    /// - `detailed`: Whether to display detailed information about shard
    ///   recovery.
    ///```ignore
    /// let response = client.indices_recovery()
    ///    .active_only(active_only)
    ///    .detailed(detailed)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_recovery(&self) -> builder::IndicesRecovery {
        builder::IndicesRecovery::new(self)
    }

    ///Performs the refresh operation in one or more indices.
    ///
    ///Sends a `GET` request to `/_refresh`
    ///
    ///Arguments:
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    ///```ignore
    /// let response = client.indices_refresh_get()
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_refresh_get(&self) -> builder::IndicesRefreshGet {
        builder::IndicesRefreshGet::new(self)
    }

    ///Performs the refresh operation in one or more indices.
    ///
    ///Sends a `POST` request to `/_refresh`
    ///
    ///Arguments:
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    ///```ignore
    /// let response = client.indices_refresh_post()
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_refresh_post(&self) -> builder::IndicesRefreshPost {
        builder::IndicesRefreshPost::new(self)
    }

    ///Allows to copy documents from one index to another, optionally filtering
    /// the source documents by a query, changing the destination index
    /// settings, or fetching the documents from a remote cluster.
    ///
    ///Sends a `POST` request to `/_reindex`
    ///
    ///Arguments:
    /// - `max_docs`: Maximum number of documents to process (default: all
    ///   documents).
    /// - `refresh`: Should the affected indexes be refreshed?.
    /// - `requests_per_second`: The throttle for this request in sub-requests
    ///   per second. -1 means no throttle.
    /// - `scroll`: Specify how long a consistent view of the index should be
    ///   maintained for scrolled search.
    /// - `slices`: The number of slices this task should be divided into.
    ///   Defaults to 1, meaning the task isn't sliced into subtasks. Can be set
    ///   to `auto`.
    /// - `timeout`: Time each individual bulk request should wait for shards
    ///   that are unavailable.
    /// - `wait_for_active_shards`: Sets the number of shard copies that must be
    ///   active before proceeding with the operation. Defaults to 1, meaning
    ///   the primary shard only. Set to `all` for all shard copies, otherwise
    ///   set to any non-negative value less than or equal to the total number
    ///   of copies for the shard (number of replicas + 1).
    /// - `wait_for_completion`: Should this request wait until the operation
    ///   has completed before returning.
    /// - `body`
    ///```ignore
    /// let response = client.reindex()
    ///    .max_docs(max_docs)
    ///    .refresh(refresh)
    ///    .requests_per_second(requests_per_second)
    ///    .scroll(scroll)
    ///    .slices(slices)
    ///    .timeout(timeout)
    ///    .wait_for_active_shards(wait_for_active_shards)
    ///    .wait_for_completion(wait_for_completion)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn reindex(&self) -> builder::Reindex {
        builder::Reindex::new(self)
    }

    ///Changes the number of requests per second for a particular Reindex
    /// operation.
    ///
    ///Sends a `POST` request to `/_reindex/{task_id}/_rethrottle`
    ///
    ///Arguments:
    /// - `task_id`: The task id to rethrottle.
    /// - `requests_per_second`: The throttle for this request in sub-requests
    ///   per second. -1 means no throttle.
    ///```ignore
    /// let response = client.reindex_rethrottle()
    ///    .task_id(task_id)
    ///    .requests_per_second(requests_per_second)
    ///    .send()
    ///    .await;
    /// ```
    pub fn reindex_rethrottle(&self) -> builder::ReindexRethrottle {
        builder::ReindexRethrottle::new(self)
    }

    ///Returns the information about configured remote clusters.
    ///
    ///Sends a `GET` request to `/_remote/info`
    ///
    ///```ignore
    /// let response = client.cluster_remote_info()
    ///    .send()
    ///    .await;
    /// ```
    pub fn cluster_remote_info(&self) -> builder::ClusterRemoteInfo {
        builder::ClusterRemoteInfo::new(self)
    }

    ///Restores from remote store.
    ///
    ///Sends a `POST` request to `/_remotestore/_restore`
    ///
    ///Arguments:
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `wait_for_completion`: Should this request wait until the operation
    ///   has completed before returning.
    /// - `body`
    ///```ignore
    /// let response = client.remote_store_restore()
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .wait_for_completion(wait_for_completion)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn remote_store_restore(&self) -> builder::RemoteStoreRestore {
        builder::RemoteStoreRestore::new(self)
    }

    ///Allows to use the Mustache language to pre-render a search definition.
    ///
    ///Sends a `GET` request to `/_render/template`
    ///
    ///```ignore
    /// let response = client.render_search_template_get()
    ///    .send()
    ///    .await;
    /// ```
    pub fn render_search_template_get(&self) -> builder::RenderSearchTemplateGet {
        builder::RenderSearchTemplateGet::new(self)
    }

    ///Allows to use the Mustache language to pre-render a search definition.
    ///
    ///Sends a `POST` request to `/_render/template`
    ///
    ///```ignore
    /// let response = client.render_search_template_post()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn render_search_template_post(&self) -> builder::RenderSearchTemplatePost {
        builder::RenderSearchTemplatePost::new(self)
    }

    ///Allows to use the Mustache language to pre-render a search definition.
    ///
    ///Sends a `GET` request to `/_render/template/{id}`
    ///
    ///Arguments:
    /// - `id`: The id of the stored search template.
    ///```ignore
    /// let response = client.render_search_template_get_with_id()
    ///    .id(id)
    ///    .send()
    ///    .await;
    /// ```
    pub fn render_search_template_get_with_id(&self) -> builder::RenderSearchTemplateGetWithId {
        builder::RenderSearchTemplateGetWithId::new(self)
    }

    ///Allows to use the Mustache language to pre-render a search definition.
    ///
    ///Sends a `POST` request to `/_render/template/{id}`
    ///
    ///Arguments:
    /// - `id`: The id of the stored search template.
    /// - `body`
    ///```ignore
    /// let response = client.render_search_template_post_with_id()
    ///    .id(id)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn render_search_template_post_with_id(&self) -> builder::RenderSearchTemplatePostWithId {
        builder::RenderSearchTemplatePostWithId::new(self)
    }

    ///Returns information about any matching indices, aliases, and data
    /// streams.
    ///
    ///Sends a `GET` request to `/_resolve/index/{name}`
    ///
    ///Arguments:
    /// - `name`: Comma-separated list of names or wildcard expressions.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    ///```ignore
    /// let response = client.indices_resolve_index()
    ///    .name(name)
    ///    .expand_wildcards(expand_wildcards)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_resolve_index(&self) -> builder::IndicesResolveIndex {
        builder::IndicesResolveIndex::new(self)
    }

    ///Returns all script contexts.
    ///
    ///Sends a `GET` request to `/_script_context`
    ///
    ///```ignore
    /// let response = client.get_script_context()
    ///    .send()
    ///    .await;
    /// ```
    pub fn get_script_context(&self) -> builder::GetScriptContext {
        builder::GetScriptContext::new(self)
    }

    ///Returns available script types, languages and contexts.
    ///
    ///Sends a `GET` request to `/_script_language`
    ///
    ///```ignore
    /// let response = client.get_script_languages()
    ///    .send()
    ///    .await;
    /// ```
    pub fn get_script_languages(&self) -> builder::GetScriptLanguages {
        builder::GetScriptLanguages::new(self)
    }

    ///Allows an arbitrary script to be executed and a result to be returned.
    ///
    ///Sends a `GET` request to `/_scripts/painless/_execute`
    ///
    ///```ignore
    /// let response = client.scripts_painless_execute_get()
    ///    .send()
    ///    .await;
    /// ```
    pub fn scripts_painless_execute_get(&self) -> builder::ScriptsPainlessExecuteGet {
        builder::ScriptsPainlessExecuteGet::new(self)
    }

    ///Allows an arbitrary script to be executed and a result to be returned.
    ///
    ///Sends a `POST` request to `/_scripts/painless/_execute`
    ///
    ///```ignore
    /// let response = client.scripts_painless_execute_post()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn scripts_painless_execute_post(&self) -> builder::ScriptsPainlessExecutePost {
        builder::ScriptsPainlessExecutePost::new(self)
    }

    ///Returns a script.
    ///
    ///Sends a `GET` request to `/_scripts/{id}`
    ///
    ///Arguments:
    /// - `id`: Script ID.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    ///```ignore
    /// let response = client.get_script()
    ///    .id(id)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .master_timeout(master_timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn get_script(&self) -> builder::GetScript {
        builder::GetScript::new(self)
    }

    ///Creates or updates a script.
    ///
    ///Sends a `PUT` request to `/_scripts/{id}`
    ///
    ///Arguments:
    /// - `id`: Script ID.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    /// - `body`
    ///```ignore
    /// let response = client.put_script_put()
    ///    .id(id)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn put_script_put(&self) -> builder::PutScriptPut {
        builder::PutScriptPut::new(self)
    }

    ///Creates or updates a script.
    ///
    ///Sends a `POST` request to `/_scripts/{id}`
    ///
    ///Arguments:
    /// - `id`: Script ID.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    /// - `body`
    ///```ignore
    /// let response = client.put_script_post()
    ///    .id(id)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn put_script_post(&self) -> builder::PutScriptPost {
        builder::PutScriptPost::new(self)
    }

    ///Deletes a script.
    ///
    ///Sends a `DELETE` request to `/_scripts/{id}`
    ///
    ///Arguments:
    /// - `id`: Script ID.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    ///```ignore
    /// let response = client.delete_script()
    ///    .id(id)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn delete_script(&self) -> builder::DeleteScript {
        builder::DeleteScript::new(self)
    }

    ///Creates or updates a script.
    ///
    ///Sends a `PUT` request to `/_scripts/{id}/{context}`
    ///
    ///Arguments:
    /// - `id`: Script ID.
    /// - `context`: Script context.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    /// - `body`
    ///```ignore
    /// let response = client.put_script_put_with_context()
    ///    .id(id)
    ///    .context(context)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn put_script_put_with_context(&self) -> builder::PutScriptPutWithContext {
        builder::PutScriptPutWithContext::new(self)
    }

    ///Creates or updates a script.
    ///
    ///Sends a `POST` request to `/_scripts/{id}/{context}`
    ///
    ///Arguments:
    /// - `id`: Script ID.
    /// - `context`: Script context.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    /// - `body`
    ///```ignore
    /// let response = client.put_script_post_with_context()
    ///    .id(id)
    ///    .context(context)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn put_script_post_with_context(&self) -> builder::PutScriptPostWithContext {
        builder::PutScriptPostWithContext::new(self)
    }

    ///Returns results matching a query.
    ///
    ///Sends a `GET` request to `/_search`
    ///
    ///Arguments:
    /// - `source`: True or false to return the _source field or not, or a list
    ///   of fields to return.
    /// - `source_excludes`: List of fields to exclude from the returned _source
    ///   field.
    /// - `source_includes`: List of fields to extract and return from the
    ///   _source field.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `allow_partial_search_results`: Indicate if an error should be
    ///   returned if there is a partial search failure or timeout.
    /// - `analyze_wildcard`: Specify whether wildcard and prefix queries should
    ///   be analyzed.
    /// - `analyzer`: The analyzer to use for the query string.
    /// - `batched_reduce_size`: The number of shard results that should be
    ///   reduced at once on the coordinating node. This value should be used as
    ///   a protection mechanism to reduce the memory overhead per search
    ///   request if the potential number of shards in the request can be large.
    /// - `ccs_minimize_roundtrips`: Indicates whether network round-trips
    ///   should be minimized as part of cross-cluster search requests
    ///   execution.
    /// - `default_operator`: The default operator for query string query (AND
    ///   or OR).
    /// - `df`: The field to use as default where no field prefix is given in
    ///   the query string.
    /// - `docvalue_fields`: Comma-separated list of fields to return as the
    ///   docvalue representation of a field for each hit.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `explain`: Specify whether to return detailed information about score
    ///   computation as part of a hit.
    /// - `from`: Starting offset.
    /// - `ignore_throttled`: Whether specified concrete, expanded or aliased
    ///   indices should be ignored when throttled.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `lenient`: Specify whether format-based query failures (such as
    ///   providing text to a numeric field) should be ignored.
    /// - `max_concurrent_shard_requests`: The number of concurrent shard
    ///   requests per node this search executes concurrently. This value should
    ///   be used to limit the impact of the search on the cluster in order to
    ///   limit the number of concurrent shard requests.
    /// - `pre_filter_shard_size`: Threshold that enforces a pre-filter
    ///   round-trip to prefilter search shards based on query rewriting if the
    ///   number of shards the search request expands to exceeds the threshold.
    ///   This filter round-trip can limit the number of shards significantly if
    ///   for instance a shard can not match any documents based on its rewrite
    ///   method ie. if date filters are mandatory to match but the shard bounds
    ///   and the query are disjoint.
    /// - `preference`: Specify the node or shard the operation should be
    ///   performed on.
    /// - `q`: Query in the Lucene query string syntax.
    /// - `request_cache`: Specify if request cache should be used for this
    ///   request or not, defaults to index level setting.
    /// - `rest_total_hits_as_int`: Indicates whether hits.total should be
    ///   rendered as an integer or an object in the rest search response.
    /// - `routing`: Comma-separated list of specific routing values.
    /// - `scroll`: Specify how long a consistent view of the index should be
    ///   maintained for scrolled search.
    /// - `search_type`: Search operation type.
    /// - `seq_no_primary_term`: Specify whether to return sequence number and
    ///   primary term of the last modification of each hit.
    /// - `size`: Number of hits to return.
    /// - `sort`: Comma-separated list of <field>:<direction> pairs.
    /// - `stats`: Specific 'tag' of the request for logging and statistical
    ///   purposes.
    /// - `stored_fields`: Comma-separated list of stored fields to return.
    /// - `suggest_field`: Specify which field to use for suggestions.
    /// - `suggest_mode`: Specify suggest mode.
    /// - `suggest_size`: How many suggestions to return in response.
    /// - `suggest_text`: The source text for which the suggestions should be
    ///   returned.
    /// - `terminate_after`: The maximum number of documents to collect for each
    ///   shard, upon reaching which the query execution will terminate early.
    /// - `timeout`: Operation timeout.
    /// - `track_scores`: Whether to calculate and return scores even if they
    ///   are not used for sorting.
    /// - `track_total_hits`: Indicate if the number of documents that match the
    ///   query should be tracked.
    /// - `typed_keys`: Specify whether aggregation and suggester names should
    ///   be prefixed by their respective types in the response.
    /// - `version`: Whether to return document version as part of a hit.
    ///```ignore
    /// let response = client.search_get()
    ///    .source(source)
    ///    .source_excludes(source_excludes)
    ///    .source_includes(source_includes)
    ///    .allow_no_indices(allow_no_indices)
    ///    .allow_partial_search_results(allow_partial_search_results)
    ///    .analyze_wildcard(analyze_wildcard)
    ///    .analyzer(analyzer)
    ///    .batched_reduce_size(batched_reduce_size)
    ///    .ccs_minimize_roundtrips(ccs_minimize_roundtrips)
    ///    .default_operator(default_operator)
    ///    .df(df)
    ///    .docvalue_fields(docvalue_fields)
    ///    .expand_wildcards(expand_wildcards)
    ///    .explain(explain)
    ///    .from(from)
    ///    .ignore_throttled(ignore_throttled)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .lenient(lenient)
    ///    .max_concurrent_shard_requests(max_concurrent_shard_requests)
    ///    .pre_filter_shard_size(pre_filter_shard_size)
    ///    .preference(preference)
    ///    .q(q)
    ///    .request_cache(request_cache)
    ///    .rest_total_hits_as_int(rest_total_hits_as_int)
    ///    .routing(routing)
    ///    .scroll(scroll)
    ///    .search_type(search_type)
    ///    .seq_no_primary_term(seq_no_primary_term)
    ///    .size(size)
    ///    .sort(sort)
    ///    .stats(stats)
    ///    .stored_fields(stored_fields)
    ///    .suggest_field(suggest_field)
    ///    .suggest_mode(suggest_mode)
    ///    .suggest_size(suggest_size)
    ///    .suggest_text(suggest_text)
    ///    .terminate_after(terminate_after)
    ///    .timeout(timeout)
    ///    .track_scores(track_scores)
    ///    .track_total_hits(track_total_hits)
    ///    .typed_keys(typed_keys)
    ///    .version(version)
    ///    .send()
    ///    .await;
    /// ```
    pub fn search_get(&self) -> builder::SearchGet {
        builder::SearchGet::new(self)
    }

    ///Returns results matching a query.
    ///
    ///Sends a `POST` request to `/_search`
    ///
    ///Arguments:
    /// - `source`: True or false to return the _source field or not, or a list
    ///   of fields to return.
    /// - `source_excludes`: List of fields to exclude from the returned _source
    ///   field.
    /// - `source_includes`: List of fields to extract and return from the
    ///   _source field.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `allow_partial_search_results`: Indicate if an error should be
    ///   returned if there is a partial search failure or timeout.
    /// - `analyze_wildcard`: Specify whether wildcard and prefix queries should
    ///   be analyzed.
    /// - `analyzer`: The analyzer to use for the query string.
    /// - `batched_reduce_size`: The number of shard results that should be
    ///   reduced at once on the coordinating node. This value should be used as
    ///   a protection mechanism to reduce the memory overhead per search
    ///   request if the potential number of shards in the request can be large.
    /// - `ccs_minimize_roundtrips`: Indicates whether network round-trips
    ///   should be minimized as part of cross-cluster search requests
    ///   execution.
    /// - `default_operator`: The default operator for query string query (AND
    ///   or OR).
    /// - `df`: The field to use as default where no field prefix is given in
    ///   the query string.
    /// - `docvalue_fields`: Comma-separated list of fields to return as the
    ///   docvalue representation of a field for each hit.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `explain`: Specify whether to return detailed information about score
    ///   computation as part of a hit.
    /// - `from`: Starting offset.
    /// - `ignore_throttled`: Whether specified concrete, expanded or aliased
    ///   indices should be ignored when throttled.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `lenient`: Specify whether format-based query failures (such as
    ///   providing text to a numeric field) should be ignored.
    /// - `max_concurrent_shard_requests`: The number of concurrent shard
    ///   requests per node this search executes concurrently. This value should
    ///   be used to limit the impact of the search on the cluster in order to
    ///   limit the number of concurrent shard requests.
    /// - `pre_filter_shard_size`: Threshold that enforces a pre-filter
    ///   round-trip to prefilter search shards based on query rewriting if the
    ///   number of shards the search request expands to exceeds the threshold.
    ///   This filter round-trip can limit the number of shards significantly if
    ///   for instance a shard can not match any documents based on its rewrite
    ///   method ie. if date filters are mandatory to match but the shard bounds
    ///   and the query are disjoint.
    /// - `preference`: Specify the node or shard the operation should be
    ///   performed on.
    /// - `q`: Query in the Lucene query string syntax.
    /// - `request_cache`: Specify if request cache should be used for this
    ///   request or not, defaults to index level setting.
    /// - `rest_total_hits_as_int`: Indicates whether hits.total should be
    ///   rendered as an integer or an object in the rest search response.
    /// - `routing`: Comma-separated list of specific routing values.
    /// - `scroll`: Specify how long a consistent view of the index should be
    ///   maintained for scrolled search.
    /// - `search_type`: Search operation type.
    /// - `seq_no_primary_term`: Specify whether to return sequence number and
    ///   primary term of the last modification of each hit.
    /// - `size`: Number of hits to return.
    /// - `sort`: Comma-separated list of <field>:<direction> pairs.
    /// - `stats`: Specific 'tag' of the request for logging and statistical
    ///   purposes.
    /// - `stored_fields`: Comma-separated list of stored fields to return.
    /// - `suggest_field`: Specify which field to use for suggestions.
    /// - `suggest_mode`: Specify suggest mode.
    /// - `suggest_size`: How many suggestions to return in response.
    /// - `suggest_text`: The source text for which the suggestions should be
    ///   returned.
    /// - `terminate_after`: The maximum number of documents to collect for each
    ///   shard, upon reaching which the query execution will terminate early.
    /// - `timeout`: Operation timeout.
    /// - `track_scores`: Whether to calculate and return scores even if they
    ///   are not used for sorting.
    /// - `track_total_hits`: Indicate if the number of documents that match the
    ///   query should be tracked.
    /// - `typed_keys`: Specify whether aggregation and suggester names should
    ///   be prefixed by their respective types in the response.
    /// - `version`: Whether to return document version as part of a hit.
    /// - `body`
    ///```ignore
    /// let response = client.search_post()
    ///    .source(source)
    ///    .source_excludes(source_excludes)
    ///    .source_includes(source_includes)
    ///    .allow_no_indices(allow_no_indices)
    ///    .allow_partial_search_results(allow_partial_search_results)
    ///    .analyze_wildcard(analyze_wildcard)
    ///    .analyzer(analyzer)
    ///    .batched_reduce_size(batched_reduce_size)
    ///    .ccs_minimize_roundtrips(ccs_minimize_roundtrips)
    ///    .default_operator(default_operator)
    ///    .df(df)
    ///    .docvalue_fields(docvalue_fields)
    ///    .expand_wildcards(expand_wildcards)
    ///    .explain(explain)
    ///    .from(from)
    ///    .ignore_throttled(ignore_throttled)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .lenient(lenient)
    ///    .max_concurrent_shard_requests(max_concurrent_shard_requests)
    ///    .pre_filter_shard_size(pre_filter_shard_size)
    ///    .preference(preference)
    ///    .q(q)
    ///    .request_cache(request_cache)
    ///    .rest_total_hits_as_int(rest_total_hits_as_int)
    ///    .routing(routing)
    ///    .scroll(scroll)
    ///    .search_type(search_type)
    ///    .seq_no_primary_term(seq_no_primary_term)
    ///    .size(size)
    ///    .sort(sort)
    ///    .stats(stats)
    ///    .stored_fields(stored_fields)
    ///    .suggest_field(suggest_field)
    ///    .suggest_mode(suggest_mode)
    ///    .suggest_size(suggest_size)
    ///    .suggest_text(suggest_text)
    ///    .terminate_after(terminate_after)
    ///    .timeout(timeout)
    ///    .track_scores(track_scores)
    ///    .track_total_hits(track_total_hits)
    ///    .typed_keys(typed_keys)
    ///    .version(version)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn search_post(&self) -> builder::SearchPost {
        builder::SearchPost::new(self)
    }

    ///Deletes one or more point in time searches based on the IDs passed.
    ///
    ///Sends a `DELETE` request to `/_search/point_in_time`
    ///
    ///```ignore
    /// let response = client.delete_pit()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn delete_pit(&self) -> builder::DeletePit {
        builder::DeletePit::new(self)
    }

    ///Lists all active point in time searches.
    ///
    ///Sends a `GET` request to `/_search/point_in_time/_all`
    ///
    ///```ignore
    /// let response = client.get_all_pits()
    ///    .send()
    ///    .await;
    /// ```
    pub fn get_all_pits(&self) -> builder::GetAllPits {
        builder::GetAllPits::new(self)
    }

    ///Deletes all active point in time searches.
    ///
    ///Sends a `DELETE` request to `/_search/point_in_time/_all`
    ///
    ///```ignore
    /// let response = client.delete_all_pits()
    ///    .send()
    ///    .await;
    /// ```
    pub fn delete_all_pits(&self) -> builder::DeleteAllPits {
        builder::DeleteAllPits::new(self)
    }

    ///Allows to retrieve a large numbers of results from a single search
    /// request.
    ///
    ///Sends a `GET` request to `/_search/scroll`
    ///
    ///Arguments:
    /// - `rest_total_hits_as_int`: Indicates whether hits.total should be
    ///   rendered as an integer or an object in the rest search response.
    /// - `scroll`: Specify how long a consistent view of the index should be
    ///   maintained for scrolled search.
    /// - `scroll_id`: Scroll ID.
    ///```ignore
    /// let response = client.scroll_get()
    ///    .rest_total_hits_as_int(rest_total_hits_as_int)
    ///    .scroll(scroll)
    ///    .scroll_id(scroll_id)
    ///    .send()
    ///    .await;
    /// ```
    pub fn scroll_get(&self) -> builder::ScrollGet {
        builder::ScrollGet::new(self)
    }

    ///Allows to retrieve a large numbers of results from a single search
    /// request.
    ///
    ///Sends a `POST` request to `/_search/scroll`
    ///
    ///Arguments:
    /// - `rest_total_hits_as_int`: Indicates whether hits.total should be
    ///   rendered as an integer or an object in the rest search response.
    /// - `scroll`: Specify how long a consistent view of the index should be
    ///   maintained for scrolled search.
    /// - `scroll_id`: Scroll ID.
    /// - `body`
    ///```ignore
    /// let response = client.scroll_post()
    ///    .rest_total_hits_as_int(rest_total_hits_as_int)
    ///    .scroll(scroll)
    ///    .scroll_id(scroll_id)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn scroll_post(&self) -> builder::ScrollPost {
        builder::ScrollPost::new(self)
    }

    ///Explicitly clears the search context for a scroll.
    ///
    ///Sends a `DELETE` request to `/_search/scroll`
    ///
    ///```ignore
    /// let response = client.clear_scroll()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn clear_scroll(&self) -> builder::ClearScroll {
        builder::ClearScroll::new(self)
    }

    ///Allows to retrieve a large numbers of results from a single search
    /// request.
    ///
    ///Sends a `GET` request to `/_search/scroll/{scroll_id}`
    ///
    ///Arguments:
    /// - `rest_total_hits_as_int`: Indicates whether hits.total should be
    ///   rendered as an integer or an object in the rest search response.
    /// - `scroll`: Specify how long a consistent view of the index should be
    ///   maintained for scrolled search.
    /// - `scroll_id`: Scroll ID.
    ///```ignore
    /// let response = client.scroll_get_with_scroll_id()
    ///    .rest_total_hits_as_int(rest_total_hits_as_int)
    ///    .scroll(scroll)
    ///    .scroll_id(scroll_id)
    ///    .send()
    ///    .await;
    /// ```
    pub fn scroll_get_with_scroll_id(&self) -> builder::ScrollGetWithScrollId {
        builder::ScrollGetWithScrollId::new(self)
    }

    ///Allows to retrieve a large numbers of results from a single search
    /// request.
    ///
    ///Sends a `POST` request to `/_search/scroll/{scroll_id}`
    ///
    ///Arguments:
    /// - `rest_total_hits_as_int`: Indicates whether hits.total should be
    ///   rendered as an integer or an object in the rest search response.
    /// - `scroll`: Specify how long a consistent view of the index should be
    ///   maintained for scrolled search.
    /// - `scroll_id`: Scroll ID.
    /// - `body`
    ///```ignore
    /// let response = client.scroll_post_with_scroll_id()
    ///    .rest_total_hits_as_int(rest_total_hits_as_int)
    ///    .scroll(scroll)
    ///    .scroll_id(scroll_id)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn scroll_post_with_scroll_id(&self) -> builder::ScrollPostWithScrollId {
        builder::ScrollPostWithScrollId::new(self)
    }

    ///Explicitly clears the search context for a scroll.
    ///
    ///Sends a `DELETE` request to `/_search/scroll/{scroll_id}`
    ///
    ///Arguments:
    /// - `scroll_id`: Comma-separated list of scroll IDs to clear.
    /// - `body`
    ///```ignore
    /// let response = client.clear_scroll_with_scroll_id()
    ///    .scroll_id(scroll_id)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn clear_scroll_with_scroll_id(&self) -> builder::ClearScrollWithScrollId {
        builder::ClearScrollWithScrollId::new(self)
    }

    ///Allows to use the Mustache language to pre-render a search definition.
    ///
    ///Sends a `GET` request to `/_search/template`
    ///
    ///Arguments:
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `ccs_minimize_roundtrips`: Indicates whether network round-trips
    ///   should be minimized as part of cross-cluster search requests
    ///   execution.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `explain`: Specify whether to return detailed information about score
    ///   computation as part of a hit.
    /// - `ignore_throttled`: Whether specified concrete, expanded or aliased
    ///   indices should be ignored when throttled.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `preference`: Specify the node or shard the operation should be
    ///   performed on.
    /// - `profile`: Specify whether to profile the query execution.
    /// - `rest_total_hits_as_int`: Indicates whether hits.total should be
    ///   rendered as an integer or an object in the rest search response.
    /// - `routing`: Comma-separated list of specific routing values.
    /// - `scroll`: Specify how long a consistent view of the index should be
    ///   maintained for scrolled search.
    /// - `search_type`: Search operation type.
    /// - `typed_keys`: Specify whether aggregation and suggester names should
    ///   be prefixed by their respective types in the response.
    ///```ignore
    /// let response = client.search_template_get()
    ///    .allow_no_indices(allow_no_indices)
    ///    .ccs_minimize_roundtrips(ccs_minimize_roundtrips)
    ///    .expand_wildcards(expand_wildcards)
    ///    .explain(explain)
    ///    .ignore_throttled(ignore_throttled)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .preference(preference)
    ///    .profile(profile)
    ///    .rest_total_hits_as_int(rest_total_hits_as_int)
    ///    .routing(routing)
    ///    .scroll(scroll)
    ///    .search_type(search_type)
    ///    .typed_keys(typed_keys)
    ///    .send()
    ///    .await;
    /// ```
    pub fn search_template_get(&self) -> builder::SearchTemplateGet {
        builder::SearchTemplateGet::new(self)
    }

    ///Allows to use the Mustache language to pre-render a search definition.
    ///
    ///Sends a `POST` request to `/_search/template`
    ///
    ///Arguments:
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `ccs_minimize_roundtrips`: Indicates whether network round-trips
    ///   should be minimized as part of cross-cluster search requests
    ///   execution.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `explain`: Specify whether to return detailed information about score
    ///   computation as part of a hit.
    /// - `ignore_throttled`: Whether specified concrete, expanded or aliased
    ///   indices should be ignored when throttled.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `preference`: Specify the node or shard the operation should be
    ///   performed on.
    /// - `profile`: Specify whether to profile the query execution.
    /// - `rest_total_hits_as_int`: Indicates whether hits.total should be
    ///   rendered as an integer or an object in the rest search response.
    /// - `routing`: Comma-separated list of specific routing values.
    /// - `scroll`: Specify how long a consistent view of the index should be
    ///   maintained for scrolled search.
    /// - `search_type`: Search operation type.
    /// - `typed_keys`: Specify whether aggregation and suggester names should
    ///   be prefixed by their respective types in the response.
    /// - `body`
    ///```ignore
    /// let response = client.search_template_post()
    ///    .allow_no_indices(allow_no_indices)
    ///    .ccs_minimize_roundtrips(ccs_minimize_roundtrips)
    ///    .expand_wildcards(expand_wildcards)
    ///    .explain(explain)
    ///    .ignore_throttled(ignore_throttled)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .preference(preference)
    ///    .profile(profile)
    ///    .rest_total_hits_as_int(rest_total_hits_as_int)
    ///    .routing(routing)
    ///    .scroll(scroll)
    ///    .search_type(search_type)
    ///    .typed_keys(typed_keys)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn search_template_post(&self) -> builder::SearchTemplatePost {
        builder::SearchTemplatePost::new(self)
    }

    ///Returns information about the indices and shards that a search request
    /// would be executed against.
    ///
    ///Sends a `GET` request to `/_search_shards`
    ///
    ///Arguments:
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `preference`: Specify the node or shard the operation should be
    ///   performed on.
    /// - `routing`: Routing value.
    ///```ignore
    /// let response = client.search_shards_get()
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .local(local)
    ///    .preference(preference)
    ///    .routing(routing)
    ///    .send()
    ///    .await;
    /// ```
    pub fn search_shards_get(&self) -> builder::SearchShardsGet {
        builder::SearchShardsGet::new(self)
    }

    ///Returns information about the indices and shards that a search request
    /// would be executed against.
    ///
    ///Sends a `POST` request to `/_search_shards`
    ///
    ///Arguments:
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `preference`: Specify the node or shard the operation should be
    ///   performed on.
    /// - `routing`: Routing value.
    ///```ignore
    /// let response = client.search_shards_post()
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .local(local)
    ///    .preference(preference)
    ///    .routing(routing)
    ///    .send()
    ///    .await;
    /// ```
    pub fn search_shards_post(&self) -> builder::SearchShardsPost {
        builder::SearchShardsPost::new(self)
    }

    ///Provides low-level information about segments in a Lucene index.
    ///
    ///Sends a `GET` request to `/_segments`
    ///
    ///Arguments:
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `verbose`: Includes detailed memory usage by Lucene.
    ///```ignore
    /// let response = client.indices_segments()
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .verbose(verbose)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_segments(&self) -> builder::IndicesSegments {
        builder::IndicesSegments::new(self)
    }

    ///Returns settings for one or more indices.
    ///
    ///Sends a `GET` request to `/_settings`
    ///
    ///Arguments:
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `flat_settings`: Return settings in flat format.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `include_defaults`: Whether to return all default setting for each of
    ///   the indices.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    ///```ignore
    /// let response = client.indices_get_settings()
    ///    .allow_no_indices(allow_no_indices)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .expand_wildcards(expand_wildcards)
    ///    .flat_settings(flat_settings)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .include_defaults(include_defaults)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_get_settings(&self) -> builder::IndicesGetSettings {
        builder::IndicesGetSettings::new(self)
    }

    ///Updates the index settings.
    ///
    ///Sends a `PUT` request to `/_settings`
    ///
    ///Arguments:
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `flat_settings`: Return settings in flat format.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `preserve_existing`: Whether to update existing settings. If set to
    ///   `true` existing settings on an index remain unchanged.
    /// - `timeout`: Operation timeout.
    /// - `body`
    ///```ignore
    /// let response = client.indices_put_settings()
    ///    .allow_no_indices(allow_no_indices)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .expand_wildcards(expand_wildcards)
    ///    .flat_settings(flat_settings)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .master_timeout(master_timeout)
    ///    .preserve_existing(preserve_existing)
    ///    .timeout(timeout)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_put_settings(&self) -> builder::IndicesPutSettings {
        builder::IndicesPutSettings::new(self)
    }

    ///Returns settings for one or more indices.
    ///
    ///Sends a `GET` request to `/_settings/{name}`
    ///
    ///Arguments:
    /// - `name`: Comma-separated list of settings.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `flat_settings`: Return settings in flat format.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `include_defaults`: Whether to return all default setting for each of
    ///   the indices.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    ///```ignore
    /// let response = client.indices_get_settings_with_name()
    ///    .name(name)
    ///    .allow_no_indices(allow_no_indices)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .expand_wildcards(expand_wildcards)
    ///    .flat_settings(flat_settings)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .include_defaults(include_defaults)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_get_settings_with_name(&self) -> builder::IndicesGetSettingsWithName {
        builder::IndicesGetSettingsWithName::new(self)
    }

    ///Provides store information for shard copies of indices.
    ///
    ///Sends a `GET` request to `/_shard_stores`
    ///
    ///Arguments:
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `status`: Comma-separated list of statuses used to filter on shards to
    ///   get store information for.
    ///```ignore
    /// let response = client.indices_shard_stores()
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .status(status)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_shard_stores(&self) -> builder::IndicesShardStores {
        builder::IndicesShardStores::new(self)
    }

    ///Returns information about a repository.
    ///
    ///Sends a `GET` request to `/_snapshot`
    ///
    ///Arguments:
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    ///```ignore
    /// let response = client.snapshot_get_repository()
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn snapshot_get_repository(&self) -> builder::SnapshotGetRepository {
        builder::SnapshotGetRepository::new(self)
    }

    ///Returns information about the status of a snapshot.
    ///
    ///Sends a `GET` request to `/_snapshot/_status`
    ///
    ///Arguments:
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `ignore_unavailable`: Whether to ignore unavailable snapshots,
    ///   defaults to false which means a SnapshotMissingException is thrown.
    /// - `master_timeout`: Operation timeout for connection to master node.
    ///```ignore
    /// let response = client.snapshot_status()
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .master_timeout(master_timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn snapshot_status(&self) -> builder::SnapshotStatus {
        builder::SnapshotStatus::new(self)
    }

    ///Returns information about a repository.
    ///
    ///Sends a `GET` request to `/_snapshot/{repository}`
    ///
    ///Arguments:
    /// - `repository`: Comma-separated list of repository names.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    ///```ignore
    /// let response = client.snapshot_get_repository_with_repository()
    ///    .repository(repository)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn snapshot_get_repository_with_repository(
        &self,
    ) -> builder::SnapshotGetRepositoryWithRepository {
        builder::SnapshotGetRepositoryWithRepository::new(self)
    }

    ///Creates a repository.
    ///
    ///Sends a `PUT` request to `/_snapshot/{repository}`
    ///
    ///Arguments:
    /// - `repository`: Repository name.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    /// - `verify`: Whether to verify the repository after creation.
    /// - `body`
    ///```ignore
    /// let response = client.snapshot_create_repository_put()
    ///    .repository(repository)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .verify(verify)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn snapshot_create_repository_put(&self) -> builder::SnapshotCreateRepositoryPut {
        builder::SnapshotCreateRepositoryPut::new(self)
    }

    ///Creates a repository.
    ///
    ///Sends a `POST` request to `/_snapshot/{repository}`
    ///
    ///Arguments:
    /// - `repository`: Repository name.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    /// - `verify`: Whether to verify the repository after creation.
    /// - `body`
    ///```ignore
    /// let response = client.snapshot_create_repository_post()
    ///    .repository(repository)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .verify(verify)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn snapshot_create_repository_post(&self) -> builder::SnapshotCreateRepositoryPost {
        builder::SnapshotCreateRepositoryPost::new(self)
    }

    ///Deletes a repository.
    ///
    ///Sends a `DELETE` request to `/_snapshot/{repository}`
    ///
    ///Arguments:
    /// - `repository`: Name of the snapshot repository to unregister. Wildcard
    ///   (`*`) patterns are supported.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    ///```ignore
    /// let response = client.snapshot_delete_repository()
    ///    .repository(repository)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn snapshot_delete_repository(&self) -> builder::SnapshotDeleteRepository {
        builder::SnapshotDeleteRepository::new(self)
    }

    ///Removes stale data from repository.
    ///
    ///Sends a `POST` request to `/_snapshot/{repository}/_cleanup`
    ///
    ///Arguments:
    /// - `repository`: Repository name.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    ///```ignore
    /// let response = client.snapshot_cleanup_repository()
    ///    .repository(repository)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn snapshot_cleanup_repository(&self) -> builder::SnapshotCleanupRepository {
        builder::SnapshotCleanupRepository::new(self)
    }

    ///Returns information about the status of a snapshot.
    ///
    ///Sends a `GET` request to `/_snapshot/{repository}/_status`
    ///
    ///Arguments:
    /// - `repository`: Repository name.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `ignore_unavailable`: Whether to ignore unavailable snapshots,
    ///   defaults to false which means a SnapshotMissingException is thrown.
    /// - `master_timeout`: Operation timeout for connection to master node.
    ///```ignore
    /// let response = client.snapshot_status_with_repository()
    ///    .repository(repository)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .master_timeout(master_timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn snapshot_status_with_repository(&self) -> builder::SnapshotStatusWithRepository {
        builder::SnapshotStatusWithRepository::new(self)
    }

    ///Verifies a repository.
    ///
    ///Sends a `POST` request to `/_snapshot/{repository}/_verify`
    ///
    ///Arguments:
    /// - `repository`: Repository name.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    ///```ignore
    /// let response = client.snapshot_verify_repository()
    ///    .repository(repository)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn snapshot_verify_repository(&self) -> builder::SnapshotVerifyRepository {
        builder::SnapshotVerifyRepository::new(self)
    }

    ///Returns information about a snapshot.
    ///
    ///Sends a `GET` request to `/_snapshot/{repository}/{snapshot}`
    ///
    ///Arguments:
    /// - `repository`: Repository name.
    /// - `snapshot`: Comma-separated list of snapshot names.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `ignore_unavailable`: Whether to ignore unavailable snapshots,
    ///   defaults to false which means a SnapshotMissingException is thrown.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `verbose`: Whether to show verbose snapshot info or only show the
    ///   basic info found in the repository index blob.
    ///```ignore
    /// let response = client.snapshot_get()
    ///    .repository(repository)
    ///    .snapshot(snapshot)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .master_timeout(master_timeout)
    ///    .verbose(verbose)
    ///    .send()
    ///    .await;
    /// ```
    pub fn snapshot_get(&self) -> builder::SnapshotGet {
        builder::SnapshotGet::new(self)
    }

    ///Creates a snapshot in a repository.
    ///
    ///Sends a `PUT` request to `/_snapshot/{repository}/{snapshot}`
    ///
    ///Arguments:
    /// - `repository`: Repository name.
    /// - `snapshot`: Snapshot name.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `wait_for_completion`: Should this request wait until the operation
    ///   has completed before returning.
    /// - `body`
    ///```ignore
    /// let response = client.snapshot_create_put()
    ///    .repository(repository)
    ///    .snapshot(snapshot)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .master_timeout(master_timeout)
    ///    .wait_for_completion(wait_for_completion)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn snapshot_create_put(&self) -> builder::SnapshotCreatePut {
        builder::SnapshotCreatePut::new(self)
    }

    ///Creates a snapshot in a repository.
    ///
    ///Sends a `POST` request to `/_snapshot/{repository}/{snapshot}`
    ///
    ///Arguments:
    /// - `repository`: Repository name.
    /// - `snapshot`: Snapshot name.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `wait_for_completion`: Should this request wait until the operation
    ///   has completed before returning.
    /// - `body`
    ///```ignore
    /// let response = client.snapshot_create_post()
    ///    .repository(repository)
    ///    .snapshot(snapshot)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .master_timeout(master_timeout)
    ///    .wait_for_completion(wait_for_completion)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn snapshot_create_post(&self) -> builder::SnapshotCreatePost {
        builder::SnapshotCreatePost::new(self)
    }

    ///Deletes a snapshot.
    ///
    ///Sends a `DELETE` request to `/_snapshot/{repository}/{snapshot}`
    ///
    ///Arguments:
    /// - `repository`: Repository name.
    /// - `snapshot`: Snapshot name.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    ///```ignore
    /// let response = client.snapshot_delete()
    ///    .repository(repository)
    ///    .snapshot(snapshot)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .master_timeout(master_timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn snapshot_delete(&self) -> builder::SnapshotDelete {
        builder::SnapshotDelete::new(self)
    }

    ///Clones indices from one snapshot into another snapshot in the same
    /// repository.
    ///
    ///Sends a `PUT` request to
    /// `/_snapshot/{repository}/{snapshot}/_clone/{target_snapshot}`
    ///
    ///Arguments:
    /// - `repository`: Repository name.
    /// - `snapshot`: Snapshot name.
    /// - `target_snapshot`: The name of the cloned snapshot to create.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `body`
    ///```ignore
    /// let response = client.snapshot_clone()
    ///    .repository(repository)
    ///    .snapshot(snapshot)
    ///    .target_snapshot(target_snapshot)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .master_timeout(master_timeout)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn snapshot_clone(&self) -> builder::SnapshotClone {
        builder::SnapshotClone::new(self)
    }

    ///Restores a snapshot.
    ///
    ///Sends a `POST` request to `/_snapshot/{repository}/{snapshot}/_restore`
    ///
    ///Arguments:
    /// - `repository`: Repository name.
    /// - `snapshot`: Snapshot name.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `wait_for_completion`: Should this request wait until the operation
    ///   has completed before returning.
    /// - `body`
    ///```ignore
    /// let response = client.snapshot_restore()
    ///    .repository(repository)
    ///    .snapshot(snapshot)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .master_timeout(master_timeout)
    ///    .wait_for_completion(wait_for_completion)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn snapshot_restore(&self) -> builder::SnapshotRestore {
        builder::SnapshotRestore::new(self)
    }

    ///Returns information about the status of a snapshot.
    ///
    ///Sends a `GET` request to `/_snapshot/{repository}/{snapshot}/_status`
    ///
    ///Arguments:
    /// - `repository`: Repository name.
    /// - `snapshot`: Comma-separated list of snapshot names.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `ignore_unavailable`: Whether to ignore unavailable snapshots,
    ///   defaults to false which means a SnapshotMissingException is thrown.
    /// - `master_timeout`: Operation timeout for connection to master node.
    ///```ignore
    /// let response = client.snapshot_status_with_repository_snapshot()
    ///    .repository(repository)
    ///    .snapshot(snapshot)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .master_timeout(master_timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn snapshot_status_with_repository_snapshot(
        &self,
    ) -> builder::SnapshotStatusWithRepositorySnapshot {
        builder::SnapshotStatusWithRepositorySnapshot::new(self)
    }

    ///Provides statistics on operations happening in an index.
    ///
    ///Sends a `GET` request to `/_stats`
    ///
    ///Arguments:
    /// - `completion_fields`: Comma-separated list of fields for `fielddata`
    ///   and `suggest` index metric (supports wildcards).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `fielddata_fields`: Comma-separated list of fields for `fielddata`
    ///   index metric (supports wildcards).
    /// - `fields`: Comma-separated list of fields for `fielddata` and
    ///   `completion` index metric (supports wildcards).
    /// - `forbid_closed_indices`: If set to false stats will also collected
    ///   from closed indices if explicitly specified or if expand_wildcards
    ///   expands to closed indices.
    /// - `groups`: Comma-separated list of search groups for `search` index
    ///   metric.
    /// - `include_segment_file_sizes`: Whether to report the aggregated disk
    ///   usage of each one of the Lucene index files (only applies if segment
    ///   stats are requested).
    /// - `include_unloaded_segments`: If set to true segment stats will include
    ///   stats for segments that are not currently loaded into memory.
    /// - `level`: Return stats aggregated at cluster, index or shard level.
    ///```ignore
    /// let response = client.indices_stats()
    ///    .completion_fields(completion_fields)
    ///    .expand_wildcards(expand_wildcards)
    ///    .fielddata_fields(fielddata_fields)
    ///    .fields(fields)
    ///    .forbid_closed_indices(forbid_closed_indices)
    ///    .groups(groups)
    ///    .include_segment_file_sizes(include_segment_file_sizes)
    ///    .include_unloaded_segments(include_unloaded_segments)
    ///    .level(level)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_stats(&self) -> builder::IndicesStats {
        builder::IndicesStats::new(self)
    }

    ///Provides statistics on operations happening in an index.
    ///
    ///Sends a `GET` request to `/_stats/{metric}`
    ///
    ///Arguments:
    /// - `metric`: Limit the information returned the specific metrics.
    /// - `completion_fields`: Comma-separated list of fields for `fielddata`
    ///   and `suggest` index metric (supports wildcards).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `fielddata_fields`: Comma-separated list of fields for `fielddata`
    ///   index metric (supports wildcards).
    /// - `fields`: Comma-separated list of fields for `fielddata` and
    ///   `completion` index metric (supports wildcards).
    /// - `forbid_closed_indices`: If set to false stats will also collected
    ///   from closed indices if explicitly specified or if expand_wildcards
    ///   expands to closed indices.
    /// - `groups`: Comma-separated list of search groups for `search` index
    ///   metric.
    /// - `include_segment_file_sizes`: Whether to report the aggregated disk
    ///   usage of each one of the Lucene index files (only applies if segment
    ///   stats are requested).
    /// - `include_unloaded_segments`: If set to true segment stats will include
    ///   stats for segments that are not currently loaded into memory.
    /// - `level`: Return stats aggregated at cluster, index or shard level.
    ///```ignore
    /// let response = client.indices_stats_with_metric()
    ///    .metric(metric)
    ///    .completion_fields(completion_fields)
    ///    .expand_wildcards(expand_wildcards)
    ///    .fielddata_fields(fielddata_fields)
    ///    .fields(fields)
    ///    .forbid_closed_indices(forbid_closed_indices)
    ///    .groups(groups)
    ///    .include_segment_file_sizes(include_segment_file_sizes)
    ///    .include_unloaded_segments(include_unloaded_segments)
    ///    .level(level)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_stats_with_metric(&self) -> builder::IndicesStatsWithMetric {
        builder::IndicesStatsWithMetric::new(self)
    }

    ///Returns a list of tasks.
    ///
    ///Sends a `GET` request to `/_tasks`
    ///
    ///Arguments:
    /// - `actions`: Comma-separated list of actions that should be returned.
    ///   Leave empty to return all.
    /// - `detailed`: Return detailed task information.
    /// - `group_by`: Group tasks by nodes or parent/child relationships.
    /// - `nodes`: Comma-separated list of node IDs or names to limit the
    ///   returned information; use `_local` to return information from the node
    ///   you're connecting to, leave empty to get information from all nodes.
    /// - `parent_task_id`: Return tasks with specified parent task id
    ///   (node_id:task_number). Set to -1 to return all.
    /// - `timeout`: Operation timeout.
    /// - `wait_for_completion`: Should this request wait until the operation
    ///   has completed before returning.
    ///```ignore
    /// let response = client.tasks_list()
    ///    .actions(actions)
    ///    .detailed(detailed)
    ///    .group_by(group_by)
    ///    .nodes(nodes)
    ///    .parent_task_id(parent_task_id)
    ///    .timeout(timeout)
    ///    .wait_for_completion(wait_for_completion)
    ///    .send()
    ///    .await;
    /// ```
    pub fn tasks_list(&self) -> builder::TasksList {
        builder::TasksList::new(self)
    }

    ///Cancels a task, if it can be cancelled through an API.
    ///
    ///Sends a `POST` request to `/_tasks/_cancel`
    ///
    ///Arguments:
    /// - `actions`: Comma-separated list of actions that should be cancelled.
    ///   Leave empty to cancel all.
    /// - `nodes`: Comma-separated list of node IDs or names to limit the
    ///   returned information; use `_local` to return information from the node
    ///   you're connecting to, leave empty to get information from all nodes.
    /// - `parent_task_id`: Cancel tasks with specified parent task id
    ///   (node_id:task_number). Set to -1 to cancel all.
    /// - `wait_for_completion`: Should this request wait until the operation
    ///   has completed before returning.
    ///```ignore
    /// let response = client.tasks_cancel()
    ///    .actions(actions)
    ///    .nodes(nodes)
    ///    .parent_task_id(parent_task_id)
    ///    .wait_for_completion(wait_for_completion)
    ///    .send()
    ///    .await;
    /// ```
    pub fn tasks_cancel(&self) -> builder::TasksCancel {
        builder::TasksCancel::new(self)
    }

    ///Returns information about a task.
    ///
    ///Sends a `GET` request to `/_tasks/{task_id}`
    ///
    ///Arguments:
    /// - `task_id`: Return the task with specified id (node_id:task_number).
    /// - `timeout`: Operation timeout.
    /// - `wait_for_completion`: Should this request wait until the operation
    ///   has completed before returning.
    ///```ignore
    /// let response = client.tasks_get()
    ///    .task_id(task_id)
    ///    .timeout(timeout)
    ///    .wait_for_completion(wait_for_completion)
    ///    .send()
    ///    .await;
    /// ```
    pub fn tasks_get(&self) -> builder::TasksGet {
        builder::TasksGet::new(self)
    }

    ///Cancels a task, if it can be cancelled through an API.
    ///
    ///Sends a `POST` request to `/_tasks/{task_id}/_cancel`
    ///
    ///Arguments:
    /// - `task_id`: Cancel the task with specified task id
    ///   (node_id:task_number).
    /// - `actions`: Comma-separated list of actions that should be cancelled.
    ///   Leave empty to cancel all.
    /// - `nodes`: Comma-separated list of node IDs or names to limit the
    ///   returned information; use `_local` to return information from the node
    ///   you're connecting to, leave empty to get information from all nodes.
    /// - `parent_task_id`: Cancel tasks with specified parent task id
    ///   (node_id:task_number). Set to -1 to cancel all.
    /// - `wait_for_completion`: Should this request wait until the operation
    ///   has completed before returning.
    ///```ignore
    /// let response = client.tasks_cancel_with_task_id()
    ///    .task_id(task_id)
    ///    .actions(actions)
    ///    .nodes(nodes)
    ///    .parent_task_id(parent_task_id)
    ///    .wait_for_completion(wait_for_completion)
    ///    .send()
    ///    .await;
    /// ```
    pub fn tasks_cancel_with_task_id(&self) -> builder::TasksCancelWithTaskId {
        builder::TasksCancelWithTaskId::new(self)
    }

    ///Returns an index template.
    ///
    ///Sends a `GET` request to `/_template`
    ///
    ///Arguments:
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `flat_settings`: Return settings in flat format.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    ///```ignore
    /// let response = client.indices_get_template()
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .flat_settings(flat_settings)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_get_template(&self) -> builder::IndicesGetTemplate {
        builder::IndicesGetTemplate::new(self)
    }

    ///Returns an index template.
    ///
    ///Sends a `GET` request to `/_template/{name}`
    ///
    ///Arguments:
    /// - `name`: Comma-separated names of the index templates.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `flat_settings`: Return settings in flat format.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    ///```ignore
    /// let response = client.indices_get_template_with_name()
    ///    .name(name)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .flat_settings(flat_settings)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_get_template_with_name(&self) -> builder::IndicesGetTemplateWithName {
        builder::IndicesGetTemplateWithName::new(self)
    }

    ///Creates or updates an index template.
    ///
    ///Sends a `PUT` request to `/_template/{name}`
    ///
    ///Arguments:
    /// - `name`: The name of the template.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `create`: Whether the index template should only be added if new or
    ///   can also replace an existing one.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `order`: The order for this template when merging multiple matching
    ///   ones (higher numbers are merged later, overriding the lower numbers).
    /// - `body`
    ///```ignore
    /// let response = client.indices_put_template_put()
    ///    .name(name)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .create(create)
    ///    .master_timeout(master_timeout)
    ///    .order(order)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_put_template_put(&self) -> builder::IndicesPutTemplatePut {
        builder::IndicesPutTemplatePut::new(self)
    }

    ///Creates or updates an index template.
    ///
    ///Sends a `POST` request to `/_template/{name}`
    ///
    ///Arguments:
    /// - `name`: The name of the template.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `create`: Whether the index template should only be added if new or
    ///   can also replace an existing one.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `order`: The order for this template when merging multiple matching
    ///   ones (higher numbers are merged later, overriding the lower numbers).
    /// - `body`
    ///```ignore
    /// let response = client.indices_put_template_post()
    ///    .name(name)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .create(create)
    ///    .master_timeout(master_timeout)
    ///    .order(order)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_put_template_post(&self) -> builder::IndicesPutTemplatePost {
        builder::IndicesPutTemplatePost::new(self)
    }

    ///Deletes an index template.
    ///
    ///Sends a `DELETE` request to `/_template/{name}`
    ///
    ///Arguments:
    /// - `name`: The name of the template.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    ///```ignore
    /// let response = client.indices_delete_template()
    ///    .name(name)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_delete_template(&self) -> builder::IndicesDeleteTemplate {
        builder::IndicesDeleteTemplate::new(self)
    }

    ///Returns information about whether a particular index template exists.
    ///
    ///Sends a `HEAD` request to `/_template/{name}`
    ///
    ///Arguments:
    /// - `name`: Comma-separated names of the index templates.
    /// - `flat_settings`: Return settings in flat format.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    ///```ignore
    /// let response = client.indices_exists_template()
    ///    .name(name)
    ///    .flat_settings(flat_settings)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_exists_template(&self) -> builder::IndicesExistsTemplate {
        builder::IndicesExistsTemplate::new(self)
    }

    ///Changes the number of requests per second for a particular Update By
    /// Query operation.
    ///
    ///Sends a `POST` request to `/_update_by_query/{task_id}/_rethrottle`
    ///
    ///Arguments:
    /// - `task_id`: The task id to rethrottle.
    /// - `requests_per_second`: The throttle for this request in sub-requests
    ///   per second. -1 means no throttle.
    ///```ignore
    /// let response = client.update_by_query_rethrottle()
    ///    .task_id(task_id)
    ///    .requests_per_second(requests_per_second)
    ///    .send()
    ///    .await;
    /// ```
    pub fn update_by_query_rethrottle(&self) -> builder::UpdateByQueryRethrottle {
        builder::UpdateByQueryRethrottle::new(self)
    }

    ///The _upgrade API is no longer useful and will be removed.
    ///
    ///Sends a `GET` request to `/_upgrade`
    ///
    ///Arguments:
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    ///```ignore
    /// let response = client.indices_get_upgrade()
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_get_upgrade(&self) -> builder::IndicesGetUpgrade {
        builder::IndicesGetUpgrade::new(self)
    }

    ///The _upgrade API is no longer useful and will be removed.
    ///
    ///Sends a `POST` request to `/_upgrade`
    ///
    ///Arguments:
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `only_ancient_segments`: If true, only ancient (an older Lucene major
    ///   release) segments will be upgraded.
    /// - `wait_for_completion`: Should this request wait until the operation
    ///   has completed before returning.
    ///```ignore
    /// let response = client.indices_upgrade()
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .only_ancient_segments(only_ancient_segments)
    ///    .wait_for_completion(wait_for_completion)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_upgrade(&self) -> builder::IndicesUpgrade {
        builder::IndicesUpgrade::new(self)
    }

    ///Allows a user to validate a potentially expensive query without
    /// executing it.
    ///
    ///Sends a `GET` request to `/_validate/query`
    ///
    ///Arguments:
    /// - `all_shards`: Execute validation on all shards instead of one random
    ///   shard per index.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `analyze_wildcard`: Specify whether wildcard and prefix queries should
    ///   be analyzed.
    /// - `analyzer`: The analyzer to use for the query string.
    /// - `default_operator`: The default operator for query string query (AND
    ///   or OR).
    /// - `df`: The field to use as default where no field prefix is given in
    ///   the query string.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `explain`: Return detailed information about the error.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `lenient`: Specify whether format-based query failures (such as
    ///   providing text to a numeric field) should be ignored.
    /// - `q`: Query in the Lucene query string syntax.
    /// - `rewrite`: Provide a more detailed explanation showing the actual
    ///   Lucene query that will be executed.
    ///```ignore
    /// let response = client.indices_validate_query_get()
    ///    .all_shards(all_shards)
    ///    .allow_no_indices(allow_no_indices)
    ///    .analyze_wildcard(analyze_wildcard)
    ///    .analyzer(analyzer)
    ///    .default_operator(default_operator)
    ///    .df(df)
    ///    .expand_wildcards(expand_wildcards)
    ///    .explain(explain)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .lenient(lenient)
    ///    .q(q)
    ///    .rewrite(rewrite)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_validate_query_get(&self) -> builder::IndicesValidateQueryGet {
        builder::IndicesValidateQueryGet::new(self)
    }

    ///Allows a user to validate a potentially expensive query without
    /// executing it.
    ///
    ///Sends a `POST` request to `/_validate/query`
    ///
    ///Arguments:
    /// - `all_shards`: Execute validation on all shards instead of one random
    ///   shard per index.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `analyze_wildcard`: Specify whether wildcard and prefix queries should
    ///   be analyzed.
    /// - `analyzer`: The analyzer to use for the query string.
    /// - `default_operator`: The default operator for query string query (AND
    ///   or OR).
    /// - `df`: The field to use as default where no field prefix is given in
    ///   the query string.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `explain`: Return detailed information about the error.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `lenient`: Specify whether format-based query failures (such as
    ///   providing text to a numeric field) should be ignored.
    /// - `q`: Query in the Lucene query string syntax.
    /// - `rewrite`: Provide a more detailed explanation showing the actual
    ///   Lucene query that will be executed.
    /// - `body`
    ///```ignore
    /// let response = client.indices_validate_query_post()
    ///    .all_shards(all_shards)
    ///    .allow_no_indices(allow_no_indices)
    ///    .analyze_wildcard(analyze_wildcard)
    ///    .analyzer(analyzer)
    ///    .default_operator(default_operator)
    ///    .df(df)
    ///    .expand_wildcards(expand_wildcards)
    ///    .explain(explain)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .lenient(lenient)
    ///    .q(q)
    ///    .rewrite(rewrite)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_validate_query_post(&self) -> builder::IndicesValidateQueryPost {
        builder::IndicesValidateQueryPost::new(self)
    }

    ///Updates an alias to point to a new index when the existing index
    ///is considered to be too large or too old.
    ///
    ///Sends a `POST` request to `/{alias}/_rollover`
    ///
    ///Arguments:
    /// - `alias`: The name of the alias to rollover.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `dry_run`: If set to true the rollover action will only be validated
    ///   but not actually performed even if a condition matches.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    /// - `wait_for_active_shards`: Set the number of active shards to wait for
    ///   on the newly created rollover index before the operation returns.
    /// - `body`
    ///```ignore
    /// let response = client.indices_rollover()
    ///    .alias(alias)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .dry_run(dry_run)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .wait_for_active_shards(wait_for_active_shards)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_rollover(&self) -> builder::IndicesRollover {
        builder::IndicesRollover::new(self)
    }

    ///Updates an alias to point to a new index when the existing index
    ///is considered to be too large or too old.
    ///
    ///Sends a `POST` request to `/{alias}/_rollover/{new_index}`
    ///
    ///Arguments:
    /// - `alias`: The name of the alias to rollover.
    /// - `new_index`: The name of the rollover index.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `dry_run`: If set to true the rollover action will only be validated
    ///   but not actually performed even if a condition matches.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    /// - `wait_for_active_shards`: Set the number of active shards to wait for
    ///   on the newly created rollover index before the operation returns.
    /// - `body`
    ///```ignore
    /// let response = client.indices_rollover_with_new_index()
    ///    .alias(alias)
    ///    .new_index(new_index)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .dry_run(dry_run)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .wait_for_active_shards(wait_for_active_shards)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_rollover_with_new_index(&self) -> builder::IndicesRolloverWithNewIndex {
        builder::IndicesRolloverWithNewIndex::new(self)
    }

    ///Returns information about one or more indices.
    ///
    ///Sends a `GET` request to `/{index}`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `flat_settings`: Return settings in flat format.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `include_defaults`: Whether to return all default setting for each of
    ///   the indices.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    ///```ignore
    /// let response = client.indices_get()
    ///    .index(index)
    ///    .allow_no_indices(allow_no_indices)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .expand_wildcards(expand_wildcards)
    ///    .flat_settings(flat_settings)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .include_defaults(include_defaults)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_get(&self) -> builder::IndicesGet {
        builder::IndicesGet::new(self)
    }

    ///Creates an index with optional settings and mappings.
    ///
    ///Sends a `PUT` request to `/{index}`
    ///
    ///Arguments:
    /// - `index`: Index name.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    /// - `wait_for_active_shards`: Set the number of active shards to wait for
    ///   before the operation returns.
    /// - `body`
    ///```ignore
    /// let response = client.indices_create()
    ///    .index(index)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .wait_for_active_shards(wait_for_active_shards)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_create(&self) -> builder::IndicesCreate {
        builder::IndicesCreate::new(self)
    }

    ///Deletes an index.
    ///
    ///Sends a `DELETE` request to `/{index}`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices to delete; use `_all` or `*`
    ///   string to delete all indices.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    ///```ignore
    /// let response = client.indices_delete()
    ///    .index(index)
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_delete(&self) -> builder::IndicesDelete {
        builder::IndicesDelete::new(self)
    }

    ///Returns information about whether a particular index exists.
    ///
    ///Sends a `HEAD` request to `/{index}`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `flat_settings`: Return settings in flat format.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `include_defaults`: Whether to return all default setting for each of
    ///   the indices.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    ///```ignore
    /// let response = client.indices_exists()
    ///    .index(index)
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .flat_settings(flat_settings)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .include_defaults(include_defaults)
    ///    .local(local)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_exists(&self) -> builder::IndicesExists {
        builder::IndicesExists::new(self)
    }

    ///Returns an alias.
    ///
    ///Sends a `GET` request to `/{index}/_alias`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices to filter aliases.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    ///```ignore
    /// let response = client.indices_get_alias_with_index()
    ///    .index(index)
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .local(local)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_get_alias_with_index(&self) -> builder::IndicesGetAliasWithIndex {
        builder::IndicesGetAliasWithIndex::new(self)
    }

    ///Returns an alias.
    ///
    ///Sends a `GET` request to `/{index}/_alias/{name}`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices to filter aliases.
    /// - `name`: Comma-separated list of alias names.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    ///```ignore
    /// let response = client.indices_get_alias_with_index_name()
    ///    .index(index)
    ///    .name(name)
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .local(local)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_get_alias_with_index_name(&self) -> builder::IndicesGetAliasWithIndexName {
        builder::IndicesGetAliasWithIndexName::new(self)
    }

    ///Creates or updates an alias.
    ///
    ///Sends a `PUT` request to `/{index}/_alias/{name}`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `name`: The name of the alias to be created or updated.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    /// - `body`
    ///```ignore
    /// let response = client.indices_put_alias_put()
    ///    .index(index)
    ///    .name(name)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_put_alias_put(&self) -> builder::IndicesPutAliasPut {
        builder::IndicesPutAliasPut::new(self)
    }

    ///Creates or updates an alias.
    ///
    ///Sends a `POST` request to `/{index}/_alias/{name}`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `name`: The name of the alias to be created or updated.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    /// - `body`
    ///```ignore
    /// let response = client.indices_put_alias_post()
    ///    .index(index)
    ///    .name(name)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_put_alias_post(&self) -> builder::IndicesPutAliasPost {
        builder::IndicesPutAliasPost::new(self)
    }

    ///Deletes an alias.
    ///
    ///Sends a `DELETE` request to `/{index}/_alias/{name}`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `name`: Comma-separated list of aliases to delete (supports
    ///   wildcards); use `_all` to delete all aliases for the specified
    ///   indices.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    ///```ignore
    /// let response = client.indices_delete_alias()
    ///    .index(index)
    ///    .name(name)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_delete_alias(&self) -> builder::IndicesDeleteAlias {
        builder::IndicesDeleteAlias::new(self)
    }

    ///Returns information about whether a particular alias exists.
    ///
    ///Sends a `HEAD` request to `/{index}/_alias/{name}`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices to filter aliases.
    /// - `name`: Comma-separated list of alias names.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    ///```ignore
    /// let response = client.indices_exists_alias_with_index()
    ///    .index(index)
    ///    .name(name)
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .local(local)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_exists_alias_with_index(&self) -> builder::IndicesExistsAliasWithIndex {
        builder::IndicesExistsAliasWithIndex::new(self)
    }

    ///Creates or updates an alias.
    ///
    ///Sends a `PUT` request to `/{index}/_aliases/{name}`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `name`: The name of the alias to be created or updated.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    /// - `body`
    ///```ignore
    /// let response = client.indices_put_alias_put_plural()
    ///    .index(index)
    ///    .name(name)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_put_alias_put_plural(&self) -> builder::IndicesPutAliasPutPlural {
        builder::IndicesPutAliasPutPlural::new(self)
    }

    ///Creates or updates an alias.
    ///
    ///Sends a `POST` request to `/{index}/_aliases/{name}`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `name`: The name of the alias to be created or updated.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    /// - `body`
    ///```ignore
    /// let response = client.indices_put_alias_post_plural()
    ///    .index(index)
    ///    .name(name)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_put_alias_post_plural(&self) -> builder::IndicesPutAliasPostPlural {
        builder::IndicesPutAliasPostPlural::new(self)
    }

    ///Deletes an alias.
    ///
    ///Sends a `DELETE` request to `/{index}/_aliases/{name}`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `name`: Comma-separated list of aliases to delete (supports
    ///   wildcards); use `_all` to delete all aliases for the specified
    ///   indices.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    ///```ignore
    /// let response = client.indices_delete_alias_plural()
    ///    .index(index)
    ///    .name(name)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_delete_alias_plural(&self) -> builder::IndicesDeleteAliasPlural {
        builder::IndicesDeleteAliasPlural::new(self)
    }

    ///Performs the analysis process on a text and return the tokens breakdown
    /// of the text.
    ///
    ///Sends a `GET` request to `/{index}/_analyze`
    ///
    ///Arguments:
    /// - `index`: The name of the index to scope the operation.
    ///```ignore
    /// let response = client.indices_analyze_get_with_index()
    ///    .index(index)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_analyze_get_with_index(&self) -> builder::IndicesAnalyzeGetWithIndex {
        builder::IndicesAnalyzeGetWithIndex::new(self)
    }

    ///Performs the analysis process on a text and return the tokens breakdown
    /// of the text.
    ///
    ///Sends a `POST` request to `/{index}/_analyze`
    ///
    ///Arguments:
    /// - `index`: The name of the index to scope the operation.
    /// - `body`
    ///```ignore
    /// let response = client.indices_analyze_post_with_index()
    ///    .index(index)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_analyze_post_with_index(&self) -> builder::IndicesAnalyzePostWithIndex {
        builder::IndicesAnalyzePostWithIndex::new(self)
    }

    ///Adds a block to an index.
    ///
    ///Sends a `PUT` request to `/{index}/_block/{block}`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices to add a block to.
    /// - `block`: The block to add (one of read, write, read_only or metadata).
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    ///```ignore
    /// let response = client.indices_add_block()
    ///    .index(index)
    ///    .block(block)
    ///    .allow_no_indices(allow_no_indices)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_add_block(&self) -> builder::IndicesAddBlock {
        builder::IndicesAddBlock::new(self)
    }

    ///Allows to perform multiple index/update/delete operations in a single
    /// request.
    ///
    ///Sends a `PUT` request to `/{index}/_bulk`
    ///
    ///Arguments:
    /// - `index`: Default index for items which don't provide one.
    /// - `source`: True or false to return the _source field or not, or default
    ///   list of fields to return, can be overridden on each sub-request.
    /// - `source_excludes`: Default list of fields to exclude from the returned
    ///   _source field, can be overridden on each sub-request.
    /// - `source_includes`: Default list of fields to extract and return from
    ///   the _source field, can be overridden on each sub-request.
    /// - `pipeline`: The pipeline id to preprocess incoming documents with.
    /// - `refresh`: If `true` then refresh the affected shards to make this
    ///   operation visible to search, if `wait_for` then wait for a refresh to
    ///   make this operation visible to search, if `false` (the default) then
    ///   do nothing with refreshes.
    /// - `require_alias`: Sets require_alias for all incoming documents.
    /// - `routing`: Routing value.
    /// - `timeout`: Operation timeout.
    /// - `type_`: Default document type for items which don't provide one.
    /// - `wait_for_active_shards`: Sets the number of shard copies that must be
    ///   active before proceeding with the operation. Defaults to 1, meaning
    ///   the primary shard only. Set to `all` for all shard copies, otherwise
    ///   set to any non-negative value less than or equal to the total number
    ///   of copies for the shard (number of replicas + 1).
    /// - `body`
    ///```ignore
    /// let response = client.bulk_put_with_index()
    ///    .index(index)
    ///    .source(source)
    ///    .source_excludes(source_excludes)
    ///    .source_includes(source_includes)
    ///    .pipeline(pipeline)
    ///    .refresh(refresh)
    ///    .require_alias(require_alias)
    ///    .routing(routing)
    ///    .timeout(timeout)
    ///    .type_(type_)
    ///    .wait_for_active_shards(wait_for_active_shards)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn bulk_put_with_index(&self) -> builder::BulkPutWithIndex {
        builder::BulkPutWithIndex::new(self)
    }

    ///Allows to perform multiple index/update/delete operations in a single
    /// request.
    ///
    ///Sends a `POST` request to `/{index}/_bulk`
    ///
    ///Arguments:
    /// - `index`: Default index for items which don't provide one.
    /// - `source`: True or false to return the _source field or not, or default
    ///   list of fields to return, can be overridden on each sub-request.
    /// - `source_excludes`: Default list of fields to exclude from the returned
    ///   _source field, can be overridden on each sub-request.
    /// - `source_includes`: Default list of fields to extract and return from
    ///   the _source field, can be overridden on each sub-request.
    /// - `pipeline`: The pipeline id to preprocess incoming documents with.
    /// - `refresh`: If `true` then refresh the affected shards to make this
    ///   operation visible to search, if `wait_for` then wait for a refresh to
    ///   make this operation visible to search, if `false` (the default) then
    ///   do nothing with refreshes.
    /// - `require_alias`: Sets require_alias for all incoming documents.
    /// - `routing`: Routing value.
    /// - `timeout`: Operation timeout.
    /// - `type_`: Default document type for items which don't provide one.
    /// - `wait_for_active_shards`: Sets the number of shard copies that must be
    ///   active before proceeding with the operation. Defaults to 1, meaning
    ///   the primary shard only. Set to `all` for all shard copies, otherwise
    ///   set to any non-negative value less than or equal to the total number
    ///   of copies for the shard (number of replicas + 1).
    /// - `body`
    ///```ignore
    /// let response = client.bulk_post_with_index()
    ///    .index(index)
    ///    .source(source)
    ///    .source_excludes(source_excludes)
    ///    .source_includes(source_includes)
    ///    .pipeline(pipeline)
    ///    .refresh(refresh)
    ///    .require_alias(require_alias)
    ///    .routing(routing)
    ///    .timeout(timeout)
    ///    .type_(type_)
    ///    .wait_for_active_shards(wait_for_active_shards)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn bulk_post_with_index(&self) -> builder::BulkPostWithIndex {
        builder::BulkPostWithIndex::new(self)
    }

    ///Clears all or specific caches for one or more indices.
    ///
    ///Sends a `POST` request to `/{index}/_cache/clear`
    ///
    ///Arguments:
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `fielddata`: Clear field data.
    /// - `fields`: Comma-separated list of fields to clear when using the
    ///   `fielddata` parameter (default: all).
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `query`: Clear query caches.
    /// - `request`: Clear request cache.
    ///```ignore
    /// let response = client.indices_clear_cache_with_index()
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .fielddata(fielddata)
    ///    .fields(fields)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .index(index)
    ///    .query(query)
    ///    .request(request)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_clear_cache_with_index(&self) -> builder::IndicesClearCacheWithIndex {
        builder::IndicesClearCacheWithIndex::new(self)
    }

    ///Clones an index.
    ///
    ///Sends a `PUT` request to `/{index}/_clone/{target}`
    ///
    ///Arguments:
    /// - `index`: The name of the source index to clone.
    /// - `target`: The name of the target index.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    /// - `wait_for_active_shards`: Set the number of active shards to wait for
    ///   on the cloned index before the operation returns.
    /// - `body`
    ///```ignore
    /// let response = client.indices_clone_put()
    ///    .index(index)
    ///    .target(target)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .wait_for_active_shards(wait_for_active_shards)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_clone_put(&self) -> builder::IndicesClonePut {
        builder::IndicesClonePut::new(self)
    }

    ///Clones an index.
    ///
    ///Sends a `POST` request to `/{index}/_clone/{target}`
    ///
    ///Arguments:
    /// - `index`: The name of the source index to clone.
    /// - `target`: The name of the target index.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    /// - `wait_for_active_shards`: Set the number of active shards to wait for
    ///   on the cloned index before the operation returns.
    /// - `body`
    ///```ignore
    /// let response = client.indices_clone_post()
    ///    .index(index)
    ///    .target(target)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .wait_for_active_shards(wait_for_active_shards)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_clone_post(&self) -> builder::IndicesClonePost {
        builder::IndicesClonePost::new(self)
    }

    ///Closes an index.
    ///
    ///Sends a `POST` request to `/{index}/_close`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices to close.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    /// - `wait_for_active_shards`: Sets the number of active shards to wait for
    ///   before the operation returns.
    ///```ignore
    /// let response = client.indices_close()
    ///    .index(index)
    ///    .allow_no_indices(allow_no_indices)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .wait_for_active_shards(wait_for_active_shards)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_close(&self) -> builder::IndicesClose {
        builder::IndicesClose::new(self)
    }

    ///Returns number of documents matching a query.
    ///
    ///Sends a `GET` request to `/{index}/_count`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices to restrict the results.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `analyze_wildcard`: Specify whether wildcard and prefix queries should
    ///   be analyzed.
    /// - `analyzer`: The analyzer to use for the query string.
    /// - `default_operator`: The default operator for query string query (AND
    ///   or OR).
    /// - `df`: The field to use as default where no field prefix is given in
    ///   the query string.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_throttled`: Whether specified concrete, expanded or aliased
    ///   indices should be ignored when throttled.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `lenient`: Specify whether format-based query failures (such as
    ///   providing text to a numeric field) should be ignored.
    /// - `min_score`: Include only documents with a specific `_score` value in
    ///   the result.
    /// - `preference`: Specify the node or shard the operation should be
    ///   performed on.
    /// - `q`: Query in the Lucene query string syntax.
    /// - `routing`: Comma-separated list of specific routing values.
    /// - `terminate_after`: The maximum number of documents to collect for each
    ///   shard, upon reaching which the query execution will terminate early.
    ///```ignore
    /// let response = client.count_get_with_index()
    ///    .index(index)
    ///    .allow_no_indices(allow_no_indices)
    ///    .analyze_wildcard(analyze_wildcard)
    ///    .analyzer(analyzer)
    ///    .default_operator(default_operator)
    ///    .df(df)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_throttled(ignore_throttled)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .lenient(lenient)
    ///    .min_score(min_score)
    ///    .preference(preference)
    ///    .q(q)
    ///    .routing(routing)
    ///    .terminate_after(terminate_after)
    ///    .send()
    ///    .await;
    /// ```
    pub fn count_get_with_index(&self) -> builder::CountGetWithIndex {
        builder::CountGetWithIndex::new(self)
    }

    ///Returns number of documents matching a query.
    ///
    ///Sends a `POST` request to `/{index}/_count`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices to restrict the results.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `analyze_wildcard`: Specify whether wildcard and prefix queries should
    ///   be analyzed.
    /// - `analyzer`: The analyzer to use for the query string.
    /// - `default_operator`: The default operator for query string query (AND
    ///   or OR).
    /// - `df`: The field to use as default where no field prefix is given in
    ///   the query string.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_throttled`: Whether specified concrete, expanded or aliased
    ///   indices should be ignored when throttled.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `lenient`: Specify whether format-based query failures (such as
    ///   providing text to a numeric field) should be ignored.
    /// - `min_score`: Include only documents with a specific `_score` value in
    ///   the result.
    /// - `preference`: Specify the node or shard the operation should be
    ///   performed on.
    /// - `q`: Query in the Lucene query string syntax.
    /// - `routing`: Comma-separated list of specific routing values.
    /// - `terminate_after`: The maximum number of documents to collect for each
    ///   shard, upon reaching which the query execution will terminate early.
    /// - `body`
    ///```ignore
    /// let response = client.count_post_with_index()
    ///    .index(index)
    ///    .allow_no_indices(allow_no_indices)
    ///    .analyze_wildcard(analyze_wildcard)
    ///    .analyzer(analyzer)
    ///    .default_operator(default_operator)
    ///    .df(df)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_throttled(ignore_throttled)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .lenient(lenient)
    ///    .min_score(min_score)
    ///    .preference(preference)
    ///    .q(q)
    ///    .routing(routing)
    ///    .terminate_after(terminate_after)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn count_post_with_index(&self) -> builder::CountPostWithIndex {
        builder::CountPostWithIndex::new(self)
    }

    ///Creates a new document in the index.
    ///
    ///Returns a 409 response when a document with a same ID already exists in
    /// the index.
    ///
    ///Sends a `PUT` request to `/{index}/_create/{id}`
    ///
    ///Arguments:
    /// - `index`: Index name.
    /// - `id`: Document ID.
    /// - `pipeline`: The pipeline id to preprocess incoming documents with.
    /// - `refresh`: If `true` then refresh the affected shards to make this
    ///   operation visible to search, if `wait_for` then wait for a refresh to
    ///   make this operation visible to search, if `false` (the default) then
    ///   do nothing with refreshes.
    /// - `routing`: Routing value.
    /// - `timeout`: Operation timeout.
    /// - `version`: Explicit version number for concurrency control.
    /// - `version_type`: Specific version type.
    /// - `wait_for_active_shards`: Sets the number of shard copies that must be
    ///   active before proceeding with the operation. Defaults to 1, meaning
    ///   the primary shard only. Set to `all` for all shard copies, otherwise
    ///   set to any non-negative value less than or equal to the total number
    ///   of copies for the shard (number of replicas + 1).
    /// - `body`
    ///```ignore
    /// let response = client.create_put()
    ///    .index(index)
    ///    .id(id)
    ///    .pipeline(pipeline)
    ///    .refresh(refresh)
    ///    .routing(routing)
    ///    .timeout(timeout)
    ///    .version(version)
    ///    .version_type(version_type)
    ///    .wait_for_active_shards(wait_for_active_shards)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn create_put(&self) -> builder::CreatePut {
        builder::CreatePut::new(self)
    }

    ///Creates a new document in the index.
    ///
    ///Returns a 409 response when a document with a same ID already exists in
    /// the index.
    ///
    ///Sends a `POST` request to `/{index}/_create/{id}`
    ///
    ///Arguments:
    /// - `index`: Index name.
    /// - `id`: Document ID.
    /// - `pipeline`: The pipeline id to preprocess incoming documents with.
    /// - `refresh`: If `true` then refresh the affected shards to make this
    ///   operation visible to search, if `wait_for` then wait for a refresh to
    ///   make this operation visible to search, if `false` (the default) then
    ///   do nothing with refreshes.
    /// - `routing`: Routing value.
    /// - `timeout`: Operation timeout.
    /// - `version`: Explicit version number for concurrency control.
    /// - `version_type`: Specific version type.
    /// - `wait_for_active_shards`: Sets the number of shard copies that must be
    ///   active before proceeding with the operation. Defaults to 1, meaning
    ///   the primary shard only. Set to `all` for all shard copies, otherwise
    ///   set to any non-negative value less than or equal to the total number
    ///   of copies for the shard (number of replicas + 1).
    /// - `body`
    ///```ignore
    /// let response = client.create_post()
    ///    .index(index)
    ///    .id(id)
    ///    .pipeline(pipeline)
    ///    .refresh(refresh)
    ///    .routing(routing)
    ///    .timeout(timeout)
    ///    .version(version)
    ///    .version_type(version_type)
    ///    .wait_for_active_shards(wait_for_active_shards)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn create_post(&self) -> builder::CreatePost {
        builder::CreatePost::new(self)
    }

    ///Deletes documents matching the provided query.
    ///
    ///Sends a `POST` request to `/{index}/_delete_by_query`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `source`: True or false to return the _source field or not, or a list
    ///   of fields to return.
    /// - `source_excludes`: List of fields to exclude from the returned _source
    ///   field.
    /// - `source_includes`: List of fields to extract and return from the
    ///   _source field.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `analyze_wildcard`: Specify whether wildcard and prefix queries should
    ///   be analyzed.
    /// - `analyzer`: The analyzer to use for the query string.
    /// - `conflicts`: What to do when the operation encounters version
    ///   conflicts?.
    /// - `default_operator`: The default operator for query string query (AND
    ///   or OR).
    /// - `df`: The field to use as default where no field prefix is given in
    ///   the query string.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `from`: Starting offset.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `lenient`: Specify whether format-based query failures (such as
    ///   providing text to a numeric field) should be ignored.
    /// - `max_docs`: Maximum number of documents to process (default: all
    ///   documents).
    /// - `preference`: Specify the node or shard the operation should be
    ///   performed on.
    /// - `q`: Query in the Lucene query string syntax.
    /// - `refresh`: Refresh the shard containing the document before performing
    ///   the operation.
    /// - `request_cache`: Specify if request cache should be used for this
    ///   request or not, defaults to index level setting.
    /// - `requests_per_second`: The throttle for this request in sub-requests
    ///   per second. -1 means no throttle.
    /// - `routing`: Comma-separated list of specific routing values.
    /// - `scroll`: Specify how long a consistent view of the index should be
    ///   maintained for scrolled search.
    /// - `scroll_size`: Size on the scroll request powering the operation.
    /// - `search_timeout`: Explicit timeout for each search request. Defaults
    ///   to no timeout.
    /// - `search_type`: Search operation type.
    /// - `size`: Deprecated, please use `max_docs` instead.
    /// - `slices`: The number of slices this task should be divided into.
    ///   Defaults to 1, meaning the task isn't sliced into subtasks. Can be set
    ///   to `auto`.
    /// - `sort`: Comma-separated list of <field>:<direction> pairs.
    /// - `stats`: Specific 'tag' of the request for logging and statistical
    ///   purposes.
    /// - `terminate_after`: The maximum number of documents to collect for each
    ///   shard, upon reaching which the query execution will terminate early.
    /// - `timeout`: Time each individual bulk request should wait for shards
    ///   that are unavailable.
    /// - `version`: Whether to return document version as part of a hit.
    /// - `wait_for_active_shards`: Sets the number of shard copies that must be
    ///   active before proceeding with the operation. Defaults to 1, meaning
    ///   the primary shard only. Set to `all` for all shard copies, otherwise
    ///   set to any non-negative value less than or equal to the total number
    ///   of copies for the shard (number of replicas + 1).
    /// - `wait_for_completion`: Should this request wait until the operation
    ///   has completed before returning.
    /// - `body`
    ///```ignore
    /// let response = client.delete_by_query()
    ///    .index(index)
    ///    .source(source)
    ///    .source_excludes(source_excludes)
    ///    .source_includes(source_includes)
    ///    .allow_no_indices(allow_no_indices)
    ///    .analyze_wildcard(analyze_wildcard)
    ///    .analyzer(analyzer)
    ///    .conflicts(conflicts)
    ///    .default_operator(default_operator)
    ///    .df(df)
    ///    .expand_wildcards(expand_wildcards)
    ///    .from(from)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .lenient(lenient)
    ///    .max_docs(max_docs)
    ///    .preference(preference)
    ///    .q(q)
    ///    .refresh(refresh)
    ///    .request_cache(request_cache)
    ///    .requests_per_second(requests_per_second)
    ///    .routing(routing)
    ///    .scroll(scroll)
    ///    .scroll_size(scroll_size)
    ///    .search_timeout(search_timeout)
    ///    .search_type(search_type)
    ///    .size(size)
    ///    .slices(slices)
    ///    .sort(sort)
    ///    .stats(stats)
    ///    .terminate_after(terminate_after)
    ///    .timeout(timeout)
    ///    .version(version)
    ///    .wait_for_active_shards(wait_for_active_shards)
    ///    .wait_for_completion(wait_for_completion)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn delete_by_query(&self) -> builder::DeleteByQuery {
        builder::DeleteByQuery::new(self)
    }

    ///Creates or updates a document in an index.
    ///
    ///Sends a `POST` request to `/{index}/_doc`
    ///
    ///Arguments:
    /// - `index`: Index name.
    /// - `if_primary_term`: only perform the operation if the last operation
    ///   that has changed the document has the specified primary term.
    /// - `if_seq_no`: only perform the operation if the last operation that has
    ///   changed the document has the specified sequence number.
    /// - `op_type`: Explicit operation type. Defaults to `index` for requests
    ///   with an explicit document ID, and to `create`for requests without an
    ///   explicit document ID.
    /// - `pipeline`: The pipeline id to preprocess incoming documents with.
    /// - `refresh`: If `true` then refresh the affected shards to make this
    ///   operation visible to search, if `wait_for` then wait for a refresh to
    ///   make this operation visible to search, if `false` (the default) then
    ///   do nothing with refreshes.
    /// - `require_alias`: When true, requires destination to be an alias.
    /// - `routing`: Routing value.
    /// - `timeout`: Operation timeout.
    /// - `version`: Explicit version number for concurrency control.
    /// - `version_type`: Specific version type.
    /// - `wait_for_active_shards`: Sets the number of shard copies that must be
    ///   active before proceeding with the operation. Defaults to 1, meaning
    ///   the primary shard only. Set to `all` for all shard copies, otherwise
    ///   set to any non-negative value less than or equal to the total number
    ///   of copies for the shard (number of replicas + 1).
    /// - `body`
    ///```ignore
    /// let response = client.index_post()
    ///    .index(index)
    ///    .if_primary_term(if_primary_term)
    ///    .if_seq_no(if_seq_no)
    ///    .op_type(op_type)
    ///    .pipeline(pipeline)
    ///    .refresh(refresh)
    ///    .require_alias(require_alias)
    ///    .routing(routing)
    ///    .timeout(timeout)
    ///    .version(version)
    ///    .version_type(version_type)
    ///    .wait_for_active_shards(wait_for_active_shards)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn index_post(&self) -> builder::IndexPost {
        builder::IndexPost::new(self)
    }

    ///Returns a document.
    ///
    ///Sends a `GET` request to `/{index}/_doc/{id}`
    ///
    ///Arguments:
    /// - `index`: Index name.
    /// - `id`: Document ID.
    /// - `source`: True or false to return the _source field or not, or a list
    ///   of fields to return.
    /// - `source_excludes`: List of fields to exclude from the returned _source
    ///   field.
    /// - `source_includes`: List of fields to extract and return from the
    ///   _source field.
    /// - `preference`: Specify the node or shard the operation should be
    ///   performed on.
    /// - `realtime`: Specify whether to perform the operation in realtime or
    ///   search mode.
    /// - `refresh`: Refresh the shard containing the document before performing
    ///   the operation.
    /// - `routing`: Routing value.
    /// - `stored_fields`: Comma-separated list of stored fields to return.
    /// - `version`: Explicit version number for concurrency control.
    /// - `version_type`: Specific version type.
    ///```ignore
    /// let response = client.get()
    ///    .index(index)
    ///    .id(id)
    ///    .source(source)
    ///    .source_excludes(source_excludes)
    ///    .source_includes(source_includes)
    ///    .preference(preference)
    ///    .realtime(realtime)
    ///    .refresh(refresh)
    ///    .routing(routing)
    ///    .stored_fields(stored_fields)
    ///    .version(version)
    ///    .version_type(version_type)
    ///    .send()
    ///    .await;
    /// ```
    pub fn get(&self) -> builder::Get {
        builder::Get::new(self)
    }

    ///Creates or updates a document in an index.
    ///
    ///Sends a `PUT` request to `/{index}/_doc/{id}`
    ///
    ///Arguments:
    /// - `index`: Index name.
    /// - `id`: Document ID.
    /// - `if_primary_term`: only perform the operation if the last operation
    ///   that has changed the document has the specified primary term.
    /// - `if_seq_no`: only perform the operation if the last operation that has
    ///   changed the document has the specified sequence number.
    /// - `op_type`: Explicit operation type. Defaults to `index` for requests
    ///   with an explicit document ID, and to `create`for requests without an
    ///   explicit document ID.
    /// - `pipeline`: The pipeline id to preprocess incoming documents with.
    /// - `refresh`: If `true` then refresh the affected shards to make this
    ///   operation visible to search, if `wait_for` then wait for a refresh to
    ///   make this operation visible to search, if `false` (the default) then
    ///   do nothing with refreshes.
    /// - `require_alias`: When true, requires destination to be an alias.
    /// - `routing`: Routing value.
    /// - `timeout`: Operation timeout.
    /// - `version`: Explicit version number for concurrency control.
    /// - `version_type`: Specific version type.
    /// - `wait_for_active_shards`: Sets the number of shard copies that must be
    ///   active before proceeding with the operation. Defaults to 1, meaning
    ///   the primary shard only. Set to `all` for all shard copies, otherwise
    ///   set to any non-negative value less than or equal to the total number
    ///   of copies for the shard (number of replicas + 1).
    /// - `body`
    ///```ignore
    /// let response = client.index_put_with_id()
    ///    .index(index)
    ///    .id(id)
    ///    .if_primary_term(if_primary_term)
    ///    .if_seq_no(if_seq_no)
    ///    .op_type(op_type)
    ///    .pipeline(pipeline)
    ///    .refresh(refresh)
    ///    .require_alias(require_alias)
    ///    .routing(routing)
    ///    .timeout(timeout)
    ///    .version(version)
    ///    .version_type(version_type)
    ///    .wait_for_active_shards(wait_for_active_shards)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn index_put_with_id(&self) -> builder::IndexPutWithId {
        builder::IndexPutWithId::new(self)
    }

    ///Creates or updates a document in an index.
    ///
    ///Sends a `POST` request to `/{index}/_doc/{id}`
    ///
    ///Arguments:
    /// - `index`: Index name.
    /// - `id`: Document ID.
    /// - `if_primary_term`: only perform the operation if the last operation
    ///   that has changed the document has the specified primary term.
    /// - `if_seq_no`: only perform the operation if the last operation that has
    ///   changed the document has the specified sequence number.
    /// - `op_type`: Explicit operation type. Defaults to `index` for requests
    ///   with an explicit document ID, and to `create`for requests without an
    ///   explicit document ID.
    /// - `pipeline`: The pipeline id to preprocess incoming documents with.
    /// - `refresh`: If `true` then refresh the affected shards to make this
    ///   operation visible to search, if `wait_for` then wait for a refresh to
    ///   make this operation visible to search, if `false` (the default) then
    ///   do nothing with refreshes.
    /// - `require_alias`: When true, requires destination to be an alias.
    /// - `routing`: Routing value.
    /// - `timeout`: Operation timeout.
    /// - `version`: Explicit version number for concurrency control.
    /// - `version_type`: Specific version type.
    /// - `wait_for_active_shards`: Sets the number of shard copies that must be
    ///   active before proceeding with the operation. Defaults to 1, meaning
    ///   the primary shard only. Set to `all` for all shard copies, otherwise
    ///   set to any non-negative value less than or equal to the total number
    ///   of copies for the shard (number of replicas + 1).
    /// - `body`
    ///```ignore
    /// let response = client.index_post_with_id()
    ///    .index(index)
    ///    .id(id)
    ///    .if_primary_term(if_primary_term)
    ///    .if_seq_no(if_seq_no)
    ///    .op_type(op_type)
    ///    .pipeline(pipeline)
    ///    .refresh(refresh)
    ///    .require_alias(require_alias)
    ///    .routing(routing)
    ///    .timeout(timeout)
    ///    .version(version)
    ///    .version_type(version_type)
    ///    .wait_for_active_shards(wait_for_active_shards)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn index_post_with_id(&self) -> builder::IndexPostWithId {
        builder::IndexPostWithId::new(self)
    }

    ///Removes a document from the index.
    ///
    ///Sends a `DELETE` request to `/{index}/_doc/{id}`
    ///
    ///Arguments:
    /// - `index`: Index name.
    /// - `id`: Document ID.
    /// - `if_primary_term`: only perform the operation if the last operation
    ///   that has changed the document has the specified primary term.
    /// - `if_seq_no`: only perform the operation if the last operation that has
    ///   changed the document has the specified sequence number.
    /// - `refresh`: If `true` then refresh the affected shards to make this
    ///   operation visible to search, if `wait_for` then wait for a refresh to
    ///   make this operation visible to search, if `false` (the default) then
    ///   do nothing with refreshes.
    /// - `routing`: Routing value.
    /// - `timeout`: Operation timeout.
    /// - `version`: Explicit version number for concurrency control.
    /// - `version_type`: Specific version type.
    /// - `wait_for_active_shards`: Sets the number of shard copies that must be
    ///   active before proceeding with the operation. Defaults to 1, meaning
    ///   the primary shard only. Set to `all` for all shard copies, otherwise
    ///   set to any non-negative value less than or equal to the total number
    ///   of copies for the shard (number of replicas + 1).
    ///```ignore
    /// let response = client.delete()
    ///    .index(index)
    ///    .id(id)
    ///    .if_primary_term(if_primary_term)
    ///    .if_seq_no(if_seq_no)
    ///    .refresh(refresh)
    ///    .routing(routing)
    ///    .timeout(timeout)
    ///    .version(version)
    ///    .version_type(version_type)
    ///    .wait_for_active_shards(wait_for_active_shards)
    ///    .send()
    ///    .await;
    /// ```
    pub fn delete(&self) -> builder::Delete {
        builder::Delete::new(self)
    }

    ///Returns information about whether a document exists in an index.
    ///
    ///Sends a `HEAD` request to `/{index}/_doc/{id}`
    ///
    ///Arguments:
    /// - `index`: Index name.
    /// - `id`: Document ID.
    /// - `source`: True or false to return the _source field or not, or a list
    ///   of fields to return.
    /// - `source_excludes`: List of fields to exclude from the returned _source
    ///   field.
    /// - `source_includes`: List of fields to extract and return from the
    ///   _source field.
    /// - `preference`: Specify the node or shard the operation should be
    ///   performed on.
    /// - `realtime`: Specify whether to perform the operation in realtime or
    ///   search mode.
    /// - `refresh`: Refresh the shard containing the document before performing
    ///   the operation.
    /// - `routing`: Routing value.
    /// - `stored_fields`: Comma-separated list of stored fields to return.
    /// - `version`: Explicit version number for concurrency control.
    /// - `version_type`: Specific version type.
    ///```ignore
    /// let response = client.exists()
    ///    .index(index)
    ///    .id(id)
    ///    .source(source)
    ///    .source_excludes(source_excludes)
    ///    .source_includes(source_includes)
    ///    .preference(preference)
    ///    .realtime(realtime)
    ///    .refresh(refresh)
    ///    .routing(routing)
    ///    .stored_fields(stored_fields)
    ///    .version(version)
    ///    .version_type(version_type)
    ///    .send()
    ///    .await;
    /// ```
    pub fn exists(&self) -> builder::Exists {
        builder::Exists::new(self)
    }

    ///Returns information about why a specific matches (or doesn't match) a
    /// query.
    ///
    ///Sends a `GET` request to `/{index}/_explain/{id}`
    ///
    ///Arguments:
    /// - `index`: Index name.
    /// - `id`: Document ID.
    /// - `source`: True or false to return the _source field or not, or a list
    ///   of fields to return.
    /// - `source_excludes`: List of fields to exclude from the returned _source
    ///   field.
    /// - `source_includes`: List of fields to extract and return from the
    ///   _source field.
    /// - `analyze_wildcard`: Specify whether wildcards and prefix queries in
    ///   the query string query should be analyzed.
    /// - `analyzer`: The analyzer to use for the query string.
    /// - `default_operator`: The default operator for query string query (AND
    ///   or OR).
    /// - `df`: The default field for query string query.
    /// - `lenient`: Specify whether format-based query failures (such as
    ///   providing text to a numeric field) should be ignored.
    /// - `preference`: Specify the node or shard the operation should be
    ///   performed on.
    /// - `q`: Query in the Lucene query string syntax.
    /// - `routing`: Routing value.
    /// - `stored_fields`: Comma-separated list of stored fields to return.
    ///```ignore
    /// let response = client.explain_get()
    ///    .index(index)
    ///    .id(id)
    ///    .source(source)
    ///    .source_excludes(source_excludes)
    ///    .source_includes(source_includes)
    ///    .analyze_wildcard(analyze_wildcard)
    ///    .analyzer(analyzer)
    ///    .default_operator(default_operator)
    ///    .df(df)
    ///    .lenient(lenient)
    ///    .preference(preference)
    ///    .q(q)
    ///    .routing(routing)
    ///    .stored_fields(stored_fields)
    ///    .send()
    ///    .await;
    /// ```
    pub fn explain_get(&self) -> builder::ExplainGet {
        builder::ExplainGet::new(self)
    }

    ///Returns information about why a specific matches (or doesn't match) a
    /// query.
    ///
    ///Sends a `POST` request to `/{index}/_explain/{id}`
    ///
    ///Arguments:
    /// - `index`: Index name.
    /// - `id`: Document ID.
    /// - `source`: True or false to return the _source field or not, or a list
    ///   of fields to return.
    /// - `source_excludes`: List of fields to exclude from the returned _source
    ///   field.
    /// - `source_includes`: List of fields to extract and return from the
    ///   _source field.
    /// - `analyze_wildcard`: Specify whether wildcards and prefix queries in
    ///   the query string query should be analyzed.
    /// - `analyzer`: The analyzer to use for the query string.
    /// - `default_operator`: The default operator for query string query (AND
    ///   or OR).
    /// - `df`: The default field for query string query.
    /// - `lenient`: Specify whether format-based query failures (such as
    ///   providing text to a numeric field) should be ignored.
    /// - `preference`: Specify the node or shard the operation should be
    ///   performed on.
    /// - `q`: Query in the Lucene query string syntax.
    /// - `routing`: Routing value.
    /// - `stored_fields`: Comma-separated list of stored fields to return.
    /// - `body`
    ///```ignore
    /// let response = client.explain_post()
    ///    .index(index)
    ///    .id(id)
    ///    .source(source)
    ///    .source_excludes(source_excludes)
    ///    .source_includes(source_includes)
    ///    .analyze_wildcard(analyze_wildcard)
    ///    .analyzer(analyzer)
    ///    .default_operator(default_operator)
    ///    .df(df)
    ///    .lenient(lenient)
    ///    .preference(preference)
    ///    .q(q)
    ///    .routing(routing)
    ///    .stored_fields(stored_fields)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn explain_post(&self) -> builder::ExplainPost {
        builder::ExplainPost::new(self)
    }

    ///Returns the information about the capabilities of fields among multiple
    /// indices.
    ///
    ///Sends a `GET` request to `/{index}/_field_caps`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `fields`: Comma-separated list of field names.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `include_unmapped`: Indicates whether unmapped fields should be
    ///   included in the response.
    ///```ignore
    /// let response = client.field_caps_get_with_index()
    ///    .index(index)
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .fields(fields)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .include_unmapped(include_unmapped)
    ///    .send()
    ///    .await;
    /// ```
    pub fn field_caps_get_with_index(&self) -> builder::FieldCapsGetWithIndex {
        builder::FieldCapsGetWithIndex::new(self)
    }

    ///Returns the information about the capabilities of fields among multiple
    /// indices.
    ///
    ///Sends a `POST` request to `/{index}/_field_caps`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `fields`: Comma-separated list of field names.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `include_unmapped`: Indicates whether unmapped fields should be
    ///   included in the response.
    /// - `body`
    ///```ignore
    /// let response = client.field_caps_post_with_index()
    ///    .index(index)
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .fields(fields)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .include_unmapped(include_unmapped)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn field_caps_post_with_index(&self) -> builder::FieldCapsPostWithIndex {
        builder::FieldCapsPostWithIndex::new(self)
    }

    ///Performs the flush operation on one or more indices.
    ///
    ///Sends a `GET` request to `/{index}/_flush`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `force`: Whether a flush should be forced even if it is not
    ///   necessarily needed ie. if no changes will be committed to the index.
    ///   This is useful if transaction log IDs should be incremented even if no
    ///   uncommitted changes are present. (This setting can be considered as
    ///   internal).
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `wait_if_ongoing`: If set to true the flush operation will block until
    ///   the flush can be executed if another flush operation is already
    ///   executing. If set to false the flush will be skipped iff if another
    ///   flush operation is already running.
    ///```ignore
    /// let response = client.indices_flush_get_with_index()
    ///    .index(index)
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .force(force)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .wait_if_ongoing(wait_if_ongoing)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_flush_get_with_index(&self) -> builder::IndicesFlushGetWithIndex {
        builder::IndicesFlushGetWithIndex::new(self)
    }

    ///Performs the flush operation on one or more indices.
    ///
    ///Sends a `POST` request to `/{index}/_flush`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `force`: Whether a flush should be forced even if it is not
    ///   necessarily needed ie. if no changes will be committed to the index.
    ///   This is useful if transaction log IDs should be incremented even if no
    ///   uncommitted changes are present. (This setting can be considered as
    ///   internal).
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `wait_if_ongoing`: If set to true the flush operation will block until
    ///   the flush can be executed if another flush operation is already
    ///   executing. If set to false the flush will be skipped iff if another
    ///   flush operation is already running.
    ///```ignore
    /// let response = client.indices_flush_post_with_index()
    ///    .index(index)
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .force(force)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .wait_if_ongoing(wait_if_ongoing)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_flush_post_with_index(&self) -> builder::IndicesFlushPostWithIndex {
        builder::IndicesFlushPostWithIndex::new(self)
    }

    ///Performs the force merge operation on one or more indices.
    ///
    ///Sends a `POST` request to `/{index}/_forcemerge`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `flush`: Specify whether the index should be flushed after performing
    ///   the operation.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `max_num_segments`: The number of segments the index should be merged
    ///   into (default: dynamic).
    /// - `only_expunge_deletes`: Specify whether the operation should only
    ///   expunge deleted documents.
    ///```ignore
    /// let response = client.indices_forcemerge_with_index()
    ///    .index(index)
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .flush(flush)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .max_num_segments(max_num_segments)
    ///    .only_expunge_deletes(only_expunge_deletes)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_forcemerge_with_index(&self) -> builder::IndicesForcemergeWithIndex {
        builder::IndicesForcemergeWithIndex::new(self)
    }

    ///Returns mappings for one or more indices.
    ///
    ///Sends a `GET` request to `/{index}/_mapping`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    ///```ignore
    /// let response = client.indices_get_mapping_with_index()
    ///    .index(index)
    ///    .allow_no_indices(allow_no_indices)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_get_mapping_with_index(&self) -> builder::IndicesGetMappingWithIndex {
        builder::IndicesGetMappingWithIndex::new(self)
    }

    ///Updates the index mappings.
    ///
    ///Sends a `PUT` request to `/{index}/_mapping`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    /// - `write_index_only`: When true, applies mappings only to the write
    ///   index of an alias or data stream.
    /// - `body`
    ///```ignore
    /// let response = client.indices_put_mapping_put()
    ///    .index(index)
    ///    .allow_no_indices(allow_no_indices)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .write_index_only(write_index_only)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_put_mapping_put(&self) -> builder::IndicesPutMappingPut {
        builder::IndicesPutMappingPut::new(self)
    }

    ///Updates the index mappings.
    ///
    ///Sends a `POST` request to `/{index}/_mapping`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    /// - `write_index_only`: When true, applies mappings only to the write
    ///   index of an alias or data stream.
    /// - `body`
    ///```ignore
    /// let response = client.indices_put_mapping_post()
    ///    .index(index)
    ///    .allow_no_indices(allow_no_indices)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .write_index_only(write_index_only)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_put_mapping_post(&self) -> builder::IndicesPutMappingPost {
        builder::IndicesPutMappingPost::new(self)
    }

    ///Returns mapping for one or more fields.
    ///
    ///Sends a `GET` request to `/{index}/_mapping/field/{fields}`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices.
    /// - `fields`: Comma-separated list of fields.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `include_defaults`: Whether the default mapping values should be
    ///   returned as well.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    ///```ignore
    /// let response = client.indices_get_field_mapping_with_index()
    ///    .index(index)
    ///    .fields(fields)
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .include_defaults(include_defaults)
    ///    .local(local)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_get_field_mapping_with_index(&self) -> builder::IndicesGetFieldMappingWithIndex {
        builder::IndicesGetFieldMappingWithIndex::new(self)
    }

    ///Allows to get multiple documents in one request.
    ///
    ///Sends a `GET` request to `/{index}/_mget`
    ///
    ///Arguments:
    /// - `index`: Index name.
    /// - `source`: True or false to return the _source field or not, or a list
    ///   of fields to return.
    /// - `source_excludes`: List of fields to exclude from the returned _source
    ///   field.
    /// - `source_includes`: List of fields to extract and return from the
    ///   _source field.
    /// - `preference`: Specify the node or shard the operation should be
    ///   performed on.
    /// - `realtime`: Specify whether to perform the operation in realtime or
    ///   search mode.
    /// - `refresh`: Refresh the shard containing the document before performing
    ///   the operation.
    /// - `routing`: Routing value.
    /// - `stored_fields`: Comma-separated list of stored fields to return.
    ///```ignore
    /// let response = client.mget_get_with_index()
    ///    .index(index)
    ///    .source(source)
    ///    .source_excludes(source_excludes)
    ///    .source_includes(source_includes)
    ///    .preference(preference)
    ///    .realtime(realtime)
    ///    .refresh(refresh)
    ///    .routing(routing)
    ///    .stored_fields(stored_fields)
    ///    .send()
    ///    .await;
    /// ```
    pub fn mget_get_with_index(&self) -> builder::MgetGetWithIndex {
        builder::MgetGetWithIndex::new(self)
    }

    ///Allows to get multiple documents in one request.
    ///
    ///Sends a `POST` request to `/{index}/_mget`
    ///
    ///Arguments:
    /// - `index`: Index name.
    /// - `source`: True or false to return the _source field or not, or a list
    ///   of fields to return.
    /// - `source_excludes`: List of fields to exclude from the returned _source
    ///   field.
    /// - `source_includes`: List of fields to extract and return from the
    ///   _source field.
    /// - `preference`: Specify the node or shard the operation should be
    ///   performed on.
    /// - `realtime`: Specify whether to perform the operation in realtime or
    ///   search mode.
    /// - `refresh`: Refresh the shard containing the document before performing
    ///   the operation.
    /// - `routing`: Routing value.
    /// - `stored_fields`: Comma-separated list of stored fields to return.
    /// - `body`
    ///```ignore
    /// let response = client.mget_post_with_index()
    ///    .index(index)
    ///    .source(source)
    ///    .source_excludes(source_excludes)
    ///    .source_includes(source_includes)
    ///    .preference(preference)
    ///    .realtime(realtime)
    ///    .refresh(refresh)
    ///    .routing(routing)
    ///    .stored_fields(stored_fields)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn mget_post_with_index(&self) -> builder::MgetPostWithIndex {
        builder::MgetPostWithIndex::new(self)
    }

    ///Allows to execute several search operations in one request.
    ///
    ///Sends a `GET` request to `/{index}/_msearch`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices to use as default.
    /// - `ccs_minimize_roundtrips`: Indicates whether network round-trips
    ///   should be minimized as part of cross-cluster search requests
    ///   execution.
    /// - `max_concurrent_searches`: Controls the maximum number of concurrent
    ///   searches the multi search api will execute.
    /// - `max_concurrent_shard_requests`: The number of concurrent shard
    ///   requests each sub search executes concurrently per node. This value
    ///   should be used to limit the impact of the search on the cluster in
    ///   order to limit the number of concurrent shard requests.
    /// - `pre_filter_shard_size`: Threshold that enforces a pre-filter
    ///   round-trip to prefilter search shards based on query rewriting if the
    ///   number of shards the search request expands to exceeds the threshold.
    ///   This filter round-trip can limit the number of shards significantly if
    ///   for instance a shard can not match any documents based on its rewrite
    ///   method ie. if date filters are mandatory to match but the shard bounds
    ///   and the query are disjoint.
    /// - `rest_total_hits_as_int`: Indicates whether hits.total should be
    ///   rendered as an integer or an object in the rest search response.
    /// - `search_type`: Search operation type.
    /// - `typed_keys`: Specify whether aggregation and suggester names should
    ///   be prefixed by their respective types in the response.
    ///```ignore
    /// let response = client.msearch_get_with_index()
    ///    .index(index)
    ///    .ccs_minimize_roundtrips(ccs_minimize_roundtrips)
    ///    .max_concurrent_searches(max_concurrent_searches)
    ///    .max_concurrent_shard_requests(max_concurrent_shard_requests)
    ///    .pre_filter_shard_size(pre_filter_shard_size)
    ///    .rest_total_hits_as_int(rest_total_hits_as_int)
    ///    .search_type(search_type)
    ///    .typed_keys(typed_keys)
    ///    .send()
    ///    .await;
    /// ```
    pub fn msearch_get_with_index(&self) -> builder::MsearchGetWithIndex {
        builder::MsearchGetWithIndex::new(self)
    }

    ///Allows to execute several search operations in one request.
    ///
    ///Sends a `POST` request to `/{index}/_msearch`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices to use as default.
    /// - `ccs_minimize_roundtrips`: Indicates whether network round-trips
    ///   should be minimized as part of cross-cluster search requests
    ///   execution.
    /// - `max_concurrent_searches`: Controls the maximum number of concurrent
    ///   searches the multi search api will execute.
    /// - `max_concurrent_shard_requests`: The number of concurrent shard
    ///   requests each sub search executes concurrently per node. This value
    ///   should be used to limit the impact of the search on the cluster in
    ///   order to limit the number of concurrent shard requests.
    /// - `pre_filter_shard_size`: Threshold that enforces a pre-filter
    ///   round-trip to prefilter search shards based on query rewriting if the
    ///   number of shards the search request expands to exceeds the threshold.
    ///   This filter round-trip can limit the number of shards significantly if
    ///   for instance a shard can not match any documents based on its rewrite
    ///   method ie. if date filters are mandatory to match but the shard bounds
    ///   and the query are disjoint.
    /// - `rest_total_hits_as_int`: Indicates whether hits.total should be
    ///   rendered as an integer or an object in the rest search response.
    /// - `search_type`: Search operation type.
    /// - `typed_keys`: Specify whether aggregation and suggester names should
    ///   be prefixed by their respective types in the response.
    /// - `body`
    ///```ignore
    /// let response = client.msearch_post_with_index()
    ///    .index(index)
    ///    .ccs_minimize_roundtrips(ccs_minimize_roundtrips)
    ///    .max_concurrent_searches(max_concurrent_searches)
    ///    .max_concurrent_shard_requests(max_concurrent_shard_requests)
    ///    .pre_filter_shard_size(pre_filter_shard_size)
    ///    .rest_total_hits_as_int(rest_total_hits_as_int)
    ///    .search_type(search_type)
    ///    .typed_keys(typed_keys)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn msearch_post_with_index(&self) -> builder::MsearchPostWithIndex {
        builder::MsearchPostWithIndex::new(self)
    }

    ///Allows to execute several search template operations in one request.
    ///
    ///Sends a `GET` request to `/{index}/_msearch/template`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices to use as default.
    /// - `ccs_minimize_roundtrips`: Indicates whether network round-trips
    ///   should be minimized as part of cross-cluster search requests
    ///   execution.
    /// - `max_concurrent_searches`: Controls the maximum number of concurrent
    ///   searches the multi search api will execute.
    /// - `rest_total_hits_as_int`: Indicates whether hits.total should be
    ///   rendered as an integer or an object in the rest search response.
    /// - `search_type`: Search operation type.
    /// - `typed_keys`: Specify whether aggregation and suggester names should
    ///   be prefixed by their respective types in the response.
    ///```ignore
    /// let response = client.msearch_template_get_with_index()
    ///    .index(index)
    ///    .ccs_minimize_roundtrips(ccs_minimize_roundtrips)
    ///    .max_concurrent_searches(max_concurrent_searches)
    ///    .rest_total_hits_as_int(rest_total_hits_as_int)
    ///    .search_type(search_type)
    ///    .typed_keys(typed_keys)
    ///    .send()
    ///    .await;
    /// ```
    pub fn msearch_template_get_with_index(&self) -> builder::MsearchTemplateGetWithIndex {
        builder::MsearchTemplateGetWithIndex::new(self)
    }

    ///Allows to execute several search template operations in one request.
    ///
    ///Sends a `POST` request to `/{index}/_msearch/template`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices to use as default.
    /// - `ccs_minimize_roundtrips`: Indicates whether network round-trips
    ///   should be minimized as part of cross-cluster search requests
    ///   execution.
    /// - `max_concurrent_searches`: Controls the maximum number of concurrent
    ///   searches the multi search api will execute.
    /// - `rest_total_hits_as_int`: Indicates whether hits.total should be
    ///   rendered as an integer or an object in the rest search response.
    /// - `search_type`: Search operation type.
    /// - `typed_keys`: Specify whether aggregation and suggester names should
    ///   be prefixed by their respective types in the response.
    /// - `body`
    ///```ignore
    /// let response = client.msearch_template_post_with_index()
    ///    .index(index)
    ///    .ccs_minimize_roundtrips(ccs_minimize_roundtrips)
    ///    .max_concurrent_searches(max_concurrent_searches)
    ///    .rest_total_hits_as_int(rest_total_hits_as_int)
    ///    .search_type(search_type)
    ///    .typed_keys(typed_keys)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn msearch_template_post_with_index(&self) -> builder::MsearchTemplatePostWithIndex {
        builder::MsearchTemplatePostWithIndex::new(self)
    }

    ///Returns multiple termvectors in one request.
    ///
    ///Sends a `GET` request to `/{index}/_mtermvectors`
    ///
    ///Arguments:
    /// - `index`: The index in which the document resides.
    /// - `field_statistics`: Specifies if document count, sum of document
    ///   frequencies and sum of total term frequencies should be returned.
    ///   Applies to all returned documents unless otherwise specified in body
    ///   'params' or 'docs'.
    /// - `fields`: Comma-separated list of fields to return. Applies to all
    ///   returned documents unless otherwise specified in body 'params' or
    ///   'docs'.
    /// - `ids`: Comma-separated list of documents ids. You must define ids as
    ///   parameter or set 'ids' or 'docs' in the request body.
    /// - `offsets`: Specifies if term offsets should be returned. Applies to
    ///   all returned documents unless otherwise specified in body 'params' or
    ///   'docs'.
    /// - `payloads`: Specifies if term payloads should be returned. Applies to
    ///   all returned documents unless otherwise specified in body 'params' or
    ///   'docs'.
    /// - `positions`: Specifies if term positions should be returned. Applies
    ///   to all returned documents unless otherwise specified in body 'params'
    ///   or 'docs'.
    /// - `preference`: Specify the node or shard the operation should be
    ///   performed on. Applies to all returned documents unless otherwise
    ///   specified in body 'params' or 'docs'.
    /// - `realtime`: Specifies if requests are real-time as opposed to
    ///   near-real-time.
    /// - `routing`: Routing value. Applies to all returned documents unless
    ///   otherwise specified in body 'params' or 'docs'.
    /// - `term_statistics`: Specifies if total term frequency and document
    ///   frequency should be returned. Applies to all returned documents unless
    ///   otherwise specified in body 'params' or 'docs'.
    /// - `version`: Explicit version number for concurrency control.
    /// - `version_type`: Specific version type.
    ///```ignore
    /// let response = client.mtermvectors_get_with_index()
    ///    .index(index)
    ///    .field_statistics(field_statistics)
    ///    .fields(fields)
    ///    .ids(ids)
    ///    .offsets(offsets)
    ///    .payloads(payloads)
    ///    .positions(positions)
    ///    .preference(preference)
    ///    .realtime(realtime)
    ///    .routing(routing)
    ///    .term_statistics(term_statistics)
    ///    .version(version)
    ///    .version_type(version_type)
    ///    .send()
    ///    .await;
    /// ```
    pub fn mtermvectors_get_with_index(&self) -> builder::MtermvectorsGetWithIndex {
        builder::MtermvectorsGetWithIndex::new(self)
    }

    ///Returns multiple termvectors in one request.
    ///
    ///Sends a `POST` request to `/{index}/_mtermvectors`
    ///
    ///Arguments:
    /// - `index`: The index in which the document resides.
    /// - `field_statistics`: Specifies if document count, sum of document
    ///   frequencies and sum of total term frequencies should be returned.
    ///   Applies to all returned documents unless otherwise specified in body
    ///   'params' or 'docs'.
    /// - `fields`: Comma-separated list of fields to return. Applies to all
    ///   returned documents unless otherwise specified in body 'params' or
    ///   'docs'.
    /// - `ids`: Comma-separated list of documents ids. You must define ids as
    ///   parameter or set 'ids' or 'docs' in the request body.
    /// - `offsets`: Specifies if term offsets should be returned. Applies to
    ///   all returned documents unless otherwise specified in body 'params' or
    ///   'docs'.
    /// - `payloads`: Specifies if term payloads should be returned. Applies to
    ///   all returned documents unless otherwise specified in body 'params' or
    ///   'docs'.
    /// - `positions`: Specifies if term positions should be returned. Applies
    ///   to all returned documents unless otherwise specified in body 'params'
    ///   or 'docs'.
    /// - `preference`: Specify the node or shard the operation should be
    ///   performed on. Applies to all returned documents unless otherwise
    ///   specified in body 'params' or 'docs'.
    /// - `realtime`: Specifies if requests are real-time as opposed to
    ///   near-real-time.
    /// - `routing`: Routing value. Applies to all returned documents unless
    ///   otherwise specified in body 'params' or 'docs'.
    /// - `term_statistics`: Specifies if total term frequency and document
    ///   frequency should be returned. Applies to all returned documents unless
    ///   otherwise specified in body 'params' or 'docs'.
    /// - `version`: Explicit version number for concurrency control.
    /// - `version_type`: Specific version type.
    /// - `body`
    ///```ignore
    /// let response = client.mtermvectors_post_with_index()
    ///    .index(index)
    ///    .field_statistics(field_statistics)
    ///    .fields(fields)
    ///    .ids(ids)
    ///    .offsets(offsets)
    ///    .payloads(payloads)
    ///    .positions(positions)
    ///    .preference(preference)
    ///    .realtime(realtime)
    ///    .routing(routing)
    ///    .term_statistics(term_statistics)
    ///    .version(version)
    ///    .version_type(version_type)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn mtermvectors_post_with_index(&self) -> builder::MtermvectorsPostWithIndex {
        builder::MtermvectorsPostWithIndex::new(self)
    }

    ///Opens an index.
    ///
    ///Sends a `POST` request to `/{index}/_open`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices to open.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    /// - `wait_for_active_shards`: Sets the number of active shards to wait for
    ///   before the operation returns.
    ///```ignore
    /// let response = client.indices_open()
    ///    .index(index)
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .wait_for_active_shards(wait_for_active_shards)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_open(&self) -> builder::IndicesOpen {
        builder::IndicesOpen::new(self)
    }

    ///Allows to evaluate the quality of ranked search results over a set of
    /// typical search queries.
    ///
    ///Sends a `GET` request to `/{index}/_rank_eval`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `search_type`: Search operation type.
    ///```ignore
    /// let response = client.rank_eval_get_with_index()
    ///    .index(index)
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .search_type(search_type)
    ///    .send()
    ///    .await;
    /// ```
    pub fn rank_eval_get_with_index(&self) -> builder::RankEvalGetWithIndex {
        builder::RankEvalGetWithIndex::new(self)
    }

    ///Allows to evaluate the quality of ranked search results over a set of
    /// typical search queries.
    ///
    ///Sends a `POST` request to `/{index}/_rank_eval`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `search_type`: Search operation type.
    /// - `body`
    ///```ignore
    /// let response = client.rank_eval_post_with_index()
    ///    .index(index)
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .search_type(search_type)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn rank_eval_post_with_index(&self) -> builder::RankEvalPostWithIndex {
        builder::RankEvalPostWithIndex::new(self)
    }

    ///Returns information about ongoing index shard recoveries.
    ///
    ///Sends a `GET` request to `/{index}/_recovery`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `active_only`: Display only those recoveries that are currently
    ///   on-going.
    /// - `detailed`: Whether to display detailed information about shard
    ///   recovery.
    ///```ignore
    /// let response = client.indices_recovery_with_index()
    ///    .index(index)
    ///    .active_only(active_only)
    ///    .detailed(detailed)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_recovery_with_index(&self) -> builder::IndicesRecoveryWithIndex {
        builder::IndicesRecoveryWithIndex::new(self)
    }

    ///Performs the refresh operation in one or more indices.
    ///
    ///Sends a `GET` request to `/{index}/_refresh`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    ///```ignore
    /// let response = client.indices_refresh_get_with_index()
    ///    .index(index)
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_refresh_get_with_index(&self) -> builder::IndicesRefreshGetWithIndex {
        builder::IndicesRefreshGetWithIndex::new(self)
    }

    ///Performs the refresh operation in one or more indices.
    ///
    ///Sends a `POST` request to `/{index}/_refresh`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    ///```ignore
    /// let response = client.indices_refresh_post_with_index()
    ///    .index(index)
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_refresh_post_with_index(&self) -> builder::IndicesRefreshPostWithIndex {
        builder::IndicesRefreshPostWithIndex::new(self)
    }

    ///Returns results matching a query.
    ///
    ///Sends a `GET` request to `/{index}/_search`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `source`: True or false to return the _source field or not, or a list
    ///   of fields to return.
    /// - `source_excludes`: List of fields to exclude from the returned _source
    ///   field.
    /// - `source_includes`: List of fields to extract and return from the
    ///   _source field.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `allow_partial_search_results`: Indicate if an error should be
    ///   returned if there is a partial search failure or timeout.
    /// - `analyze_wildcard`: Specify whether wildcard and prefix queries should
    ///   be analyzed.
    /// - `analyzer`: The analyzer to use for the query string.
    /// - `batched_reduce_size`: The number of shard results that should be
    ///   reduced at once on the coordinating node. This value should be used as
    ///   a protection mechanism to reduce the memory overhead per search
    ///   request if the potential number of shards in the request can be large.
    /// - `ccs_minimize_roundtrips`: Indicates whether network round-trips
    ///   should be minimized as part of cross-cluster search requests
    ///   execution.
    /// - `default_operator`: The default operator for query string query (AND
    ///   or OR).
    /// - `df`: The field to use as default where no field prefix is given in
    ///   the query string.
    /// - `docvalue_fields`: Comma-separated list of fields to return as the
    ///   docvalue representation of a field for each hit.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `explain`: Specify whether to return detailed information about score
    ///   computation as part of a hit.
    /// - `from`: Starting offset.
    /// - `ignore_throttled`: Whether specified concrete, expanded or aliased
    ///   indices should be ignored when throttled.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `lenient`: Specify whether format-based query failures (such as
    ///   providing text to a numeric field) should be ignored.
    /// - `max_concurrent_shard_requests`: The number of concurrent shard
    ///   requests per node this search executes concurrently. This value should
    ///   be used to limit the impact of the search on the cluster in order to
    ///   limit the number of concurrent shard requests.
    /// - `pre_filter_shard_size`: Threshold that enforces a pre-filter
    ///   round-trip to prefilter search shards based on query rewriting if the
    ///   number of shards the search request expands to exceeds the threshold.
    ///   This filter round-trip can limit the number of shards significantly if
    ///   for instance a shard can not match any documents based on its rewrite
    ///   method ie. if date filters are mandatory to match but the shard bounds
    ///   and the query are disjoint.
    /// - `preference`: Specify the node or shard the operation should be
    ///   performed on.
    /// - `q`: Query in the Lucene query string syntax.
    /// - `request_cache`: Specify if request cache should be used for this
    ///   request or not, defaults to index level setting.
    /// - `rest_total_hits_as_int`: Indicates whether hits.total should be
    ///   rendered as an integer or an object in the rest search response.
    /// - `routing`: Comma-separated list of specific routing values.
    /// - `scroll`: Specify how long a consistent view of the index should be
    ///   maintained for scrolled search.
    /// - `search_type`: Search operation type.
    /// - `seq_no_primary_term`: Specify whether to return sequence number and
    ///   primary term of the last modification of each hit.
    /// - `size`: Number of hits to return.
    /// - `sort`: Comma-separated list of <field>:<direction> pairs.
    /// - `stats`: Specific 'tag' of the request for logging and statistical
    ///   purposes.
    /// - `stored_fields`: Comma-separated list of stored fields to return.
    /// - `suggest_field`: Specify which field to use for suggestions.
    /// - `suggest_mode`: Specify suggest mode.
    /// - `suggest_size`: How many suggestions to return in response.
    /// - `suggest_text`: The source text for which the suggestions should be
    ///   returned.
    /// - `terminate_after`: The maximum number of documents to collect for each
    ///   shard, upon reaching which the query execution will terminate early.
    /// - `timeout`: Operation timeout.
    /// - `track_scores`: Whether to calculate and return scores even if they
    ///   are not used for sorting.
    /// - `track_total_hits`: Indicate if the number of documents that match the
    ///   query should be tracked.
    /// - `typed_keys`: Specify whether aggregation and suggester names should
    ///   be prefixed by their respective types in the response.
    /// - `version`: Whether to return document version as part of a hit.
    ///```ignore
    /// let response = client.search_get_with_index()
    ///    .index(index)
    ///    .source(source)
    ///    .source_excludes(source_excludes)
    ///    .source_includes(source_includes)
    ///    .allow_no_indices(allow_no_indices)
    ///    .allow_partial_search_results(allow_partial_search_results)
    ///    .analyze_wildcard(analyze_wildcard)
    ///    .analyzer(analyzer)
    ///    .batched_reduce_size(batched_reduce_size)
    ///    .ccs_minimize_roundtrips(ccs_minimize_roundtrips)
    ///    .default_operator(default_operator)
    ///    .df(df)
    ///    .docvalue_fields(docvalue_fields)
    ///    .expand_wildcards(expand_wildcards)
    ///    .explain(explain)
    ///    .from(from)
    ///    .ignore_throttled(ignore_throttled)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .lenient(lenient)
    ///    .max_concurrent_shard_requests(max_concurrent_shard_requests)
    ///    .pre_filter_shard_size(pre_filter_shard_size)
    ///    .preference(preference)
    ///    .q(q)
    ///    .request_cache(request_cache)
    ///    .rest_total_hits_as_int(rest_total_hits_as_int)
    ///    .routing(routing)
    ///    .scroll(scroll)
    ///    .search_type(search_type)
    ///    .seq_no_primary_term(seq_no_primary_term)
    ///    .size(size)
    ///    .sort(sort)
    ///    .stats(stats)
    ///    .stored_fields(stored_fields)
    ///    .suggest_field(suggest_field)
    ///    .suggest_mode(suggest_mode)
    ///    .suggest_size(suggest_size)
    ///    .suggest_text(suggest_text)
    ///    .terminate_after(terminate_after)
    ///    .timeout(timeout)
    ///    .track_scores(track_scores)
    ///    .track_total_hits(track_total_hits)
    ///    .typed_keys(typed_keys)
    ///    .version(version)
    ///    .send()
    ///    .await;
    /// ```
    pub fn search_get_with_index(&self) -> builder::SearchGetWithIndex {
        builder::SearchGetWithIndex::new(self)
    }

    ///Returns results matching a query.
    ///
    ///Sends a `POST` request to `/{index}/_search`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `source`: True or false to return the _source field or not, or a list
    ///   of fields to return.
    /// - `source_excludes`: List of fields to exclude from the returned _source
    ///   field.
    /// - `source_includes`: List of fields to extract and return from the
    ///   _source field.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `allow_partial_search_results`: Indicate if an error should be
    ///   returned if there is a partial search failure or timeout.
    /// - `analyze_wildcard`: Specify whether wildcard and prefix queries should
    ///   be analyzed.
    /// - `analyzer`: The analyzer to use for the query string.
    /// - `batched_reduce_size`: The number of shard results that should be
    ///   reduced at once on the coordinating node. This value should be used as
    ///   a protection mechanism to reduce the memory overhead per search
    ///   request if the potential number of shards in the request can be large.
    /// - `ccs_minimize_roundtrips`: Indicates whether network round-trips
    ///   should be minimized as part of cross-cluster search requests
    ///   execution.
    /// - `default_operator`: The default operator for query string query (AND
    ///   or OR).
    /// - `df`: The field to use as default where no field prefix is given in
    ///   the query string.
    /// - `docvalue_fields`: Comma-separated list of fields to return as the
    ///   docvalue representation of a field for each hit.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `explain`: Specify whether to return detailed information about score
    ///   computation as part of a hit.
    /// - `from`: Starting offset.
    /// - `ignore_throttled`: Whether specified concrete, expanded or aliased
    ///   indices should be ignored when throttled.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `lenient`: Specify whether format-based query failures (such as
    ///   providing text to a numeric field) should be ignored.
    /// - `max_concurrent_shard_requests`: The number of concurrent shard
    ///   requests per node this search executes concurrently. This value should
    ///   be used to limit the impact of the search on the cluster in order to
    ///   limit the number of concurrent shard requests.
    /// - `pre_filter_shard_size`: Threshold that enforces a pre-filter
    ///   round-trip to prefilter search shards based on query rewriting if the
    ///   number of shards the search request expands to exceeds the threshold.
    ///   This filter round-trip can limit the number of shards significantly if
    ///   for instance a shard can not match any documents based on its rewrite
    ///   method ie. if date filters are mandatory to match but the shard bounds
    ///   and the query are disjoint.
    /// - `preference`: Specify the node or shard the operation should be
    ///   performed on.
    /// - `q`: Query in the Lucene query string syntax.
    /// - `request_cache`: Specify if request cache should be used for this
    ///   request or not, defaults to index level setting.
    /// - `rest_total_hits_as_int`: Indicates whether hits.total should be
    ///   rendered as an integer or an object in the rest search response.
    /// - `routing`: Comma-separated list of specific routing values.
    /// - `scroll`: Specify how long a consistent view of the index should be
    ///   maintained for scrolled search.
    /// - `search_type`: Search operation type.
    /// - `seq_no_primary_term`: Specify whether to return sequence number and
    ///   primary term of the last modification of each hit.
    /// - `size`: Number of hits to return.
    /// - `sort`: Comma-separated list of <field>:<direction> pairs.
    /// - `stats`: Specific 'tag' of the request for logging and statistical
    ///   purposes.
    /// - `stored_fields`: Comma-separated list of stored fields to return.
    /// - `suggest_field`: Specify which field to use for suggestions.
    /// - `suggest_mode`: Specify suggest mode.
    /// - `suggest_size`: How many suggestions to return in response.
    /// - `suggest_text`: The source text for which the suggestions should be
    ///   returned.
    /// - `terminate_after`: The maximum number of documents to collect for each
    ///   shard, upon reaching which the query execution will terminate early.
    /// - `timeout`: Operation timeout.
    /// - `track_scores`: Whether to calculate and return scores even if they
    ///   are not used for sorting.
    /// - `track_total_hits`: Indicate if the number of documents that match the
    ///   query should be tracked.
    /// - `typed_keys`: Specify whether aggregation and suggester names should
    ///   be prefixed by their respective types in the response.
    /// - `version`: Whether to return document version as part of a hit.
    /// - `body`
    ///```ignore
    /// let response = client.search_post_with_index()
    ///    .index(index)
    ///    .source(source)
    ///    .source_excludes(source_excludes)
    ///    .source_includes(source_includes)
    ///    .allow_no_indices(allow_no_indices)
    ///    .allow_partial_search_results(allow_partial_search_results)
    ///    .analyze_wildcard(analyze_wildcard)
    ///    .analyzer(analyzer)
    ///    .batched_reduce_size(batched_reduce_size)
    ///    .ccs_minimize_roundtrips(ccs_minimize_roundtrips)
    ///    .default_operator(default_operator)
    ///    .df(df)
    ///    .docvalue_fields(docvalue_fields)
    ///    .expand_wildcards(expand_wildcards)
    ///    .explain(explain)
    ///    .from(from)
    ///    .ignore_throttled(ignore_throttled)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .lenient(lenient)
    ///    .max_concurrent_shard_requests(max_concurrent_shard_requests)
    ///    .pre_filter_shard_size(pre_filter_shard_size)
    ///    .preference(preference)
    ///    .q(q)
    ///    .request_cache(request_cache)
    ///    .rest_total_hits_as_int(rest_total_hits_as_int)
    ///    .routing(routing)
    ///    .scroll(scroll)
    ///    .search_type(search_type)
    ///    .seq_no_primary_term(seq_no_primary_term)
    ///    .size(size)
    ///    .sort(sort)
    ///    .stats(stats)
    ///    .stored_fields(stored_fields)
    ///    .suggest_field(suggest_field)
    ///    .suggest_mode(suggest_mode)
    ///    .suggest_size(suggest_size)
    ///    .suggest_text(suggest_text)
    ///    .terminate_after(terminate_after)
    ///    .timeout(timeout)
    ///    .track_scores(track_scores)
    ///    .track_total_hits(track_total_hits)
    ///    .typed_keys(typed_keys)
    ///    .version(version)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn search_post_with_index(&self) -> builder::SearchPostWithIndex {
        builder::SearchPostWithIndex::new(self)
    }

    ///Creates point in time context.
    ///
    ///Sends a `POST` request to `/{index}/_search/point_in_time`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `allow_partial_pit_creation`: Allow if point in time can be created
    ///   with partial failures.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `keep_alive`: Specify the keep alive for point in time.
    /// - `preference`: Specify the node or shard the operation should be
    ///   performed on.
    /// - `routing`: Comma-separated list of specific routing values.
    ///```ignore
    /// let response = client.create_pit()
    ///    .index(index)
    ///    .allow_partial_pit_creation(allow_partial_pit_creation)
    ///    .expand_wildcards(expand_wildcards)
    ///    .keep_alive(keep_alive)
    ///    .preference(preference)
    ///    .routing(routing)
    ///    .send()
    ///    .await;
    /// ```
    pub fn create_pit(&self) -> builder::CreatePit {
        builder::CreatePit::new(self)
    }

    ///Allows to use the Mustache language to pre-render a search definition.
    ///
    ///Sends a `GET` request to `/{index}/_search/template`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `ccs_minimize_roundtrips`: Indicates whether network round-trips
    ///   should be minimized as part of cross-cluster search requests
    ///   execution.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `explain`: Specify whether to return detailed information about score
    ///   computation as part of a hit.
    /// - `ignore_throttled`: Whether specified concrete, expanded or aliased
    ///   indices should be ignored when throttled.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `preference`: Specify the node or shard the operation should be
    ///   performed on.
    /// - `profile`: Specify whether to profile the query execution.
    /// - `rest_total_hits_as_int`: Indicates whether hits.total should be
    ///   rendered as an integer or an object in the rest search response.
    /// - `routing`: Comma-separated list of specific routing values.
    /// - `scroll`: Specify how long a consistent view of the index should be
    ///   maintained for scrolled search.
    /// - `search_type`: Search operation type.
    /// - `typed_keys`: Specify whether aggregation and suggester names should
    ///   be prefixed by their respective types in the response.
    ///```ignore
    /// let response = client.search_template_get_with_index()
    ///    .index(index)
    ///    .allow_no_indices(allow_no_indices)
    ///    .ccs_minimize_roundtrips(ccs_minimize_roundtrips)
    ///    .expand_wildcards(expand_wildcards)
    ///    .explain(explain)
    ///    .ignore_throttled(ignore_throttled)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .preference(preference)
    ///    .profile(profile)
    ///    .rest_total_hits_as_int(rest_total_hits_as_int)
    ///    .routing(routing)
    ///    .scroll(scroll)
    ///    .search_type(search_type)
    ///    .typed_keys(typed_keys)
    ///    .send()
    ///    .await;
    /// ```
    pub fn search_template_get_with_index(&self) -> builder::SearchTemplateGetWithIndex {
        builder::SearchTemplateGetWithIndex::new(self)
    }

    ///Allows to use the Mustache language to pre-render a search definition.
    ///
    ///Sends a `POST` request to `/{index}/_search/template`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `ccs_minimize_roundtrips`: Indicates whether network round-trips
    ///   should be minimized as part of cross-cluster search requests
    ///   execution.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `explain`: Specify whether to return detailed information about score
    ///   computation as part of a hit.
    /// - `ignore_throttled`: Whether specified concrete, expanded or aliased
    ///   indices should be ignored when throttled.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `preference`: Specify the node or shard the operation should be
    ///   performed on.
    /// - `profile`: Specify whether to profile the query execution.
    /// - `rest_total_hits_as_int`: Indicates whether hits.total should be
    ///   rendered as an integer or an object in the rest search response.
    /// - `routing`: Comma-separated list of specific routing values.
    /// - `scroll`: Specify how long a consistent view of the index should be
    ///   maintained for scrolled search.
    /// - `search_type`: Search operation type.
    /// - `typed_keys`: Specify whether aggregation and suggester names should
    ///   be prefixed by their respective types in the response.
    /// - `body`
    ///```ignore
    /// let response = client.search_template_post_with_index()
    ///    .index(index)
    ///    .allow_no_indices(allow_no_indices)
    ///    .ccs_minimize_roundtrips(ccs_minimize_roundtrips)
    ///    .expand_wildcards(expand_wildcards)
    ///    .explain(explain)
    ///    .ignore_throttled(ignore_throttled)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .preference(preference)
    ///    .profile(profile)
    ///    .rest_total_hits_as_int(rest_total_hits_as_int)
    ///    .routing(routing)
    ///    .scroll(scroll)
    ///    .search_type(search_type)
    ///    .typed_keys(typed_keys)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn search_template_post_with_index(&self) -> builder::SearchTemplatePostWithIndex {
        builder::SearchTemplatePostWithIndex::new(self)
    }

    ///Returns information about the indices and shards that a search request
    /// would be executed against.
    ///
    ///Sends a `GET` request to `/{index}/_search_shards`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `preference`: Specify the node or shard the operation should be
    ///   performed on.
    /// - `routing`: Routing value.
    ///```ignore
    /// let response = client.search_shards_get_with_index()
    ///    .index(index)
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .local(local)
    ///    .preference(preference)
    ///    .routing(routing)
    ///    .send()
    ///    .await;
    /// ```
    pub fn search_shards_get_with_index(&self) -> builder::SearchShardsGetWithIndex {
        builder::SearchShardsGetWithIndex::new(self)
    }

    ///Returns information about the indices and shards that a search request
    /// would be executed against.
    ///
    ///Sends a `POST` request to `/{index}/_search_shards`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `preference`: Specify the node or shard the operation should be
    ///   performed on.
    /// - `routing`: Routing value.
    ///```ignore
    /// let response = client.search_shards_post_with_index()
    ///    .index(index)
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .local(local)
    ///    .preference(preference)
    ///    .routing(routing)
    ///    .send()
    ///    .await;
    /// ```
    pub fn search_shards_post_with_index(&self) -> builder::SearchShardsPostWithIndex {
        builder::SearchShardsPostWithIndex::new(self)
    }

    ///Provides low-level information about segments in a Lucene index.
    ///
    ///Sends a `GET` request to `/{index}/_segments`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `verbose`: Includes detailed memory usage by Lucene.
    ///```ignore
    /// let response = client.indices_segments_with_index()
    ///    .index(index)
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .verbose(verbose)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_segments_with_index(&self) -> builder::IndicesSegmentsWithIndex {
        builder::IndicesSegmentsWithIndex::new(self)
    }

    ///Returns settings for one or more indices.
    ///
    ///Sends a `GET` request to `/{index}/_settings`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `flat_settings`: Return settings in flat format.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `include_defaults`: Whether to return all default setting for each of
    ///   the indices.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    ///```ignore
    /// let response = client.indices_get_settings_with_index()
    ///    .index(index)
    ///    .allow_no_indices(allow_no_indices)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .expand_wildcards(expand_wildcards)
    ///    .flat_settings(flat_settings)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .include_defaults(include_defaults)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_get_settings_with_index(&self) -> builder::IndicesGetSettingsWithIndex {
        builder::IndicesGetSettingsWithIndex::new(self)
    }

    ///Updates the index settings.
    ///
    ///Sends a `PUT` request to `/{index}/_settings`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `flat_settings`: Return settings in flat format.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `preserve_existing`: Whether to update existing settings. If set to
    ///   `true` existing settings on an index remain unchanged.
    /// - `timeout`: Operation timeout.
    /// - `body`
    ///```ignore
    /// let response = client.indices_put_settings_with_index()
    ///    .index(index)
    ///    .allow_no_indices(allow_no_indices)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .expand_wildcards(expand_wildcards)
    ///    .flat_settings(flat_settings)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .master_timeout(master_timeout)
    ///    .preserve_existing(preserve_existing)
    ///    .timeout(timeout)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_put_settings_with_index(&self) -> builder::IndicesPutSettingsWithIndex {
        builder::IndicesPutSettingsWithIndex::new(self)
    }

    ///Returns settings for one or more indices.
    ///
    ///Sends a `GET` request to `/{index}/_settings/{name}`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `name`: Comma-separated list of settings.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `flat_settings`: Return settings in flat format.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `include_defaults`: Whether to return all default setting for each of
    ///   the indices.
    /// - `local`: Return local information, do not retrieve the state from
    ///   cluster-manager node.
    /// - `master_timeout`: Operation timeout for connection to master node.
    ///```ignore
    /// let response = client.indices_get_settings_with_index_name()
    ///    .index(index)
    ///    .name(name)
    ///    .allow_no_indices(allow_no_indices)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .expand_wildcards(expand_wildcards)
    ///    .flat_settings(flat_settings)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .include_defaults(include_defaults)
    ///    .local(local)
    ///    .master_timeout(master_timeout)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_get_settings_with_index_name(&self) -> builder::IndicesGetSettingsWithIndexName {
        builder::IndicesGetSettingsWithIndexName::new(self)
    }

    ///Provides store information for shard copies of indices.
    ///
    ///Sends a `GET` request to `/{index}/_shard_stores`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `status`: Comma-separated list of statuses used to filter on shards to
    ///   get store information for.
    ///```ignore
    /// let response = client.indices_shard_stores_with_index()
    ///    .index(index)
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .status(status)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_shard_stores_with_index(&self) -> builder::IndicesShardStoresWithIndex {
        builder::IndicesShardStoresWithIndex::new(self)
    }

    ///Allow to shrink an existing index into a new index with fewer primary
    /// shards.
    ///
    ///Sends a `PUT` request to `/{index}/_shrink/{target}`
    ///
    ///Arguments:
    /// - `index`: The name of the source index to shrink.
    /// - `target`: The name of the target index.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `copy_settings`: whether or not to copy settings from the source
    ///   index.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    /// - `wait_for_active_shards`: Set the number of active shards to wait for
    ///   on the shrunken index before the operation returns.
    /// - `body`
    ///```ignore
    /// let response = client.indices_shrink_put()
    ///    .index(index)
    ///    .target(target)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .copy_settings(copy_settings)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .wait_for_active_shards(wait_for_active_shards)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_shrink_put(&self) -> builder::IndicesShrinkPut {
        builder::IndicesShrinkPut::new(self)
    }

    ///Allow to shrink an existing index into a new index with fewer primary
    /// shards.
    ///
    ///Sends a `POST` request to `/{index}/_shrink/{target}`
    ///
    ///Arguments:
    /// - `index`: The name of the source index to shrink.
    /// - `target`: The name of the target index.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `copy_settings`: whether or not to copy settings from the source
    ///   index.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    /// - `wait_for_active_shards`: Set the number of active shards to wait for
    ///   on the shrunken index before the operation returns.
    /// - `body`
    ///```ignore
    /// let response = client.indices_shrink_post()
    ///    .index(index)
    ///    .target(target)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .copy_settings(copy_settings)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .wait_for_active_shards(wait_for_active_shards)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_shrink_post(&self) -> builder::IndicesShrinkPost {
        builder::IndicesShrinkPost::new(self)
    }

    ///Returns the source of a document.
    ///
    ///Sends a `GET` request to `/{index}/_source/{id}`
    ///
    ///Arguments:
    /// - `index`: Index name.
    /// - `id`: Document ID.
    /// - `source`: True or false to return the _source field or not, or a list
    ///   of fields to return.
    /// - `source_excludes`: List of fields to exclude from the returned _source
    ///   field.
    /// - `source_includes`: List of fields to extract and return from the
    ///   _source field.
    /// - `preference`: Specify the node or shard the operation should be
    ///   performed on.
    /// - `realtime`: Specify whether to perform the operation in realtime or
    ///   search mode.
    /// - `refresh`: Refresh the shard containing the document before performing
    ///   the operation.
    /// - `routing`: Routing value.
    /// - `version`: Explicit version number for concurrency control.
    /// - `version_type`: Specific version type.
    ///```ignore
    /// let response = client.get_source()
    ///    .index(index)
    ///    .id(id)
    ///    .source(source)
    ///    .source_excludes(source_excludes)
    ///    .source_includes(source_includes)
    ///    .preference(preference)
    ///    .realtime(realtime)
    ///    .refresh(refresh)
    ///    .routing(routing)
    ///    .version(version)
    ///    .version_type(version_type)
    ///    .send()
    ///    .await;
    /// ```
    pub fn get_source(&self) -> builder::GetSource {
        builder::GetSource::new(self)
    }

    ///Returns information about whether a document source exists in an index.
    ///
    ///Sends a `HEAD` request to `/{index}/_source/{id}`
    ///
    ///Arguments:
    /// - `index`: Index name.
    /// - `id`: Document ID.
    /// - `source`: True or false to return the _source field or not, or a list
    ///   of fields to return.
    /// - `source_excludes`: List of fields to exclude from the returned _source
    ///   field.
    /// - `source_includes`: List of fields to extract and return from the
    ///   _source field.
    /// - `preference`: Specify the node or shard the operation should be
    ///   performed on.
    /// - `realtime`: Specify whether to perform the operation in realtime or
    ///   search mode.
    /// - `refresh`: Refresh the shard containing the document before performing
    ///   the operation.
    /// - `routing`: Routing value.
    /// - `version`: Explicit version number for concurrency control.
    /// - `version_type`: Specific version type.
    ///```ignore
    /// let response = client.exists_source()
    ///    .index(index)
    ///    .id(id)
    ///    .source(source)
    ///    .source_excludes(source_excludes)
    ///    .source_includes(source_includes)
    ///    .preference(preference)
    ///    .realtime(realtime)
    ///    .refresh(refresh)
    ///    .routing(routing)
    ///    .version(version)
    ///    .version_type(version_type)
    ///    .send()
    ///    .await;
    /// ```
    pub fn exists_source(&self) -> builder::ExistsSource {
        builder::ExistsSource::new(self)
    }

    ///Allows you to split an existing index into a new index with more primary
    /// shards.
    ///
    ///Sends a `PUT` request to `/{index}/_split/{target}`
    ///
    ///Arguments:
    /// - `index`: The name of the source index to split.
    /// - `target`: The name of the target index.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `copy_settings`: whether or not to copy settings from the source
    ///   index.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    /// - `wait_for_active_shards`: Set the number of active shards to wait for
    ///   on the shrunken index before the operation returns.
    /// - `body`
    ///```ignore
    /// let response = client.indices_split_put()
    ///    .index(index)
    ///    .target(target)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .copy_settings(copy_settings)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .wait_for_active_shards(wait_for_active_shards)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_split_put(&self) -> builder::IndicesSplitPut {
        builder::IndicesSplitPut::new(self)
    }

    ///Allows you to split an existing index into a new index with more primary
    /// shards.
    ///
    ///Sends a `POST` request to `/{index}/_split/{target}`
    ///
    ///Arguments:
    /// - `index`: The name of the source index to split.
    /// - `target`: The name of the target index.
    /// - `cluster_manager_timeout`: Operation timeout for connection to
    ///   cluster-manager node.
    /// - `copy_settings`: whether or not to copy settings from the source
    ///   index.
    /// - `master_timeout`: Operation timeout for connection to master node.
    /// - `timeout`: Operation timeout.
    /// - `wait_for_active_shards`: Set the number of active shards to wait for
    ///   on the shrunken index before the operation returns.
    /// - `body`
    ///```ignore
    /// let response = client.indices_split_post()
    ///    .index(index)
    ///    .target(target)
    ///    .cluster_manager_timeout(cluster_manager_timeout)
    ///    .copy_settings(copy_settings)
    ///    .master_timeout(master_timeout)
    ///    .timeout(timeout)
    ///    .wait_for_active_shards(wait_for_active_shards)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_split_post(&self) -> builder::IndicesSplitPost {
        builder::IndicesSplitPost::new(self)
    }

    ///Provides statistics on operations happening in an index.
    ///
    ///Sends a `GET` request to `/{index}/_stats`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `completion_fields`: Comma-separated list of fields for `fielddata`
    ///   and `suggest` index metric (supports wildcards).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `fielddata_fields`: Comma-separated list of fields for `fielddata`
    ///   index metric (supports wildcards).
    /// - `fields`: Comma-separated list of fields for `fielddata` and
    ///   `completion` index metric (supports wildcards).
    /// - `forbid_closed_indices`: If set to false stats will also collected
    ///   from closed indices if explicitly specified or if expand_wildcards
    ///   expands to closed indices.
    /// - `groups`: Comma-separated list of search groups for `search` index
    ///   metric.
    /// - `include_segment_file_sizes`: Whether to report the aggregated disk
    ///   usage of each one of the Lucene index files (only applies if segment
    ///   stats are requested).
    /// - `include_unloaded_segments`: If set to true segment stats will include
    ///   stats for segments that are not currently loaded into memory.
    /// - `level`: Return stats aggregated at cluster, index or shard level.
    ///```ignore
    /// let response = client.indices_stats_with_index()
    ///    .index(index)
    ///    .completion_fields(completion_fields)
    ///    .expand_wildcards(expand_wildcards)
    ///    .fielddata_fields(fielddata_fields)
    ///    .fields(fields)
    ///    .forbid_closed_indices(forbid_closed_indices)
    ///    .groups(groups)
    ///    .include_segment_file_sizes(include_segment_file_sizes)
    ///    .include_unloaded_segments(include_unloaded_segments)
    ///    .level(level)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_stats_with_index(&self) -> builder::IndicesStatsWithIndex {
        builder::IndicesStatsWithIndex::new(self)
    }

    ///Provides statistics on operations happening in an index.
    ///
    ///Sends a `GET` request to `/{index}/_stats/{metric}`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `metric`: Limit the information returned the specific metrics.
    /// - `completion_fields`: Comma-separated list of fields for `fielddata`
    ///   and `suggest` index metric (supports wildcards).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `fielddata_fields`: Comma-separated list of fields for `fielddata`
    ///   index metric (supports wildcards).
    /// - `fields`: Comma-separated list of fields for `fielddata` and
    ///   `completion` index metric (supports wildcards).
    /// - `forbid_closed_indices`: If set to false stats will also collected
    ///   from closed indices if explicitly specified or if expand_wildcards
    ///   expands to closed indices.
    /// - `groups`: Comma-separated list of search groups for `search` index
    ///   metric.
    /// - `include_segment_file_sizes`: Whether to report the aggregated disk
    ///   usage of each one of the Lucene index files (only applies if segment
    ///   stats are requested).
    /// - `include_unloaded_segments`: If set to true segment stats will include
    ///   stats for segments that are not currently loaded into memory.
    /// - `level`: Return stats aggregated at cluster, index or shard level.
    ///```ignore
    /// let response = client.indices_stats_with_index_metric()
    ///    .index(index)
    ///    .metric(metric)
    ///    .completion_fields(completion_fields)
    ///    .expand_wildcards(expand_wildcards)
    ///    .fielddata_fields(fielddata_fields)
    ///    .fields(fields)
    ///    .forbid_closed_indices(forbid_closed_indices)
    ///    .groups(groups)
    ///    .include_segment_file_sizes(include_segment_file_sizes)
    ///    .include_unloaded_segments(include_unloaded_segments)
    ///    .level(level)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_stats_with_index_metric(&self) -> builder::IndicesStatsWithIndexMetric {
        builder::IndicesStatsWithIndexMetric::new(self)
    }

    ///Returns information and statistics about terms in the fields of a
    /// particular document.
    ///
    ///Sends a `GET` request to `/{index}/_termvectors`
    ///
    ///Arguments:
    /// - `index`: The index in which the document resides.
    /// - `field_statistics`: Specifies if document count, sum of document
    ///   frequencies and sum of total term frequencies should be returned.
    /// - `fields`: Comma-separated list of fields to return.
    /// - `offsets`: Specifies if term offsets should be returned.
    /// - `payloads`: Specifies if term payloads should be returned.
    /// - `positions`: Specifies if term positions should be returned.
    /// - `preference`: Specify the node or shard the operation should be
    ///   performed on.
    /// - `realtime`: Specifies if request is real-time as opposed to
    ///   near-real-time.
    /// - `routing`: Routing value.
    /// - `term_statistics`: Specifies if total term frequency and document
    ///   frequency should be returned.
    /// - `version`: Explicit version number for concurrency control.
    /// - `version_type`: Specific version type.
    ///```ignore
    /// let response = client.termvectors_get()
    ///    .index(index)
    ///    .field_statistics(field_statistics)
    ///    .fields(fields)
    ///    .offsets(offsets)
    ///    .payloads(payloads)
    ///    .positions(positions)
    ///    .preference(preference)
    ///    .realtime(realtime)
    ///    .routing(routing)
    ///    .term_statistics(term_statistics)
    ///    .version(version)
    ///    .version_type(version_type)
    ///    .send()
    ///    .await;
    /// ```
    pub fn termvectors_get(&self) -> builder::TermvectorsGet {
        builder::TermvectorsGet::new(self)
    }

    ///Returns information and statistics about terms in the fields of a
    /// particular document.
    ///
    ///Sends a `POST` request to `/{index}/_termvectors`
    ///
    ///Arguments:
    /// - `index`: The index in which the document resides.
    /// - `field_statistics`: Specifies if document count, sum of document
    ///   frequencies and sum of total term frequencies should be returned.
    /// - `fields`: Comma-separated list of fields to return.
    /// - `offsets`: Specifies if term offsets should be returned.
    /// - `payloads`: Specifies if term payloads should be returned.
    /// - `positions`: Specifies if term positions should be returned.
    /// - `preference`: Specify the node or shard the operation should be
    ///   performed on.
    /// - `realtime`: Specifies if request is real-time as opposed to
    ///   near-real-time.
    /// - `routing`: Routing value.
    /// - `term_statistics`: Specifies if total term frequency and document
    ///   frequency should be returned.
    /// - `version`: Explicit version number for concurrency control.
    /// - `version_type`: Specific version type.
    /// - `body`
    ///```ignore
    /// let response = client.termvectors_post()
    ///    .index(index)
    ///    .field_statistics(field_statistics)
    ///    .fields(fields)
    ///    .offsets(offsets)
    ///    .payloads(payloads)
    ///    .positions(positions)
    ///    .preference(preference)
    ///    .realtime(realtime)
    ///    .routing(routing)
    ///    .term_statistics(term_statistics)
    ///    .version(version)
    ///    .version_type(version_type)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn termvectors_post(&self) -> builder::TermvectorsPost {
        builder::TermvectorsPost::new(self)
    }

    ///Returns information and statistics about terms in the fields of a
    /// particular document.
    ///
    ///Sends a `GET` request to `/{index}/_termvectors/{id}`
    ///
    ///Arguments:
    /// - `index`: The index in which the document resides.
    /// - `id`: Document ID. When not specified a doc param should be supplied.
    /// - `field_statistics`: Specifies if document count, sum of document
    ///   frequencies and sum of total term frequencies should be returned.
    /// - `fields`: Comma-separated list of fields to return.
    /// - `offsets`: Specifies if term offsets should be returned.
    /// - `payloads`: Specifies if term payloads should be returned.
    /// - `positions`: Specifies if term positions should be returned.
    /// - `preference`: Specify the node or shard the operation should be
    ///   performed on.
    /// - `realtime`: Specifies if request is real-time as opposed to
    ///   near-real-time.
    /// - `routing`: Routing value.
    /// - `term_statistics`: Specifies if total term frequency and document
    ///   frequency should be returned.
    /// - `version`: Explicit version number for concurrency control.
    /// - `version_type`: Specific version type.
    ///```ignore
    /// let response = client.termvectors_get_with_id()
    ///    .index(index)
    ///    .id(id)
    ///    .field_statistics(field_statistics)
    ///    .fields(fields)
    ///    .offsets(offsets)
    ///    .payloads(payloads)
    ///    .positions(positions)
    ///    .preference(preference)
    ///    .realtime(realtime)
    ///    .routing(routing)
    ///    .term_statistics(term_statistics)
    ///    .version(version)
    ///    .version_type(version_type)
    ///    .send()
    ///    .await;
    /// ```
    pub fn termvectors_get_with_id(&self) -> builder::TermvectorsGetWithId {
        builder::TermvectorsGetWithId::new(self)
    }

    ///Returns information and statistics about terms in the fields of a
    /// particular document.
    ///
    ///Sends a `POST` request to `/{index}/_termvectors/{id}`
    ///
    ///Arguments:
    /// - `index`: The index in which the document resides.
    /// - `id`: Document ID. When not specified a doc param should be supplied.
    /// - `field_statistics`: Specifies if document count, sum of document
    ///   frequencies and sum of total term frequencies should be returned.
    /// - `fields`: Comma-separated list of fields to return.
    /// - `offsets`: Specifies if term offsets should be returned.
    /// - `payloads`: Specifies if term payloads should be returned.
    /// - `positions`: Specifies if term positions should be returned.
    /// - `preference`: Specify the node or shard the operation should be
    ///   performed on.
    /// - `realtime`: Specifies if request is real-time as opposed to
    ///   near-real-time.
    /// - `routing`: Routing value.
    /// - `term_statistics`: Specifies if total term frequency and document
    ///   frequency should be returned.
    /// - `version`: Explicit version number for concurrency control.
    /// - `version_type`: Specific version type.
    /// - `body`
    ///```ignore
    /// let response = client.termvectors_post_with_id()
    ///    .index(index)
    ///    .id(id)
    ///    .field_statistics(field_statistics)
    ///    .fields(fields)
    ///    .offsets(offsets)
    ///    .payloads(payloads)
    ///    .positions(positions)
    ///    .preference(preference)
    ///    .realtime(realtime)
    ///    .routing(routing)
    ///    .term_statistics(term_statistics)
    ///    .version(version)
    ///    .version_type(version_type)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn termvectors_post_with_id(&self) -> builder::TermvectorsPostWithId {
        builder::TermvectorsPostWithId::new(self)
    }

    ///Updates a document with a script or partial document.
    ///
    ///Sends a `POST` request to `/{index}/_update/{id}`
    ///
    ///Arguments:
    /// - `index`: Index name.
    /// - `id`: Document ID.
    /// - `source`: True or false to return the _source field or not, or a list
    ///   of fields to return.
    /// - `source_excludes`: List of fields to exclude from the returned _source
    ///   field.
    /// - `source_includes`: List of fields to extract and return from the
    ///   _source field.
    /// - `if_primary_term`: only perform the operation if the last operation
    ///   that has changed the document has the specified primary term.
    /// - `if_seq_no`: only perform the operation if the last operation that has
    ///   changed the document has the specified sequence number.
    /// - `lang`: The script language.
    /// - `refresh`: If `true` then refresh the affected shards to make this
    ///   operation visible to search, if `wait_for` then wait for a refresh to
    ///   make this operation visible to search, if `false` (the default) then
    ///   do nothing with refreshes.
    /// - `require_alias`: When true, requires destination to be an alias.
    /// - `retry_on_conflict`: Specify how many times should the operation be
    ///   retried when a conflict occurs.
    /// - `routing`: Routing value.
    /// - `timeout`: Operation timeout.
    /// - `wait_for_active_shards`: Sets the number of shard copies that must be
    ///   active before proceeding with the operation. Defaults to 1, meaning
    ///   the primary shard only. Set to `all` for all shard copies, otherwise
    ///   set to any non-negative value less than or equal to the total number
    ///   of copies for the shard (number of replicas + 1).
    /// - `body`
    ///```ignore
    /// let response = client.update()
    ///    .index(index)
    ///    .id(id)
    ///    .source(source)
    ///    .source_excludes(source_excludes)
    ///    .source_includes(source_includes)
    ///    .if_primary_term(if_primary_term)
    ///    .if_seq_no(if_seq_no)
    ///    .lang(lang)
    ///    .refresh(refresh)
    ///    .require_alias(require_alias)
    ///    .retry_on_conflict(retry_on_conflict)
    ///    .routing(routing)
    ///    .timeout(timeout)
    ///    .wait_for_active_shards(wait_for_active_shards)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn update(&self) -> builder::Update {
        builder::Update::new(self)
    }

    ///Performs an update on every document in the index without changing the
    /// source, for example to pick up a mapping change.
    ///
    ///Sends a `POST` request to `/{index}/_update_by_query`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `source`: True or false to return the _source field or not, or a list
    ///   of fields to return.
    /// - `source_excludes`: List of fields to exclude from the returned _source
    ///   field.
    /// - `source_includes`: List of fields to extract and return from the
    ///   _source field.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `analyze_wildcard`: Specify whether wildcard and prefix queries should
    ///   be analyzed.
    /// - `analyzer`: The analyzer to use for the query string.
    /// - `conflicts`: What to do when the operation encounters version
    ///   conflicts?.
    /// - `default_operator`: The default operator for query string query (AND
    ///   or OR).
    /// - `df`: The field to use as default where no field prefix is given in
    ///   the query string.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `from`: Starting offset.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `lenient`: Specify whether format-based query failures (such as
    ///   providing text to a numeric field) should be ignored.
    /// - `max_docs`: Maximum number of documents to process (default: all
    ///   documents).
    /// - `pipeline`: The pipeline id to preprocess incoming documents with.
    /// - `preference`: Specify the node or shard the operation should be
    ///   performed on.
    /// - `q`: Query in the Lucene query string syntax.
    /// - `refresh`: Should the affected indexes be refreshed?.
    /// - `request_cache`: Specify if request cache should be used for this
    ///   request or not, defaults to index level setting.
    /// - `requests_per_second`: The throttle for this request in sub-requests
    ///   per second. -1 means no throttle.
    /// - `routing`: Comma-separated list of specific routing values.
    /// - `scroll`: Specify how long a consistent view of the index should be
    ///   maintained for scrolled search.
    /// - `scroll_size`: Size on the scroll request powering the operation.
    /// - `search_timeout`: Explicit timeout for each search request. Defaults
    ///   to no timeout.
    /// - `search_type`: Search operation type.
    /// - `size`: Deprecated, please use `max_docs` instead.
    /// - `slices`: The number of slices this task should be divided into.
    ///   Defaults to 1, meaning the task isn't sliced into subtasks. Can be set
    ///   to `auto`.
    /// - `sort`: Comma-separated list of <field>:<direction> pairs.
    /// - `stats`: Specific 'tag' of the request for logging and statistical
    ///   purposes.
    /// - `terminate_after`: The maximum number of documents to collect for each
    ///   shard, upon reaching which the query execution will terminate early.
    /// - `timeout`: Time each individual bulk request should wait for shards
    ///   that are unavailable.
    /// - `version`: Whether to return document version as part of a hit.
    /// - `wait_for_active_shards`: Sets the number of shard copies that must be
    ///   active before proceeding with the operation. Defaults to 1, meaning
    ///   the primary shard only. Set to `all` for all shard copies, otherwise
    ///   set to any non-negative value less than or equal to the total number
    ///   of copies for the shard (number of replicas + 1).
    /// - `wait_for_completion`: Should this request wait until the operation
    ///   has completed before returning.
    /// - `body`
    ///```ignore
    /// let response = client.update_by_query()
    ///    .index(index)
    ///    .source(source)
    ///    .source_excludes(source_excludes)
    ///    .source_includes(source_includes)
    ///    .allow_no_indices(allow_no_indices)
    ///    .analyze_wildcard(analyze_wildcard)
    ///    .analyzer(analyzer)
    ///    .conflicts(conflicts)
    ///    .default_operator(default_operator)
    ///    .df(df)
    ///    .expand_wildcards(expand_wildcards)
    ///    .from(from)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .lenient(lenient)
    ///    .max_docs(max_docs)
    ///    .pipeline(pipeline)
    ///    .preference(preference)
    ///    .q(q)
    ///    .refresh(refresh)
    ///    .request_cache(request_cache)
    ///    .requests_per_second(requests_per_second)
    ///    .routing(routing)
    ///    .scroll(scroll)
    ///    .scroll_size(scroll_size)
    ///    .search_timeout(search_timeout)
    ///    .search_type(search_type)
    ///    .size(size)
    ///    .slices(slices)
    ///    .sort(sort)
    ///    .stats(stats)
    ///    .terminate_after(terminate_after)
    ///    .timeout(timeout)
    ///    .version(version)
    ///    .wait_for_active_shards(wait_for_active_shards)
    ///    .wait_for_completion(wait_for_completion)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn update_by_query(&self) -> builder::UpdateByQuery {
        builder::UpdateByQuery::new(self)
    }

    ///The _upgrade API is no longer useful and will be removed.
    ///
    ///Sends a `GET` request to `/{index}/_upgrade`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    ///```ignore
    /// let response = client.indices_get_upgrade_with_index()
    ///    .index(index)
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_get_upgrade_with_index(&self) -> builder::IndicesGetUpgradeWithIndex {
        builder::IndicesGetUpgradeWithIndex::new(self)
    }

    ///The _upgrade API is no longer useful and will be removed.
    ///
    ///Sends a `POST` request to `/{index}/_upgrade`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `only_ancient_segments`: If true, only ancient (an older Lucene major
    ///   release) segments will be upgraded.
    /// - `wait_for_completion`: Should this request wait until the operation
    ///   has completed before returning.
    ///```ignore
    /// let response = client.indices_upgrade_with_index()
    ///    .index(index)
    ///    .allow_no_indices(allow_no_indices)
    ///    .expand_wildcards(expand_wildcards)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .only_ancient_segments(only_ancient_segments)
    ///    .wait_for_completion(wait_for_completion)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_upgrade_with_index(&self) -> builder::IndicesUpgradeWithIndex {
        builder::IndicesUpgradeWithIndex::new(self)
    }

    ///Allows a user to validate a potentially expensive query without
    /// executing it.
    ///
    ///Sends a `GET` request to `/{index}/_validate/query`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `all_shards`: Execute validation on all shards instead of one random
    ///   shard per index.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `analyze_wildcard`: Specify whether wildcard and prefix queries should
    ///   be analyzed.
    /// - `analyzer`: The analyzer to use for the query string.
    /// - `default_operator`: The default operator for query string query (AND
    ///   or OR).
    /// - `df`: The field to use as default where no field prefix is given in
    ///   the query string.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `explain`: Return detailed information about the error.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `lenient`: Specify whether format-based query failures (such as
    ///   providing text to a numeric field) should be ignored.
    /// - `q`: Query in the Lucene query string syntax.
    /// - `rewrite`: Provide a more detailed explanation showing the actual
    ///   Lucene query that will be executed.
    ///```ignore
    /// let response = client.indices_validate_query_get_with_index()
    ///    .index(index)
    ///    .all_shards(all_shards)
    ///    .allow_no_indices(allow_no_indices)
    ///    .analyze_wildcard(analyze_wildcard)
    ///    .analyzer(analyzer)
    ///    .default_operator(default_operator)
    ///    .df(df)
    ///    .expand_wildcards(expand_wildcards)
    ///    .explain(explain)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .lenient(lenient)
    ///    .q(q)
    ///    .rewrite(rewrite)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_validate_query_get_with_index(
        &self,
    ) -> builder::IndicesValidateQueryGetWithIndex {
        builder::IndicesValidateQueryGetWithIndex::new(self)
    }

    ///Allows a user to validate a potentially expensive query without
    /// executing it.
    ///
    ///Sends a `POST` request to `/{index}/_validate/query`
    ///
    ///Arguments:
    /// - `index`: Comma-separated list of indices; use `_all` or empty string
    ///   to perform the operation on all indices.
    /// - `all_shards`: Execute validation on all shards instead of one random
    ///   shard per index.
    /// - `allow_no_indices`: Whether to ignore if a wildcard indices expression
    ///   resolves into no concrete indices. (This includes `_all` string or
    ///   when no indices have been specified).
    /// - `analyze_wildcard`: Specify whether wildcard and prefix queries should
    ///   be analyzed.
    /// - `analyzer`: The analyzer to use for the query string.
    /// - `default_operator`: The default operator for query string query (AND
    ///   or OR).
    /// - `df`: The field to use as default where no field prefix is given in
    ///   the query string.
    /// - `expand_wildcards`: Whether to expand wildcard expression to concrete
    ///   indices that are open, closed or both.
    /// - `explain`: Return detailed information about the error.
    /// - `ignore_unavailable`: Whether specified concrete indices should be
    ///   ignored when unavailable (missing or closed).
    /// - `lenient`: Specify whether format-based query failures (such as
    ///   providing text to a numeric field) should be ignored.
    /// - `q`: Query in the Lucene query string syntax.
    /// - `rewrite`: Provide a more detailed explanation showing the actual
    ///   Lucene query that will be executed.
    /// - `body`
    ///```ignore
    /// let response = client.indices_validate_query_post_with_index()
    ///    .index(index)
    ///    .all_shards(all_shards)
    ///    .allow_no_indices(allow_no_indices)
    ///    .analyze_wildcard(analyze_wildcard)
    ///    .analyzer(analyzer)
    ///    .default_operator(default_operator)
    ///    .df(df)
    ///    .expand_wildcards(expand_wildcards)
    ///    .explain(explain)
    ///    .ignore_unavailable(ignore_unavailable)
    ///    .lenient(lenient)
    ///    .q(q)
    ///    .rewrite(rewrite)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    pub fn indices_validate_query_post_with_index(
        &self,
    ) -> builder::IndicesValidateQueryPostWithIndex {
        builder::IndicesValidateQueryPostWithIndex::new(self)
    }
}

pub mod builder {
    use super::types;
    #[allow(unused_imports)]
    use super::{
        encode_path, ByteStream, Error, HeaderMap, HeaderValue, RequestBuilderExt, ResponseValue,
    };
    ///Builder for [`Client::info`]
    ///
    ///[`Client::info`]: super::Client::info
    #[derive(Debug, Clone)]
    pub struct Info<'a> {
        client: &'a super::Client,
    }

    impl<'a> Info<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        ///Sends a `GET` request to `/`
        pub async fn send(self) -> Result<ResponseValue<types::InfoResponseContent>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/", client.baseurl,);
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::ping`]
    ///
    ///[`Client::ping`]: super::Client::ping
    #[derive(Debug, Clone)]
    pub struct Ping<'a> {
        client: &'a super::Client,
    }

    impl<'a> Ping<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        ///Sends a `HEAD` request to `/`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/", client.baseurl,);
            let request = client.client.head(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_get_alias`]
    ///
    ///[`Client::indices_get_alias`]: super::Client::indices_get_alias
    #[derive(Debug, Clone)]
    pub struct IndicesGetAlias<'a> {
        client: &'a super::Client,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
    }

    impl<'a> IndicesGetAlias<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                ignore_unavailable: Ok(None),
                local: Ok(None),
            }
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_alias`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                allow_no_indices,
                expand_wildcards,
                ignore_unavailable,
                local,
            } = self;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_alias", client.baseurl,);
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_get_alias_with_name`]
    ///
    ///[`Client::indices_get_alias_with_name`]: super::Client::indices_get_alias_with_name
    #[derive(Debug, Clone)]
    pub struct IndicesGetAliasWithName<'a> {
        client: &'a super::Client,
        name: Result<types::IndicesGetAliasWithNameName, String>,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
    }

    impl<'a> IndicesGetAliasWithName<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                name: Err("name was not initialized".to_string()),
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                ignore_unavailable: Ok(None),
                local: Ok(None),
            }
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesGetAliasWithNameName>,
        {
            self.name = value.try_into().map_err(|_| {
                "conversion to `IndicesGetAliasWithNameName` for name failed".to_string()
            });
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_alias/{name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                name,
                allow_no_indices,
                expand_wildcards,
                ignore_unavailable,
                local,
            } = self;
            let name = name.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_alias/{}",
                client.baseurl,
                encode_path(&name.to_string()),
            );
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_exists_alias`]
    ///
    ///[`Client::indices_exists_alias`]: super::Client::indices_exists_alias
    #[derive(Debug, Clone)]
    pub struct IndicesExistsAlias<'a> {
        client: &'a super::Client,
        name: Result<types::IndicesExistsAliasName, String>,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
    }

    impl<'a> IndicesExistsAlias<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                name: Err("name was not initialized".to_string()),
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                ignore_unavailable: Ok(None),
                local: Ok(None),
            }
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesExistsAliasName>,
        {
            self.name = value
                .try_into()
                .map_err(|_| "conversion to `IndicesExistsAliasName` for name failed".to_string());
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        ///Sends a `HEAD` request to `/_alias/{name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                name,
                allow_no_indices,
                expand_wildcards,
                ignore_unavailable,
                local,
            } = self;
            let name = name.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_alias/{}",
                client.baseurl,
                encode_path(&name.to_string()),
            );
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            let request = client.client.head(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_update_aliases`]
    ///
    ///[`Client::indices_update_aliases`]: super::Client::indices_update_aliases
    #[derive(Debug, Clone)]
    pub struct IndicesUpdateAliases<'a> {
        client: &'a super::Client,
        cluster_manager_timeout:
            Result<Option<types::IndicesUpdateAliasesClusterManagerTimeout>, String>,
        master_timeout: Result<Option<types::IndicesUpdateAliasesMasterTimeout>, String>,
        timeout: Result<Option<types::IndicesUpdateAliasesTimeout>, String>,
        body: Result<types::builder::IndicesUpdateAliasesBodyParams, String>,
    }

    impl<'a> IndicesUpdateAliases<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                cluster_manager_timeout: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
                body: Ok(types::builder::IndicesUpdateAliasesBodyParams::default()),
            }
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesUpdateAliasesClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesUpdateAliasesClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesUpdateAliasesMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesUpdateAliasesMasterTimeout` for master_timeout failed"
                    .to_string()
            });
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesUpdateAliasesTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesUpdateAliasesTimeout` for timeout failed".to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesUpdateAliasesBodyParams>,
        {
            self.body = value.try_into().map(From::from).map_err(|_| {
                "conversion to `IndicesUpdateAliasesBodyParams` for body failed".to_string()
            });
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::IndicesUpdateAliasesBodyParams,
            ) -> types::builder::IndicesUpdateAliasesBodyParams,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to `/_aliases`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::IndicesUpdateAliasesResponseContent>, Error<()>> {
            let Self {
                client,
                cluster_manager_timeout,
                master_timeout,
                timeout,
                body,
            } = self;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(std::convert::TryInto::<types::IndicesUpdateAliasesBodyParams>::try_into)
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/_aliases", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_analyze_get`]
    ///
    ///[`Client::indices_analyze_get`]: super::Client::indices_analyze_get
    #[derive(Debug, Clone)]
    pub struct IndicesAnalyzeGet<'a> {
        client: &'a super::Client,
        index: Result<Option<String>, String>,
    }

    impl<'a> IndicesAnalyzeGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.index = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for index failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_analyze`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, index } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_analyze", client.baseurl,);
            let mut query = Vec::with_capacity(1usize);
            if let Some(v) = &index {
                query.push(("index", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_analyze_post`]
    ///
    ///[`Client::indices_analyze_post`]: super::Client::indices_analyze_post
    #[derive(Debug, Clone)]
    pub struct IndicesAnalyzePost<'a> {
        client: &'a super::Client,
        index: Result<Option<String>, String>,
        body: Result<types::IndicesAnalyzeBodyParams, String>,
    }

    impl<'a> IndicesAnalyzePost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.index = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for index failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesAnalyzeBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `IndicesAnalyzeBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `POST` request to `/_analyze`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                body,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_analyze", client.baseurl,);
            let mut query = Vec::with_capacity(1usize);
            if let Some(v) = &index {
                query.push(("index", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::bulk_put`]
    ///
    ///[`Client::bulk_put`]: super::Client::bulk_put
    #[derive(Debug, Clone)]
    pub struct BulkPut<'a> {
        client: &'a super::Client,
        source: Result<Option<Vec<String>>, String>,
        source_excludes: Result<Option<Vec<String>>, String>,
        source_includes: Result<Option<Vec<String>>, String>,
        pipeline: Result<Option<String>, String>,
        refresh: Result<Option<types::RefreshEnum>, String>,
        require_alias: Result<Option<bool>, String>,
        routing: Result<Option<String>, String>,
        timeout: Result<Option<types::BulkPutTimeout>, String>,
        type_: Result<Option<String>, String>,
        wait_for_active_shards: Result<Option<String>, String>,
        body: Result<types::BulkBodyParams, String>,
    }

    impl<'a> BulkPut<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                source: Ok(None),
                source_excludes: Ok(None),
                source_includes: Ok(None),
                pipeline: Ok(None),
                refresh: Ok(None),
                require_alias: Ok(None),
                routing: Ok(None),
                timeout: Ok(None),
                type_: Ok(None),
                wait_for_active_shards: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn source<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for source failed".to_string());
            self
        }

        pub fn source_excludes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_excludes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_excludes failed".to_string()
            });
            self
        }

        pub fn source_includes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_includes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_includes failed".to_string()
            });
            self
        }

        pub fn pipeline<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.pipeline = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for pipeline failed".to_string());
            self
        }

        pub fn refresh<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RefreshEnum>,
        {
            self.refresh = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `RefreshEnum` for refresh failed".to_string());
            self
        }

        pub fn require_alias<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.require_alias = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for require_alias failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for routing failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::BulkPutTimeout>,
        {
            self.timeout = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `BulkPutTimeout` for timeout failed".to_string());
            self
        }

        pub fn type_<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.type_ = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for type_ failed".to_string());
            self
        }

        pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.wait_for_active_shards = value.try_into().map(Some).map_err(|_| {
                "conversion to `String` for wait_for_active_shards failed".to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::BulkBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `BulkBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `PUT` request to `/_bulk`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                source,
                source_excludes,
                source_includes,
                pipeline,
                refresh,
                require_alias,
                routing,
                timeout,
                type_,
                wait_for_active_shards,
                body,
            } = self;
            let source = source.map_err(Error::InvalidRequest)?;
            let source_excludes = source_excludes.map_err(Error::InvalidRequest)?;
            let source_includes = source_includes.map_err(Error::InvalidRequest)?;
            let pipeline = pipeline.map_err(Error::InvalidRequest)?;
            let refresh = refresh.map_err(Error::InvalidRequest)?;
            let require_alias = require_alias.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let type_ = type_.map_err(Error::InvalidRequest)?;
            let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_bulk", client.baseurl,);
            let mut query = Vec::with_capacity(10usize);
            if let Some(v) = &source {
                query.push(("_source", v.to_string()));
            }
            if let Some(v) = &source_excludes {
                query.push(("_source_excludes", v.to_string()));
            }
            if let Some(v) = &source_includes {
                query.push(("_source_includes", v.to_string()));
            }
            if let Some(v) = &pipeline {
                query.push(("pipeline", v.to_string()));
            }
            if let Some(v) = &refresh {
                query.push(("refresh", v.to_string()));
            }
            if let Some(v) = &require_alias {
                query.push(("require_alias", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &type_ {
                query.push(("type", v.to_string()));
            }
            if let Some(v) = &wait_for_active_shards {
                query.push(("wait_for_active_shards", v.to_string()));
            }
            let request = client.client.put(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::bulk_post`]
    ///
    ///[`Client::bulk_post`]: super::Client::bulk_post
    #[derive(Debug, Clone)]
    pub struct BulkPost<'a> {
        client: &'a super::Client,
        source: Result<Option<Vec<String>>, String>,
        source_excludes: Result<Option<Vec<String>>, String>,
        source_includes: Result<Option<Vec<String>>, String>,
        pipeline: Result<Option<String>, String>,
        refresh: Result<Option<types::RefreshEnum>, String>,
        require_alias: Result<Option<bool>, String>,
        routing: Result<Option<String>, String>,
        timeout: Result<Option<types::BulkPostTimeout>, String>,
        type_: Result<Option<String>, String>,
        wait_for_active_shards: Result<Option<String>, String>,
        body: Result<types::BulkBodyParams, String>,
    }

    impl<'a> BulkPost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                source: Ok(None),
                source_excludes: Ok(None),
                source_includes: Ok(None),
                pipeline: Ok(None),
                refresh: Ok(None),
                require_alias: Ok(None),
                routing: Ok(None),
                timeout: Ok(None),
                type_: Ok(None),
                wait_for_active_shards: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn source<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for source failed".to_string());
            self
        }

        pub fn source_excludes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_excludes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_excludes failed".to_string()
            });
            self
        }

        pub fn source_includes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_includes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_includes failed".to_string()
            });
            self
        }

        pub fn pipeline<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.pipeline = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for pipeline failed".to_string());
            self
        }

        pub fn refresh<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RefreshEnum>,
        {
            self.refresh = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `RefreshEnum` for refresh failed".to_string());
            self
        }

        pub fn require_alias<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.require_alias = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for require_alias failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for routing failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::BulkPostTimeout>,
        {
            self.timeout = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `BulkPostTimeout` for timeout failed".to_string());
            self
        }

        pub fn type_<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.type_ = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for type_ failed".to_string());
            self
        }

        pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.wait_for_active_shards = value.try_into().map(Some).map_err(|_| {
                "conversion to `String` for wait_for_active_shards failed".to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::BulkBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `BulkBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `POST` request to `/_bulk`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                source,
                source_excludes,
                source_includes,
                pipeline,
                refresh,
                require_alias,
                routing,
                timeout,
                type_,
                wait_for_active_shards,
                body,
            } = self;
            let source = source.map_err(Error::InvalidRequest)?;
            let source_excludes = source_excludes.map_err(Error::InvalidRequest)?;
            let source_includes = source_includes.map_err(Error::InvalidRequest)?;
            let pipeline = pipeline.map_err(Error::InvalidRequest)?;
            let refresh = refresh.map_err(Error::InvalidRequest)?;
            let require_alias = require_alias.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let type_ = type_.map_err(Error::InvalidRequest)?;
            let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_bulk", client.baseurl,);
            let mut query = Vec::with_capacity(10usize);
            if let Some(v) = &source {
                query.push(("_source", v.to_string()));
            }
            if let Some(v) = &source_excludes {
                query.push(("_source_excludes", v.to_string()));
            }
            if let Some(v) = &source_includes {
                query.push(("_source_includes", v.to_string()));
            }
            if let Some(v) = &pipeline {
                query.push(("pipeline", v.to_string()));
            }
            if let Some(v) = &refresh {
                query.push(("refresh", v.to_string()));
            }
            if let Some(v) = &require_alias {
                query.push(("require_alias", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &type_ {
                query.push(("type", v.to_string()));
            }
            if let Some(v) = &wait_for_active_shards {
                query.push(("wait_for_active_shards", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_clear_cache`]
    ///
    ///[`Client::indices_clear_cache`]: super::Client::indices_clear_cache
    #[derive(Debug, Clone)]
    pub struct IndicesClearCache<'a> {
        client: &'a super::Client,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        fielddata: Result<Option<bool>, String>,
        fields: Result<Option<Vec<String>>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        index: Result<Option<Vec<String>>, String>,
        query: Result<Option<bool>, String>,
        request: Result<Option<bool>, String>,
    }

    impl<'a> IndicesClearCache<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                fielddata: Ok(None),
                fields: Ok(None),
                ignore_unavailable: Ok(None),
                index: Ok(None),
                query: Ok(None),
                request: Ok(None),
            }
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn fielddata<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.fielddata = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for fielddata failed".to_string());
            self
        }

        pub fn fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.fields = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.index = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for index failed".to_string());
            self
        }

        pub fn query<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.query = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for query failed".to_string());
            self
        }

        pub fn request<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.request = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for request failed".to_string());
            self
        }

        ///Sends a `POST` request to `/_cache/clear`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                allow_no_indices,
                expand_wildcards,
                fielddata,
                fields,
                ignore_unavailable,
                index,
                query,
                request,
            } = self;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let fielddata = fielddata.map_err(Error::InvalidRequest)?;
            let fields = fields.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let index = index.map_err(Error::InvalidRequest)?;
            let query = query.map_err(Error::InvalidRequest)?;
            let request = request.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_cache/clear", client.baseurl,);
            let mut query = Vec::with_capacity(8usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &fielddata {
                query.push(("fielddata", v.to_string()));
            }
            if let Some(v) = &fields {
                query.push(("fields", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &index {
                query.push(("index", v.to_string()));
            }
            if let Some(v) = &query {
                query.push(("query", v.to_string()));
            }
            if let Some(v) = &request {
                query.push(("request", v.to_string()));
            }
            let request = client.client.post(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cat_help`]
    ///
    ///[`Client::cat_help`]: super::Client::cat_help
    #[derive(Debug, Clone)]
    pub struct CatHelp<'a> {
        client: &'a super::Client,
        help: Result<Option<bool>, String>,
        s: Result<Option<Vec<String>>, String>,
    }

    impl<'a> CatHelp<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                help: Ok(None),
                s: Ok(None),
            }
        }

        pub fn help<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.help = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for help failed".to_string());
            self
        }

        pub fn s<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.s = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cat`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, help, s } = self;
            let help = help.map_err(Error::InvalidRequest)?;
            let s = s.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_cat", client.baseurl,);
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &help {
                query.push(("help", v.to_string()));
            }
            if let Some(v) = &s {
                query.push(("s", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cat_aliases`]
    ///
    ///[`Client::cat_aliases`]: super::Client::cat_aliases
    #[derive(Debug, Clone)]
    pub struct CatAliases<'a> {
        client: &'a super::Client,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        format: Result<Option<String>, String>,
        h: Result<Option<Vec<String>>, String>,
        help: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
        s: Result<Option<Vec<String>>, String>,
        v: Result<Option<bool>, String>,
    }

    impl<'a> CatAliases<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                expand_wildcards: Ok(None),
                format: Ok(None),
                h: Ok(None),
                help: Ok(None),
                local: Ok(None),
                s: Ok(None),
                v: Ok(None),
            }
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn format<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.format = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for format failed".to_string());
            self
        }

        pub fn h<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.h = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
            self
        }

        pub fn help<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.help = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for help failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn s<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.s = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
            self
        }

        pub fn v<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.v = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for v failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cat/aliases`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                expand_wildcards,
                format,
                h,
                help,
                local,
                s,
                v,
            } = self;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let format = format.map_err(Error::InvalidRequest)?;
            let h = h.map_err(Error::InvalidRequest)?;
            let help = help.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let s = s.map_err(Error::InvalidRequest)?;
            let v = v.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_cat/aliases", client.baseurl,);
            let mut query = Vec::with_capacity(7usize);
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &format {
                query.push(("format", v.to_string()));
            }
            if let Some(v) = &h {
                query.push(("h", v.to_string()));
            }
            if let Some(v) = &help {
                query.push(("help", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &s {
                query.push(("s", v.to_string()));
            }
            if let Some(v) = &v {
                query.push(("v", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cat_aliases_with_name`]
    ///
    ///[`Client::cat_aliases_with_name`]: super::Client::cat_aliases_with_name
    #[derive(Debug, Clone)]
    pub struct CatAliasesWithName<'a> {
        client: &'a super::Client,
        name: Result<types::CatAliasesWithNameName, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        format: Result<Option<String>, String>,
        h: Result<Option<Vec<String>>, String>,
        help: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
        s: Result<Option<Vec<String>>, String>,
        v: Result<Option<bool>, String>,
    }

    impl<'a> CatAliasesWithName<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                name: Err("name was not initialized".to_string()),
                expand_wildcards: Ok(None),
                format: Ok(None),
                h: Ok(None),
                help: Ok(None),
                local: Ok(None),
                s: Ok(None),
                v: Ok(None),
            }
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatAliasesWithNameName>,
        {
            self.name = value
                .try_into()
                .map_err(|_| "conversion to `CatAliasesWithNameName` for name failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn format<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.format = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for format failed".to_string());
            self
        }

        pub fn h<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.h = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
            self
        }

        pub fn help<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.help = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for help failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn s<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.s = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
            self
        }

        pub fn v<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.v = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for v failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cat/aliases/{name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                name,
                expand_wildcards,
                format,
                h,
                help,
                local,
                s,
                v,
            } = self;
            let name = name.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let format = format.map_err(Error::InvalidRequest)?;
            let h = h.map_err(Error::InvalidRequest)?;
            let help = help.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let s = s.map_err(Error::InvalidRequest)?;
            let v = v.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_cat/aliases/{}",
                client.baseurl,
                encode_path(&name.to_string()),
            );
            let mut query = Vec::with_capacity(7usize);
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &format {
                query.push(("format", v.to_string()));
            }
            if let Some(v) = &h {
                query.push(("h", v.to_string()));
            }
            if let Some(v) = &help {
                query.push(("help", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &s {
                query.push(("s", v.to_string()));
            }
            if let Some(v) = &v {
                query.push(("v", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cat_allocation`]
    ///
    ///[`Client::cat_allocation`]: super::Client::cat_allocation
    #[derive(Debug, Clone)]
    pub struct CatAllocation<'a> {
        client: &'a super::Client,
        bytes: Result<Option<types::Bytes>, String>,
        cluster_manager_timeout: Result<Option<types::CatAllocationClusterManagerTimeout>, String>,
        format: Result<Option<String>, String>,
        h: Result<Option<Vec<String>>, String>,
        help: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::CatAllocationMasterTimeout>, String>,
        s: Result<Option<Vec<String>>, String>,
        v: Result<Option<bool>, String>,
    }

    impl<'a> CatAllocation<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                bytes: Ok(None),
                cluster_manager_timeout: Ok(None),
                format: Ok(None),
                h: Ok(None),
                help: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
                s: Ok(None),
                v: Ok(None),
            }
        }

        pub fn bytes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Bytes>,
        {
            self.bytes = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Bytes` for bytes failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatAllocationClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `CatAllocationClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn format<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.format = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for format failed".to_string());
            self
        }

        pub fn h<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.h = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
            self
        }

        pub fn help<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.help = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for help failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatAllocationMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `CatAllocationMasterTimeout` for master_timeout failed".to_string()
            });
            self
        }

        pub fn s<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.s = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
            self
        }

        pub fn v<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.v = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for v failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cat/allocation`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                bytes,
                cluster_manager_timeout,
                format,
                h,
                help,
                local,
                master_timeout,
                s,
                v,
            } = self;
            let bytes = bytes.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let format = format.map_err(Error::InvalidRequest)?;
            let h = h.map_err(Error::InvalidRequest)?;
            let help = help.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let s = s.map_err(Error::InvalidRequest)?;
            let v = v.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_cat/allocation", client.baseurl,);
            let mut query = Vec::with_capacity(9usize);
            if let Some(v) = &bytes {
                query.push(("bytes", v.to_string()));
            }
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &format {
                query.push(("format", v.to_string()));
            }
            if let Some(v) = &h {
                query.push(("h", v.to_string()));
            }
            if let Some(v) = &help {
                query.push(("help", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &s {
                query.push(("s", v.to_string()));
            }
            if let Some(v) = &v {
                query.push(("v", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cat_allocation_with_node_id`]
    ///
    ///[`Client::cat_allocation_with_node_id`]: super::Client::cat_allocation_with_node_id
    #[derive(Debug, Clone)]
    pub struct CatAllocationWithNodeId<'a> {
        client: &'a super::Client,
        node_id: Result<types::CatAllocationWithNodeIdNodeId, String>,
        bytes: Result<Option<types::Bytes>, String>,
        cluster_manager_timeout:
            Result<Option<types::CatAllocationWithNodeIdClusterManagerTimeout>, String>,
        format: Result<Option<String>, String>,
        h: Result<Option<Vec<String>>, String>,
        help: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::CatAllocationWithNodeIdMasterTimeout>, String>,
        s: Result<Option<Vec<String>>, String>,
        v: Result<Option<bool>, String>,
    }

    impl<'a> CatAllocationWithNodeId<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                node_id: Err("node_id was not initialized".to_string()),
                bytes: Ok(None),
                cluster_manager_timeout: Ok(None),
                format: Ok(None),
                h: Ok(None),
                help: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
                s: Ok(None),
                v: Ok(None),
            }
        }

        pub fn node_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatAllocationWithNodeIdNodeId>,
        {
            self.node_id = value.try_into().map_err(|_| {
                "conversion to `CatAllocationWithNodeIdNodeId` for node_id failed".to_string()
            });
            self
        }

        pub fn bytes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Bytes>,
        {
            self.bytes = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Bytes` for bytes failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatAllocationWithNodeIdClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `CatAllocationWithNodeIdClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn format<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.format = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for format failed".to_string());
            self
        }

        pub fn h<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.h = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
            self
        }

        pub fn help<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.help = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for help failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatAllocationWithNodeIdMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `CatAllocationWithNodeIdMasterTimeout` for master_timeout failed"
                    .to_string()
            });
            self
        }

        pub fn s<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.s = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
            self
        }

        pub fn v<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.v = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for v failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cat/allocation/{node_id}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                node_id,
                bytes,
                cluster_manager_timeout,
                format,
                h,
                help,
                local,
                master_timeout,
                s,
                v,
            } = self;
            let node_id = node_id.map_err(Error::InvalidRequest)?;
            let bytes = bytes.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let format = format.map_err(Error::InvalidRequest)?;
            let h = h.map_err(Error::InvalidRequest)?;
            let help = help.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let s = s.map_err(Error::InvalidRequest)?;
            let v = v.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_cat/allocation/{}",
                client.baseurl,
                encode_path(&node_id.to_string()),
            );
            let mut query = Vec::with_capacity(9usize);
            if let Some(v) = &bytes {
                query.push(("bytes", v.to_string()));
            }
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &format {
                query.push(("format", v.to_string()));
            }
            if let Some(v) = &h {
                query.push(("h", v.to_string()));
            }
            if let Some(v) = &help {
                query.push(("help", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &s {
                query.push(("s", v.to_string()));
            }
            if let Some(v) = &v {
                query.push(("v", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cat_cluster_manager`]
    ///
    ///[`Client::cat_cluster_manager`]: super::Client::cat_cluster_manager
    #[derive(Debug, Clone)]
    pub struct CatClusterManager<'a> {
        client: &'a super::Client,
        cluster_manager_timeout:
            Result<Option<types::CatClusterManagerClusterManagerTimeout>, String>,
        format: Result<Option<String>, String>,
        h: Result<Option<Vec<String>>, String>,
        help: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::CatClusterManagerMasterTimeout>, String>,
        s: Result<Option<Vec<String>>, String>,
        v: Result<Option<bool>, String>,
    }

    impl<'a> CatClusterManager<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                cluster_manager_timeout: Ok(None),
                format: Ok(None),
                h: Ok(None),
                help: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
                s: Ok(None),
                v: Ok(None),
            }
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatClusterManagerClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `CatClusterManagerClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn format<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.format = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for format failed".to_string());
            self
        }

        pub fn h<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.h = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
            self
        }

        pub fn help<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.help = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for help failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatClusterManagerMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `CatClusterManagerMasterTimeout` for master_timeout failed"
                    .to_string()
            });
            self
        }

        pub fn s<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.s = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
            self
        }

        pub fn v<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.v = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for v failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cat/cluster_manager`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                cluster_manager_timeout,
                format,
                h,
                help,
                local,
                master_timeout,
                s,
                v,
            } = self;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let format = format.map_err(Error::InvalidRequest)?;
            let h = h.map_err(Error::InvalidRequest)?;
            let help = help.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let s = s.map_err(Error::InvalidRequest)?;
            let v = v.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_cat/cluster_manager", client.baseurl,);
            let mut query = Vec::with_capacity(8usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &format {
                query.push(("format", v.to_string()));
            }
            if let Some(v) = &h {
                query.push(("h", v.to_string()));
            }
            if let Some(v) = &help {
                query.push(("help", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &s {
                query.push(("s", v.to_string()));
            }
            if let Some(v) = &v {
                query.push(("v", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cat_count`]
    ///
    ///[`Client::cat_count`]: super::Client::cat_count
    #[derive(Debug, Clone)]
    pub struct CatCount<'a> {
        client: &'a super::Client,
        format: Result<Option<String>, String>,
        h: Result<Option<Vec<String>>, String>,
        help: Result<Option<bool>, String>,
        s: Result<Option<Vec<String>>, String>,
        v: Result<Option<bool>, String>,
    }

    impl<'a> CatCount<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                format: Ok(None),
                h: Ok(None),
                help: Ok(None),
                s: Ok(None),
                v: Ok(None),
            }
        }

        pub fn format<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.format = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for format failed".to_string());
            self
        }

        pub fn h<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.h = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
            self
        }

        pub fn help<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.help = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for help failed".to_string());
            self
        }

        pub fn s<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.s = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
            self
        }

        pub fn v<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.v = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for v failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cat/count`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                format,
                h,
                help,
                s,
                v,
            } = self;
            let format = format.map_err(Error::InvalidRequest)?;
            let h = h.map_err(Error::InvalidRequest)?;
            let help = help.map_err(Error::InvalidRequest)?;
            let s = s.map_err(Error::InvalidRequest)?;
            let v = v.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_cat/count", client.baseurl,);
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &format {
                query.push(("format", v.to_string()));
            }
            if let Some(v) = &h {
                query.push(("h", v.to_string()));
            }
            if let Some(v) = &help {
                query.push(("help", v.to_string()));
            }
            if let Some(v) = &s {
                query.push(("s", v.to_string()));
            }
            if let Some(v) = &v {
                query.push(("v", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cat_count_with_index`]
    ///
    ///[`Client::cat_count_with_index`]: super::Client::cat_count_with_index
    #[derive(Debug, Clone)]
    pub struct CatCountWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::CatCountWithIndexIndex, String>,
        format: Result<Option<String>, String>,
        h: Result<Option<Vec<String>>, String>,
        help: Result<Option<bool>, String>,
        s: Result<Option<Vec<String>>, String>,
        v: Result<Option<bool>, String>,
    }

    impl<'a> CatCountWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                format: Ok(None),
                h: Ok(None),
                help: Ok(None),
                s: Ok(None),
                v: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatCountWithIndexIndex>,
        {
            self.index = value
                .try_into()
                .map_err(|_| "conversion to `CatCountWithIndexIndex` for index failed".to_string());
            self
        }

        pub fn format<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.format = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for format failed".to_string());
            self
        }

        pub fn h<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.h = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
            self
        }

        pub fn help<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.help = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for help failed".to_string());
            self
        }

        pub fn s<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.s = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
            self
        }

        pub fn v<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.v = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for v failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cat/count/{index}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                format,
                h,
                help,
                s,
                v,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let format = format.map_err(Error::InvalidRequest)?;
            let h = h.map_err(Error::InvalidRequest)?;
            let help = help.map_err(Error::InvalidRequest)?;
            let s = s.map_err(Error::InvalidRequest)?;
            let v = v.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_cat/count/{}",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &format {
                query.push(("format", v.to_string()));
            }
            if let Some(v) = &h {
                query.push(("h", v.to_string()));
            }
            if let Some(v) = &help {
                query.push(("help", v.to_string()));
            }
            if let Some(v) = &s {
                query.push(("s", v.to_string()));
            }
            if let Some(v) = &v {
                query.push(("v", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cat_fielddata`]
    ///
    ///[`Client::cat_fielddata`]: super::Client::cat_fielddata
    #[derive(Debug, Clone)]
    pub struct CatFielddata<'a> {
        client: &'a super::Client,
        bytes: Result<Option<types::Bytes>, String>,
        fields: Result<Option<Vec<String>>, String>,
        format: Result<Option<String>, String>,
        h: Result<Option<Vec<String>>, String>,
        help: Result<Option<bool>, String>,
        s: Result<Option<Vec<String>>, String>,
        v: Result<Option<bool>, String>,
    }

    impl<'a> CatFielddata<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                bytes: Ok(None),
                fields: Ok(None),
                format: Ok(None),
                h: Ok(None),
                help: Ok(None),
                s: Ok(None),
                v: Ok(None),
            }
        }

        pub fn bytes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Bytes>,
        {
            self.bytes = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Bytes` for bytes failed".to_string());
            self
        }

        pub fn fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.fields = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
            self
        }

        pub fn format<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.format = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for format failed".to_string());
            self
        }

        pub fn h<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.h = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
            self
        }

        pub fn help<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.help = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for help failed".to_string());
            self
        }

        pub fn s<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.s = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
            self
        }

        pub fn v<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.v = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for v failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cat/fielddata`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                bytes,
                fields,
                format,
                h,
                help,
                s,
                v,
            } = self;
            let bytes = bytes.map_err(Error::InvalidRequest)?;
            let fields = fields.map_err(Error::InvalidRequest)?;
            let format = format.map_err(Error::InvalidRequest)?;
            let h = h.map_err(Error::InvalidRequest)?;
            let help = help.map_err(Error::InvalidRequest)?;
            let s = s.map_err(Error::InvalidRequest)?;
            let v = v.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_cat/fielddata", client.baseurl,);
            let mut query = Vec::with_capacity(7usize);
            if let Some(v) = &bytes {
                query.push(("bytes", v.to_string()));
            }
            if let Some(v) = &fields {
                query.push(("fields", v.to_string()));
            }
            if let Some(v) = &format {
                query.push(("format", v.to_string()));
            }
            if let Some(v) = &h {
                query.push(("h", v.to_string()));
            }
            if let Some(v) = &help {
                query.push(("help", v.to_string()));
            }
            if let Some(v) = &s {
                query.push(("s", v.to_string()));
            }
            if let Some(v) = &v {
                query.push(("v", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cat_fielddata_with_fields`]
    ///
    ///[`Client::cat_fielddata_with_fields`]: super::Client::cat_fielddata_with_fields
    #[derive(Debug, Clone)]
    pub struct CatFielddataWithFields<'a> {
        client: &'a super::Client,
        bytes: Result<Option<types::Bytes>, String>,
        fields: Result<Option<Vec<String>>, String>,
        format: Result<Option<String>, String>,
        h: Result<Option<Vec<String>>, String>,
        help: Result<Option<bool>, String>,
        s: Result<Option<Vec<String>>, String>,
        v: Result<Option<bool>, String>,
    }

    impl<'a> CatFielddataWithFields<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                bytes: Ok(None),
                fields: Ok(None),
                format: Ok(None),
                h: Ok(None),
                help: Ok(None),
                s: Ok(None),
                v: Ok(None),
            }
        }

        pub fn bytes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Bytes>,
        {
            self.bytes = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Bytes` for bytes failed".to_string());
            self
        }

        pub fn fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.fields = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
            self
        }

        pub fn format<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.format = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for format failed".to_string());
            self
        }

        pub fn h<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.h = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
            self
        }

        pub fn help<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.help = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for help failed".to_string());
            self
        }

        pub fn s<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.s = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
            self
        }

        pub fn v<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.v = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for v failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cat/fielddata/{fields}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                bytes,
                fields,
                format,
                h,
                help,
                s,
                v,
            } = self;
            let bytes = bytes.map_err(Error::InvalidRequest)?;
            let fields = fields.map_err(Error::InvalidRequest)?;
            let format = format.map_err(Error::InvalidRequest)?;
            let h = h.map_err(Error::InvalidRequest)?;
            let help = help.map_err(Error::InvalidRequest)?;
            let s = s.map_err(Error::InvalidRequest)?;
            let v = v.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_cat/fielddata/{}",
                client.baseurl,
                encode_path(&fields.to_string()),
            );
            let mut query = Vec::with_capacity(7usize);
            if let Some(v) = &bytes {
                query.push(("bytes", v.to_string()));
            }
            if let Some(v) = &fields {
                query.push(("fields", v.to_string()));
            }
            if let Some(v) = &format {
                query.push(("format", v.to_string()));
            }
            if let Some(v) = &h {
                query.push(("h", v.to_string()));
            }
            if let Some(v) = &help {
                query.push(("help", v.to_string()));
            }
            if let Some(v) = &s {
                query.push(("s", v.to_string()));
            }
            if let Some(v) = &v {
                query.push(("v", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cat_health`]
    ///
    ///[`Client::cat_health`]: super::Client::cat_health
    #[derive(Debug, Clone)]
    pub struct CatHealth<'a> {
        client: &'a super::Client,
        format: Result<Option<String>, String>,
        h: Result<Option<Vec<String>>, String>,
        help: Result<Option<bool>, String>,
        s: Result<Option<Vec<String>>, String>,
        time: Result<Option<types::Time>, String>,
        ts: Result<Option<bool>, String>,
        v: Result<Option<bool>, String>,
    }

    impl<'a> CatHealth<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                format: Ok(None),
                h: Ok(None),
                help: Ok(None),
                s: Ok(None),
                time: Ok(None),
                ts: Ok(None),
                v: Ok(None),
            }
        }

        pub fn format<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.format = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for format failed".to_string());
            self
        }

        pub fn h<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.h = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
            self
        }

        pub fn help<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.help = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for help failed".to_string());
            self
        }

        pub fn s<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.s = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
            self
        }

        pub fn time<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Time>,
        {
            self.time = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Time` for time failed".to_string());
            self
        }

        pub fn ts<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ts = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ts failed".to_string());
            self
        }

        pub fn v<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.v = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for v failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cat/health`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                format,
                h,
                help,
                s,
                time,
                ts,
                v,
            } = self;
            let format = format.map_err(Error::InvalidRequest)?;
            let h = h.map_err(Error::InvalidRequest)?;
            let help = help.map_err(Error::InvalidRequest)?;
            let s = s.map_err(Error::InvalidRequest)?;
            let time = time.map_err(Error::InvalidRequest)?;
            let ts = ts.map_err(Error::InvalidRequest)?;
            let v = v.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_cat/health", client.baseurl,);
            let mut query = Vec::with_capacity(7usize);
            if let Some(v) = &format {
                query.push(("format", v.to_string()));
            }
            if let Some(v) = &h {
                query.push(("h", v.to_string()));
            }
            if let Some(v) = &help {
                query.push(("help", v.to_string()));
            }
            if let Some(v) = &s {
                query.push(("s", v.to_string()));
            }
            if let Some(v) = &time {
                query.push(("time", v.to_string()));
            }
            if let Some(v) = &ts {
                query.push(("ts", v.to_string()));
            }
            if let Some(v) = &v {
                query.push(("v", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cat_indices`]
    ///
    ///[`Client::cat_indices`]: super::Client::cat_indices
    #[derive(Debug, Clone)]
    pub struct CatIndices<'a> {
        client: &'a super::Client,
        bytes: Result<Option<types::Bytes>, String>,
        cluster_manager_timeout: Result<Option<types::CatIndicesClusterManagerTimeout>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        format: Result<Option<String>, String>,
        h: Result<Option<Vec<String>>, String>,
        health: Result<Option<types::Health>, String>,
        help: Result<Option<bool>, String>,
        include_unloaded_segments: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::CatIndicesMasterTimeout>, String>,
        pri: Result<Option<bool>, String>,
        s: Result<Option<Vec<String>>, String>,
        time: Result<Option<types::Time>, String>,
        v: Result<Option<bool>, String>,
    }

    impl<'a> CatIndices<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                bytes: Ok(None),
                cluster_manager_timeout: Ok(None),
                expand_wildcards: Ok(None),
                format: Ok(None),
                h: Ok(None),
                health: Ok(None),
                help: Ok(None),
                include_unloaded_segments: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
                pri: Ok(None),
                s: Ok(None),
                time: Ok(None),
                v: Ok(None),
            }
        }

        pub fn bytes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Bytes>,
        {
            self.bytes = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Bytes` for bytes failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatIndicesClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `CatIndicesClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn format<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.format = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for format failed".to_string());
            self
        }

        pub fn h<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.h = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
            self
        }

        pub fn health<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Health>,
        {
            self.health = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Health` for health failed".to_string());
            self
        }

        pub fn help<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.help = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for help failed".to_string());
            self
        }

        pub fn include_unloaded_segments<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.include_unloaded_segments = value.try_into().map(Some).map_err(|_| {
                "conversion to `bool` for include_unloaded_segments failed".to_string()
            });
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatIndicesMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `CatIndicesMasterTimeout` for master_timeout failed".to_string()
            });
            self
        }

        pub fn pri<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.pri = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for pri failed".to_string());
            self
        }

        pub fn s<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.s = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
            self
        }

        pub fn time<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Time>,
        {
            self.time = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Time` for time failed".to_string());
            self
        }

        pub fn v<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.v = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for v failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cat/indices`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                bytes,
                cluster_manager_timeout,
                expand_wildcards,
                format,
                h,
                health,
                help,
                include_unloaded_segments,
                local,
                master_timeout,
                pri,
                s,
                time,
                v,
            } = self;
            let bytes = bytes.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let format = format.map_err(Error::InvalidRequest)?;
            let h = h.map_err(Error::InvalidRequest)?;
            let health = health.map_err(Error::InvalidRequest)?;
            let help = help.map_err(Error::InvalidRequest)?;
            let include_unloaded_segments =
                include_unloaded_segments.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let pri = pri.map_err(Error::InvalidRequest)?;
            let s = s.map_err(Error::InvalidRequest)?;
            let time = time.map_err(Error::InvalidRequest)?;
            let v = v.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_cat/indices", client.baseurl,);
            let mut query = Vec::with_capacity(14usize);
            if let Some(v) = &bytes {
                query.push(("bytes", v.to_string()));
            }
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &format {
                query.push(("format", v.to_string()));
            }
            if let Some(v) = &h {
                query.push(("h", v.to_string()));
            }
            if let Some(v) = &health {
                query.push(("health", v.to_string()));
            }
            if let Some(v) = &help {
                query.push(("help", v.to_string()));
            }
            if let Some(v) = &include_unloaded_segments {
                query.push(("include_unloaded_segments", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &pri {
                query.push(("pri", v.to_string()));
            }
            if let Some(v) = &s {
                query.push(("s", v.to_string()));
            }
            if let Some(v) = &time {
                query.push(("time", v.to_string()));
            }
            if let Some(v) = &v {
                query.push(("v", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cat_indices_with_index`]
    ///
    ///[`Client::cat_indices_with_index`]: super::Client::cat_indices_with_index
    #[derive(Debug, Clone)]
    pub struct CatIndicesWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::CatIndicesWithIndexIndex, String>,
        bytes: Result<Option<types::Bytes>, String>,
        cluster_manager_timeout:
            Result<Option<types::CatIndicesWithIndexClusterManagerTimeout>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        format: Result<Option<String>, String>,
        h: Result<Option<Vec<String>>, String>,
        health: Result<Option<types::Health>, String>,
        help: Result<Option<bool>, String>,
        include_unloaded_segments: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::CatIndicesWithIndexMasterTimeout>, String>,
        pri: Result<Option<bool>, String>,
        s: Result<Option<Vec<String>>, String>,
        time: Result<Option<types::Time>, String>,
        v: Result<Option<bool>, String>,
    }

    impl<'a> CatIndicesWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                bytes: Ok(None),
                cluster_manager_timeout: Ok(None),
                expand_wildcards: Ok(None),
                format: Ok(None),
                h: Ok(None),
                health: Ok(None),
                help: Ok(None),
                include_unloaded_segments: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
                pri: Ok(None),
                s: Ok(None),
                time: Ok(None),
                v: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatIndicesWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `CatIndicesWithIndexIndex` for index failed".to_string()
            });
            self
        }

        pub fn bytes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Bytes>,
        {
            self.bytes = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Bytes` for bytes failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatIndicesWithIndexClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `CatIndicesWithIndexClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn format<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.format = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for format failed".to_string());
            self
        }

        pub fn h<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.h = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
            self
        }

        pub fn health<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Health>,
        {
            self.health = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Health` for health failed".to_string());
            self
        }

        pub fn help<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.help = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for help failed".to_string());
            self
        }

        pub fn include_unloaded_segments<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.include_unloaded_segments = value.try_into().map(Some).map_err(|_| {
                "conversion to `bool` for include_unloaded_segments failed".to_string()
            });
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatIndicesWithIndexMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `CatIndicesWithIndexMasterTimeout` for master_timeout failed"
                    .to_string()
            });
            self
        }

        pub fn pri<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.pri = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for pri failed".to_string());
            self
        }

        pub fn s<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.s = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
            self
        }

        pub fn time<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Time>,
        {
            self.time = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Time` for time failed".to_string());
            self
        }

        pub fn v<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.v = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for v failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cat/indices/{index}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                bytes,
                cluster_manager_timeout,
                expand_wildcards,
                format,
                h,
                health,
                help,
                include_unloaded_segments,
                local,
                master_timeout,
                pri,
                s,
                time,
                v,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let bytes = bytes.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let format = format.map_err(Error::InvalidRequest)?;
            let h = h.map_err(Error::InvalidRequest)?;
            let health = health.map_err(Error::InvalidRequest)?;
            let help = help.map_err(Error::InvalidRequest)?;
            let include_unloaded_segments =
                include_unloaded_segments.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let pri = pri.map_err(Error::InvalidRequest)?;
            let s = s.map_err(Error::InvalidRequest)?;
            let time = time.map_err(Error::InvalidRequest)?;
            let v = v.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_cat/indices/{}",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(14usize);
            if let Some(v) = &bytes {
                query.push(("bytes", v.to_string()));
            }
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &format {
                query.push(("format", v.to_string()));
            }
            if let Some(v) = &h {
                query.push(("h", v.to_string()));
            }
            if let Some(v) = &health {
                query.push(("health", v.to_string()));
            }
            if let Some(v) = &help {
                query.push(("help", v.to_string()));
            }
            if let Some(v) = &include_unloaded_segments {
                query.push(("include_unloaded_segments", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &pri {
                query.push(("pri", v.to_string()));
            }
            if let Some(v) = &s {
                query.push(("s", v.to_string()));
            }
            if let Some(v) = &time {
                query.push(("time", v.to_string()));
            }
            if let Some(v) = &v {
                query.push(("v", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cat_master`]
    ///
    ///[`Client::cat_master`]: super::Client::cat_master
    #[derive(Debug, Clone)]
    pub struct CatMaster<'a> {
        client: &'a super::Client,
        cluster_manager_timeout: Result<Option<types::CatMasterClusterManagerTimeout>, String>,
        format: Result<Option<String>, String>,
        h: Result<Option<Vec<String>>, String>,
        help: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::CatMasterMasterTimeout>, String>,
        s: Result<Option<Vec<String>>, String>,
        v: Result<Option<bool>, String>,
    }

    impl<'a> CatMaster<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                cluster_manager_timeout: Ok(None),
                format: Ok(None),
                h: Ok(None),
                help: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
                s: Ok(None),
                v: Ok(None),
            }
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatMasterClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `CatMasterClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn format<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.format = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for format failed".to_string());
            self
        }

        pub fn h<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.h = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
            self
        }

        pub fn help<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.help = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for help failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatMasterMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `CatMasterMasterTimeout` for master_timeout failed".to_string()
            });
            self
        }

        pub fn s<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.s = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
            self
        }

        pub fn v<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.v = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for v failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cat/master`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                cluster_manager_timeout,
                format,
                h,
                help,
                local,
                master_timeout,
                s,
                v,
            } = self;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let format = format.map_err(Error::InvalidRequest)?;
            let h = h.map_err(Error::InvalidRequest)?;
            let help = help.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let s = s.map_err(Error::InvalidRequest)?;
            let v = v.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_cat/master", client.baseurl,);
            let mut query = Vec::with_capacity(8usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &format {
                query.push(("format", v.to_string()));
            }
            if let Some(v) = &h {
                query.push(("h", v.to_string()));
            }
            if let Some(v) = &help {
                query.push(("help", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &s {
                query.push(("s", v.to_string()));
            }
            if let Some(v) = &v {
                query.push(("v", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cat_nodeattrs`]
    ///
    ///[`Client::cat_nodeattrs`]: super::Client::cat_nodeattrs
    #[derive(Debug, Clone)]
    pub struct CatNodeattrs<'a> {
        client: &'a super::Client,
        cluster_manager_timeout: Result<Option<types::CatNodeattrsClusterManagerTimeout>, String>,
        format: Result<Option<String>, String>,
        h: Result<Option<Vec<String>>, String>,
        help: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::CatNodeattrsMasterTimeout>, String>,
        s: Result<Option<Vec<String>>, String>,
        v: Result<Option<bool>, String>,
    }

    impl<'a> CatNodeattrs<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                cluster_manager_timeout: Ok(None),
                format: Ok(None),
                h: Ok(None),
                help: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
                s: Ok(None),
                v: Ok(None),
            }
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatNodeattrsClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `CatNodeattrsClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn format<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.format = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for format failed".to_string());
            self
        }

        pub fn h<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.h = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
            self
        }

        pub fn help<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.help = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for help failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatNodeattrsMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `CatNodeattrsMasterTimeout` for master_timeout failed".to_string()
            });
            self
        }

        pub fn s<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.s = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
            self
        }

        pub fn v<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.v = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for v failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cat/nodeattrs`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                cluster_manager_timeout,
                format,
                h,
                help,
                local,
                master_timeout,
                s,
                v,
            } = self;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let format = format.map_err(Error::InvalidRequest)?;
            let h = h.map_err(Error::InvalidRequest)?;
            let help = help.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let s = s.map_err(Error::InvalidRequest)?;
            let v = v.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_cat/nodeattrs", client.baseurl,);
            let mut query = Vec::with_capacity(8usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &format {
                query.push(("format", v.to_string()));
            }
            if let Some(v) = &h {
                query.push(("h", v.to_string()));
            }
            if let Some(v) = &help {
                query.push(("help", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &s {
                query.push(("s", v.to_string()));
            }
            if let Some(v) = &v {
                query.push(("v", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cat_nodes`]
    ///
    ///[`Client::cat_nodes`]: super::Client::cat_nodes
    #[derive(Debug, Clone)]
    pub struct CatNodes<'a> {
        client: &'a super::Client,
        bytes: Result<Option<types::Bytes>, String>,
        cluster_manager_timeout: Result<Option<types::CatNodesClusterManagerTimeout>, String>,
        format: Result<Option<String>, String>,
        full_id: Result<Option<bool>, String>,
        h: Result<Option<Vec<String>>, String>,
        help: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::CatNodesMasterTimeout>, String>,
        s: Result<Option<Vec<String>>, String>,
        time: Result<Option<types::Time>, String>,
        v: Result<Option<bool>, String>,
    }

    impl<'a> CatNodes<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                bytes: Ok(None),
                cluster_manager_timeout: Ok(None),
                format: Ok(None),
                full_id: Ok(None),
                h: Ok(None),
                help: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
                s: Ok(None),
                time: Ok(None),
                v: Ok(None),
            }
        }

        pub fn bytes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Bytes>,
        {
            self.bytes = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Bytes` for bytes failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatNodesClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `CatNodesClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn format<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.format = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for format failed".to_string());
            self
        }

        pub fn full_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.full_id = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for full_id failed".to_string());
            self
        }

        pub fn h<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.h = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
            self
        }

        pub fn help<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.help = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for help failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatNodesMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `CatNodesMasterTimeout` for master_timeout failed".to_string()
            });
            self
        }

        pub fn s<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.s = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
            self
        }

        pub fn time<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Time>,
        {
            self.time = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Time` for time failed".to_string());
            self
        }

        pub fn v<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.v = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for v failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cat/nodes`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                bytes,
                cluster_manager_timeout,
                format,
                full_id,
                h,
                help,
                local,
                master_timeout,
                s,
                time,
                v,
            } = self;
            let bytes = bytes.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let format = format.map_err(Error::InvalidRequest)?;
            let full_id = full_id.map_err(Error::InvalidRequest)?;
            let h = h.map_err(Error::InvalidRequest)?;
            let help = help.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let s = s.map_err(Error::InvalidRequest)?;
            let time = time.map_err(Error::InvalidRequest)?;
            let v = v.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_cat/nodes", client.baseurl,);
            let mut query = Vec::with_capacity(11usize);
            if let Some(v) = &bytes {
                query.push(("bytes", v.to_string()));
            }
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &format {
                query.push(("format", v.to_string()));
            }
            if let Some(v) = &full_id {
                query.push(("full_id", v.to_string()));
            }
            if let Some(v) = &h {
                query.push(("h", v.to_string()));
            }
            if let Some(v) = &help {
                query.push(("help", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &s {
                query.push(("s", v.to_string()));
            }
            if let Some(v) = &time {
                query.push(("time", v.to_string()));
            }
            if let Some(v) = &v {
                query.push(("v", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cat_pending_tasks`]
    ///
    ///[`Client::cat_pending_tasks`]: super::Client::cat_pending_tasks
    #[derive(Debug, Clone)]
    pub struct CatPendingTasks<'a> {
        client: &'a super::Client,
        cluster_manager_timeout:
            Result<Option<types::CatPendingTasksClusterManagerTimeout>, String>,
        format: Result<Option<String>, String>,
        h: Result<Option<Vec<String>>, String>,
        help: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::CatPendingTasksMasterTimeout>, String>,
        s: Result<Option<Vec<String>>, String>,
        time: Result<Option<types::Time>, String>,
        v: Result<Option<bool>, String>,
    }

    impl<'a> CatPendingTasks<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                cluster_manager_timeout: Ok(None),
                format: Ok(None),
                h: Ok(None),
                help: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
                s: Ok(None),
                time: Ok(None),
                v: Ok(None),
            }
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatPendingTasksClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `CatPendingTasksClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn format<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.format = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for format failed".to_string());
            self
        }

        pub fn h<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.h = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
            self
        }

        pub fn help<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.help = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for help failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatPendingTasksMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `CatPendingTasksMasterTimeout` for master_timeout failed".to_string()
            });
            self
        }

        pub fn s<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.s = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
            self
        }

        pub fn time<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Time>,
        {
            self.time = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Time` for time failed".to_string());
            self
        }

        pub fn v<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.v = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for v failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cat/pending_tasks`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                cluster_manager_timeout,
                format,
                h,
                help,
                local,
                master_timeout,
                s,
                time,
                v,
            } = self;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let format = format.map_err(Error::InvalidRequest)?;
            let h = h.map_err(Error::InvalidRequest)?;
            let help = help.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let s = s.map_err(Error::InvalidRequest)?;
            let time = time.map_err(Error::InvalidRequest)?;
            let v = v.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_cat/pending_tasks", client.baseurl,);
            let mut query = Vec::with_capacity(9usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &format {
                query.push(("format", v.to_string()));
            }
            if let Some(v) = &h {
                query.push(("h", v.to_string()));
            }
            if let Some(v) = &help {
                query.push(("help", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &s {
                query.push(("s", v.to_string()));
            }
            if let Some(v) = &time {
                query.push(("time", v.to_string()));
            }
            if let Some(v) = &v {
                query.push(("v", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cat_pit_segments`]
    ///
    ///[`Client::cat_pit_segments`]: super::Client::cat_pit_segments
    #[derive(Debug, Clone)]
    pub struct CatPitSegments<'a> {
        client: &'a super::Client,
        body: Result<types::builder::CatPitSegmentsBodyParams, String>,
    }

    impl<'a> CatPitSegments<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Ok(types::builder::CatPitSegmentsBodyParams::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatPitSegmentsBodyParams>,
        {
            self.body = value.try_into().map(From::from).map_err(|_| {
                "conversion to `CatPitSegmentsBodyParams` for body failed".to_string()
            });
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::CatPitSegmentsBodyParams,
            ) -> types::builder::CatPitSegmentsBodyParams,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `GET` request to `/_cat/pit_segments`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::CatPitSegmentsResponseContent>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(std::convert::TryInto::<types::CatPitSegmentsBodyParams>::try_into)
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/_cat/pit_segments", client.baseurl,);
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cat_all_pit_segments`]
    ///
    ///[`Client::cat_all_pit_segments`]: super::Client::cat_all_pit_segments
    #[derive(Debug, Clone)]
    pub struct CatAllPitSegments<'a> {
        client: &'a super::Client,
    }

    impl<'a> CatAllPitSegments<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        ///Sends a `GET` request to `/_cat/pit_segments/_all`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::CatAllPitSegmentsResponseContent>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/_cat/pit_segments/_all", client.baseurl,);
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cat_plugins`]
    ///
    ///[`Client::cat_plugins`]: super::Client::cat_plugins
    #[derive(Debug, Clone)]
    pub struct CatPlugins<'a> {
        client: &'a super::Client,
        cluster_manager_timeout: Result<Option<types::CatPluginsClusterManagerTimeout>, String>,
        format: Result<Option<String>, String>,
        h: Result<Option<Vec<String>>, String>,
        help: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::CatPluginsMasterTimeout>, String>,
        s: Result<Option<Vec<String>>, String>,
        v: Result<Option<bool>, String>,
    }

    impl<'a> CatPlugins<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                cluster_manager_timeout: Ok(None),
                format: Ok(None),
                h: Ok(None),
                help: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
                s: Ok(None),
                v: Ok(None),
            }
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatPluginsClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `CatPluginsClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn format<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.format = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for format failed".to_string());
            self
        }

        pub fn h<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.h = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
            self
        }

        pub fn help<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.help = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for help failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatPluginsMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `CatPluginsMasterTimeout` for master_timeout failed".to_string()
            });
            self
        }

        pub fn s<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.s = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
            self
        }

        pub fn v<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.v = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for v failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cat/plugins`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                cluster_manager_timeout,
                format,
                h,
                help,
                local,
                master_timeout,
                s,
                v,
            } = self;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let format = format.map_err(Error::InvalidRequest)?;
            let h = h.map_err(Error::InvalidRequest)?;
            let help = help.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let s = s.map_err(Error::InvalidRequest)?;
            let v = v.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_cat/plugins", client.baseurl,);
            let mut query = Vec::with_capacity(8usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &format {
                query.push(("format", v.to_string()));
            }
            if let Some(v) = &h {
                query.push(("h", v.to_string()));
            }
            if let Some(v) = &help {
                query.push(("help", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &s {
                query.push(("s", v.to_string()));
            }
            if let Some(v) = &v {
                query.push(("v", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cat_recovery`]
    ///
    ///[`Client::cat_recovery`]: super::Client::cat_recovery
    #[derive(Debug, Clone)]
    pub struct CatRecovery<'a> {
        client: &'a super::Client,
        active_only: Result<Option<bool>, String>,
        bytes: Result<Option<types::Bytes>, String>,
        detailed: Result<Option<bool>, String>,
        format: Result<Option<String>, String>,
        h: Result<Option<Vec<String>>, String>,
        help: Result<Option<bool>, String>,
        index: Result<Option<Vec<String>>, String>,
        s: Result<Option<Vec<String>>, String>,
        time: Result<Option<types::Time>, String>,
        v: Result<Option<bool>, String>,
    }

    impl<'a> CatRecovery<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                active_only: Ok(None),
                bytes: Ok(None),
                detailed: Ok(None),
                format: Ok(None),
                h: Ok(None),
                help: Ok(None),
                index: Ok(None),
                s: Ok(None),
                time: Ok(None),
                v: Ok(None),
            }
        }

        pub fn active_only<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.active_only = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for active_only failed".to_string());
            self
        }

        pub fn bytes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Bytes>,
        {
            self.bytes = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Bytes` for bytes failed".to_string());
            self
        }

        pub fn detailed<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.detailed = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for detailed failed".to_string());
            self
        }

        pub fn format<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.format = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for format failed".to_string());
            self
        }

        pub fn h<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.h = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
            self
        }

        pub fn help<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.help = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for help failed".to_string());
            self
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.index = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for index failed".to_string());
            self
        }

        pub fn s<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.s = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
            self
        }

        pub fn time<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Time>,
        {
            self.time = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Time` for time failed".to_string());
            self
        }

        pub fn v<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.v = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for v failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cat/recovery`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                active_only,
                bytes,
                detailed,
                format,
                h,
                help,
                index,
                s,
                time,
                v,
            } = self;
            let active_only = active_only.map_err(Error::InvalidRequest)?;
            let bytes = bytes.map_err(Error::InvalidRequest)?;
            let detailed = detailed.map_err(Error::InvalidRequest)?;
            let format = format.map_err(Error::InvalidRequest)?;
            let h = h.map_err(Error::InvalidRequest)?;
            let help = help.map_err(Error::InvalidRequest)?;
            let index = index.map_err(Error::InvalidRequest)?;
            let s = s.map_err(Error::InvalidRequest)?;
            let time = time.map_err(Error::InvalidRequest)?;
            let v = v.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_cat/recovery", client.baseurl,);
            let mut query = Vec::with_capacity(10usize);
            if let Some(v) = &active_only {
                query.push(("active_only", v.to_string()));
            }
            if let Some(v) = &bytes {
                query.push(("bytes", v.to_string()));
            }
            if let Some(v) = &detailed {
                query.push(("detailed", v.to_string()));
            }
            if let Some(v) = &format {
                query.push(("format", v.to_string()));
            }
            if let Some(v) = &h {
                query.push(("h", v.to_string()));
            }
            if let Some(v) = &help {
                query.push(("help", v.to_string()));
            }
            if let Some(v) = &index {
                query.push(("index", v.to_string()));
            }
            if let Some(v) = &s {
                query.push(("s", v.to_string()));
            }
            if let Some(v) = &time {
                query.push(("time", v.to_string()));
            }
            if let Some(v) = &v {
                query.push(("v", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cat_recovery_with_index`]
    ///
    ///[`Client::cat_recovery_with_index`]: super::Client::cat_recovery_with_index
    #[derive(Debug, Clone)]
    pub struct CatRecoveryWithIndex<'a> {
        client: &'a super::Client,
        active_only: Result<Option<bool>, String>,
        bytes: Result<Option<types::Bytes>, String>,
        detailed: Result<Option<bool>, String>,
        format: Result<Option<String>, String>,
        h: Result<Option<Vec<String>>, String>,
        help: Result<Option<bool>, String>,
        index: Result<Option<Vec<String>>, String>,
        s: Result<Option<Vec<String>>, String>,
        time: Result<Option<types::Time>, String>,
        v: Result<Option<bool>, String>,
    }

    impl<'a> CatRecoveryWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                active_only: Ok(None),
                bytes: Ok(None),
                detailed: Ok(None),
                format: Ok(None),
                h: Ok(None),
                help: Ok(None),
                index: Ok(None),
                s: Ok(None),
                time: Ok(None),
                v: Ok(None),
            }
        }

        pub fn active_only<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.active_only = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for active_only failed".to_string());
            self
        }

        pub fn bytes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Bytes>,
        {
            self.bytes = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Bytes` for bytes failed".to_string());
            self
        }

        pub fn detailed<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.detailed = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for detailed failed".to_string());
            self
        }

        pub fn format<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.format = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for format failed".to_string());
            self
        }

        pub fn h<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.h = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
            self
        }

        pub fn help<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.help = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for help failed".to_string());
            self
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.index = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for index failed".to_string());
            self
        }

        pub fn s<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.s = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
            self
        }

        pub fn time<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Time>,
        {
            self.time = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Time` for time failed".to_string());
            self
        }

        pub fn v<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.v = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for v failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cat/recovery/{index}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                active_only,
                bytes,
                detailed,
                format,
                h,
                help,
                index,
                s,
                time,
                v,
            } = self;
            let active_only = active_only.map_err(Error::InvalidRequest)?;
            let bytes = bytes.map_err(Error::InvalidRequest)?;
            let detailed = detailed.map_err(Error::InvalidRequest)?;
            let format = format.map_err(Error::InvalidRequest)?;
            let h = h.map_err(Error::InvalidRequest)?;
            let help = help.map_err(Error::InvalidRequest)?;
            let index = index.map_err(Error::InvalidRequest)?;
            let s = s.map_err(Error::InvalidRequest)?;
            let time = time.map_err(Error::InvalidRequest)?;
            let v = v.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_cat/recovery/{}",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(10usize);
            if let Some(v) = &active_only {
                query.push(("active_only", v.to_string()));
            }
            if let Some(v) = &bytes {
                query.push(("bytes", v.to_string()));
            }
            if let Some(v) = &detailed {
                query.push(("detailed", v.to_string()));
            }
            if let Some(v) = &format {
                query.push(("format", v.to_string()));
            }
            if let Some(v) = &h {
                query.push(("h", v.to_string()));
            }
            if let Some(v) = &help {
                query.push(("help", v.to_string()));
            }
            if let Some(v) = &index {
                query.push(("index", v.to_string()));
            }
            if let Some(v) = &s {
                query.push(("s", v.to_string()));
            }
            if let Some(v) = &time {
                query.push(("time", v.to_string()));
            }
            if let Some(v) = &v {
                query.push(("v", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cat_repositories`]
    ///
    ///[`Client::cat_repositories`]: super::Client::cat_repositories
    #[derive(Debug, Clone)]
    pub struct CatRepositories<'a> {
        client: &'a super::Client,
        cluster_manager_timeout:
            Result<Option<types::CatRepositoriesClusterManagerTimeout>, String>,
        format: Result<Option<String>, String>,
        h: Result<Option<Vec<String>>, String>,
        help: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::CatRepositoriesMasterTimeout>, String>,
        s: Result<Option<Vec<String>>, String>,
        v: Result<Option<bool>, String>,
    }

    impl<'a> CatRepositories<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                cluster_manager_timeout: Ok(None),
                format: Ok(None),
                h: Ok(None),
                help: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
                s: Ok(None),
                v: Ok(None),
            }
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatRepositoriesClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `CatRepositoriesClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn format<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.format = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for format failed".to_string());
            self
        }

        pub fn h<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.h = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
            self
        }

        pub fn help<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.help = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for help failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatRepositoriesMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `CatRepositoriesMasterTimeout` for master_timeout failed".to_string()
            });
            self
        }

        pub fn s<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.s = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
            self
        }

        pub fn v<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.v = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for v failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cat/repositories`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                cluster_manager_timeout,
                format,
                h,
                help,
                local,
                master_timeout,
                s,
                v,
            } = self;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let format = format.map_err(Error::InvalidRequest)?;
            let h = h.map_err(Error::InvalidRequest)?;
            let help = help.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let s = s.map_err(Error::InvalidRequest)?;
            let v = v.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_cat/repositories", client.baseurl,);
            let mut query = Vec::with_capacity(8usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &format {
                query.push(("format", v.to_string()));
            }
            if let Some(v) = &h {
                query.push(("h", v.to_string()));
            }
            if let Some(v) = &help {
                query.push(("help", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &s {
                query.push(("s", v.to_string()));
            }
            if let Some(v) = &v {
                query.push(("v", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cat_segment_replication`]
    ///
    ///[`Client::cat_segment_replication`]: super::Client::cat_segment_replication
    #[derive(Debug, Clone)]
    pub struct CatSegmentReplication<'a> {
        client: &'a super::Client,
        active_only: Result<Option<bool>, String>,
        bytes: Result<Option<types::Bytes>, String>,
        completed_only: Result<Option<bool>, String>,
        detailed: Result<Option<bool>, String>,
        format: Result<Option<String>, String>,
        h: Result<Option<Vec<String>>, String>,
        help: Result<Option<bool>, String>,
        index: Result<Option<Vec<String>>, String>,
        s: Result<Option<Vec<String>>, String>,
        shards: Result<Option<Vec<String>>, String>,
        time: Result<Option<types::Time>, String>,
        v: Result<Option<bool>, String>,
    }

    impl<'a> CatSegmentReplication<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                active_only: Ok(None),
                bytes: Ok(None),
                completed_only: Ok(None),
                detailed: Ok(None),
                format: Ok(None),
                h: Ok(None),
                help: Ok(None),
                index: Ok(None),
                s: Ok(None),
                shards: Ok(None),
                time: Ok(None),
                v: Ok(None),
            }
        }

        pub fn active_only<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.active_only = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for active_only failed".to_string());
            self
        }

        pub fn bytes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Bytes>,
        {
            self.bytes = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Bytes` for bytes failed".to_string());
            self
        }

        pub fn completed_only<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.completed_only = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for completed_only failed".to_string());
            self
        }

        pub fn detailed<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.detailed = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for detailed failed".to_string());
            self
        }

        pub fn format<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.format = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for format failed".to_string());
            self
        }

        pub fn h<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.h = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
            self
        }

        pub fn help<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.help = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for help failed".to_string());
            self
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.index = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for index failed".to_string());
            self
        }

        pub fn s<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.s = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
            self
        }

        pub fn shards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.shards = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for shards failed".to_string());
            self
        }

        pub fn time<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Time>,
        {
            self.time = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Time` for time failed".to_string());
            self
        }

        pub fn v<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.v = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for v failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cat/segment_replication`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                active_only,
                bytes,
                completed_only,
                detailed,
                format,
                h,
                help,
                index,
                s,
                shards,
                time,
                v,
            } = self;
            let active_only = active_only.map_err(Error::InvalidRequest)?;
            let bytes = bytes.map_err(Error::InvalidRequest)?;
            let completed_only = completed_only.map_err(Error::InvalidRequest)?;
            let detailed = detailed.map_err(Error::InvalidRequest)?;
            let format = format.map_err(Error::InvalidRequest)?;
            let h = h.map_err(Error::InvalidRequest)?;
            let help = help.map_err(Error::InvalidRequest)?;
            let index = index.map_err(Error::InvalidRequest)?;
            let s = s.map_err(Error::InvalidRequest)?;
            let shards = shards.map_err(Error::InvalidRequest)?;
            let time = time.map_err(Error::InvalidRequest)?;
            let v = v.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_cat/segment_replication", client.baseurl,);
            let mut query = Vec::with_capacity(12usize);
            if let Some(v) = &active_only {
                query.push(("active_only", v.to_string()));
            }
            if let Some(v) = &bytes {
                query.push(("bytes", v.to_string()));
            }
            if let Some(v) = &completed_only {
                query.push(("completed_only", v.to_string()));
            }
            if let Some(v) = &detailed {
                query.push(("detailed", v.to_string()));
            }
            if let Some(v) = &format {
                query.push(("format", v.to_string()));
            }
            if let Some(v) = &h {
                query.push(("h", v.to_string()));
            }
            if let Some(v) = &help {
                query.push(("help", v.to_string()));
            }
            if let Some(v) = &index {
                query.push(("index", v.to_string()));
            }
            if let Some(v) = &s {
                query.push(("s", v.to_string()));
            }
            if let Some(v) = &shards {
                query.push(("shards", v.to_string()));
            }
            if let Some(v) = &time {
                query.push(("time", v.to_string()));
            }
            if let Some(v) = &v {
                query.push(("v", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cat_segment_replication_with_index`]
    ///
    ///[`Client::cat_segment_replication_with_index`]: super::Client::cat_segment_replication_with_index
    #[derive(Debug, Clone)]
    pub struct CatSegmentReplicationWithIndex<'a> {
        client: &'a super::Client,
        active_only: Result<Option<bool>, String>,
        bytes: Result<Option<types::Bytes>, String>,
        completed_only: Result<Option<bool>, String>,
        detailed: Result<Option<bool>, String>,
        format: Result<Option<String>, String>,
        h: Result<Option<Vec<String>>, String>,
        help: Result<Option<bool>, String>,
        index: Result<Option<Vec<String>>, String>,
        s: Result<Option<Vec<String>>, String>,
        shards: Result<Option<Vec<String>>, String>,
        time: Result<Option<types::Time>, String>,
        v: Result<Option<bool>, String>,
    }

    impl<'a> CatSegmentReplicationWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                active_only: Ok(None),
                bytes: Ok(None),
                completed_only: Ok(None),
                detailed: Ok(None),
                format: Ok(None),
                h: Ok(None),
                help: Ok(None),
                index: Ok(None),
                s: Ok(None),
                shards: Ok(None),
                time: Ok(None),
                v: Ok(None),
            }
        }

        pub fn active_only<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.active_only = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for active_only failed".to_string());
            self
        }

        pub fn bytes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Bytes>,
        {
            self.bytes = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Bytes` for bytes failed".to_string());
            self
        }

        pub fn completed_only<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.completed_only = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for completed_only failed".to_string());
            self
        }

        pub fn detailed<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.detailed = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for detailed failed".to_string());
            self
        }

        pub fn format<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.format = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for format failed".to_string());
            self
        }

        pub fn h<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.h = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
            self
        }

        pub fn help<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.help = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for help failed".to_string());
            self
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.index = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for index failed".to_string());
            self
        }

        pub fn s<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.s = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
            self
        }

        pub fn shards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.shards = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for shards failed".to_string());
            self
        }

        pub fn time<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Time>,
        {
            self.time = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Time` for time failed".to_string());
            self
        }

        pub fn v<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.v = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for v failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cat/segment_replication/{index}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                active_only,
                bytes,
                completed_only,
                detailed,
                format,
                h,
                help,
                index,
                s,
                shards,
                time,
                v,
            } = self;
            let active_only = active_only.map_err(Error::InvalidRequest)?;
            let bytes = bytes.map_err(Error::InvalidRequest)?;
            let completed_only = completed_only.map_err(Error::InvalidRequest)?;
            let detailed = detailed.map_err(Error::InvalidRequest)?;
            let format = format.map_err(Error::InvalidRequest)?;
            let h = h.map_err(Error::InvalidRequest)?;
            let help = help.map_err(Error::InvalidRequest)?;
            let index = index.map_err(Error::InvalidRequest)?;
            let s = s.map_err(Error::InvalidRequest)?;
            let shards = shards.map_err(Error::InvalidRequest)?;
            let time = time.map_err(Error::InvalidRequest)?;
            let v = v.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_cat/segment_replication/{}",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(12usize);
            if let Some(v) = &active_only {
                query.push(("active_only", v.to_string()));
            }
            if let Some(v) = &bytes {
                query.push(("bytes", v.to_string()));
            }
            if let Some(v) = &completed_only {
                query.push(("completed_only", v.to_string()));
            }
            if let Some(v) = &detailed {
                query.push(("detailed", v.to_string()));
            }
            if let Some(v) = &format {
                query.push(("format", v.to_string()));
            }
            if let Some(v) = &h {
                query.push(("h", v.to_string()));
            }
            if let Some(v) = &help {
                query.push(("help", v.to_string()));
            }
            if let Some(v) = &index {
                query.push(("index", v.to_string()));
            }
            if let Some(v) = &s {
                query.push(("s", v.to_string()));
            }
            if let Some(v) = &shards {
                query.push(("shards", v.to_string()));
            }
            if let Some(v) = &time {
                query.push(("time", v.to_string()));
            }
            if let Some(v) = &v {
                query.push(("v", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cat_segments`]
    ///
    ///[`Client::cat_segments`]: super::Client::cat_segments
    #[derive(Debug, Clone)]
    pub struct CatSegments<'a> {
        client: &'a super::Client,
        bytes: Result<Option<types::Bytes>, String>,
        cluster_manager_timeout: Result<Option<types::CatSegmentsClusterManagerTimeout>, String>,
        format: Result<Option<String>, String>,
        h: Result<Option<Vec<String>>, String>,
        help: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::CatSegmentsMasterTimeout>, String>,
        s: Result<Option<Vec<String>>, String>,
        v: Result<Option<bool>, String>,
    }

    impl<'a> CatSegments<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                bytes: Ok(None),
                cluster_manager_timeout: Ok(None),
                format: Ok(None),
                h: Ok(None),
                help: Ok(None),
                master_timeout: Ok(None),
                s: Ok(None),
                v: Ok(None),
            }
        }

        pub fn bytes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Bytes>,
        {
            self.bytes = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Bytes` for bytes failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatSegmentsClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `CatSegmentsClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn format<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.format = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for format failed".to_string());
            self
        }

        pub fn h<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.h = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
            self
        }

        pub fn help<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.help = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for help failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatSegmentsMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `CatSegmentsMasterTimeout` for master_timeout failed".to_string()
            });
            self
        }

        pub fn s<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.s = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
            self
        }

        pub fn v<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.v = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for v failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cat/segments`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                bytes,
                cluster_manager_timeout,
                format,
                h,
                help,
                master_timeout,
                s,
                v,
            } = self;
            let bytes = bytes.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let format = format.map_err(Error::InvalidRequest)?;
            let h = h.map_err(Error::InvalidRequest)?;
            let help = help.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let s = s.map_err(Error::InvalidRequest)?;
            let v = v.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_cat/segments", client.baseurl,);
            let mut query = Vec::with_capacity(8usize);
            if let Some(v) = &bytes {
                query.push(("bytes", v.to_string()));
            }
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &format {
                query.push(("format", v.to_string()));
            }
            if let Some(v) = &h {
                query.push(("h", v.to_string()));
            }
            if let Some(v) = &help {
                query.push(("help", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &s {
                query.push(("s", v.to_string()));
            }
            if let Some(v) = &v {
                query.push(("v", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cat_segments_with_index`]
    ///
    ///[`Client::cat_segments_with_index`]: super::Client::cat_segments_with_index
    #[derive(Debug, Clone)]
    pub struct CatSegmentsWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::CatSegmentsWithIndexIndex, String>,
        bytes: Result<Option<types::Bytes>, String>,
        cluster_manager_timeout:
            Result<Option<types::CatSegmentsWithIndexClusterManagerTimeout>, String>,
        format: Result<Option<String>, String>,
        h: Result<Option<Vec<String>>, String>,
        help: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::CatSegmentsWithIndexMasterTimeout>, String>,
        s: Result<Option<Vec<String>>, String>,
        v: Result<Option<bool>, String>,
    }

    impl<'a> CatSegmentsWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                bytes: Ok(None),
                cluster_manager_timeout: Ok(None),
                format: Ok(None),
                h: Ok(None),
                help: Ok(None),
                master_timeout: Ok(None),
                s: Ok(None),
                v: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatSegmentsWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `CatSegmentsWithIndexIndex` for index failed".to_string()
            });
            self
        }

        pub fn bytes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Bytes>,
        {
            self.bytes = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Bytes` for bytes failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatSegmentsWithIndexClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `CatSegmentsWithIndexClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn format<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.format = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for format failed".to_string());
            self
        }

        pub fn h<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.h = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
            self
        }

        pub fn help<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.help = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for help failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatSegmentsWithIndexMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `CatSegmentsWithIndexMasterTimeout` for master_timeout failed"
                    .to_string()
            });
            self
        }

        pub fn s<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.s = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
            self
        }

        pub fn v<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.v = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for v failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cat/segments/{index}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                bytes,
                cluster_manager_timeout,
                format,
                h,
                help,
                master_timeout,
                s,
                v,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let bytes = bytes.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let format = format.map_err(Error::InvalidRequest)?;
            let h = h.map_err(Error::InvalidRequest)?;
            let help = help.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let s = s.map_err(Error::InvalidRequest)?;
            let v = v.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_cat/segments/{}",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(8usize);
            if let Some(v) = &bytes {
                query.push(("bytes", v.to_string()));
            }
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &format {
                query.push(("format", v.to_string()));
            }
            if let Some(v) = &h {
                query.push(("h", v.to_string()));
            }
            if let Some(v) = &help {
                query.push(("help", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &s {
                query.push(("s", v.to_string()));
            }
            if let Some(v) = &v {
                query.push(("v", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cat_shards`]
    ///
    ///[`Client::cat_shards`]: super::Client::cat_shards
    #[derive(Debug, Clone)]
    pub struct CatShards<'a> {
        client: &'a super::Client,
        bytes: Result<Option<types::Bytes>, String>,
        cluster_manager_timeout: Result<Option<types::CatShardsClusterManagerTimeout>, String>,
        format: Result<Option<String>, String>,
        h: Result<Option<Vec<String>>, String>,
        help: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::CatShardsMasterTimeout>, String>,
        s: Result<Option<Vec<String>>, String>,
        time: Result<Option<types::Time>, String>,
        v: Result<Option<bool>, String>,
    }

    impl<'a> CatShards<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                bytes: Ok(None),
                cluster_manager_timeout: Ok(None),
                format: Ok(None),
                h: Ok(None),
                help: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
                s: Ok(None),
                time: Ok(None),
                v: Ok(None),
            }
        }

        pub fn bytes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Bytes>,
        {
            self.bytes = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Bytes` for bytes failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatShardsClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `CatShardsClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn format<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.format = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for format failed".to_string());
            self
        }

        pub fn h<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.h = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
            self
        }

        pub fn help<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.help = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for help failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatShardsMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `CatShardsMasterTimeout` for master_timeout failed".to_string()
            });
            self
        }

        pub fn s<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.s = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
            self
        }

        pub fn time<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Time>,
        {
            self.time = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Time` for time failed".to_string());
            self
        }

        pub fn v<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.v = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for v failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cat/shards`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                bytes,
                cluster_manager_timeout,
                format,
                h,
                help,
                local,
                master_timeout,
                s,
                time,
                v,
            } = self;
            let bytes = bytes.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let format = format.map_err(Error::InvalidRequest)?;
            let h = h.map_err(Error::InvalidRequest)?;
            let help = help.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let s = s.map_err(Error::InvalidRequest)?;
            let time = time.map_err(Error::InvalidRequest)?;
            let v = v.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_cat/shards", client.baseurl,);
            let mut query = Vec::with_capacity(10usize);
            if let Some(v) = &bytes {
                query.push(("bytes", v.to_string()));
            }
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &format {
                query.push(("format", v.to_string()));
            }
            if let Some(v) = &h {
                query.push(("h", v.to_string()));
            }
            if let Some(v) = &help {
                query.push(("help", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &s {
                query.push(("s", v.to_string()));
            }
            if let Some(v) = &time {
                query.push(("time", v.to_string()));
            }
            if let Some(v) = &v {
                query.push(("v", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cat_shards_with_index`]
    ///
    ///[`Client::cat_shards_with_index`]: super::Client::cat_shards_with_index
    #[derive(Debug, Clone)]
    pub struct CatShardsWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::CatShardsWithIndexIndex, String>,
        bytes: Result<Option<types::Bytes>, String>,
        cluster_manager_timeout:
            Result<Option<types::CatShardsWithIndexClusterManagerTimeout>, String>,
        format: Result<Option<String>, String>,
        h: Result<Option<Vec<String>>, String>,
        help: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::CatShardsWithIndexMasterTimeout>, String>,
        s: Result<Option<Vec<String>>, String>,
        time: Result<Option<types::Time>, String>,
        v: Result<Option<bool>, String>,
    }

    impl<'a> CatShardsWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                bytes: Ok(None),
                cluster_manager_timeout: Ok(None),
                format: Ok(None),
                h: Ok(None),
                help: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
                s: Ok(None),
                time: Ok(None),
                v: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatShardsWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `CatShardsWithIndexIndex` for index failed".to_string()
            });
            self
        }

        pub fn bytes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Bytes>,
        {
            self.bytes = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Bytes` for bytes failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatShardsWithIndexClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `CatShardsWithIndexClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn format<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.format = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for format failed".to_string());
            self
        }

        pub fn h<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.h = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
            self
        }

        pub fn help<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.help = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for help failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatShardsWithIndexMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `CatShardsWithIndexMasterTimeout` for master_timeout failed"
                    .to_string()
            });
            self
        }

        pub fn s<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.s = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
            self
        }

        pub fn time<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Time>,
        {
            self.time = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Time` for time failed".to_string());
            self
        }

        pub fn v<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.v = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for v failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cat/shards/{index}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                bytes,
                cluster_manager_timeout,
                format,
                h,
                help,
                local,
                master_timeout,
                s,
                time,
                v,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let bytes = bytes.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let format = format.map_err(Error::InvalidRequest)?;
            let h = h.map_err(Error::InvalidRequest)?;
            let help = help.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let s = s.map_err(Error::InvalidRequest)?;
            let time = time.map_err(Error::InvalidRequest)?;
            let v = v.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_cat/shards/{}",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(10usize);
            if let Some(v) = &bytes {
                query.push(("bytes", v.to_string()));
            }
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &format {
                query.push(("format", v.to_string()));
            }
            if let Some(v) = &h {
                query.push(("h", v.to_string()));
            }
            if let Some(v) = &help {
                query.push(("help", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &s {
                query.push(("s", v.to_string()));
            }
            if let Some(v) = &time {
                query.push(("time", v.to_string()));
            }
            if let Some(v) = &v {
                query.push(("v", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cat_snapshots`]
    ///
    ///[`Client::cat_snapshots`]: super::Client::cat_snapshots
    #[derive(Debug, Clone)]
    pub struct CatSnapshots<'a> {
        client: &'a super::Client,
        cluster_manager_timeout: Result<Option<types::CatSnapshotsClusterManagerTimeout>, String>,
        format: Result<Option<String>, String>,
        h: Result<Option<Vec<String>>, String>,
        help: Result<Option<bool>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::CatSnapshotsMasterTimeout>, String>,
        s: Result<Option<Vec<String>>, String>,
        time: Result<Option<types::Time>, String>,
        v: Result<Option<bool>, String>,
    }

    impl<'a> CatSnapshots<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                cluster_manager_timeout: Ok(None),
                format: Ok(None),
                h: Ok(None),
                help: Ok(None),
                ignore_unavailable: Ok(None),
                master_timeout: Ok(None),
                s: Ok(None),
                time: Ok(None),
                v: Ok(None),
            }
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatSnapshotsClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `CatSnapshotsClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn format<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.format = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for format failed".to_string());
            self
        }

        pub fn h<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.h = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
            self
        }

        pub fn help<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.help = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for help failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatSnapshotsMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `CatSnapshotsMasterTimeout` for master_timeout failed".to_string()
            });
            self
        }

        pub fn s<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.s = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
            self
        }

        pub fn time<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Time>,
        {
            self.time = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Time` for time failed".to_string());
            self
        }

        pub fn v<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.v = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for v failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cat/snapshots`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                cluster_manager_timeout,
                format,
                h,
                help,
                ignore_unavailable,
                master_timeout,
                s,
                time,
                v,
            } = self;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let format = format.map_err(Error::InvalidRequest)?;
            let h = h.map_err(Error::InvalidRequest)?;
            let help = help.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let s = s.map_err(Error::InvalidRequest)?;
            let time = time.map_err(Error::InvalidRequest)?;
            let v = v.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_cat/snapshots", client.baseurl,);
            let mut query = Vec::with_capacity(9usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &format {
                query.push(("format", v.to_string()));
            }
            if let Some(v) = &h {
                query.push(("h", v.to_string()));
            }
            if let Some(v) = &help {
                query.push(("help", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &s {
                query.push(("s", v.to_string()));
            }
            if let Some(v) = &time {
                query.push(("time", v.to_string()));
            }
            if let Some(v) = &v {
                query.push(("v", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cat_snapshots_with_repository`]
    ///
    ///[`Client::cat_snapshots_with_repository`]: super::Client::cat_snapshots_with_repository
    #[derive(Debug, Clone)]
    pub struct CatSnapshotsWithRepository<'a> {
        client: &'a super::Client,
        repository: Result<types::CatSnapshotsWithRepositoryRepository, String>,
        cluster_manager_timeout:
            Result<Option<types::CatSnapshotsWithRepositoryClusterManagerTimeout>, String>,
        format: Result<Option<String>, String>,
        h: Result<Option<Vec<String>>, String>,
        help: Result<Option<bool>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::CatSnapshotsWithRepositoryMasterTimeout>, String>,
        s: Result<Option<Vec<String>>, String>,
        time: Result<Option<types::Time>, String>,
        v: Result<Option<bool>, String>,
    }

    impl<'a> CatSnapshotsWithRepository<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                repository: Err("repository was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                format: Ok(None),
                h: Ok(None),
                help: Ok(None),
                ignore_unavailable: Ok(None),
                master_timeout: Ok(None),
                s: Ok(None),
                time: Ok(None),
                v: Ok(None),
            }
        }

        pub fn repository<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatSnapshotsWithRepositoryRepository>,
        {
            self.repository = value.try_into().map_err(|_| {
                "conversion to `CatSnapshotsWithRepositoryRepository` for repository failed"
                    .to_string()
            });
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatSnapshotsWithRepositoryClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `CatSnapshotsWithRepositoryClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn format<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.format = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for format failed".to_string());
            self
        }

        pub fn h<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.h = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
            self
        }

        pub fn help<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.help = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for help failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatSnapshotsWithRepositoryMasterTimeout>,
        {
            self . master_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `CatSnapshotsWithRepositoryMasterTimeout` for master_timeout failed" . to_string ()) ;
            self
        }

        pub fn s<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.s = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
            self
        }

        pub fn time<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Time>,
        {
            self.time = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Time` for time failed".to_string());
            self
        }

        pub fn v<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.v = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for v failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cat/snapshots/{repository}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                repository,
                cluster_manager_timeout,
                format,
                h,
                help,
                ignore_unavailable,
                master_timeout,
                s,
                time,
                v,
            } = self;
            let repository = repository.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let format = format.map_err(Error::InvalidRequest)?;
            let h = h.map_err(Error::InvalidRequest)?;
            let help = help.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let s = s.map_err(Error::InvalidRequest)?;
            let time = time.map_err(Error::InvalidRequest)?;
            let v = v.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_cat/snapshots/{}",
                client.baseurl,
                encode_path(&repository.to_string()),
            );
            let mut query = Vec::with_capacity(9usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &format {
                query.push(("format", v.to_string()));
            }
            if let Some(v) = &h {
                query.push(("h", v.to_string()));
            }
            if let Some(v) = &help {
                query.push(("help", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &s {
                query.push(("s", v.to_string()));
            }
            if let Some(v) = &time {
                query.push(("time", v.to_string()));
            }
            if let Some(v) = &v {
                query.push(("v", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cat_tasks`]
    ///
    ///[`Client::cat_tasks`]: super::Client::cat_tasks
    #[derive(Debug, Clone)]
    pub struct CatTasks<'a> {
        client: &'a super::Client,
        actions: Result<Option<Vec<String>>, String>,
        detailed: Result<Option<bool>, String>,
        format: Result<Option<String>, String>,
        h: Result<Option<Vec<String>>, String>,
        help: Result<Option<bool>, String>,
        nodes: Result<Option<Vec<String>>, String>,
        parent_task_id: Result<Option<String>, String>,
        s: Result<Option<Vec<String>>, String>,
        time: Result<Option<types::Time>, String>,
        v: Result<Option<bool>, String>,
    }

    impl<'a> CatTasks<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                actions: Ok(None),
                detailed: Ok(None),
                format: Ok(None),
                h: Ok(None),
                help: Ok(None),
                nodes: Ok(None),
                parent_task_id: Ok(None),
                s: Ok(None),
                time: Ok(None),
                v: Ok(None),
            }
        }

        pub fn actions<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.actions = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for actions failed".to_string());
            self
        }

        pub fn detailed<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.detailed = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for detailed failed".to_string());
            self
        }

        pub fn format<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.format = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for format failed".to_string());
            self
        }

        pub fn h<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.h = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
            self
        }

        pub fn help<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.help = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for help failed".to_string());
            self
        }

        pub fn nodes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.nodes = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for nodes failed".to_string());
            self
        }

        pub fn parent_task_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.parent_task_id = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for parent_task_id failed".to_string());
            self
        }

        pub fn s<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.s = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
            self
        }

        pub fn time<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Time>,
        {
            self.time = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Time` for time failed".to_string());
            self
        }

        pub fn v<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.v = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for v failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cat/tasks`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                actions,
                detailed,
                format,
                h,
                help,
                nodes,
                parent_task_id,
                s,
                time,
                v,
            } = self;
            let actions = actions.map_err(Error::InvalidRequest)?;
            let detailed = detailed.map_err(Error::InvalidRequest)?;
            let format = format.map_err(Error::InvalidRequest)?;
            let h = h.map_err(Error::InvalidRequest)?;
            let help = help.map_err(Error::InvalidRequest)?;
            let nodes = nodes.map_err(Error::InvalidRequest)?;
            let parent_task_id = parent_task_id.map_err(Error::InvalidRequest)?;
            let s = s.map_err(Error::InvalidRequest)?;
            let time = time.map_err(Error::InvalidRequest)?;
            let v = v.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_cat/tasks", client.baseurl,);
            let mut query = Vec::with_capacity(10usize);
            if let Some(v) = &actions {
                query.push(("actions", v.to_string()));
            }
            if let Some(v) = &detailed {
                query.push(("detailed", v.to_string()));
            }
            if let Some(v) = &format {
                query.push(("format", v.to_string()));
            }
            if let Some(v) = &h {
                query.push(("h", v.to_string()));
            }
            if let Some(v) = &help {
                query.push(("help", v.to_string()));
            }
            if let Some(v) = &nodes {
                query.push(("nodes", v.to_string()));
            }
            if let Some(v) = &parent_task_id {
                query.push(("parent_task_id", v.to_string()));
            }
            if let Some(v) = &s {
                query.push(("s", v.to_string()));
            }
            if let Some(v) = &time {
                query.push(("time", v.to_string()));
            }
            if let Some(v) = &v {
                query.push(("v", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cat_templates`]
    ///
    ///[`Client::cat_templates`]: super::Client::cat_templates
    #[derive(Debug, Clone)]
    pub struct CatTemplates<'a> {
        client: &'a super::Client,
        cluster_manager_timeout: Result<Option<types::CatTemplatesClusterManagerTimeout>, String>,
        format: Result<Option<String>, String>,
        h: Result<Option<Vec<String>>, String>,
        help: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::CatTemplatesMasterTimeout>, String>,
        s: Result<Option<Vec<String>>, String>,
        v: Result<Option<bool>, String>,
    }

    impl<'a> CatTemplates<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                cluster_manager_timeout: Ok(None),
                format: Ok(None),
                h: Ok(None),
                help: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
                s: Ok(None),
                v: Ok(None),
            }
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatTemplatesClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `CatTemplatesClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn format<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.format = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for format failed".to_string());
            self
        }

        pub fn h<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.h = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
            self
        }

        pub fn help<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.help = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for help failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatTemplatesMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `CatTemplatesMasterTimeout` for master_timeout failed".to_string()
            });
            self
        }

        pub fn s<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.s = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
            self
        }

        pub fn v<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.v = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for v failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cat/templates`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                cluster_manager_timeout,
                format,
                h,
                help,
                local,
                master_timeout,
                s,
                v,
            } = self;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let format = format.map_err(Error::InvalidRequest)?;
            let h = h.map_err(Error::InvalidRequest)?;
            let help = help.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let s = s.map_err(Error::InvalidRequest)?;
            let v = v.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_cat/templates", client.baseurl,);
            let mut query = Vec::with_capacity(8usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &format {
                query.push(("format", v.to_string()));
            }
            if let Some(v) = &h {
                query.push(("h", v.to_string()));
            }
            if let Some(v) = &help {
                query.push(("help", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &s {
                query.push(("s", v.to_string()));
            }
            if let Some(v) = &v {
                query.push(("v", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cat_templates_with_name`]
    ///
    ///[`Client::cat_templates_with_name`]: super::Client::cat_templates_with_name
    #[derive(Debug, Clone)]
    pub struct CatTemplatesWithName<'a> {
        client: &'a super::Client,
        name: Result<types::CatTemplatesWithNameName, String>,
        cluster_manager_timeout:
            Result<Option<types::CatTemplatesWithNameClusterManagerTimeout>, String>,
        format: Result<Option<String>, String>,
        h: Result<Option<Vec<String>>, String>,
        help: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::CatTemplatesWithNameMasterTimeout>, String>,
        s: Result<Option<Vec<String>>, String>,
        v: Result<Option<bool>, String>,
    }

    impl<'a> CatTemplatesWithName<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                name: Err("name was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                format: Ok(None),
                h: Ok(None),
                help: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
                s: Ok(None),
                v: Ok(None),
            }
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatTemplatesWithNameName>,
        {
            self.name = value.try_into().map_err(|_| {
                "conversion to `CatTemplatesWithNameName` for name failed".to_string()
            });
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatTemplatesWithNameClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `CatTemplatesWithNameClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn format<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.format = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for format failed".to_string());
            self
        }

        pub fn h<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.h = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
            self
        }

        pub fn help<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.help = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for help failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatTemplatesWithNameMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `CatTemplatesWithNameMasterTimeout` for master_timeout failed"
                    .to_string()
            });
            self
        }

        pub fn s<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.s = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
            self
        }

        pub fn v<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.v = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for v failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cat/templates/{name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                name,
                cluster_manager_timeout,
                format,
                h,
                help,
                local,
                master_timeout,
                s,
                v,
            } = self;
            let name = name.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let format = format.map_err(Error::InvalidRequest)?;
            let h = h.map_err(Error::InvalidRequest)?;
            let help = help.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let s = s.map_err(Error::InvalidRequest)?;
            let v = v.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_cat/templates/{}",
                client.baseurl,
                encode_path(&name.to_string()),
            );
            let mut query = Vec::with_capacity(8usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &format {
                query.push(("format", v.to_string()));
            }
            if let Some(v) = &h {
                query.push(("h", v.to_string()));
            }
            if let Some(v) = &help {
                query.push(("help", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &s {
                query.push(("s", v.to_string()));
            }
            if let Some(v) = &v {
                query.push(("v", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cat_thread_pool`]
    ///
    ///[`Client::cat_thread_pool`]: super::Client::cat_thread_pool
    #[derive(Debug, Clone)]
    pub struct CatThreadPool<'a> {
        client: &'a super::Client,
        cluster_manager_timeout: Result<Option<types::CatThreadPoolClusterManagerTimeout>, String>,
        format: Result<Option<String>, String>,
        h: Result<Option<Vec<String>>, String>,
        help: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::CatThreadPoolMasterTimeout>, String>,
        s: Result<Option<Vec<String>>, String>,
        size: Result<Option<i32>, String>,
        v: Result<Option<bool>, String>,
    }

    impl<'a> CatThreadPool<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                cluster_manager_timeout: Ok(None),
                format: Ok(None),
                h: Ok(None),
                help: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
                s: Ok(None),
                size: Ok(None),
                v: Ok(None),
            }
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatThreadPoolClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `CatThreadPoolClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn format<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.format = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for format failed".to_string());
            self
        }

        pub fn h<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.h = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
            self
        }

        pub fn help<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.help = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for help failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatThreadPoolMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `CatThreadPoolMasterTimeout` for master_timeout failed".to_string()
            });
            self
        }

        pub fn s<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.s = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
            self
        }

        pub fn size<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.size = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for size failed".to_string());
            self
        }

        pub fn v<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.v = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for v failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cat/thread_pool`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                cluster_manager_timeout,
                format,
                h,
                help,
                local,
                master_timeout,
                s,
                size,
                v,
            } = self;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let format = format.map_err(Error::InvalidRequest)?;
            let h = h.map_err(Error::InvalidRequest)?;
            let help = help.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let s = s.map_err(Error::InvalidRequest)?;
            let size = size.map_err(Error::InvalidRequest)?;
            let v = v.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_cat/thread_pool", client.baseurl,);
            let mut query = Vec::with_capacity(9usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &format {
                query.push(("format", v.to_string()));
            }
            if let Some(v) = &h {
                query.push(("h", v.to_string()));
            }
            if let Some(v) = &help {
                query.push(("help", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &s {
                query.push(("s", v.to_string()));
            }
            if let Some(v) = &size {
                query.push(("size", v.to_string()));
            }
            if let Some(v) = &v {
                query.push(("v", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cat_thread_pool_with_thread_pool_patterns`]
    ///
    ///[`Client::cat_thread_pool_with_thread_pool_patterns`]: super::Client::cat_thread_pool_with_thread_pool_patterns
    #[derive(Debug, Clone)]
    pub struct CatThreadPoolWithThreadPoolPatterns<'a> {
        client: &'a super::Client,
        thread_pool_patterns:
            Result<types::CatThreadPoolWithThreadPoolPatternsThreadPoolPatterns, String>,
        cluster_manager_timeout:
            Result<Option<types::CatThreadPoolWithThreadPoolPatternsClusterManagerTimeout>, String>,
        format: Result<Option<String>, String>,
        h: Result<Option<Vec<String>>, String>,
        help: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
        master_timeout:
            Result<Option<types::CatThreadPoolWithThreadPoolPatternsMasterTimeout>, String>,
        s: Result<Option<Vec<String>>, String>,
        size: Result<Option<i32>, String>,
        v: Result<Option<bool>, String>,
    }

    impl<'a> CatThreadPoolWithThreadPoolPatterns<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                thread_pool_patterns: Err("thread_pool_patterns was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                format: Ok(None),
                h: Ok(None),
                help: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
                s: Ok(None),
                size: Ok(None),
                v: Ok(None),
            }
        }

        pub fn thread_pool_patterns<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatThreadPoolWithThreadPoolPatternsThreadPoolPatterns>,
        {
            self . thread_pool_patterns = value . try_into () . map_err (| _ | "conversion to `CatThreadPoolWithThreadPoolPatternsThreadPoolPatterns` for thread_pool_patterns failed" . to_string ()) ;
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<
                types::CatThreadPoolWithThreadPoolPatternsClusterManagerTimeout,
            >,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `CatThreadPoolWithThreadPoolPatternsClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn format<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.format = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for format failed".to_string());
            self
        }

        pub fn h<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.h = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for h failed".to_string());
            self
        }

        pub fn help<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.help = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for help failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CatThreadPoolWithThreadPoolPatternsMasterTimeout>,
        {
            self . master_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `CatThreadPoolWithThreadPoolPatternsMasterTimeout` for master_timeout failed" . to_string ()) ;
            self
        }

        pub fn s<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.s = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for s failed".to_string());
            self
        }

        pub fn size<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.size = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for size failed".to_string());
            self
        }

        pub fn v<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.v = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for v failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cat/thread_pool/{thread_pool_patterns}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                thread_pool_patterns,
                cluster_manager_timeout,
                format,
                h,
                help,
                local,
                master_timeout,
                s,
                size,
                v,
            } = self;
            let thread_pool_patterns = thread_pool_patterns.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let format = format.map_err(Error::InvalidRequest)?;
            let h = h.map_err(Error::InvalidRequest)?;
            let help = help.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let s = s.map_err(Error::InvalidRequest)?;
            let size = size.map_err(Error::InvalidRequest)?;
            let v = v.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_cat/thread_pool/{}",
                client.baseurl,
                encode_path(&thread_pool_patterns.to_string()),
            );
            let mut query = Vec::with_capacity(9usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &format {
                query.push(("format", v.to_string()));
            }
            if let Some(v) = &h {
                query.push(("h", v.to_string()));
            }
            if let Some(v) = &help {
                query.push(("help", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &s {
                query.push(("s", v.to_string()));
            }
            if let Some(v) = &size {
                query.push(("size", v.to_string()));
            }
            if let Some(v) = &v {
                query.push(("v", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cluster_allocation_explain_get`]
    ///
    ///[`Client::cluster_allocation_explain_get`]: super::Client::cluster_allocation_explain_get
    #[derive(Debug, Clone)]
    pub struct ClusterAllocationExplainGet<'a> {
        client: &'a super::Client,
        include_disk_info: Result<Option<bool>, String>,
        include_yes_decisions: Result<Option<bool>, String>,
    }

    impl<'a> ClusterAllocationExplainGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                include_disk_info: Ok(None),
                include_yes_decisions: Ok(None),
            }
        }

        pub fn include_disk_info<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.include_disk_info = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for include_disk_info failed".to_string());
            self
        }

        pub fn include_yes_decisions<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.include_yes_decisions = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for include_yes_decisions failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cluster/allocation/explain`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                include_disk_info,
                include_yes_decisions,
            } = self;
            let include_disk_info = include_disk_info.map_err(Error::InvalidRequest)?;
            let include_yes_decisions = include_yes_decisions.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_cluster/allocation/explain", client.baseurl,);
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &include_disk_info {
                query.push(("include_disk_info", v.to_string()));
            }
            if let Some(v) = &include_yes_decisions {
                query.push(("include_yes_decisions", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cluster_allocation_explain_post`]
    ///
    ///[`Client::cluster_allocation_explain_post`]: super::Client::cluster_allocation_explain_post
    #[derive(Debug, Clone)]
    pub struct ClusterAllocationExplainPost<'a> {
        client: &'a super::Client,
        include_disk_info: Result<Option<bool>, String>,
        include_yes_decisions: Result<Option<bool>, String>,
        body: Result<types::ClusterAllocationExplainBodyParams, String>,
    }

    impl<'a> ClusterAllocationExplainPost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                include_disk_info: Ok(None),
                include_yes_decisions: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn include_disk_info<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.include_disk_info = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for include_disk_info failed".to_string());
            self
        }

        pub fn include_yes_decisions<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.include_yes_decisions = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for include_yes_decisions failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterAllocationExplainBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `ClusterAllocationExplainBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `POST` request to `/_cluster/allocation/explain`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                include_disk_info,
                include_yes_decisions,
                body,
            } = self;
            let include_disk_info = include_disk_info.map_err(Error::InvalidRequest)?;
            let include_yes_decisions = include_yes_decisions.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_cluster/allocation/explain", client.baseurl,);
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &include_disk_info {
                query.push(("include_disk_info", v.to_string()));
            }
            if let Some(v) = &include_yes_decisions {
                query.push(("include_yes_decisions", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cluster_delete_decommission_awareness`]
    ///
    ///[`Client::cluster_delete_decommission_awareness`]: super::Client::cluster_delete_decommission_awareness
    #[derive(Debug, Clone)]
    pub struct ClusterDeleteDecommissionAwareness<'a> {
        client: &'a super::Client,
    }

    impl<'a> ClusterDeleteDecommissionAwareness<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        ///Sends a `DELETE` request to `/_cluster/decommission/awareness/`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/_cluster/decommission/awareness/", client.baseurl,);
            let request = client.client.delete(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cluster_get_decommission_awareness`]
    ///
    ///[`Client::cluster_get_decommission_awareness`]: super::Client::cluster_get_decommission_awareness
    #[derive(Debug, Clone)]
    pub struct ClusterGetDecommissionAwareness<'a> {
        client: &'a super::Client,
        awareness_attribute_name:
            Result<types::ClusterGetDecommissionAwarenessAwarenessAttributeName, String>,
    }

    impl<'a> ClusterGetDecommissionAwareness<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                awareness_attribute_name: Err(
                    "awareness_attribute_name was not initialized".to_string()
                ),
            }
        }

        pub fn awareness_attribute_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterGetDecommissionAwarenessAwarenessAttributeName>,
        {
            self . awareness_attribute_name = value . try_into () . map_err (| _ | "conversion to `ClusterGetDecommissionAwarenessAwarenessAttributeName` for awareness_attribute_name failed" . to_string ()) ;
            self
        }

        ///Sends a `GET` request to
        /// `/_cluster/decommission/awareness/{awareness_attribute_name}/
        /// _status`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                awareness_attribute_name,
            } = self;
            let awareness_attribute_name =
                awareness_attribute_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_cluster/decommission/awareness/{}/_status",
                client.baseurl,
                encode_path(&awareness_attribute_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cluster_put_decommission_awareness`]
    ///
    ///[`Client::cluster_put_decommission_awareness`]: super::Client::cluster_put_decommission_awareness
    #[derive(Debug, Clone)]
    pub struct ClusterPutDecommissionAwareness<'a> {
        client: &'a super::Client,
        awareness_attribute_name:
            Result<types::ClusterPutDecommissionAwarenessAwarenessAttributeName, String>,
        awareness_attribute_value:
            Result<types::ClusterPutDecommissionAwarenessAwarenessAttributeValue, String>,
    }

    impl<'a> ClusterPutDecommissionAwareness<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                awareness_attribute_name: Err(
                    "awareness_attribute_name was not initialized".to_string()
                ),
                awareness_attribute_value: Err(
                    "awareness_attribute_value was not initialized".to_string()
                ),
            }
        }

        pub fn awareness_attribute_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterPutDecommissionAwarenessAwarenessAttributeName>,
        {
            self . awareness_attribute_name = value . try_into () . map_err (| _ | "conversion to `ClusterPutDecommissionAwarenessAwarenessAttributeName` for awareness_attribute_name failed" . to_string ()) ;
            self
        }

        pub fn awareness_attribute_value<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterPutDecommissionAwarenessAwarenessAttributeValue>,
        {
            self . awareness_attribute_value = value . try_into () . map_err (| _ | "conversion to `ClusterPutDecommissionAwarenessAwarenessAttributeValue` for awareness_attribute_value failed" . to_string ()) ;
            self
        }

        ///Sends a `PUT` request to
        /// `/_cluster/decommission/awareness/{awareness_attribute_name}/
        /// {awareness_attribute_value}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                awareness_attribute_name,
                awareness_attribute_value,
            } = self;
            let awareness_attribute_name =
                awareness_attribute_name.map_err(Error::InvalidRequest)?;
            let awareness_attribute_value =
                awareness_attribute_value.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_cluster/decommission/awareness/{}/{}",
                client.baseurl,
                encode_path(&awareness_attribute_name.to_string()),
                encode_path(&awareness_attribute_value.to_string()),
            );
            let request = client.client.put(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cluster_health`]
    ///
    ///[`Client::cluster_health`]: super::Client::cluster_health
    #[derive(Debug, Clone)]
    pub struct ClusterHealth<'a> {
        client: &'a super::Client,
        awareness_attribute: Result<Option<String>, String>,
        cluster_manager_timeout: Result<Option<types::ClusterHealthClusterManagerTimeout>, String>,
        ensure_node_commissioned: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        level: Result<Option<types::ClusterHealthLevel>, String>,
        local: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::ClusterHealthMasterTimeout>, String>,
        timeout: Result<Option<types::ClusterHealthTimeout>, String>,
        wait_for_active_shards: Result<Option<String>, String>,
        wait_for_events: Result<Option<types::WaitForEvents>, String>,
        wait_for_no_initializing_shards: Result<Option<bool>, String>,
        wait_for_no_relocating_shards: Result<Option<bool>, String>,
        wait_for_nodes: Result<Option<String>, String>,
        wait_for_status: Result<Option<types::WaitForStatus>, String>,
    }

    impl<'a> ClusterHealth<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                awareness_attribute: Ok(None),
                cluster_manager_timeout: Ok(None),
                ensure_node_commissioned: Ok(None),
                expand_wildcards: Ok(None),
                level: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
                wait_for_active_shards: Ok(None),
                wait_for_events: Ok(None),
                wait_for_no_initializing_shards: Ok(None),
                wait_for_no_relocating_shards: Ok(None),
                wait_for_nodes: Ok(None),
                wait_for_status: Ok(None),
            }
        }

        pub fn awareness_attribute<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.awareness_attribute = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for awareness_attribute failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterHealthClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `ClusterHealthClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn ensure_node_commissioned<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ensure_node_commissioned = value.try_into().map(Some).map_err(|_| {
                "conversion to `bool` for ensure_node_commissioned failed".to_string()
            });
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn level<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterHealthLevel>,
        {
            self.level = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `ClusterHealthLevel` for level failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterHealthMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `ClusterHealthMasterTimeout` for master_timeout failed".to_string()
            });
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterHealthTimeout>,
        {
            self.timeout = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `ClusterHealthTimeout` for timeout failed".to_string());
            self
        }

        pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.wait_for_active_shards = value.try_into().map(Some).map_err(|_| {
                "conversion to `String` for wait_for_active_shards failed".to_string()
            });
            self
        }

        pub fn wait_for_events<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::WaitForEvents>,
        {
            self.wait_for_events = value.try_into().map(Some).map_err(|_| {
                "conversion to `WaitForEvents` for wait_for_events failed".to_string()
            });
            self
        }

        pub fn wait_for_no_initializing_shards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.wait_for_no_initializing_shards = value.try_into().map(Some).map_err(|_| {
                "conversion to `bool` for wait_for_no_initializing_shards failed".to_string()
            });
            self
        }

        pub fn wait_for_no_relocating_shards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.wait_for_no_relocating_shards = value.try_into().map(Some).map_err(|_| {
                "conversion to `bool` for wait_for_no_relocating_shards failed".to_string()
            });
            self
        }

        pub fn wait_for_nodes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.wait_for_nodes = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for wait_for_nodes failed".to_string());
            self
        }

        pub fn wait_for_status<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::WaitForStatus>,
        {
            self.wait_for_status = value.try_into().map(Some).map_err(|_| {
                "conversion to `WaitForStatus` for wait_for_status failed".to_string()
            });
            self
        }

        ///Sends a `GET` request to `/_cluster/health`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                awareness_attribute,
                cluster_manager_timeout,
                ensure_node_commissioned,
                expand_wildcards,
                level,
                local,
                master_timeout,
                timeout,
                wait_for_active_shards,
                wait_for_events,
                wait_for_no_initializing_shards,
                wait_for_no_relocating_shards,
                wait_for_nodes,
                wait_for_status,
            } = self;
            let awareness_attribute = awareness_attribute.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let ensure_node_commissioned =
                ensure_node_commissioned.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let level = level.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
            let wait_for_events = wait_for_events.map_err(Error::InvalidRequest)?;
            let wait_for_no_initializing_shards =
                wait_for_no_initializing_shards.map_err(Error::InvalidRequest)?;
            let wait_for_no_relocating_shards =
                wait_for_no_relocating_shards.map_err(Error::InvalidRequest)?;
            let wait_for_nodes = wait_for_nodes.map_err(Error::InvalidRequest)?;
            let wait_for_status = wait_for_status.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_cluster/health", client.baseurl,);
            let mut query = Vec::with_capacity(14usize);
            if let Some(v) = &awareness_attribute {
                query.push(("awareness_attribute", v.to_string()));
            }
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &ensure_node_commissioned {
                query.push(("ensure_node_commissioned", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &level {
                query.push(("level", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &wait_for_active_shards {
                query.push(("wait_for_active_shards", v.to_string()));
            }
            if let Some(v) = &wait_for_events {
                query.push(("wait_for_events", v.to_string()));
            }
            if let Some(v) = &wait_for_no_initializing_shards {
                query.push(("wait_for_no_initializing_shards", v.to_string()));
            }
            if let Some(v) = &wait_for_no_relocating_shards {
                query.push(("wait_for_no_relocating_shards", v.to_string()));
            }
            if let Some(v) = &wait_for_nodes {
                query.push(("wait_for_nodes", v.to_string()));
            }
            if let Some(v) = &wait_for_status {
                query.push(("wait_for_status", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cluster_health_with_index`]
    ///
    ///[`Client::cluster_health_with_index`]: super::Client::cluster_health_with_index
    #[derive(Debug, Clone)]
    pub struct ClusterHealthWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::ClusterHealthWithIndexIndex, String>,
        awareness_attribute: Result<Option<String>, String>,
        cluster_manager_timeout:
            Result<Option<types::ClusterHealthWithIndexClusterManagerTimeout>, String>,
        ensure_node_commissioned: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        level: Result<Option<types::ClusterHealthLevel>, String>,
        local: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::ClusterHealthWithIndexMasterTimeout>, String>,
        timeout: Result<Option<types::ClusterHealthWithIndexTimeout>, String>,
        wait_for_active_shards: Result<Option<String>, String>,
        wait_for_events: Result<Option<types::WaitForEvents>, String>,
        wait_for_no_initializing_shards: Result<Option<bool>, String>,
        wait_for_no_relocating_shards: Result<Option<bool>, String>,
        wait_for_nodes: Result<Option<String>, String>,
        wait_for_status: Result<Option<types::WaitForStatus>, String>,
    }

    impl<'a> ClusterHealthWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                awareness_attribute: Ok(None),
                cluster_manager_timeout: Ok(None),
                ensure_node_commissioned: Ok(None),
                expand_wildcards: Ok(None),
                level: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
                wait_for_active_shards: Ok(None),
                wait_for_events: Ok(None),
                wait_for_no_initializing_shards: Ok(None),
                wait_for_no_relocating_shards: Ok(None),
                wait_for_nodes: Ok(None),
                wait_for_status: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterHealthWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `ClusterHealthWithIndexIndex` for index failed".to_string()
            });
            self
        }

        pub fn awareness_attribute<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.awareness_attribute = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for awareness_attribute failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterHealthWithIndexClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `ClusterHealthWithIndexClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn ensure_node_commissioned<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ensure_node_commissioned = value.try_into().map(Some).map_err(|_| {
                "conversion to `bool` for ensure_node_commissioned failed".to_string()
            });
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn level<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterHealthLevel>,
        {
            self.level = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `ClusterHealthLevel` for level failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterHealthWithIndexMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `ClusterHealthWithIndexMasterTimeout` for master_timeout failed"
                    .to_string()
            });
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterHealthWithIndexTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `ClusterHealthWithIndexTimeout` for timeout failed".to_string()
            });
            self
        }

        pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.wait_for_active_shards = value.try_into().map(Some).map_err(|_| {
                "conversion to `String` for wait_for_active_shards failed".to_string()
            });
            self
        }

        pub fn wait_for_events<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::WaitForEvents>,
        {
            self.wait_for_events = value.try_into().map(Some).map_err(|_| {
                "conversion to `WaitForEvents` for wait_for_events failed".to_string()
            });
            self
        }

        pub fn wait_for_no_initializing_shards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.wait_for_no_initializing_shards = value.try_into().map(Some).map_err(|_| {
                "conversion to `bool` for wait_for_no_initializing_shards failed".to_string()
            });
            self
        }

        pub fn wait_for_no_relocating_shards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.wait_for_no_relocating_shards = value.try_into().map(Some).map_err(|_| {
                "conversion to `bool` for wait_for_no_relocating_shards failed".to_string()
            });
            self
        }

        pub fn wait_for_nodes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.wait_for_nodes = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for wait_for_nodes failed".to_string());
            self
        }

        pub fn wait_for_status<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::WaitForStatus>,
        {
            self.wait_for_status = value.try_into().map(Some).map_err(|_| {
                "conversion to `WaitForStatus` for wait_for_status failed".to_string()
            });
            self
        }

        ///Sends a `GET` request to `/_cluster/health/{index}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                awareness_attribute,
                cluster_manager_timeout,
                ensure_node_commissioned,
                expand_wildcards,
                level,
                local,
                master_timeout,
                timeout,
                wait_for_active_shards,
                wait_for_events,
                wait_for_no_initializing_shards,
                wait_for_no_relocating_shards,
                wait_for_nodes,
                wait_for_status,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let awareness_attribute = awareness_attribute.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let ensure_node_commissioned =
                ensure_node_commissioned.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let level = level.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
            let wait_for_events = wait_for_events.map_err(Error::InvalidRequest)?;
            let wait_for_no_initializing_shards =
                wait_for_no_initializing_shards.map_err(Error::InvalidRequest)?;
            let wait_for_no_relocating_shards =
                wait_for_no_relocating_shards.map_err(Error::InvalidRequest)?;
            let wait_for_nodes = wait_for_nodes.map_err(Error::InvalidRequest)?;
            let wait_for_status = wait_for_status.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_cluster/health/{}",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(14usize);
            if let Some(v) = &awareness_attribute {
                query.push(("awareness_attribute", v.to_string()));
            }
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &ensure_node_commissioned {
                query.push(("ensure_node_commissioned", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &level {
                query.push(("level", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &wait_for_active_shards {
                query.push(("wait_for_active_shards", v.to_string()));
            }
            if let Some(v) = &wait_for_events {
                query.push(("wait_for_events", v.to_string()));
            }
            if let Some(v) = &wait_for_no_initializing_shards {
                query.push(("wait_for_no_initializing_shards", v.to_string()));
            }
            if let Some(v) = &wait_for_no_relocating_shards {
                query.push(("wait_for_no_relocating_shards", v.to_string()));
            }
            if let Some(v) = &wait_for_nodes {
                query.push(("wait_for_nodes", v.to_string()));
            }
            if let Some(v) = &wait_for_status {
                query.push(("wait_for_status", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::nodes_hot_threads_deprecated_dash`]
    ///
    ///[`Client::nodes_hot_threads_deprecated_dash`]: super::Client::nodes_hot_threads_deprecated_dash
    #[derive(Debug, Clone)]
    pub struct NodesHotThreadsDeprecatedDash<'a> {
        client: &'a super::Client,
        ignore_idle_threads: Result<Option<bool>, String>,
        interval: Result<Option<types::NodesHotThreadsDeprecatedDashInterval>, String>,
        snapshots: Result<Option<i32>, String>,
        threads: Result<Option<i32>, String>,
        timeout: Result<Option<types::NodesHotThreadsDeprecatedDashTimeout>, String>,
        type_: Result<Option<types::SampleType>, String>,
    }

    impl<'a> NodesHotThreadsDeprecatedDash<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                ignore_idle_threads: Ok(None),
                interval: Ok(None),
                snapshots: Ok(None),
                threads: Ok(None),
                timeout: Ok(None),
                type_: Ok(None),
            }
        }

        pub fn ignore_idle_threads<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_idle_threads = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_idle_threads failed".to_string());
            self
        }

        pub fn interval<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesHotThreadsDeprecatedDashInterval>,
        {
            self.interval = value.try_into().map(Some).map_err(|_| {
                "conversion to `NodesHotThreadsDeprecatedDashInterval` for interval failed"
                    .to_string()
            });
            self
        }

        pub fn snapshots<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.snapshots = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for snapshots failed".to_string());
            self
        }

        pub fn threads<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.threads = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for threads failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesHotThreadsDeprecatedDashTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `NodesHotThreadsDeprecatedDashTimeout` for timeout failed"
                    .to_string()
            });
            self
        }

        pub fn type_<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SampleType>,
        {
            self.type_ = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SampleType` for type_ failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cluster/nodes/hot_threads`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                ignore_idle_threads,
                interval,
                snapshots,
                threads,
                timeout,
                type_,
            } = self;
            let ignore_idle_threads = ignore_idle_threads.map_err(Error::InvalidRequest)?;
            let interval = interval.map_err(Error::InvalidRequest)?;
            let snapshots = snapshots.map_err(Error::InvalidRequest)?;
            let threads = threads.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let type_ = type_.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_cluster/nodes/hot_threads", client.baseurl,);
            let mut query = Vec::with_capacity(6usize);
            if let Some(v) = &ignore_idle_threads {
                query.push(("ignore_idle_threads", v.to_string()));
            }
            if let Some(v) = &interval {
                query.push(("interval", v.to_string()));
            }
            if let Some(v) = &snapshots {
                query.push(("snapshots", v.to_string()));
            }
            if let Some(v) = &threads {
                query.push(("threads", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &type_ {
                query.push(("type", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::nodes_hot_threads_deprecated_cluster`]
    ///
    ///[`Client::nodes_hot_threads_deprecated_cluster`]: super::Client::nodes_hot_threads_deprecated_cluster
    #[derive(Debug, Clone)]
    pub struct NodesHotThreadsDeprecatedCluster<'a> {
        client: &'a super::Client,
        ignore_idle_threads: Result<Option<bool>, String>,
        interval: Result<Option<types::NodesHotThreadsDeprecatedClusterInterval>, String>,
        snapshots: Result<Option<i32>, String>,
        threads: Result<Option<i32>, String>,
        timeout: Result<Option<types::NodesHotThreadsDeprecatedClusterTimeout>, String>,
        type_: Result<Option<types::SampleType>, String>,
    }

    impl<'a> NodesHotThreadsDeprecatedCluster<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                ignore_idle_threads: Ok(None),
                interval: Ok(None),
                snapshots: Ok(None),
                threads: Ok(None),
                timeout: Ok(None),
                type_: Ok(None),
            }
        }

        pub fn ignore_idle_threads<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_idle_threads = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_idle_threads failed".to_string());
            self
        }

        pub fn interval<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesHotThreadsDeprecatedClusterInterval>,
        {
            self.interval = value.try_into().map(Some).map_err(|_| {
                "conversion to `NodesHotThreadsDeprecatedClusterInterval` for interval failed"
                    .to_string()
            });
            self
        }

        pub fn snapshots<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.snapshots = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for snapshots failed".to_string());
            self
        }

        pub fn threads<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.threads = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for threads failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesHotThreadsDeprecatedClusterTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `NodesHotThreadsDeprecatedClusterTimeout` for timeout failed"
                    .to_string()
            });
            self
        }

        pub fn type_<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SampleType>,
        {
            self.type_ = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SampleType` for type_ failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cluster/nodes/hotthreads`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                ignore_idle_threads,
                interval,
                snapshots,
                threads,
                timeout,
                type_,
            } = self;
            let ignore_idle_threads = ignore_idle_threads.map_err(Error::InvalidRequest)?;
            let interval = interval.map_err(Error::InvalidRequest)?;
            let snapshots = snapshots.map_err(Error::InvalidRequest)?;
            let threads = threads.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let type_ = type_.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_cluster/nodes/hotthreads", client.baseurl,);
            let mut query = Vec::with_capacity(6usize);
            if let Some(v) = &ignore_idle_threads {
                query.push(("ignore_idle_threads", v.to_string()));
            }
            if let Some(v) = &interval {
                query.push(("interval", v.to_string()));
            }
            if let Some(v) = &snapshots {
                query.push(("snapshots", v.to_string()));
            }
            if let Some(v) = &threads {
                query.push(("threads", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &type_ {
                query.push(("type", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::nodes_hot_threads_with_node_id_deprecated_dash`]
    ///
    ///[`Client::nodes_hot_threads_with_node_id_deprecated_dash`]: super::Client::nodes_hot_threads_with_node_id_deprecated_dash
    #[derive(Debug, Clone)]
    pub struct NodesHotThreadsWithNodeIdDeprecatedDash<'a> {
        client: &'a super::Client,
        node_id: Result<types::NodesHotThreadsWithNodeIdDeprecatedDashNodeId, String>,
        ignore_idle_threads: Result<Option<bool>, String>,
        interval: Result<Option<types::NodesHotThreadsWithNodeIdDeprecatedDashInterval>, String>,
        snapshots: Result<Option<i32>, String>,
        threads: Result<Option<i32>, String>,
        timeout: Result<Option<types::NodesHotThreadsWithNodeIdDeprecatedDashTimeout>, String>,
        type_: Result<Option<types::SampleType>, String>,
    }

    impl<'a> NodesHotThreadsWithNodeIdDeprecatedDash<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                node_id: Err("node_id was not initialized".to_string()),
                ignore_idle_threads: Ok(None),
                interval: Ok(None),
                snapshots: Ok(None),
                threads: Ok(None),
                timeout: Ok(None),
                type_: Ok(None),
            }
        }

        pub fn node_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesHotThreadsWithNodeIdDeprecatedDashNodeId>,
        {
            self . node_id = value . try_into () . map_err (| _ | "conversion to `NodesHotThreadsWithNodeIdDeprecatedDashNodeId` for node_id failed" . to_string ()) ;
            self
        }

        pub fn ignore_idle_threads<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_idle_threads = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_idle_threads failed".to_string());
            self
        }

        pub fn interval<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesHotThreadsWithNodeIdDeprecatedDashInterval>,
        {
            self . interval = value . try_into () . map (Some) . map_err (| _ | "conversion to `NodesHotThreadsWithNodeIdDeprecatedDashInterval` for interval failed" . to_string ()) ;
            self
        }

        pub fn snapshots<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.snapshots = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for snapshots failed".to_string());
            self
        }

        pub fn threads<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.threads = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for threads failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesHotThreadsWithNodeIdDeprecatedDashTimeout>,
        {
            self . timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `NodesHotThreadsWithNodeIdDeprecatedDashTimeout` for timeout failed" . to_string ()) ;
            self
        }

        pub fn type_<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SampleType>,
        {
            self.type_ = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SampleType` for type_ failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cluster/nodes/{node_id}/hot_threads`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                node_id,
                ignore_idle_threads,
                interval,
                snapshots,
                threads,
                timeout,
                type_,
            } = self;
            let node_id = node_id.map_err(Error::InvalidRequest)?;
            let ignore_idle_threads = ignore_idle_threads.map_err(Error::InvalidRequest)?;
            let interval = interval.map_err(Error::InvalidRequest)?;
            let snapshots = snapshots.map_err(Error::InvalidRequest)?;
            let threads = threads.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let type_ = type_.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_cluster/nodes/{}/hot_threads",
                client.baseurl,
                encode_path(&node_id.to_string()),
            );
            let mut query = Vec::with_capacity(6usize);
            if let Some(v) = &ignore_idle_threads {
                query.push(("ignore_idle_threads", v.to_string()));
            }
            if let Some(v) = &interval {
                query.push(("interval", v.to_string()));
            }
            if let Some(v) = &snapshots {
                query.push(("snapshots", v.to_string()));
            }
            if let Some(v) = &threads {
                query.push(("threads", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &type_ {
                query.push(("type", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for
    /// [`Client::nodes_hot_threads_with_node_id_deprecated_cluster`]
    ///
    ///[`Client::nodes_hot_threads_with_node_id_deprecated_cluster`]: super::Client::nodes_hot_threads_with_node_id_deprecated_cluster
    #[derive(Debug, Clone)]
    pub struct NodesHotThreadsWithNodeIdDeprecatedCluster<'a> {
        client: &'a super::Client,
        node_id: Result<types::NodesHotThreadsWithNodeIdDeprecatedClusterNodeId, String>,
        ignore_idle_threads: Result<Option<bool>, String>,
        interval: Result<Option<types::NodesHotThreadsWithNodeIdDeprecatedClusterInterval>, String>,
        snapshots: Result<Option<i32>, String>,
        threads: Result<Option<i32>, String>,
        timeout: Result<Option<types::NodesHotThreadsWithNodeIdDeprecatedClusterTimeout>, String>,
        type_: Result<Option<types::SampleType>, String>,
    }

    impl<'a> NodesHotThreadsWithNodeIdDeprecatedCluster<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                node_id: Err("node_id was not initialized".to_string()),
                ignore_idle_threads: Ok(None),
                interval: Ok(None),
                snapshots: Ok(None),
                threads: Ok(None),
                timeout: Ok(None),
                type_: Ok(None),
            }
        }

        pub fn node_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesHotThreadsWithNodeIdDeprecatedClusterNodeId>,
        {
            self . node_id = value . try_into () . map_err (| _ | "conversion to `NodesHotThreadsWithNodeIdDeprecatedClusterNodeId` for node_id failed" . to_string ()) ;
            self
        }

        pub fn ignore_idle_threads<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_idle_threads = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_idle_threads failed".to_string());
            self
        }

        pub fn interval<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesHotThreadsWithNodeIdDeprecatedClusterInterval>,
        {
            self . interval = value . try_into () . map (Some) . map_err (| _ | "conversion to `NodesHotThreadsWithNodeIdDeprecatedClusterInterval` for interval failed" . to_string ()) ;
            self
        }

        pub fn snapshots<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.snapshots = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for snapshots failed".to_string());
            self
        }

        pub fn threads<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.threads = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for threads failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesHotThreadsWithNodeIdDeprecatedClusterTimeout>,
        {
            self . timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `NodesHotThreadsWithNodeIdDeprecatedClusterTimeout` for timeout failed" . to_string ()) ;
            self
        }

        pub fn type_<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SampleType>,
        {
            self.type_ = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SampleType` for type_ failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cluster/nodes/{node_id}/hotthreads`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                node_id,
                ignore_idle_threads,
                interval,
                snapshots,
                threads,
                timeout,
                type_,
            } = self;
            let node_id = node_id.map_err(Error::InvalidRequest)?;
            let ignore_idle_threads = ignore_idle_threads.map_err(Error::InvalidRequest)?;
            let interval = interval.map_err(Error::InvalidRequest)?;
            let snapshots = snapshots.map_err(Error::InvalidRequest)?;
            let threads = threads.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let type_ = type_.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_cluster/nodes/{}/hotthreads",
                client.baseurl,
                encode_path(&node_id.to_string()),
            );
            let mut query = Vec::with_capacity(6usize);
            if let Some(v) = &ignore_idle_threads {
                query.push(("ignore_idle_threads", v.to_string()));
            }
            if let Some(v) = &interval {
                query.push(("interval", v.to_string()));
            }
            if let Some(v) = &snapshots {
                query.push(("snapshots", v.to_string()));
            }
            if let Some(v) = &threads {
                query.push(("threads", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &type_ {
                query.push(("type", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cluster_pending_tasks`]
    ///
    ///[`Client::cluster_pending_tasks`]: super::Client::cluster_pending_tasks
    #[derive(Debug, Clone)]
    pub struct ClusterPendingTasks<'a> {
        client: &'a super::Client,
        cluster_manager_timeout:
            Result<Option<types::ClusterPendingTasksClusterManagerTimeout>, String>,
        local: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::ClusterPendingTasksMasterTimeout>, String>,
    }

    impl<'a> ClusterPendingTasks<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                cluster_manager_timeout: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
            }
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterPendingTasksClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `ClusterPendingTasksClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterPendingTasksMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `ClusterPendingTasksMasterTimeout` for master_timeout failed"
                    .to_string()
            });
            self
        }

        ///Sends a `GET` request to `/_cluster/pending_tasks`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                cluster_manager_timeout,
                local,
                master_timeout,
            } = self;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_cluster/pending_tasks", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cluster_reroute`]
    ///
    ///[`Client::cluster_reroute`]: super::Client::cluster_reroute
    #[derive(Debug, Clone)]
    pub struct ClusterReroute<'a> {
        client: &'a super::Client,
        cluster_manager_timeout: Result<Option<types::ClusterRerouteClusterManagerTimeout>, String>,
        dry_run: Result<Option<bool>, String>,
        explain: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::ClusterRerouteMasterTimeout>, String>,
        metric: Result<Option<Vec<types::ClusterRerouteMetricMember>>, String>,
        retry_failed: Result<Option<bool>, String>,
        timeout: Result<Option<types::ClusterRerouteTimeout>, String>,
        body: Result<types::ClusterRerouteBodyParams, String>,
    }

    impl<'a> ClusterReroute<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                cluster_manager_timeout: Ok(None),
                dry_run: Ok(None),
                explain: Ok(None),
                master_timeout: Ok(None),
                metric: Ok(None),
                retry_failed: Ok(None),
                timeout: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterRerouteClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `ClusterRerouteClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn dry_run<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.dry_run = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for dry_run failed".to_string());
            self
        }

        pub fn explain<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.explain = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for explain failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterRerouteMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `ClusterRerouteMasterTimeout` for master_timeout failed".to_string()
            });
            self
        }

        pub fn metric<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<types::ClusterRerouteMetricMember>>,
        {
            self.metric = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < ClusterRerouteMetricMember >` for metric failed".to_string()
            });
            self
        }

        pub fn retry_failed<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.retry_failed = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for retry_failed failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterRerouteTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `ClusterRerouteTimeout` for timeout failed".to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterRerouteBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `ClusterRerouteBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `POST` request to `/_cluster/reroute`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                cluster_manager_timeout,
                dry_run,
                explain,
                master_timeout,
                metric,
                retry_failed,
                timeout,
                body,
            } = self;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let dry_run = dry_run.map_err(Error::InvalidRequest)?;
            let explain = explain.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let metric = metric.map_err(Error::InvalidRequest)?;
            let retry_failed = retry_failed.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_cluster/reroute", client.baseurl,);
            let mut query = Vec::with_capacity(7usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &dry_run {
                query.push(("dry_run", v.to_string()));
            }
            if let Some(v) = &explain {
                query.push(("explain", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &metric {
                query.push(("metric", v.to_string()));
            }
            if let Some(v) = &retry_failed {
                query.push(("retry_failed", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cluster_delete_weighted_routing`]
    ///
    ///[`Client::cluster_delete_weighted_routing`]: super::Client::cluster_delete_weighted_routing
    #[derive(Debug, Clone)]
    pub struct ClusterDeleteWeightedRouting<'a> {
        client: &'a super::Client,
    }

    impl<'a> ClusterDeleteWeightedRouting<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        ///Sends a `DELETE` request to `/_cluster/routing/awareness/weights`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/_cluster/routing/awareness/weights", client.baseurl,);
            let request = client.client.delete(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cluster_get_weighted_routing`]
    ///
    ///[`Client::cluster_get_weighted_routing`]: super::Client::cluster_get_weighted_routing
    #[derive(Debug, Clone)]
    pub struct ClusterGetWeightedRouting<'a> {
        client: &'a super::Client,
        attribute: Result<types::ClusterGetWeightedRoutingAttribute, String>,
    }

    impl<'a> ClusterGetWeightedRouting<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                attribute: Err("attribute was not initialized".to_string()),
            }
        }

        pub fn attribute<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterGetWeightedRoutingAttribute>,
        {
            self.attribute = value.try_into().map_err(|_| {
                "conversion to `ClusterGetWeightedRoutingAttribute` for attribute failed"
                    .to_string()
            });
            self
        }

        ///Sends a `GET` request to
        /// `/_cluster/routing/awareness/{attribute}/weights`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, attribute } = self;
            let attribute = attribute.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_cluster/routing/awareness/{}/weights",
                client.baseurl,
                encode_path(&attribute.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cluster_put_weighted_routing`]
    ///
    ///[`Client::cluster_put_weighted_routing`]: super::Client::cluster_put_weighted_routing
    #[derive(Debug, Clone)]
    pub struct ClusterPutWeightedRouting<'a> {
        client: &'a super::Client,
        attribute: Result<types::ClusterPutWeightedRoutingAttribute, String>,
    }

    impl<'a> ClusterPutWeightedRouting<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                attribute: Err("attribute was not initialized".to_string()),
            }
        }

        pub fn attribute<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterPutWeightedRoutingAttribute>,
        {
            self.attribute = value.try_into().map_err(|_| {
                "conversion to `ClusterPutWeightedRoutingAttribute` for attribute failed"
                    .to_string()
            });
            self
        }

        ///Sends a `PUT` request to
        /// `/_cluster/routing/awareness/{attribute}/weights`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, attribute } = self;
            let attribute = attribute.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_cluster/routing/awareness/{}/weights",
                client.baseurl,
                encode_path(&attribute.to_string()),
            );
            let request = client.client.put(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cluster_get_settings`]
    ///
    ///[`Client::cluster_get_settings`]: super::Client::cluster_get_settings
    #[derive(Debug, Clone)]
    pub struct ClusterGetSettings<'a> {
        client: &'a super::Client,
        cluster_manager_timeout:
            Result<Option<types::ClusterGetSettingsClusterManagerTimeout>, String>,
        flat_settings: Result<Option<bool>, String>,
        include_defaults: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::ClusterGetSettingsMasterTimeout>, String>,
        timeout: Result<Option<types::ClusterGetSettingsTimeout>, String>,
    }

    impl<'a> ClusterGetSettings<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                cluster_manager_timeout: Ok(None),
                flat_settings: Ok(None),
                include_defaults: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
            }
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterGetSettingsClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `ClusterGetSettingsClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn flat_settings<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.flat_settings = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
            self
        }

        pub fn include_defaults<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.include_defaults = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for include_defaults failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterGetSettingsMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `ClusterGetSettingsMasterTimeout` for master_timeout failed"
                    .to_string()
            });
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterGetSettingsTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `ClusterGetSettingsTimeout` for timeout failed".to_string()
            });
            self
        }

        ///Sends a `GET` request to `/_cluster/settings`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ClusterGetSettingsResponseContent>, Error<()>> {
            let Self {
                client,
                cluster_manager_timeout,
                flat_settings,
                include_defaults,
                master_timeout,
                timeout,
            } = self;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
            let include_defaults = include_defaults.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_cluster/settings", client.baseurl,);
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &flat_settings {
                query.push(("flat_settings", v.to_string()));
            }
            if let Some(v) = &include_defaults {
                query.push(("include_defaults", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cluster_put_settings`]
    ///
    ///[`Client::cluster_put_settings`]: super::Client::cluster_put_settings
    #[derive(Debug, Clone)]
    pub struct ClusterPutSettings<'a> {
        client: &'a super::Client,
        cluster_manager_timeout:
            Result<Option<types::ClusterPutSettingsClusterManagerTimeout>, String>,
        flat_settings: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::ClusterPutSettingsMasterTimeout>, String>,
        timeout: Result<Option<types::ClusterPutSettingsTimeout>, String>,
        body: Result<types::builder::ClusterPutSettingsBodyParams, String>,
    }

    impl<'a> ClusterPutSettings<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                cluster_manager_timeout: Ok(None),
                flat_settings: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
                body: Ok(types::builder::ClusterPutSettingsBodyParams::default()),
            }
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterPutSettingsClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `ClusterPutSettingsClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn flat_settings<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.flat_settings = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterPutSettingsMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `ClusterPutSettingsMasterTimeout` for master_timeout failed"
                    .to_string()
            });
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterPutSettingsTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `ClusterPutSettingsTimeout` for timeout failed".to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterPutSettingsBodyParams>,
        {
            self.body = value.try_into().map(From::from).map_err(|_| {
                "conversion to `ClusterPutSettingsBodyParams` for body failed".to_string()
            });
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::ClusterPutSettingsBodyParams,
            ) -> types::builder::ClusterPutSettingsBodyParams,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `PUT` request to `/_cluster/settings`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ClusterPutSettingsResponseContent>, Error<()>> {
            let Self {
                client,
                cluster_manager_timeout,
                flat_settings,
                master_timeout,
                timeout,
                body,
            } = self;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(std::convert::TryInto::<types::ClusterPutSettingsBodyParams>::try_into)
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/_cluster/settings", client.baseurl,);
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &flat_settings {
                query.push(("flat_settings", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client
                .client
                .put(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cluster_state`]
    ///
    ///[`Client::cluster_state`]: super::Client::cluster_state
    #[derive(Debug, Clone)]
    pub struct ClusterState<'a> {
        client: &'a super::Client,
        allow_no_indices: Result<Option<bool>, String>,
        cluster_manager_timeout: Result<Option<types::ClusterStateClusterManagerTimeout>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        flat_settings: Result<Option<bool>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::ClusterStateMasterTimeout>, String>,
        wait_for_metadata_version: Result<Option<i32>, String>,
        wait_for_timeout: Result<Option<types::ClusterStateWaitForTimeout>, String>,
    }

    impl<'a> ClusterState<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                allow_no_indices: Ok(None),
                cluster_manager_timeout: Ok(None),
                expand_wildcards: Ok(None),
                flat_settings: Ok(None),
                ignore_unavailable: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
                wait_for_metadata_version: Ok(None),
                wait_for_timeout: Ok(None),
            }
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterStateClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `ClusterStateClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn flat_settings<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.flat_settings = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterStateMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `ClusterStateMasterTimeout` for master_timeout failed".to_string()
            });
            self
        }

        pub fn wait_for_metadata_version<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.wait_for_metadata_version = value.try_into().map(Some).map_err(|_| {
                "conversion to `i32` for wait_for_metadata_version failed".to_string()
            });
            self
        }

        pub fn wait_for_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterStateWaitForTimeout>,
        {
            self.wait_for_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `ClusterStateWaitForTimeout` for wait_for_timeout failed".to_string()
            });
            self
        }

        ///Sends a `GET` request to `/_cluster/state`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                allow_no_indices,
                cluster_manager_timeout,
                expand_wildcards,
                flat_settings,
                ignore_unavailable,
                local,
                master_timeout,
                wait_for_metadata_version,
                wait_for_timeout,
            } = self;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let wait_for_metadata_version =
                wait_for_metadata_version.map_err(Error::InvalidRequest)?;
            let wait_for_timeout = wait_for_timeout.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_cluster/state", client.baseurl,);
            let mut query = Vec::with_capacity(9usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &flat_settings {
                query.push(("flat_settings", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &wait_for_metadata_version {
                query.push(("wait_for_metadata_version", v.to_string()));
            }
            if let Some(v) = &wait_for_timeout {
                query.push(("wait_for_timeout", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cluster_state_with_metric`]
    ///
    ///[`Client::cluster_state_with_metric`]: super::Client::cluster_state_with_metric
    #[derive(Debug, Clone)]
    pub struct ClusterStateWithMetric<'a> {
        client: &'a super::Client,
        metric: Result<types::ClusterStateWithMetricMetric, String>,
        allow_no_indices: Result<Option<bool>, String>,
        cluster_manager_timeout:
            Result<Option<types::ClusterStateWithMetricClusterManagerTimeout>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        flat_settings: Result<Option<bool>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::ClusterStateWithMetricMasterTimeout>, String>,
        wait_for_metadata_version: Result<Option<i32>, String>,
        wait_for_timeout: Result<Option<types::ClusterStateWithMetricWaitForTimeout>, String>,
    }

    impl<'a> ClusterStateWithMetric<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                metric: Err("metric was not initialized".to_string()),
                allow_no_indices: Ok(None),
                cluster_manager_timeout: Ok(None),
                expand_wildcards: Ok(None),
                flat_settings: Ok(None),
                ignore_unavailable: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
                wait_for_metadata_version: Ok(None),
                wait_for_timeout: Ok(None),
            }
        }

        pub fn metric<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterStateWithMetricMetric>,
        {
            self.metric = value.try_into().map_err(|_| {
                "conversion to `ClusterStateWithMetricMetric` for metric failed".to_string()
            });
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterStateWithMetricClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `ClusterStateWithMetricClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn flat_settings<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.flat_settings = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterStateWithMetricMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `ClusterStateWithMetricMasterTimeout` for master_timeout failed"
                    .to_string()
            });
            self
        }

        pub fn wait_for_metadata_version<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.wait_for_metadata_version = value.try_into().map(Some).map_err(|_| {
                "conversion to `i32` for wait_for_metadata_version failed".to_string()
            });
            self
        }

        pub fn wait_for_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterStateWithMetricWaitForTimeout>,
        {
            self . wait_for_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `ClusterStateWithMetricWaitForTimeout` for wait_for_timeout failed" . to_string ()) ;
            self
        }

        ///Sends a `GET` request to `/_cluster/state/{metric}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                metric,
                allow_no_indices,
                cluster_manager_timeout,
                expand_wildcards,
                flat_settings,
                ignore_unavailable,
                local,
                master_timeout,
                wait_for_metadata_version,
                wait_for_timeout,
            } = self;
            let metric = metric.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let wait_for_metadata_version =
                wait_for_metadata_version.map_err(Error::InvalidRequest)?;
            let wait_for_timeout = wait_for_timeout.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_cluster/state/{}",
                client.baseurl,
                encode_path(&metric.to_string()),
            );
            let mut query = Vec::with_capacity(9usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &flat_settings {
                query.push(("flat_settings", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &wait_for_metadata_version {
                query.push(("wait_for_metadata_version", v.to_string()));
            }
            if let Some(v) = &wait_for_timeout {
                query.push(("wait_for_timeout", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cluster_state_with_index_metric`]
    ///
    ///[`Client::cluster_state_with_index_metric`]: super::Client::cluster_state_with_index_metric
    #[derive(Debug, Clone)]
    pub struct ClusterStateWithIndexMetric<'a> {
        client: &'a super::Client,
        metric: Result<types::ClusterStateWithIndexMetricMetric, String>,
        index: Result<types::ClusterStateWithIndexMetricIndex, String>,
        allow_no_indices: Result<Option<bool>, String>,
        cluster_manager_timeout:
            Result<Option<types::ClusterStateWithIndexMetricClusterManagerTimeout>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        flat_settings: Result<Option<bool>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::ClusterStateWithIndexMetricMasterTimeout>, String>,
        wait_for_metadata_version: Result<Option<i32>, String>,
        wait_for_timeout: Result<Option<types::ClusterStateWithIndexMetricWaitForTimeout>, String>,
    }

    impl<'a> ClusterStateWithIndexMetric<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                metric: Err("metric was not initialized".to_string()),
                index: Err("index was not initialized".to_string()),
                allow_no_indices: Ok(None),
                cluster_manager_timeout: Ok(None),
                expand_wildcards: Ok(None),
                flat_settings: Ok(None),
                ignore_unavailable: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
                wait_for_metadata_version: Ok(None),
                wait_for_timeout: Ok(None),
            }
        }

        pub fn metric<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterStateWithIndexMetricMetric>,
        {
            self.metric = value.try_into().map_err(|_| {
                "conversion to `ClusterStateWithIndexMetricMetric` for metric failed".to_string()
            });
            self
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterStateWithIndexMetricIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `ClusterStateWithIndexMetricIndex` for index failed".to_string()
            });
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterStateWithIndexMetricClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `ClusterStateWithIndexMetricClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn flat_settings<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.flat_settings = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterStateWithIndexMetricMasterTimeout>,
        {
            self . master_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `ClusterStateWithIndexMetricMasterTimeout` for master_timeout failed" . to_string ()) ;
            self
        }

        pub fn wait_for_metadata_version<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.wait_for_metadata_version = value.try_into().map(Some).map_err(|_| {
                "conversion to `i32` for wait_for_metadata_version failed".to_string()
            });
            self
        }

        pub fn wait_for_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterStateWithIndexMetricWaitForTimeout>,
        {
            self . wait_for_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `ClusterStateWithIndexMetricWaitForTimeout` for wait_for_timeout failed" . to_string ()) ;
            self
        }

        ///Sends a `GET` request to `/_cluster/state/{metric}/{index}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                metric,
                index,
                allow_no_indices,
                cluster_manager_timeout,
                expand_wildcards,
                flat_settings,
                ignore_unavailable,
                local,
                master_timeout,
                wait_for_metadata_version,
                wait_for_timeout,
            } = self;
            let metric = metric.map_err(Error::InvalidRequest)?;
            let index = index.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let wait_for_metadata_version =
                wait_for_metadata_version.map_err(Error::InvalidRequest)?;
            let wait_for_timeout = wait_for_timeout.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_cluster/state/{}/{}",
                client.baseurl,
                encode_path(&metric.to_string()),
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(9usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &flat_settings {
                query.push(("flat_settings", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &wait_for_metadata_version {
                query.push(("wait_for_metadata_version", v.to_string()));
            }
            if let Some(v) = &wait_for_timeout {
                query.push(("wait_for_timeout", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cluster_stats`]
    ///
    ///[`Client::cluster_stats`]: super::Client::cluster_stats
    #[derive(Debug, Clone)]
    pub struct ClusterStats<'a> {
        client: &'a super::Client,
        flat_settings: Result<Option<bool>, String>,
        timeout: Result<Option<types::ClusterStatsTimeout>, String>,
    }

    impl<'a> ClusterStats<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                flat_settings: Ok(None),
                timeout: Ok(None),
            }
        }

        pub fn flat_settings<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.flat_settings = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterStatsTimeout>,
        {
            self.timeout = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `ClusterStatsTimeout` for timeout failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_cluster/stats`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                flat_settings,
                timeout,
            } = self;
            let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_cluster/stats", client.baseurl,);
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &flat_settings {
                query.push(("flat_settings", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cluster_stats_with_node_id`]
    ///
    ///[`Client::cluster_stats_with_node_id`]: super::Client::cluster_stats_with_node_id
    #[derive(Debug, Clone)]
    pub struct ClusterStatsWithNodeId<'a> {
        client: &'a super::Client,
        node_id: Result<types::ClusterStatsWithNodeIdNodeId, String>,
        flat_settings: Result<Option<bool>, String>,
        timeout: Result<Option<types::ClusterStatsWithNodeIdTimeout>, String>,
    }

    impl<'a> ClusterStatsWithNodeId<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                node_id: Err("node_id was not initialized".to_string()),
                flat_settings: Ok(None),
                timeout: Ok(None),
            }
        }

        pub fn node_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterStatsWithNodeIdNodeId>,
        {
            self.node_id = value.try_into().map_err(|_| {
                "conversion to `ClusterStatsWithNodeIdNodeId` for node_id failed".to_string()
            });
            self
        }

        pub fn flat_settings<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.flat_settings = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterStatsWithNodeIdTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `ClusterStatsWithNodeIdTimeout` for timeout failed".to_string()
            });
            self
        }

        ///Sends a `GET` request to `/_cluster/stats/nodes/{node_id}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                node_id,
                flat_settings,
                timeout,
            } = self;
            let node_id = node_id.map_err(Error::InvalidRequest)?;
            let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_cluster/stats/nodes/{}",
                client.baseurl,
                encode_path(&node_id.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &flat_settings {
                query.push(("flat_settings", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cluster_post_voting_config_exclusions`]
    ///
    ///[`Client::cluster_post_voting_config_exclusions`]: super::Client::cluster_post_voting_config_exclusions
    #[derive(Debug, Clone)]
    pub struct ClusterPostVotingConfigExclusions<'a> {
        client: &'a super::Client,
        node_ids: Result<Option<String>, String>,
        node_names: Result<Option<String>, String>,
        timeout: Result<Option<types::ClusterPostVotingConfigExclusionsTimeout>, String>,
    }

    impl<'a> ClusterPostVotingConfigExclusions<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                node_ids: Ok(None),
                node_names: Ok(None),
                timeout: Ok(None),
            }
        }

        pub fn node_ids<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.node_ids = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for node_ids failed".to_string());
            self
        }

        pub fn node_names<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.node_names = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for node_names failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterPostVotingConfigExclusionsTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `ClusterPostVotingConfigExclusionsTimeout` for timeout failed"
                    .to_string()
            });
            self
        }

        ///Sends a `POST` request to `/_cluster/voting_config_exclusions`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                node_ids,
                node_names,
                timeout,
            } = self;
            let node_ids = node_ids.map_err(Error::InvalidRequest)?;
            let node_names = node_names.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_cluster/voting_config_exclusions", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &node_ids {
                query.push(("node_ids", v.to_string()));
            }
            if let Some(v) = &node_names {
                query.push(("node_names", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client.client.post(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cluster_delete_voting_config_exclusions`]
    ///
    ///[`Client::cluster_delete_voting_config_exclusions`]: super::Client::cluster_delete_voting_config_exclusions
    #[derive(Debug, Clone)]
    pub struct ClusterDeleteVotingConfigExclusions<'a> {
        client: &'a super::Client,
        wait_for_removal: Result<Option<bool>, String>,
    }

    impl<'a> ClusterDeleteVotingConfigExclusions<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                wait_for_removal: Ok(None),
            }
        }

        pub fn wait_for_removal<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.wait_for_removal = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for wait_for_removal failed".to_string());
            self
        }

        ///Sends a `DELETE` request to `/_cluster/voting_config_exclusions`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                wait_for_removal,
            } = self;
            let wait_for_removal = wait_for_removal.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_cluster/voting_config_exclusions", client.baseurl,);
            let mut query = Vec::with_capacity(1usize);
            if let Some(v) = &wait_for_removal {
                query.push(("wait_for_removal", v.to_string()));
            }
            let request = client.client.delete(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cluster_get_component_template`]
    ///
    ///[`Client::cluster_get_component_template`]: super::Client::cluster_get_component_template
    #[derive(Debug, Clone)]
    pub struct ClusterGetComponentTemplate<'a> {
        client: &'a super::Client,
        cluster_manager_timeout:
            Result<Option<types::ClusterGetComponentTemplateClusterManagerTimeout>, String>,
        local: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::ClusterGetComponentTemplateMasterTimeout>, String>,
    }

    impl<'a> ClusterGetComponentTemplate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                cluster_manager_timeout: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
            }
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterGetComponentTemplateClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `ClusterGetComponentTemplateClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterGetComponentTemplateMasterTimeout>,
        {
            self . master_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `ClusterGetComponentTemplateMasterTimeout` for master_timeout failed" . to_string ()) ;
            self
        }

        ///Sends a `GET` request to `/_component_template`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                cluster_manager_timeout,
                local,
                master_timeout,
            } = self;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_component_template", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cluster_get_component_template_with_name`]
    ///
    ///[`Client::cluster_get_component_template_with_name`]: super::Client::cluster_get_component_template_with_name
    #[derive(Debug, Clone)]
    pub struct ClusterGetComponentTemplateWithName<'a> {
        client: &'a super::Client,
        name: Result<types::ClusterGetComponentTemplateWithNameName, String>,
        cluster_manager_timeout:
            Result<Option<types::ClusterGetComponentTemplateWithNameClusterManagerTimeout>, String>,
        local: Result<Option<bool>, String>,
        master_timeout:
            Result<Option<types::ClusterGetComponentTemplateWithNameMasterTimeout>, String>,
    }

    impl<'a> ClusterGetComponentTemplateWithName<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                name: Err("name was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
            }
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterGetComponentTemplateWithNameName>,
        {
            self.name = value.try_into().map_err(|_| {
                "conversion to `ClusterGetComponentTemplateWithNameName` for name failed"
                    .to_string()
            });
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<
                types::ClusterGetComponentTemplateWithNameClusterManagerTimeout,
            >,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `ClusterGetComponentTemplateWithNameClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterGetComponentTemplateWithNameMasterTimeout>,
        {
            self . master_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `ClusterGetComponentTemplateWithNameMasterTimeout` for master_timeout failed" . to_string ()) ;
            self
        }

        ///Sends a `GET` request to `/_component_template/{name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                name,
                cluster_manager_timeout,
                local,
                master_timeout,
            } = self;
            let name = name.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_component_template/{}",
                client.baseurl,
                encode_path(&name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cluster_put_component_template_put`]
    ///
    ///[`Client::cluster_put_component_template_put`]: super::Client::cluster_put_component_template_put
    #[derive(Debug, Clone)]
    pub struct ClusterPutComponentTemplatePut<'a> {
        client: &'a super::Client,
        name: Result<types::ClusterPutComponentTemplatePutName, String>,
        cluster_manager_timeout:
            Result<Option<types::ClusterPutComponentTemplatePutClusterManagerTimeout>, String>,
        create: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::ClusterPutComponentTemplatePutMasterTimeout>, String>,
        timeout: Result<Option<types::ClusterPutComponentTemplatePutTimeout>, String>,
        body: Result<types::ClusterPutComponentTemplateBodyParams, String>,
    }

    impl<'a> ClusterPutComponentTemplatePut<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                name: Err("name was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                create: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterPutComponentTemplatePutName>,
        {
            self.name = value.try_into().map_err(|_| {
                "conversion to `ClusterPutComponentTemplatePutName` for name failed".to_string()
            });
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterPutComponentTemplatePutClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `ClusterPutComponentTemplatePutClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn create<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.create = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for create failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterPutComponentTemplatePutMasterTimeout>,
        {
            self . master_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `ClusterPutComponentTemplatePutMasterTimeout` for master_timeout failed" . to_string ()) ;
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterPutComponentTemplatePutTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `ClusterPutComponentTemplatePutTimeout` for timeout failed"
                    .to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterPutComponentTemplateBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `ClusterPutComponentTemplateBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `PUT` request to `/_component_template/{name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                name,
                cluster_manager_timeout,
                create,
                master_timeout,
                timeout,
                body,
            } = self;
            let name = name.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let create = create.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_component_template/{}",
                client.baseurl,
                encode_path(&name.to_string()),
            );
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &create {
                query.push(("create", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client.client.put(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cluster_put_component_template_post`]
    ///
    ///[`Client::cluster_put_component_template_post`]: super::Client::cluster_put_component_template_post
    #[derive(Debug, Clone)]
    pub struct ClusterPutComponentTemplatePost<'a> {
        client: &'a super::Client,
        name: Result<types::ClusterPutComponentTemplatePostName, String>,
        cluster_manager_timeout:
            Result<Option<types::ClusterPutComponentTemplatePostClusterManagerTimeout>, String>,
        create: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::ClusterPutComponentTemplatePostMasterTimeout>, String>,
        timeout: Result<Option<types::ClusterPutComponentTemplatePostTimeout>, String>,
        body: Result<types::ClusterPutComponentTemplateBodyParams, String>,
    }

    impl<'a> ClusterPutComponentTemplatePost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                name: Err("name was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                create: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterPutComponentTemplatePostName>,
        {
            self.name = value.try_into().map_err(|_| {
                "conversion to `ClusterPutComponentTemplatePostName` for name failed".to_string()
            });
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterPutComponentTemplatePostClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `ClusterPutComponentTemplatePostClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn create<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.create = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for create failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterPutComponentTemplatePostMasterTimeout>,
        {
            self . master_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `ClusterPutComponentTemplatePostMasterTimeout` for master_timeout failed" . to_string ()) ;
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterPutComponentTemplatePostTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `ClusterPutComponentTemplatePostTimeout` for timeout failed"
                    .to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterPutComponentTemplateBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `ClusterPutComponentTemplateBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `POST` request to `/_component_template/{name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                name,
                cluster_manager_timeout,
                create,
                master_timeout,
                timeout,
                body,
            } = self;
            let name = name.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let create = create.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_component_template/{}",
                client.baseurl,
                encode_path(&name.to_string()),
            );
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &create {
                query.push(("create", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cluster_delete_component_template`]
    ///
    ///[`Client::cluster_delete_component_template`]: super::Client::cluster_delete_component_template
    #[derive(Debug, Clone)]
    pub struct ClusterDeleteComponentTemplate<'a> {
        client: &'a super::Client,
        name: Result<types::ClusterDeleteComponentTemplateName, String>,
        cluster_manager_timeout:
            Result<Option<types::ClusterDeleteComponentTemplateClusterManagerTimeout>, String>,
        master_timeout: Result<Option<types::ClusterDeleteComponentTemplateMasterTimeout>, String>,
        timeout: Result<Option<types::ClusterDeleteComponentTemplateTimeout>, String>,
    }

    impl<'a> ClusterDeleteComponentTemplate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                name: Err("name was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
            }
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterDeleteComponentTemplateName>,
        {
            self.name = value.try_into().map_err(|_| {
                "conversion to `ClusterDeleteComponentTemplateName` for name failed".to_string()
            });
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterDeleteComponentTemplateClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `ClusterDeleteComponentTemplateClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterDeleteComponentTemplateMasterTimeout>,
        {
            self . master_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `ClusterDeleteComponentTemplateMasterTimeout` for master_timeout failed" . to_string ()) ;
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterDeleteComponentTemplateTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `ClusterDeleteComponentTemplateTimeout` for timeout failed"
                    .to_string()
            });
            self
        }

        ///Sends a `DELETE` request to `/_component_template/{name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                name,
                cluster_manager_timeout,
                master_timeout,
                timeout,
            } = self;
            let name = name.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_component_template/{}",
                client.baseurl,
                encode_path(&name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client.client.delete(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cluster_exists_component_template`]
    ///
    ///[`Client::cluster_exists_component_template`]: super::Client::cluster_exists_component_template
    #[derive(Debug, Clone)]
    pub struct ClusterExistsComponentTemplate<'a> {
        client: &'a super::Client,
        name: Result<types::ClusterExistsComponentTemplateName, String>,
        local: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::ClusterExistsComponentTemplateMasterTimeout>, String>,
    }

    impl<'a> ClusterExistsComponentTemplate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                name: Err("name was not initialized".to_string()),
                local: Ok(None),
                master_timeout: Ok(None),
            }
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterExistsComponentTemplateName>,
        {
            self.name = value.try_into().map_err(|_| {
                "conversion to `ClusterExistsComponentTemplateName` for name failed".to_string()
            });
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClusterExistsComponentTemplateMasterTimeout>,
        {
            self . master_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `ClusterExistsComponentTemplateMasterTimeout` for master_timeout failed" . to_string ()) ;
            self
        }

        ///Sends a `HEAD` request to `/_component_template/{name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                name,
                local,
                master_timeout,
            } = self;
            let name = name.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_component_template/{}",
                client.baseurl,
                encode_path(&name.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            let request = client.client.head(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::count_get`]
    ///
    ///[`Client::count_get`]: super::Client::count_get
    #[derive(Debug, Clone)]
    pub struct CountGet<'a> {
        client: &'a super::Client,
        allow_no_indices: Result<Option<bool>, String>,
        analyze_wildcard: Result<Option<bool>, String>,
        analyzer: Result<Option<String>, String>,
        default_operator: Result<Option<types::DefaultOperator>, String>,
        df: Result<Option<String>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_throttled: Result<Option<bool>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        lenient: Result<Option<bool>, String>,
        min_score: Result<Option<i32>, String>,
        preference: Result<Option<String>, String>,
        q: Result<Option<String>, String>,
        routing: Result<Option<Vec<String>>, String>,
        terminate_after: Result<Option<i32>, String>,
    }

    impl<'a> CountGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                allow_no_indices: Ok(None),
                analyze_wildcard: Ok(None),
                analyzer: Ok(None),
                default_operator: Ok(None),
                df: Ok(None),
                expand_wildcards: Ok(None),
                ignore_throttled: Ok(None),
                ignore_unavailable: Ok(None),
                lenient: Ok(None),
                min_score: Ok(None),
                preference: Ok(None),
                q: Ok(None),
                routing: Ok(None),
                terminate_after: Ok(None),
            }
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn analyze_wildcard<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.analyze_wildcard = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for analyze_wildcard failed".to_string());
            self
        }

        pub fn analyzer<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.analyzer = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for analyzer failed".to_string());
            self
        }

        pub fn default_operator<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DefaultOperator>,
        {
            self.default_operator = value.try_into().map(Some).map_err(|_| {
                "conversion to `DefaultOperator` for default_operator failed".to_string()
            });
            self
        }

        pub fn df<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.df = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for df failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_throttled<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_throttled = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_throttled failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn lenient<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.lenient = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for lenient failed".to_string());
            self
        }

        pub fn min_score<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.min_score = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for min_score failed".to_string());
            self
        }

        pub fn preference<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.preference = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for preference failed".to_string());
            self
        }

        pub fn q<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.q = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for q failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for routing failed".to_string());
            self
        }

        pub fn terminate_after<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.terminate_after = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for terminate_after failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_count`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                allow_no_indices,
                analyze_wildcard,
                analyzer,
                default_operator,
                df,
                expand_wildcards,
                ignore_throttled,
                ignore_unavailable,
                lenient,
                min_score,
                preference,
                q,
                routing,
                terminate_after,
            } = self;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let analyze_wildcard = analyze_wildcard.map_err(Error::InvalidRequest)?;
            let analyzer = analyzer.map_err(Error::InvalidRequest)?;
            let default_operator = default_operator.map_err(Error::InvalidRequest)?;
            let df = df.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_throttled = ignore_throttled.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let lenient = lenient.map_err(Error::InvalidRequest)?;
            let min_score = min_score.map_err(Error::InvalidRequest)?;
            let preference = preference.map_err(Error::InvalidRequest)?;
            let q = q.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let terminate_after = terminate_after.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_count", client.baseurl,);
            let mut query = Vec::with_capacity(14usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &analyze_wildcard {
                query.push(("analyze_wildcard", v.to_string()));
            }
            if let Some(v) = &analyzer {
                query.push(("analyzer", v.to_string()));
            }
            if let Some(v) = &default_operator {
                query.push(("default_operator", v.to_string()));
            }
            if let Some(v) = &df {
                query.push(("df", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_throttled {
                query.push(("ignore_throttled", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &lenient {
                query.push(("lenient", v.to_string()));
            }
            if let Some(v) = &min_score {
                query.push(("min_score", v.to_string()));
            }
            if let Some(v) = &preference {
                query.push(("preference", v.to_string()));
            }
            if let Some(v) = &q {
                query.push(("q", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &terminate_after {
                query.push(("terminate_after", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::count_post`]
    ///
    ///[`Client::count_post`]: super::Client::count_post
    #[derive(Debug, Clone)]
    pub struct CountPost<'a> {
        client: &'a super::Client,
        allow_no_indices: Result<Option<bool>, String>,
        analyze_wildcard: Result<Option<bool>, String>,
        analyzer: Result<Option<String>, String>,
        default_operator: Result<Option<types::DefaultOperator>, String>,
        df: Result<Option<String>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_throttled: Result<Option<bool>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        lenient: Result<Option<bool>, String>,
        min_score: Result<Option<i32>, String>,
        preference: Result<Option<String>, String>,
        q: Result<Option<String>, String>,
        routing: Result<Option<Vec<String>>, String>,
        terminate_after: Result<Option<i32>, String>,
        body: Result<types::CountBodyParams, String>,
    }

    impl<'a> CountPost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                allow_no_indices: Ok(None),
                analyze_wildcard: Ok(None),
                analyzer: Ok(None),
                default_operator: Ok(None),
                df: Ok(None),
                expand_wildcards: Ok(None),
                ignore_throttled: Ok(None),
                ignore_unavailable: Ok(None),
                lenient: Ok(None),
                min_score: Ok(None),
                preference: Ok(None),
                q: Ok(None),
                routing: Ok(None),
                terminate_after: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn analyze_wildcard<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.analyze_wildcard = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for analyze_wildcard failed".to_string());
            self
        }

        pub fn analyzer<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.analyzer = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for analyzer failed".to_string());
            self
        }

        pub fn default_operator<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DefaultOperator>,
        {
            self.default_operator = value.try_into().map(Some).map_err(|_| {
                "conversion to `DefaultOperator` for default_operator failed".to_string()
            });
            self
        }

        pub fn df<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.df = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for df failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_throttled<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_throttled = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_throttled failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn lenient<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.lenient = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for lenient failed".to_string());
            self
        }

        pub fn min_score<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.min_score = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for min_score failed".to_string());
            self
        }

        pub fn preference<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.preference = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for preference failed".to_string());
            self
        }

        pub fn q<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.q = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for q failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for routing failed".to_string());
            self
        }

        pub fn terminate_after<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.terminate_after = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for terminate_after failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CountBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `CountBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `POST` request to `/_count`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                allow_no_indices,
                analyze_wildcard,
                analyzer,
                default_operator,
                df,
                expand_wildcards,
                ignore_throttled,
                ignore_unavailable,
                lenient,
                min_score,
                preference,
                q,
                routing,
                terminate_after,
                body,
            } = self;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let analyze_wildcard = analyze_wildcard.map_err(Error::InvalidRequest)?;
            let analyzer = analyzer.map_err(Error::InvalidRequest)?;
            let default_operator = default_operator.map_err(Error::InvalidRequest)?;
            let df = df.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_throttled = ignore_throttled.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let lenient = lenient.map_err(Error::InvalidRequest)?;
            let min_score = min_score.map_err(Error::InvalidRequest)?;
            let preference = preference.map_err(Error::InvalidRequest)?;
            let q = q.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let terminate_after = terminate_after.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_count", client.baseurl,);
            let mut query = Vec::with_capacity(14usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &analyze_wildcard {
                query.push(("analyze_wildcard", v.to_string()));
            }
            if let Some(v) = &analyzer {
                query.push(("analyzer", v.to_string()));
            }
            if let Some(v) = &default_operator {
                query.push(("default_operator", v.to_string()));
            }
            if let Some(v) = &df {
                query.push(("df", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_throttled {
                query.push(("ignore_throttled", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &lenient {
                query.push(("lenient", v.to_string()));
            }
            if let Some(v) = &min_score {
                query.push(("min_score", v.to_string()));
            }
            if let Some(v) = &preference {
                query.push(("preference", v.to_string()));
            }
            if let Some(v) = &q {
                query.push(("q", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &terminate_after {
                query.push(("terminate_after", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::dangling_indices_list_dangling_indices`]
    ///
    ///[`Client::dangling_indices_list_dangling_indices`]: super::Client::dangling_indices_list_dangling_indices
    #[derive(Debug, Clone)]
    pub struct DanglingIndicesListDanglingIndices<'a> {
        client: &'a super::Client,
    }

    impl<'a> DanglingIndicesListDanglingIndices<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        ///Sends a `GET` request to `/_dangling`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/_dangling", client.baseurl,);
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::dangling_indices_import_dangling_index`]
    ///
    ///[`Client::dangling_indices_import_dangling_index`]: super::Client::dangling_indices_import_dangling_index
    #[derive(Debug, Clone)]
    pub struct DanglingIndicesImportDanglingIndex<'a> {
        client: &'a super::Client,
        index_uuid: Result<types::DanglingIndicesImportDanglingIndexIndexUuid, String>,
        accept_data_loss: Result<Option<bool>, String>,
        cluster_manager_timeout:
            Result<Option<types::DanglingIndicesImportDanglingIndexClusterManagerTimeout>, String>,
        master_timeout:
            Result<Option<types::DanglingIndicesImportDanglingIndexMasterTimeout>, String>,
        timeout: Result<Option<types::DanglingIndicesImportDanglingIndexTimeout>, String>,
    }

    impl<'a> DanglingIndicesImportDanglingIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index_uuid: Err("index_uuid was not initialized".to_string()),
                accept_data_loss: Ok(None),
                cluster_manager_timeout: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
            }
        }

        pub fn index_uuid<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DanglingIndicesImportDanglingIndexIndexUuid>,
        {
            self . index_uuid = value . try_into () . map_err (| _ | "conversion to `DanglingIndicesImportDanglingIndexIndexUuid` for index_uuid failed" . to_string ()) ;
            self
        }

        pub fn accept_data_loss<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.accept_data_loss = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for accept_data_loss failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<
                types::DanglingIndicesImportDanglingIndexClusterManagerTimeout,
            >,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `DanglingIndicesImportDanglingIndexClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DanglingIndicesImportDanglingIndexMasterTimeout>,
        {
            self . master_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `DanglingIndicesImportDanglingIndexMasterTimeout` for master_timeout failed" . to_string ()) ;
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DanglingIndicesImportDanglingIndexTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `DanglingIndicesImportDanglingIndexTimeout` for timeout failed"
                    .to_string()
            });
            self
        }

        ///Sends a `POST` request to `/_dangling/{index_uuid}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index_uuid,
                accept_data_loss,
                cluster_manager_timeout,
                master_timeout,
                timeout,
            } = self;
            let index_uuid = index_uuid.map_err(Error::InvalidRequest)?;
            let accept_data_loss = accept_data_loss.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_dangling/{}",
                client.baseurl,
                encode_path(&index_uuid.to_string()),
            );
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &accept_data_loss {
                query.push(("accept_data_loss", v.to_string()));
            }
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client.client.post(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::dangling_indices_delete_dangling_index`]
    ///
    ///[`Client::dangling_indices_delete_dangling_index`]: super::Client::dangling_indices_delete_dangling_index
    #[derive(Debug, Clone)]
    pub struct DanglingIndicesDeleteDanglingIndex<'a> {
        client: &'a super::Client,
        index_uuid: Result<types::DanglingIndicesDeleteDanglingIndexIndexUuid, String>,
        accept_data_loss: Result<Option<bool>, String>,
        cluster_manager_timeout:
            Result<Option<types::DanglingIndicesDeleteDanglingIndexClusterManagerTimeout>, String>,
        master_timeout:
            Result<Option<types::DanglingIndicesDeleteDanglingIndexMasterTimeout>, String>,
        timeout: Result<Option<types::DanglingIndicesDeleteDanglingIndexTimeout>, String>,
    }

    impl<'a> DanglingIndicesDeleteDanglingIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index_uuid: Err("index_uuid was not initialized".to_string()),
                accept_data_loss: Ok(None),
                cluster_manager_timeout: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
            }
        }

        pub fn index_uuid<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DanglingIndicesDeleteDanglingIndexIndexUuid>,
        {
            self . index_uuid = value . try_into () . map_err (| _ | "conversion to `DanglingIndicesDeleteDanglingIndexIndexUuid` for index_uuid failed" . to_string ()) ;
            self
        }

        pub fn accept_data_loss<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.accept_data_loss = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for accept_data_loss failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<
                types::DanglingIndicesDeleteDanglingIndexClusterManagerTimeout,
            >,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `DanglingIndicesDeleteDanglingIndexClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DanglingIndicesDeleteDanglingIndexMasterTimeout>,
        {
            self . master_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `DanglingIndicesDeleteDanglingIndexMasterTimeout` for master_timeout failed" . to_string ()) ;
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DanglingIndicesDeleteDanglingIndexTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `DanglingIndicesDeleteDanglingIndexTimeout` for timeout failed"
                    .to_string()
            });
            self
        }

        ///Sends a `DELETE` request to `/_dangling/{index_uuid}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index_uuid,
                accept_data_loss,
                cluster_manager_timeout,
                master_timeout,
                timeout,
            } = self;
            let index_uuid = index_uuid.map_err(Error::InvalidRequest)?;
            let accept_data_loss = accept_data_loss.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_dangling/{}",
                client.baseurl,
                encode_path(&index_uuid.to_string()),
            );
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &accept_data_loss {
                query.push(("accept_data_loss", v.to_string()));
            }
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client.client.delete(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_get_data_stream`]
    ///
    ///[`Client::indices_get_data_stream`]: super::Client::indices_get_data_stream
    #[derive(Debug, Clone)]
    pub struct IndicesGetDataStream<'a> {
        client: &'a super::Client,
    }

    impl<'a> IndicesGetDataStream<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        ///Sends a `GET` request to `/_data_stream`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::IndicesGetDataStreamResponseContent>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/_data_stream", client.baseurl,);
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_data_streams_stats`]
    ///
    ///[`Client::indices_data_streams_stats`]: super::Client::indices_data_streams_stats
    #[derive(Debug, Clone)]
    pub struct IndicesDataStreamsStats<'a> {
        client: &'a super::Client,
    }

    impl<'a> IndicesDataStreamsStats<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        ///Sends a `GET` request to `/_data_stream/_stats`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/_data_stream/_stats", client.baseurl,);
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_get_data_stream_with_name`]
    ///
    ///[`Client::indices_get_data_stream_with_name`]: super::Client::indices_get_data_stream_with_name
    #[derive(Debug, Clone)]
    pub struct IndicesGetDataStreamWithName<'a> {
        client: &'a super::Client,
        name: Result<types::IndicesGetDataStreamWithNameName, String>,
    }

    impl<'a> IndicesGetDataStreamWithName<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                name: Err("name was not initialized".to_string()),
            }
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesGetDataStreamWithNameName>,
        {
            self.name = value.try_into().map_err(|_| {
                "conversion to `IndicesGetDataStreamWithNameName` for name failed".to_string()
            });
            self
        }

        ///Sends a `GET` request to `/_data_stream/{name}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::IndicesGetDataStreamWithNameResponseContent>, Error<()>>
        {
            let Self { client, name } = self;
            let name = name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_data_stream/{}",
                client.baseurl,
                encode_path(&name.to_string()),
            );
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_create_data_stream`]
    ///
    ///[`Client::indices_create_data_stream`]: super::Client::indices_create_data_stream
    #[derive(Debug, Clone)]
    pub struct IndicesCreateDataStream<'a> {
        client: &'a super::Client,
        name: Result<types::IndicesCreateDataStreamName, String>,
        body: Result<types::IndicesCreateDataStreamBodyParams, String>,
    }

    impl<'a> IndicesCreateDataStream<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                name: Err("name was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesCreateDataStreamName>,
        {
            self.name = value.try_into().map_err(|_| {
                "conversion to `IndicesCreateDataStreamName` for name failed".to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesCreateDataStreamBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `IndicesCreateDataStreamBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `PUT` request to `/_data_stream/{name}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::IndicesCreateDataStreamResponseContent>, Error<()>>
        {
            let Self { client, name, body } = self;
            let name = name.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_data_stream/{}",
                client.baseurl,
                encode_path(&name.to_string()),
            );
            let request = client
                .client
                .put(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_delete_data_stream`]
    ///
    ///[`Client::indices_delete_data_stream`]: super::Client::indices_delete_data_stream
    #[derive(Debug, Clone)]
    pub struct IndicesDeleteDataStream<'a> {
        client: &'a super::Client,
        name: Result<types::IndicesDeleteDataStreamName, String>,
    }

    impl<'a> IndicesDeleteDataStream<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                name: Err("name was not initialized".to_string()),
            }
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesDeleteDataStreamName>,
        {
            self.name = value.try_into().map_err(|_| {
                "conversion to `IndicesDeleteDataStreamName` for name failed".to_string()
            });
            self
        }

        ///Sends a `DELETE` request to `/_data_stream/{name}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::IndicesDeleteDataStreamResponseContent>, Error<()>>
        {
            let Self { client, name } = self;
            let name = name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_data_stream/{}",
                client.baseurl,
                encode_path(&name.to_string()),
            );
            let request = client
                .client
                .delete(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_data_streams_stats_with_name`]
    ///
    ///[`Client::indices_data_streams_stats_with_name`]: super::Client::indices_data_streams_stats_with_name
    #[derive(Debug, Clone)]
    pub struct IndicesDataStreamsStatsWithName<'a> {
        client: &'a super::Client,
        name: Result<types::IndicesDataStreamsStatsWithNameName, String>,
    }

    impl<'a> IndicesDataStreamsStatsWithName<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                name: Err("name was not initialized".to_string()),
            }
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesDataStreamsStatsWithNameName>,
        {
            self.name = value.try_into().map_err(|_| {
                "conversion to `IndicesDataStreamsStatsWithNameName` for name failed".to_string()
            });
            self
        }

        ///Sends a `GET` request to `/_data_stream/{name}/_stats`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, name } = self;
            let name = name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_data_stream/{}/_stats",
                client.baseurl,
                encode_path(&name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::delete_by_query_rethrottle`]
    ///
    ///[`Client::delete_by_query_rethrottle`]: super::Client::delete_by_query_rethrottle
    #[derive(Debug, Clone)]
    pub struct DeleteByQueryRethrottle<'a> {
        client: &'a super::Client,
        task_id: Result<types::DeleteByQueryRethrottleTaskId, String>,
        requests_per_second: Result<i32, String>,
    }

    impl<'a> DeleteByQueryRethrottle<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                task_id: Err("task_id was not initialized".to_string()),
                requests_per_second: Err("requests_per_second was not initialized".to_string()),
            }
        }

        pub fn task_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DeleteByQueryRethrottleTaskId>,
        {
            self.task_id = value.try_into().map_err(|_| {
                "conversion to `DeleteByQueryRethrottleTaskId` for task_id failed".to_string()
            });
            self
        }

        pub fn requests_per_second<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.requests_per_second = value
                .try_into()
                .map_err(|_| "conversion to `i32` for requests_per_second failed".to_string());
            self
        }

        ///Sends a `POST` request to `/_delete_by_query/{task_id}/_rethrottle`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                task_id,
                requests_per_second,
            } = self;
            let task_id = task_id.map_err(Error::InvalidRequest)?;
            let requests_per_second = requests_per_second.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_delete_by_query/{}/_rethrottle",
                client.baseurl,
                encode_path(&task_id.to_string()),
            );
            let mut query = Vec::with_capacity(1usize);
            query.push(("requests_per_second", requests_per_second.to_string()));
            let request = client.client.post(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::field_caps_get`]
    ///
    ///[`Client::field_caps_get`]: super::Client::field_caps_get
    #[derive(Debug, Clone)]
    pub struct FieldCapsGet<'a> {
        client: &'a super::Client,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        fields: Result<Option<Vec<String>>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        include_unmapped: Result<Option<bool>, String>,
    }

    impl<'a> FieldCapsGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                fields: Ok(None),
                ignore_unavailable: Ok(None),
                include_unmapped: Ok(None),
            }
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.fields = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn include_unmapped<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.include_unmapped = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for include_unmapped failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_field_caps`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                allow_no_indices,
                expand_wildcards,
                fields,
                ignore_unavailable,
                include_unmapped,
            } = self;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let fields = fields.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let include_unmapped = include_unmapped.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_field_caps", client.baseurl,);
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &fields {
                query.push(("fields", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &include_unmapped {
                query.push(("include_unmapped", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::field_caps_post`]
    ///
    ///[`Client::field_caps_post`]: super::Client::field_caps_post
    #[derive(Debug, Clone)]
    pub struct FieldCapsPost<'a> {
        client: &'a super::Client,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        fields: Result<Option<Vec<String>>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        include_unmapped: Result<Option<bool>, String>,
        body: Result<types::FieldCapsBodyParams, String>,
    }

    impl<'a> FieldCapsPost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                fields: Ok(None),
                ignore_unavailable: Ok(None),
                include_unmapped: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.fields = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn include_unmapped<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.include_unmapped = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for include_unmapped failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::FieldCapsBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `FieldCapsBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `POST` request to `/_field_caps`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                allow_no_indices,
                expand_wildcards,
                fields,
                ignore_unavailable,
                include_unmapped,
                body,
            } = self;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let fields = fields.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let include_unmapped = include_unmapped.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_field_caps", client.baseurl,);
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &fields {
                query.push(("fields", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &include_unmapped {
                query.push(("include_unmapped", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_flush_get`]
    ///
    ///[`Client::indices_flush_get`]: super::Client::indices_flush_get
    #[derive(Debug, Clone)]
    pub struct IndicesFlushGet<'a> {
        client: &'a super::Client,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        force: Result<Option<bool>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        wait_if_ongoing: Result<Option<bool>, String>,
    }

    impl<'a> IndicesFlushGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                force: Ok(None),
                ignore_unavailable: Ok(None),
                wait_if_ongoing: Ok(None),
            }
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn force<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.force = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for force failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn wait_if_ongoing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.wait_if_ongoing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for wait_if_ongoing failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_flush`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                allow_no_indices,
                expand_wildcards,
                force,
                ignore_unavailable,
                wait_if_ongoing,
            } = self;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let force = force.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let wait_if_ongoing = wait_if_ongoing.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_flush", client.baseurl,);
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &force {
                query.push(("force", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &wait_if_ongoing {
                query.push(("wait_if_ongoing", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_flush_post`]
    ///
    ///[`Client::indices_flush_post`]: super::Client::indices_flush_post
    #[derive(Debug, Clone)]
    pub struct IndicesFlushPost<'a> {
        client: &'a super::Client,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        force: Result<Option<bool>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        wait_if_ongoing: Result<Option<bool>, String>,
    }

    impl<'a> IndicesFlushPost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                force: Ok(None),
                ignore_unavailable: Ok(None),
                wait_if_ongoing: Ok(None),
            }
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn force<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.force = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for force failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn wait_if_ongoing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.wait_if_ongoing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for wait_if_ongoing failed".to_string());
            self
        }

        ///Sends a `POST` request to `/_flush`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                allow_no_indices,
                expand_wildcards,
                force,
                ignore_unavailable,
                wait_if_ongoing,
            } = self;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let force = force.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let wait_if_ongoing = wait_if_ongoing.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_flush", client.baseurl,);
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &force {
                query.push(("force", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &wait_if_ongoing {
                query.push(("wait_if_ongoing", v.to_string()));
            }
            let request = client.client.post(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_forcemerge`]
    ///
    ///[`Client::indices_forcemerge`]: super::Client::indices_forcemerge
    #[derive(Debug, Clone)]
    pub struct IndicesForcemerge<'a> {
        client: &'a super::Client,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        flush: Result<Option<bool>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        max_num_segments: Result<Option<i32>, String>,
        only_expunge_deletes: Result<Option<bool>, String>,
    }

    impl<'a> IndicesForcemerge<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                flush: Ok(None),
                ignore_unavailable: Ok(None),
                max_num_segments: Ok(None),
                only_expunge_deletes: Ok(None),
            }
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn flush<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.flush = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for flush failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn max_num_segments<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.max_num_segments = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for max_num_segments failed".to_string());
            self
        }

        pub fn only_expunge_deletes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.only_expunge_deletes = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for only_expunge_deletes failed".to_string());
            self
        }

        ///Sends a `POST` request to `/_forcemerge`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                allow_no_indices,
                expand_wildcards,
                flush,
                ignore_unavailable,
                max_num_segments,
                only_expunge_deletes,
            } = self;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let flush = flush.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let max_num_segments = max_num_segments.map_err(Error::InvalidRequest)?;
            let only_expunge_deletes = only_expunge_deletes.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_forcemerge", client.baseurl,);
            let mut query = Vec::with_capacity(6usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &flush {
                query.push(("flush", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &max_num_segments {
                query.push(("max_num_segments", v.to_string()));
            }
            if let Some(v) = &only_expunge_deletes {
                query.push(("only_expunge_deletes", v.to_string()));
            }
            let request = client.client.post(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_get_index_template`]
    ///
    ///[`Client::indices_get_index_template`]: super::Client::indices_get_index_template
    #[derive(Debug, Clone)]
    pub struct IndicesGetIndexTemplate<'a> {
        client: &'a super::Client,
        cluster_manager_timeout:
            Result<Option<types::IndicesGetIndexTemplateClusterManagerTimeout>, String>,
        flat_settings: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::IndicesGetIndexTemplateMasterTimeout>, String>,
    }

    impl<'a> IndicesGetIndexTemplate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                cluster_manager_timeout: Ok(None),
                flat_settings: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
            }
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesGetIndexTemplateClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesGetIndexTemplateClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn flat_settings<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.flat_settings = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesGetIndexTemplateMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesGetIndexTemplateMasterTimeout` for master_timeout failed"
                    .to_string()
            });
            self
        }

        ///Sends a `GET` request to `/_index_template`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                cluster_manager_timeout,
                flat_settings,
                local,
                master_timeout,
            } = self;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_index_template", client.baseurl,);
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &flat_settings {
                query.push(("flat_settings", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_simulate_template`]
    ///
    ///[`Client::indices_simulate_template`]: super::Client::indices_simulate_template
    #[derive(Debug, Clone)]
    pub struct IndicesSimulateTemplate<'a> {
        client: &'a super::Client,
        cause: Result<Option<String>, String>,
        cluster_manager_timeout:
            Result<Option<types::IndicesSimulateTemplateClusterManagerTimeout>, String>,
        create: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::IndicesSimulateTemplateMasterTimeout>, String>,
        body: Result<types::IndicesSimulateTemplateBodyParams, String>,
    }

    impl<'a> IndicesSimulateTemplate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                cause: Ok(None),
                cluster_manager_timeout: Ok(None),
                create: Ok(None),
                master_timeout: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn cause<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.cause = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for cause failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesSimulateTemplateClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesSimulateTemplateClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn create<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.create = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for create failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesSimulateTemplateMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesSimulateTemplateMasterTimeout` for master_timeout failed"
                    .to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesSimulateTemplateBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `IndicesSimulateTemplateBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `POST` request to `/_index_template/_simulate`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                cause,
                cluster_manager_timeout,
                create,
                master_timeout,
                body,
            } = self;
            let cause = cause.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let create = create.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_index_template/_simulate", client.baseurl,);
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &cause {
                query.push(("cause", v.to_string()));
            }
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &create {
                query.push(("create", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_simulate_template_with_name`]
    ///
    ///[`Client::indices_simulate_template_with_name`]: super::Client::indices_simulate_template_with_name
    #[derive(Debug, Clone)]
    pub struct IndicesSimulateTemplateWithName<'a> {
        client: &'a super::Client,
        name: Result<types::IndicesSimulateTemplateWithNameName, String>,
        cause: Result<Option<String>, String>,
        cluster_manager_timeout:
            Result<Option<types::IndicesSimulateTemplateWithNameClusterManagerTimeout>, String>,
        create: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::IndicesSimulateTemplateWithNameMasterTimeout>, String>,
        body: Result<types::IndicesSimulateTemplateBodyParams, String>,
    }

    impl<'a> IndicesSimulateTemplateWithName<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                name: Err("name was not initialized".to_string()),
                cause: Ok(None),
                cluster_manager_timeout: Ok(None),
                create: Ok(None),
                master_timeout: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesSimulateTemplateWithNameName>,
        {
            self.name = value.try_into().map_err(|_| {
                "conversion to `IndicesSimulateTemplateWithNameName` for name failed".to_string()
            });
            self
        }

        pub fn cause<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.cause = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for cause failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesSimulateTemplateWithNameClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesSimulateTemplateWithNameClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn create<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.create = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for create failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesSimulateTemplateWithNameMasterTimeout>,
        {
            self . master_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesSimulateTemplateWithNameMasterTimeout` for master_timeout failed" . to_string ()) ;
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesSimulateTemplateBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `IndicesSimulateTemplateBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `POST` request to `/_index_template/_simulate/{name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                name,
                cause,
                cluster_manager_timeout,
                create,
                master_timeout,
                body,
            } = self;
            let name = name.map_err(Error::InvalidRequest)?;
            let cause = cause.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let create = create.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_index_template/_simulate/{}",
                client.baseurl,
                encode_path(&name.to_string()),
            );
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &cause {
                query.push(("cause", v.to_string()));
            }
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &create {
                query.push(("create", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_simulate_index_template`]
    ///
    ///[`Client::indices_simulate_index_template`]: super::Client::indices_simulate_index_template
    #[derive(Debug, Clone)]
    pub struct IndicesSimulateIndexTemplate<'a> {
        client: &'a super::Client,
        name: Result<types::IndicesSimulateIndexTemplateName, String>,
        cause: Result<Option<String>, String>,
        cluster_manager_timeout:
            Result<Option<types::IndicesSimulateIndexTemplateClusterManagerTimeout>, String>,
        create: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::IndicesSimulateIndexTemplateMasterTimeout>, String>,
        body: Result<types::IndicesSimulateIndexTemplateBodyParams, String>,
    }

    impl<'a> IndicesSimulateIndexTemplate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                name: Err("name was not initialized".to_string()),
                cause: Ok(None),
                cluster_manager_timeout: Ok(None),
                create: Ok(None),
                master_timeout: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesSimulateIndexTemplateName>,
        {
            self.name = value.try_into().map_err(|_| {
                "conversion to `IndicesSimulateIndexTemplateName` for name failed".to_string()
            });
            self
        }

        pub fn cause<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.cause = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for cause failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesSimulateIndexTemplateClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesSimulateIndexTemplateClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn create<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.create = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for create failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesSimulateIndexTemplateMasterTimeout>,
        {
            self . master_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesSimulateIndexTemplateMasterTimeout` for master_timeout failed" . to_string ()) ;
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesSimulateIndexTemplateBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `IndicesSimulateIndexTemplateBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `POST` request to `/_index_template/_simulate_index/{name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                name,
                cause,
                cluster_manager_timeout,
                create,
                master_timeout,
                body,
            } = self;
            let name = name.map_err(Error::InvalidRequest)?;
            let cause = cause.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let create = create.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_index_template/_simulate_index/{}",
                client.baseurl,
                encode_path(&name.to_string()),
            );
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &cause {
                query.push(("cause", v.to_string()));
            }
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &create {
                query.push(("create", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_get_index_template_with_name`]
    ///
    ///[`Client::indices_get_index_template_with_name`]: super::Client::indices_get_index_template_with_name
    #[derive(Debug, Clone)]
    pub struct IndicesGetIndexTemplateWithName<'a> {
        client: &'a super::Client,
        name: Result<types::IndicesGetIndexTemplateWithNameName, String>,
        cluster_manager_timeout:
            Result<Option<types::IndicesGetIndexTemplateWithNameClusterManagerTimeout>, String>,
        flat_settings: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::IndicesGetIndexTemplateWithNameMasterTimeout>, String>,
    }

    impl<'a> IndicesGetIndexTemplateWithName<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                name: Err("name was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                flat_settings: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
            }
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesGetIndexTemplateWithNameName>,
        {
            self.name = value.try_into().map_err(|_| {
                "conversion to `IndicesGetIndexTemplateWithNameName` for name failed".to_string()
            });
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesGetIndexTemplateWithNameClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesGetIndexTemplateWithNameClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn flat_settings<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.flat_settings = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesGetIndexTemplateWithNameMasterTimeout>,
        {
            self . master_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesGetIndexTemplateWithNameMasterTimeout` for master_timeout failed" . to_string ()) ;
            self
        }

        ///Sends a `GET` request to `/_index_template/{name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                name,
                cluster_manager_timeout,
                flat_settings,
                local,
                master_timeout,
            } = self;
            let name = name.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_index_template/{}",
                client.baseurl,
                encode_path(&name.to_string()),
            );
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &flat_settings {
                query.push(("flat_settings", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_put_index_template_put`]
    ///
    ///[`Client::indices_put_index_template_put`]: super::Client::indices_put_index_template_put
    #[derive(Debug, Clone)]
    pub struct IndicesPutIndexTemplatePut<'a> {
        client: &'a super::Client,
        name: Result<types::IndicesPutIndexTemplatePutName, String>,
        cause: Result<Option<String>, String>,
        cluster_manager_timeout:
            Result<Option<types::IndicesPutIndexTemplatePutClusterManagerTimeout>, String>,
        create: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::IndicesPutIndexTemplatePutMasterTimeout>, String>,
        body: Result<types::IndicesPutIndexTemplateBodyParams, String>,
    }

    impl<'a> IndicesPutIndexTemplatePut<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                name: Err("name was not initialized".to_string()),
                cause: Ok(None),
                cluster_manager_timeout: Ok(None),
                create: Ok(None),
                master_timeout: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutIndexTemplatePutName>,
        {
            self.name = value.try_into().map_err(|_| {
                "conversion to `IndicesPutIndexTemplatePutName` for name failed".to_string()
            });
            self
        }

        pub fn cause<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.cause = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for cause failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutIndexTemplatePutClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesPutIndexTemplatePutClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn create<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.create = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for create failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutIndexTemplatePutMasterTimeout>,
        {
            self . master_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesPutIndexTemplatePutMasterTimeout` for master_timeout failed" . to_string ()) ;
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutIndexTemplateBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `IndicesPutIndexTemplateBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `PUT` request to `/_index_template/{name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                name,
                cause,
                cluster_manager_timeout,
                create,
                master_timeout,
                body,
            } = self;
            let name = name.map_err(Error::InvalidRequest)?;
            let cause = cause.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let create = create.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_index_template/{}",
                client.baseurl,
                encode_path(&name.to_string()),
            );
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &cause {
                query.push(("cause", v.to_string()));
            }
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &create {
                query.push(("create", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            let request = client.client.put(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_put_index_template_post`]
    ///
    ///[`Client::indices_put_index_template_post`]: super::Client::indices_put_index_template_post
    #[derive(Debug, Clone)]
    pub struct IndicesPutIndexTemplatePost<'a> {
        client: &'a super::Client,
        name: Result<types::IndicesPutIndexTemplatePostName, String>,
        cause: Result<Option<String>, String>,
        cluster_manager_timeout:
            Result<Option<types::IndicesPutIndexTemplatePostClusterManagerTimeout>, String>,
        create: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::IndicesPutIndexTemplatePostMasterTimeout>, String>,
        body: Result<types::IndicesPutIndexTemplateBodyParams, String>,
    }

    impl<'a> IndicesPutIndexTemplatePost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                name: Err("name was not initialized".to_string()),
                cause: Ok(None),
                cluster_manager_timeout: Ok(None),
                create: Ok(None),
                master_timeout: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutIndexTemplatePostName>,
        {
            self.name = value.try_into().map_err(|_| {
                "conversion to `IndicesPutIndexTemplatePostName` for name failed".to_string()
            });
            self
        }

        pub fn cause<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.cause = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for cause failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutIndexTemplatePostClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesPutIndexTemplatePostClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn create<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.create = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for create failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutIndexTemplatePostMasterTimeout>,
        {
            self . master_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesPutIndexTemplatePostMasterTimeout` for master_timeout failed" . to_string ()) ;
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutIndexTemplateBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `IndicesPutIndexTemplateBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `POST` request to `/_index_template/{name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                name,
                cause,
                cluster_manager_timeout,
                create,
                master_timeout,
                body,
            } = self;
            let name = name.map_err(Error::InvalidRequest)?;
            let cause = cause.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let create = create.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_index_template/{}",
                client.baseurl,
                encode_path(&name.to_string()),
            );
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &cause {
                query.push(("cause", v.to_string()));
            }
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &create {
                query.push(("create", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_delete_index_template`]
    ///
    ///[`Client::indices_delete_index_template`]: super::Client::indices_delete_index_template
    #[derive(Debug, Clone)]
    pub struct IndicesDeleteIndexTemplate<'a> {
        client: &'a super::Client,
        name: Result<types::IndicesDeleteIndexTemplateName, String>,
        cluster_manager_timeout:
            Result<Option<types::IndicesDeleteIndexTemplateClusterManagerTimeout>, String>,
        master_timeout: Result<Option<types::IndicesDeleteIndexTemplateMasterTimeout>, String>,
        timeout: Result<Option<types::IndicesDeleteIndexTemplateTimeout>, String>,
    }

    impl<'a> IndicesDeleteIndexTemplate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                name: Err("name was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
            }
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesDeleteIndexTemplateName>,
        {
            self.name = value.try_into().map_err(|_| {
                "conversion to `IndicesDeleteIndexTemplateName` for name failed".to_string()
            });
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesDeleteIndexTemplateClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesDeleteIndexTemplateClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesDeleteIndexTemplateMasterTimeout>,
        {
            self . master_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesDeleteIndexTemplateMasterTimeout` for master_timeout failed" . to_string ()) ;
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesDeleteIndexTemplateTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesDeleteIndexTemplateTimeout` for timeout failed".to_string()
            });
            self
        }

        ///Sends a `DELETE` request to `/_index_template/{name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                name,
                cluster_manager_timeout,
                master_timeout,
                timeout,
            } = self;
            let name = name.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_index_template/{}",
                client.baseurl,
                encode_path(&name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client.client.delete(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_exists_index_template`]
    ///
    ///[`Client::indices_exists_index_template`]: super::Client::indices_exists_index_template
    #[derive(Debug, Clone)]
    pub struct IndicesExistsIndexTemplate<'a> {
        client: &'a super::Client,
        name: Result<types::IndicesExistsIndexTemplateName, String>,
        flat_settings: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::IndicesExistsIndexTemplateMasterTimeout>, String>,
    }

    impl<'a> IndicesExistsIndexTemplate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                name: Err("name was not initialized".to_string()),
                flat_settings: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
            }
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesExistsIndexTemplateName>,
        {
            self.name = value.try_into().map_err(|_| {
                "conversion to `IndicesExistsIndexTemplateName` for name failed".to_string()
            });
            self
        }

        pub fn flat_settings<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.flat_settings = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesExistsIndexTemplateMasterTimeout>,
        {
            self . master_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesExistsIndexTemplateMasterTimeout` for master_timeout failed" . to_string ()) ;
            self
        }

        ///Sends a `HEAD` request to `/_index_template/{name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                name,
                flat_settings,
                local,
                master_timeout,
            } = self;
            let name = name.map_err(Error::InvalidRequest)?;
            let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_index_template/{}",
                client.baseurl,
                encode_path(&name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &flat_settings {
                query.push(("flat_settings", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            let request = client.client.head(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::ingest_get_pipeline`]
    ///
    ///[`Client::ingest_get_pipeline`]: super::Client::ingest_get_pipeline
    #[derive(Debug, Clone)]
    pub struct IngestGetPipeline<'a> {
        client: &'a super::Client,
        cluster_manager_timeout:
            Result<Option<types::IngestGetPipelineClusterManagerTimeout>, String>,
        master_timeout: Result<Option<types::IngestGetPipelineMasterTimeout>, String>,
    }

    impl<'a> IngestGetPipeline<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                cluster_manager_timeout: Ok(None),
                master_timeout: Ok(None),
            }
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IngestGetPipelineClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IngestGetPipelineClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IngestGetPipelineMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IngestGetPipelineMasterTimeout` for master_timeout failed"
                    .to_string()
            });
            self
        }

        ///Sends a `GET` request to `/_ingest/pipeline`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                cluster_manager_timeout,
                master_timeout,
            } = self;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_ingest/pipeline", client.baseurl,);
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::ingest_simulate_get`]
    ///
    ///[`Client::ingest_simulate_get`]: super::Client::ingest_simulate_get
    #[derive(Debug, Clone)]
    pub struct IngestSimulateGet<'a> {
        client: &'a super::Client,
        verbose: Result<Option<bool>, String>,
    }

    impl<'a> IngestSimulateGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                verbose: Ok(None),
            }
        }

        pub fn verbose<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.verbose = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for verbose failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_ingest/pipeline/_simulate`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, verbose } = self;
            let verbose = verbose.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_ingest/pipeline/_simulate", client.baseurl,);
            let mut query = Vec::with_capacity(1usize);
            if let Some(v) = &verbose {
                query.push(("verbose", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::ingest_simulate_post`]
    ///
    ///[`Client::ingest_simulate_post`]: super::Client::ingest_simulate_post
    #[derive(Debug, Clone)]
    pub struct IngestSimulatePost<'a> {
        client: &'a super::Client,
        verbose: Result<Option<bool>, String>,
        body: Result<types::IngestSimulateBodyParams, String>,
    }

    impl<'a> IngestSimulatePost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                verbose: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn verbose<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.verbose = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for verbose failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IngestSimulateBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `IngestSimulateBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `POST` request to `/_ingest/pipeline/_simulate`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                verbose,
                body,
            } = self;
            let verbose = verbose.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_ingest/pipeline/_simulate", client.baseurl,);
            let mut query = Vec::with_capacity(1usize);
            if let Some(v) = &verbose {
                query.push(("verbose", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::ingest_get_pipeline_with_id`]
    ///
    ///[`Client::ingest_get_pipeline_with_id`]: super::Client::ingest_get_pipeline_with_id
    #[derive(Debug, Clone)]
    pub struct IngestGetPipelineWithId<'a> {
        client: &'a super::Client,
        id: Result<types::IngestGetPipelineWithIdId, String>,
        cluster_manager_timeout:
            Result<Option<types::IngestGetPipelineWithIdClusterManagerTimeout>, String>,
        master_timeout: Result<Option<types::IngestGetPipelineWithIdMasterTimeout>, String>,
    }

    impl<'a> IngestGetPipelineWithId<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                id: Err("id was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                master_timeout: Ok(None),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IngestGetPipelineWithIdId>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `IngestGetPipelineWithIdId` for id failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IngestGetPipelineWithIdClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IngestGetPipelineWithIdClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IngestGetPipelineWithIdMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IngestGetPipelineWithIdMasterTimeout` for master_timeout failed"
                    .to_string()
            });
            self
        }

        ///Sends a `GET` request to `/_ingest/pipeline/{id}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                id,
                cluster_manager_timeout,
                master_timeout,
            } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_ingest/pipeline/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::ingest_put_pipeline`]
    ///
    ///[`Client::ingest_put_pipeline`]: super::Client::ingest_put_pipeline
    #[derive(Debug, Clone)]
    pub struct IngestPutPipeline<'a> {
        client: &'a super::Client,
        id: Result<types::IngestPutPipelineId, String>,
        cluster_manager_timeout:
            Result<Option<types::IngestPutPipelineClusterManagerTimeout>, String>,
        master_timeout: Result<Option<types::IngestPutPipelineMasterTimeout>, String>,
        timeout: Result<Option<types::IngestPutPipelineTimeout>, String>,
        body: Result<types::IngestPutPipelineBodyParams, String>,
    }

    impl<'a> IngestPutPipeline<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                id: Err("id was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IngestPutPipelineId>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `IngestPutPipelineId` for id failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IngestPutPipelineClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IngestPutPipelineClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IngestPutPipelineMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IngestPutPipelineMasterTimeout` for master_timeout failed"
                    .to_string()
            });
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IngestPutPipelineTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IngestPutPipelineTimeout` for timeout failed".to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IngestPutPipelineBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `IngestPutPipelineBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `PUT` request to `/_ingest/pipeline/{id}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                id,
                cluster_manager_timeout,
                master_timeout,
                timeout,
                body,
            } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_ingest/pipeline/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client.client.put(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::ingest_delete_pipeline`]
    ///
    ///[`Client::ingest_delete_pipeline`]: super::Client::ingest_delete_pipeline
    #[derive(Debug, Clone)]
    pub struct IngestDeletePipeline<'a> {
        client: &'a super::Client,
        id: Result<types::IngestDeletePipelineId, String>,
        cluster_manager_timeout:
            Result<Option<types::IngestDeletePipelineClusterManagerTimeout>, String>,
        master_timeout: Result<Option<types::IngestDeletePipelineMasterTimeout>, String>,
        timeout: Result<Option<types::IngestDeletePipelineTimeout>, String>,
    }

    impl<'a> IngestDeletePipeline<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                id: Err("id was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IngestDeletePipelineId>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `IngestDeletePipelineId` for id failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IngestDeletePipelineClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IngestDeletePipelineClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IngestDeletePipelineMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IngestDeletePipelineMasterTimeout` for master_timeout failed"
                    .to_string()
            });
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IngestDeletePipelineTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IngestDeletePipelineTimeout` for timeout failed".to_string()
            });
            self
        }

        ///Sends a `DELETE` request to `/_ingest/pipeline/{id}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                id,
                cluster_manager_timeout,
                master_timeout,
                timeout,
            } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_ingest/pipeline/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client.client.delete(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::ingest_simulate_get_with_id`]
    ///
    ///[`Client::ingest_simulate_get_with_id`]: super::Client::ingest_simulate_get_with_id
    #[derive(Debug, Clone)]
    pub struct IngestSimulateGetWithId<'a> {
        client: &'a super::Client,
        id: Result<types::IngestSimulateGetWithIdId, String>,
        verbose: Result<Option<bool>, String>,
    }

    impl<'a> IngestSimulateGetWithId<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                id: Err("id was not initialized".to_string()),
                verbose: Ok(None),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IngestSimulateGetWithIdId>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `IngestSimulateGetWithIdId` for id failed".to_string());
            self
        }

        pub fn verbose<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.verbose = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for verbose failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_ingest/pipeline/{id}/_simulate`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                id,
                verbose,
            } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let verbose = verbose.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_ingest/pipeline/{}/_simulate",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut query = Vec::with_capacity(1usize);
            if let Some(v) = &verbose {
                query.push(("verbose", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::ingest_simulate_post_with_id`]
    ///
    ///[`Client::ingest_simulate_post_with_id`]: super::Client::ingest_simulate_post_with_id
    #[derive(Debug, Clone)]
    pub struct IngestSimulatePostWithId<'a> {
        client: &'a super::Client,
        id: Result<types::IngestSimulatePostWithIdId, String>,
        verbose: Result<Option<bool>, String>,
        body: Result<types::IngestSimulateBodyParams, String>,
    }

    impl<'a> IngestSimulatePostWithId<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                id: Err("id was not initialized".to_string()),
                verbose: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IngestSimulatePostWithIdId>,
        {
            self.id = value.try_into().map_err(|_| {
                "conversion to `IngestSimulatePostWithIdId` for id failed".to_string()
            });
            self
        }

        pub fn verbose<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.verbose = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for verbose failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IngestSimulateBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `IngestSimulateBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `POST` request to `/_ingest/pipeline/{id}/_simulate`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                id,
                verbose,
                body,
            } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let verbose = verbose.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_ingest/pipeline/{}/_simulate",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut query = Vec::with_capacity(1usize);
            if let Some(v) = &verbose {
                query.push(("verbose", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::ingest_processor_grok`]
    ///
    ///[`Client::ingest_processor_grok`]: super::Client::ingest_processor_grok
    #[derive(Debug, Clone)]
    pub struct IngestProcessorGrok<'a> {
        client: &'a super::Client,
    }

    impl<'a> IngestProcessorGrok<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        ///Sends a `GET` request to `/_ingest/processor/grok`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/_ingest/processor/grok", client.baseurl,);
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_get_mapping`]
    ///
    ///[`Client::indices_get_mapping`]: super::Client::indices_get_mapping
    #[derive(Debug, Clone)]
    pub struct IndicesGetMapping<'a> {
        client: &'a super::Client,
        allow_no_indices: Result<Option<bool>, String>,
        cluster_manager_timeout:
            Result<Option<types::IndicesGetMappingClusterManagerTimeout>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::IndicesGetMappingMasterTimeout>, String>,
    }

    impl<'a> IndicesGetMapping<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                allow_no_indices: Ok(None),
                cluster_manager_timeout: Ok(None),
                expand_wildcards: Ok(None),
                ignore_unavailable: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
            }
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesGetMappingClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesGetMappingClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesGetMappingMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesGetMappingMasterTimeout` for master_timeout failed"
                    .to_string()
            });
            self
        }

        ///Sends a `GET` request to `/_mapping`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                allow_no_indices,
                cluster_manager_timeout,
                expand_wildcards,
                ignore_unavailable,
                local,
                master_timeout,
            } = self;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_mapping", client.baseurl,);
            let mut query = Vec::with_capacity(6usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_get_field_mapping`]
    ///
    ///[`Client::indices_get_field_mapping`]: super::Client::indices_get_field_mapping
    #[derive(Debug, Clone)]
    pub struct IndicesGetFieldMapping<'a> {
        client: &'a super::Client,
        fields: Result<types::IndicesGetFieldMappingFields, String>,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        include_defaults: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
    }

    impl<'a> IndicesGetFieldMapping<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                fields: Err("fields was not initialized".to_string()),
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                ignore_unavailable: Ok(None),
                include_defaults: Ok(None),
                local: Ok(None),
            }
        }

        pub fn fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesGetFieldMappingFields>,
        {
            self.fields = value.try_into().map_err(|_| {
                "conversion to `IndicesGetFieldMappingFields` for fields failed".to_string()
            });
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn include_defaults<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.include_defaults = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for include_defaults failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_mapping/field/{fields}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                fields,
                allow_no_indices,
                expand_wildcards,
                ignore_unavailable,
                include_defaults,
                local,
            } = self;
            let fields = fields.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let include_defaults = include_defaults.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_mapping/field/{}",
                client.baseurl,
                encode_path(&fields.to_string()),
            );
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &include_defaults {
                query.push(("include_defaults", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::mget_get`]
    ///
    ///[`Client::mget_get`]: super::Client::mget_get
    #[derive(Debug, Clone)]
    pub struct MgetGet<'a> {
        client: &'a super::Client,
        source: Result<Option<Vec<String>>, String>,
        source_excludes: Result<Option<Vec<String>>, String>,
        source_includes: Result<Option<Vec<String>>, String>,
        preference: Result<Option<String>, String>,
        realtime: Result<Option<bool>, String>,
        refresh: Result<Option<bool>, String>,
        routing: Result<Option<String>, String>,
        stored_fields: Result<Option<Vec<String>>, String>,
    }

    impl<'a> MgetGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                source: Ok(None),
                source_excludes: Ok(None),
                source_includes: Ok(None),
                preference: Ok(None),
                realtime: Ok(None),
                refresh: Ok(None),
                routing: Ok(None),
                stored_fields: Ok(None),
            }
        }

        pub fn source<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for source failed".to_string());
            self
        }

        pub fn source_excludes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_excludes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_excludes failed".to_string()
            });
            self
        }

        pub fn source_includes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_includes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_includes failed".to_string()
            });
            self
        }

        pub fn preference<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.preference = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for preference failed".to_string());
            self
        }

        pub fn realtime<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.realtime = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for realtime failed".to_string());
            self
        }

        pub fn refresh<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.refresh = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for refresh failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for routing failed".to_string());
            self
        }

        pub fn stored_fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.stored_fields = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for stored_fields failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_mget`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                source,
                source_excludes,
                source_includes,
                preference,
                realtime,
                refresh,
                routing,
                stored_fields,
            } = self;
            let source = source.map_err(Error::InvalidRequest)?;
            let source_excludes = source_excludes.map_err(Error::InvalidRequest)?;
            let source_includes = source_includes.map_err(Error::InvalidRequest)?;
            let preference = preference.map_err(Error::InvalidRequest)?;
            let realtime = realtime.map_err(Error::InvalidRequest)?;
            let refresh = refresh.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let stored_fields = stored_fields.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_mget", client.baseurl,);
            let mut query = Vec::with_capacity(8usize);
            if let Some(v) = &source {
                query.push(("_source", v.to_string()));
            }
            if let Some(v) = &source_excludes {
                query.push(("_source_excludes", v.to_string()));
            }
            if let Some(v) = &source_includes {
                query.push(("_source_includes", v.to_string()));
            }
            if let Some(v) = &preference {
                query.push(("preference", v.to_string()));
            }
            if let Some(v) = &realtime {
                query.push(("realtime", v.to_string()));
            }
            if let Some(v) = &refresh {
                query.push(("refresh", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &stored_fields {
                query.push(("stored_fields", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::mget_post`]
    ///
    ///[`Client::mget_post`]: super::Client::mget_post
    #[derive(Debug, Clone)]
    pub struct MgetPost<'a> {
        client: &'a super::Client,
        source: Result<Option<Vec<String>>, String>,
        source_excludes: Result<Option<Vec<String>>, String>,
        source_includes: Result<Option<Vec<String>>, String>,
        preference: Result<Option<String>, String>,
        realtime: Result<Option<bool>, String>,
        refresh: Result<Option<bool>, String>,
        routing: Result<Option<String>, String>,
        stored_fields: Result<Option<Vec<String>>, String>,
        body: Result<types::MgetBodyParams, String>,
    }

    impl<'a> MgetPost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                source: Ok(None),
                source_excludes: Ok(None),
                source_includes: Ok(None),
                preference: Ok(None),
                realtime: Ok(None),
                refresh: Ok(None),
                routing: Ok(None),
                stored_fields: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn source<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for source failed".to_string());
            self
        }

        pub fn source_excludes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_excludes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_excludes failed".to_string()
            });
            self
        }

        pub fn source_includes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_includes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_includes failed".to_string()
            });
            self
        }

        pub fn preference<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.preference = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for preference failed".to_string());
            self
        }

        pub fn realtime<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.realtime = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for realtime failed".to_string());
            self
        }

        pub fn refresh<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.refresh = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for refresh failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for routing failed".to_string());
            self
        }

        pub fn stored_fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.stored_fields = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for stored_fields failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::MgetBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `MgetBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `POST` request to `/_mget`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                source,
                source_excludes,
                source_includes,
                preference,
                realtime,
                refresh,
                routing,
                stored_fields,
                body,
            } = self;
            let source = source.map_err(Error::InvalidRequest)?;
            let source_excludes = source_excludes.map_err(Error::InvalidRequest)?;
            let source_includes = source_includes.map_err(Error::InvalidRequest)?;
            let preference = preference.map_err(Error::InvalidRequest)?;
            let realtime = realtime.map_err(Error::InvalidRequest)?;
            let refresh = refresh.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let stored_fields = stored_fields.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_mget", client.baseurl,);
            let mut query = Vec::with_capacity(8usize);
            if let Some(v) = &source {
                query.push(("_source", v.to_string()));
            }
            if let Some(v) = &source_excludes {
                query.push(("_source_excludes", v.to_string()));
            }
            if let Some(v) = &source_includes {
                query.push(("_source_includes", v.to_string()));
            }
            if let Some(v) = &preference {
                query.push(("preference", v.to_string()));
            }
            if let Some(v) = &realtime {
                query.push(("realtime", v.to_string()));
            }
            if let Some(v) = &refresh {
                query.push(("refresh", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &stored_fields {
                query.push(("stored_fields", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::msearch_get`]
    ///
    ///[`Client::msearch_get`]: super::Client::msearch_get
    #[derive(Debug, Clone)]
    pub struct MsearchGet<'a> {
        client: &'a super::Client,
        ccs_minimize_roundtrips: Result<Option<bool>, String>,
        max_concurrent_searches: Result<Option<i32>, String>,
        max_concurrent_shard_requests: Result<Option<i32>, String>,
        pre_filter_shard_size: Result<Option<i32>, String>,
        rest_total_hits_as_int: Result<Option<bool>, String>,
        search_type: Result<Option<types::SearchTypeMulti>, String>,
        typed_keys: Result<Option<bool>, String>,
    }

    impl<'a> MsearchGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                ccs_minimize_roundtrips: Ok(None),
                max_concurrent_searches: Ok(None),
                max_concurrent_shard_requests: Ok(None),
                pre_filter_shard_size: Ok(None),
                rest_total_hits_as_int: Ok(None),
                search_type: Ok(None),
                typed_keys: Ok(None),
            }
        }

        pub fn ccs_minimize_roundtrips<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ccs_minimize_roundtrips = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ccs_minimize_roundtrips failed".to_string());
            self
        }

        pub fn max_concurrent_searches<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.max_concurrent_searches = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for max_concurrent_searches failed".to_string());
            self
        }

        pub fn max_concurrent_shard_requests<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.max_concurrent_shard_requests = value.try_into().map(Some).map_err(|_| {
                "conversion to `i32` for max_concurrent_shard_requests failed".to_string()
            });
            self
        }

        pub fn pre_filter_shard_size<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.pre_filter_shard_size = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for pre_filter_shard_size failed".to_string());
            self
        }

        pub fn rest_total_hits_as_int<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.rest_total_hits_as_int = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for rest_total_hits_as_int failed".to_string());
            self
        }

        pub fn search_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchTypeMulti>,
        {
            self.search_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SearchTypeMulti` for search_type failed".to_string());
            self
        }

        pub fn typed_keys<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.typed_keys = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for typed_keys failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_msearch`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                ccs_minimize_roundtrips,
                max_concurrent_searches,
                max_concurrent_shard_requests,
                pre_filter_shard_size,
                rest_total_hits_as_int,
                search_type,
                typed_keys,
            } = self;
            let ccs_minimize_roundtrips = ccs_minimize_roundtrips.map_err(Error::InvalidRequest)?;
            let max_concurrent_searches = max_concurrent_searches.map_err(Error::InvalidRequest)?;
            let max_concurrent_shard_requests =
                max_concurrent_shard_requests.map_err(Error::InvalidRequest)?;
            let pre_filter_shard_size = pre_filter_shard_size.map_err(Error::InvalidRequest)?;
            let rest_total_hits_as_int = rest_total_hits_as_int.map_err(Error::InvalidRequest)?;
            let search_type = search_type.map_err(Error::InvalidRequest)?;
            let typed_keys = typed_keys.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_msearch", client.baseurl,);
            let mut query = Vec::with_capacity(7usize);
            if let Some(v) = &ccs_minimize_roundtrips {
                query.push(("ccs_minimize_roundtrips", v.to_string()));
            }
            if let Some(v) = &max_concurrent_searches {
                query.push(("max_concurrent_searches", v.to_string()));
            }
            if let Some(v) = &max_concurrent_shard_requests {
                query.push(("max_concurrent_shard_requests", v.to_string()));
            }
            if let Some(v) = &pre_filter_shard_size {
                query.push(("pre_filter_shard_size", v.to_string()));
            }
            if let Some(v) = &rest_total_hits_as_int {
                query.push(("rest_total_hits_as_int", v.to_string()));
            }
            if let Some(v) = &search_type {
                query.push(("search_type", v.to_string()));
            }
            if let Some(v) = &typed_keys {
                query.push(("typed_keys", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::msearch_post`]
    ///
    ///[`Client::msearch_post`]: super::Client::msearch_post
    #[derive(Debug, Clone)]
    pub struct MsearchPost<'a> {
        client: &'a super::Client,
        ccs_minimize_roundtrips: Result<Option<bool>, String>,
        max_concurrent_searches: Result<Option<i32>, String>,
        max_concurrent_shard_requests: Result<Option<i32>, String>,
        pre_filter_shard_size: Result<Option<i32>, String>,
        rest_total_hits_as_int: Result<Option<bool>, String>,
        search_type: Result<Option<types::SearchTypeMulti>, String>,
        typed_keys: Result<Option<bool>, String>,
        body: Result<types::MsearchBodyParams, String>,
    }

    impl<'a> MsearchPost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                ccs_minimize_roundtrips: Ok(None),
                max_concurrent_searches: Ok(None),
                max_concurrent_shard_requests: Ok(None),
                pre_filter_shard_size: Ok(None),
                rest_total_hits_as_int: Ok(None),
                search_type: Ok(None),
                typed_keys: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn ccs_minimize_roundtrips<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ccs_minimize_roundtrips = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ccs_minimize_roundtrips failed".to_string());
            self
        }

        pub fn max_concurrent_searches<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.max_concurrent_searches = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for max_concurrent_searches failed".to_string());
            self
        }

        pub fn max_concurrent_shard_requests<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.max_concurrent_shard_requests = value.try_into().map(Some).map_err(|_| {
                "conversion to `i32` for max_concurrent_shard_requests failed".to_string()
            });
            self
        }

        pub fn pre_filter_shard_size<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.pre_filter_shard_size = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for pre_filter_shard_size failed".to_string());
            self
        }

        pub fn rest_total_hits_as_int<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.rest_total_hits_as_int = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for rest_total_hits_as_int failed".to_string());
            self
        }

        pub fn search_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchTypeMulti>,
        {
            self.search_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SearchTypeMulti` for search_type failed".to_string());
            self
        }

        pub fn typed_keys<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.typed_keys = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for typed_keys failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::MsearchBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `MsearchBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `POST` request to `/_msearch`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                ccs_minimize_roundtrips,
                max_concurrent_searches,
                max_concurrent_shard_requests,
                pre_filter_shard_size,
                rest_total_hits_as_int,
                search_type,
                typed_keys,
                body,
            } = self;
            let ccs_minimize_roundtrips = ccs_minimize_roundtrips.map_err(Error::InvalidRequest)?;
            let max_concurrent_searches = max_concurrent_searches.map_err(Error::InvalidRequest)?;
            let max_concurrent_shard_requests =
                max_concurrent_shard_requests.map_err(Error::InvalidRequest)?;
            let pre_filter_shard_size = pre_filter_shard_size.map_err(Error::InvalidRequest)?;
            let rest_total_hits_as_int = rest_total_hits_as_int.map_err(Error::InvalidRequest)?;
            let search_type = search_type.map_err(Error::InvalidRequest)?;
            let typed_keys = typed_keys.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_msearch", client.baseurl,);
            let mut query = Vec::with_capacity(7usize);
            if let Some(v) = &ccs_minimize_roundtrips {
                query.push(("ccs_minimize_roundtrips", v.to_string()));
            }
            if let Some(v) = &max_concurrent_searches {
                query.push(("max_concurrent_searches", v.to_string()));
            }
            if let Some(v) = &max_concurrent_shard_requests {
                query.push(("max_concurrent_shard_requests", v.to_string()));
            }
            if let Some(v) = &pre_filter_shard_size {
                query.push(("pre_filter_shard_size", v.to_string()));
            }
            if let Some(v) = &rest_total_hits_as_int {
                query.push(("rest_total_hits_as_int", v.to_string()));
            }
            if let Some(v) = &search_type {
                query.push(("search_type", v.to_string()));
            }
            if let Some(v) = &typed_keys {
                query.push(("typed_keys", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::msearch_template_get`]
    ///
    ///[`Client::msearch_template_get`]: super::Client::msearch_template_get
    #[derive(Debug, Clone)]
    pub struct MsearchTemplateGet<'a> {
        client: &'a super::Client,
        ccs_minimize_roundtrips: Result<Option<bool>, String>,
        max_concurrent_searches: Result<Option<i32>, String>,
        rest_total_hits_as_int: Result<Option<bool>, String>,
        search_type: Result<Option<types::SearchTypeMulti>, String>,
        typed_keys: Result<Option<bool>, String>,
    }

    impl<'a> MsearchTemplateGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                ccs_minimize_roundtrips: Ok(None),
                max_concurrent_searches: Ok(None),
                rest_total_hits_as_int: Ok(None),
                search_type: Ok(None),
                typed_keys: Ok(None),
            }
        }

        pub fn ccs_minimize_roundtrips<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ccs_minimize_roundtrips = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ccs_minimize_roundtrips failed".to_string());
            self
        }

        pub fn max_concurrent_searches<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.max_concurrent_searches = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for max_concurrent_searches failed".to_string());
            self
        }

        pub fn rest_total_hits_as_int<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.rest_total_hits_as_int = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for rest_total_hits_as_int failed".to_string());
            self
        }

        pub fn search_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchTypeMulti>,
        {
            self.search_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SearchTypeMulti` for search_type failed".to_string());
            self
        }

        pub fn typed_keys<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.typed_keys = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for typed_keys failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_msearch/template`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                ccs_minimize_roundtrips,
                max_concurrent_searches,
                rest_total_hits_as_int,
                search_type,
                typed_keys,
            } = self;
            let ccs_minimize_roundtrips = ccs_minimize_roundtrips.map_err(Error::InvalidRequest)?;
            let max_concurrent_searches = max_concurrent_searches.map_err(Error::InvalidRequest)?;
            let rest_total_hits_as_int = rest_total_hits_as_int.map_err(Error::InvalidRequest)?;
            let search_type = search_type.map_err(Error::InvalidRequest)?;
            let typed_keys = typed_keys.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_msearch/template", client.baseurl,);
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &ccs_minimize_roundtrips {
                query.push(("ccs_minimize_roundtrips", v.to_string()));
            }
            if let Some(v) = &max_concurrent_searches {
                query.push(("max_concurrent_searches", v.to_string()));
            }
            if let Some(v) = &rest_total_hits_as_int {
                query.push(("rest_total_hits_as_int", v.to_string()));
            }
            if let Some(v) = &search_type {
                query.push(("search_type", v.to_string()));
            }
            if let Some(v) = &typed_keys {
                query.push(("typed_keys", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::msearch_template_post`]
    ///
    ///[`Client::msearch_template_post`]: super::Client::msearch_template_post
    #[derive(Debug, Clone)]
    pub struct MsearchTemplatePost<'a> {
        client: &'a super::Client,
        ccs_minimize_roundtrips: Result<Option<bool>, String>,
        max_concurrent_searches: Result<Option<i32>, String>,
        rest_total_hits_as_int: Result<Option<bool>, String>,
        search_type: Result<Option<types::SearchTypeMulti>, String>,
        typed_keys: Result<Option<bool>, String>,
        body: Result<types::MsearchTemplateBodyParams, String>,
    }

    impl<'a> MsearchTemplatePost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                ccs_minimize_roundtrips: Ok(None),
                max_concurrent_searches: Ok(None),
                rest_total_hits_as_int: Ok(None),
                search_type: Ok(None),
                typed_keys: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn ccs_minimize_roundtrips<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ccs_minimize_roundtrips = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ccs_minimize_roundtrips failed".to_string());
            self
        }

        pub fn max_concurrent_searches<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.max_concurrent_searches = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for max_concurrent_searches failed".to_string());
            self
        }

        pub fn rest_total_hits_as_int<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.rest_total_hits_as_int = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for rest_total_hits_as_int failed".to_string());
            self
        }

        pub fn search_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchTypeMulti>,
        {
            self.search_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SearchTypeMulti` for search_type failed".to_string());
            self
        }

        pub fn typed_keys<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.typed_keys = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for typed_keys failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::MsearchTemplateBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `MsearchTemplateBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `POST` request to `/_msearch/template`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                ccs_minimize_roundtrips,
                max_concurrent_searches,
                rest_total_hits_as_int,
                search_type,
                typed_keys,
                body,
            } = self;
            let ccs_minimize_roundtrips = ccs_minimize_roundtrips.map_err(Error::InvalidRequest)?;
            let max_concurrent_searches = max_concurrent_searches.map_err(Error::InvalidRequest)?;
            let rest_total_hits_as_int = rest_total_hits_as_int.map_err(Error::InvalidRequest)?;
            let search_type = search_type.map_err(Error::InvalidRequest)?;
            let typed_keys = typed_keys.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_msearch/template", client.baseurl,);
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &ccs_minimize_roundtrips {
                query.push(("ccs_minimize_roundtrips", v.to_string()));
            }
            if let Some(v) = &max_concurrent_searches {
                query.push(("max_concurrent_searches", v.to_string()));
            }
            if let Some(v) = &rest_total_hits_as_int {
                query.push(("rest_total_hits_as_int", v.to_string()));
            }
            if let Some(v) = &search_type {
                query.push(("search_type", v.to_string()));
            }
            if let Some(v) = &typed_keys {
                query.push(("typed_keys", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::mtermvectors_get`]
    ///
    ///[`Client::mtermvectors_get`]: super::Client::mtermvectors_get
    #[derive(Debug, Clone)]
    pub struct MtermvectorsGet<'a> {
        client: &'a super::Client,
        field_statistics: Result<Option<bool>, String>,
        fields: Result<Option<Vec<String>>, String>,
        ids: Result<Option<Vec<String>>, String>,
        offsets: Result<Option<bool>, String>,
        payloads: Result<Option<bool>, String>,
        positions: Result<Option<bool>, String>,
        preference: Result<Option<String>, String>,
        realtime: Result<Option<bool>, String>,
        routing: Result<Option<String>, String>,
        term_statistics: Result<Option<bool>, String>,
        version: Result<Option<i32>, String>,
        version_type: Result<Option<types::VersionType>, String>,
    }

    impl<'a> MtermvectorsGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                field_statistics: Ok(None),
                fields: Ok(None),
                ids: Ok(None),
                offsets: Ok(None),
                payloads: Ok(None),
                positions: Ok(None),
                preference: Ok(None),
                realtime: Ok(None),
                routing: Ok(None),
                term_statistics: Ok(None),
                version: Ok(None),
                version_type: Ok(None),
            }
        }

        pub fn field_statistics<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.field_statistics = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for field_statistics failed".to_string());
            self
        }

        pub fn fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.fields = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
            self
        }

        pub fn ids<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.ids = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for ids failed".to_string());
            self
        }

        pub fn offsets<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.offsets = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for offsets failed".to_string());
            self
        }

        pub fn payloads<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.payloads = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for payloads failed".to_string());
            self
        }

        pub fn positions<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.positions = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for positions failed".to_string());
            self
        }

        pub fn preference<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.preference = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for preference failed".to_string());
            self
        }

        pub fn realtime<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.realtime = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for realtime failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for routing failed".to_string());
            self
        }

        pub fn term_statistics<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.term_statistics = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for term_statistics failed".to_string());
            self
        }

        pub fn version<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.version = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for version failed".to_string());
            self
        }

        pub fn version_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VersionType>,
        {
            self.version_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `VersionType` for version_type failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_mtermvectors`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                field_statistics,
                fields,
                ids,
                offsets,
                payloads,
                positions,
                preference,
                realtime,
                routing,
                term_statistics,
                version,
                version_type,
            } = self;
            let field_statistics = field_statistics.map_err(Error::InvalidRequest)?;
            let fields = fields.map_err(Error::InvalidRequest)?;
            let ids = ids.map_err(Error::InvalidRequest)?;
            let offsets = offsets.map_err(Error::InvalidRequest)?;
            let payloads = payloads.map_err(Error::InvalidRequest)?;
            let positions = positions.map_err(Error::InvalidRequest)?;
            let preference = preference.map_err(Error::InvalidRequest)?;
            let realtime = realtime.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let term_statistics = term_statistics.map_err(Error::InvalidRequest)?;
            let version = version.map_err(Error::InvalidRequest)?;
            let version_type = version_type.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_mtermvectors", client.baseurl,);
            let mut query = Vec::with_capacity(12usize);
            if let Some(v) = &field_statistics {
                query.push(("field_statistics", v.to_string()));
            }
            if let Some(v) = &fields {
                query.push(("fields", v.to_string()));
            }
            if let Some(v) = &ids {
                query.push(("ids", v.to_string()));
            }
            if let Some(v) = &offsets {
                query.push(("offsets", v.to_string()));
            }
            if let Some(v) = &payloads {
                query.push(("payloads", v.to_string()));
            }
            if let Some(v) = &positions {
                query.push(("positions", v.to_string()));
            }
            if let Some(v) = &preference {
                query.push(("preference", v.to_string()));
            }
            if let Some(v) = &realtime {
                query.push(("realtime", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &term_statistics {
                query.push(("term_statistics", v.to_string()));
            }
            if let Some(v) = &version {
                query.push(("version", v.to_string()));
            }
            if let Some(v) = &version_type {
                query.push(("version_type", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::mtermvectors_post`]
    ///
    ///[`Client::mtermvectors_post`]: super::Client::mtermvectors_post
    #[derive(Debug, Clone)]
    pub struct MtermvectorsPost<'a> {
        client: &'a super::Client,
        field_statistics: Result<Option<bool>, String>,
        fields: Result<Option<Vec<String>>, String>,
        ids: Result<Option<Vec<String>>, String>,
        offsets: Result<Option<bool>, String>,
        payloads: Result<Option<bool>, String>,
        positions: Result<Option<bool>, String>,
        preference: Result<Option<String>, String>,
        realtime: Result<Option<bool>, String>,
        routing: Result<Option<String>, String>,
        term_statistics: Result<Option<bool>, String>,
        version: Result<Option<i32>, String>,
        version_type: Result<Option<types::VersionType>, String>,
        body: Result<types::MtermvectorsBodyParams, String>,
    }

    impl<'a> MtermvectorsPost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                field_statistics: Ok(None),
                fields: Ok(None),
                ids: Ok(None),
                offsets: Ok(None),
                payloads: Ok(None),
                positions: Ok(None),
                preference: Ok(None),
                realtime: Ok(None),
                routing: Ok(None),
                term_statistics: Ok(None),
                version: Ok(None),
                version_type: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn field_statistics<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.field_statistics = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for field_statistics failed".to_string());
            self
        }

        pub fn fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.fields = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
            self
        }

        pub fn ids<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.ids = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for ids failed".to_string());
            self
        }

        pub fn offsets<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.offsets = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for offsets failed".to_string());
            self
        }

        pub fn payloads<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.payloads = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for payloads failed".to_string());
            self
        }

        pub fn positions<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.positions = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for positions failed".to_string());
            self
        }

        pub fn preference<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.preference = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for preference failed".to_string());
            self
        }

        pub fn realtime<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.realtime = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for realtime failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for routing failed".to_string());
            self
        }

        pub fn term_statistics<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.term_statistics = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for term_statistics failed".to_string());
            self
        }

        pub fn version<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.version = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for version failed".to_string());
            self
        }

        pub fn version_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VersionType>,
        {
            self.version_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `VersionType` for version_type failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::MtermvectorsBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `MtermvectorsBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `POST` request to `/_mtermvectors`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                field_statistics,
                fields,
                ids,
                offsets,
                payloads,
                positions,
                preference,
                realtime,
                routing,
                term_statistics,
                version,
                version_type,
                body,
            } = self;
            let field_statistics = field_statistics.map_err(Error::InvalidRequest)?;
            let fields = fields.map_err(Error::InvalidRequest)?;
            let ids = ids.map_err(Error::InvalidRequest)?;
            let offsets = offsets.map_err(Error::InvalidRequest)?;
            let payloads = payloads.map_err(Error::InvalidRequest)?;
            let positions = positions.map_err(Error::InvalidRequest)?;
            let preference = preference.map_err(Error::InvalidRequest)?;
            let realtime = realtime.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let term_statistics = term_statistics.map_err(Error::InvalidRequest)?;
            let version = version.map_err(Error::InvalidRequest)?;
            let version_type = version_type.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_mtermvectors", client.baseurl,);
            let mut query = Vec::with_capacity(12usize);
            if let Some(v) = &field_statistics {
                query.push(("field_statistics", v.to_string()));
            }
            if let Some(v) = &fields {
                query.push(("fields", v.to_string()));
            }
            if let Some(v) = &ids {
                query.push(("ids", v.to_string()));
            }
            if let Some(v) = &offsets {
                query.push(("offsets", v.to_string()));
            }
            if let Some(v) = &payloads {
                query.push(("payloads", v.to_string()));
            }
            if let Some(v) = &positions {
                query.push(("positions", v.to_string()));
            }
            if let Some(v) = &preference {
                query.push(("preference", v.to_string()));
            }
            if let Some(v) = &realtime {
                query.push(("realtime", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &term_statistics {
                query.push(("term_statistics", v.to_string()));
            }
            if let Some(v) = &version {
                query.push(("version", v.to_string()));
            }
            if let Some(v) = &version_type {
                query.push(("version_type", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::nodes_info`]
    ///
    ///[`Client::nodes_info`]: super::Client::nodes_info
    #[derive(Debug, Clone)]
    pub struct NodesInfo<'a> {
        client: &'a super::Client,
        flat_settings: Result<Option<bool>, String>,
        timeout: Result<Option<types::NodesInfoTimeout>, String>,
    }

    impl<'a> NodesInfo<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                flat_settings: Ok(None),
                timeout: Ok(None),
            }
        }

        pub fn flat_settings<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.flat_settings = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesInfoTimeout>,
        {
            self.timeout = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NodesInfoTimeout` for timeout failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_nodes`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                flat_settings,
                timeout,
            } = self;
            let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_nodes", client.baseurl,);
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &flat_settings {
                query.push(("flat_settings", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::nodes_hot_threads`]
    ///
    ///[`Client::nodes_hot_threads`]: super::Client::nodes_hot_threads
    #[derive(Debug, Clone)]
    pub struct NodesHotThreads<'a> {
        client: &'a super::Client,
        ignore_idle_threads: Result<Option<bool>, String>,
        interval: Result<Option<types::NodesHotThreadsInterval>, String>,
        snapshots: Result<Option<i32>, String>,
        threads: Result<Option<i32>, String>,
        timeout: Result<Option<types::NodesHotThreadsTimeout>, String>,
        type_: Result<Option<types::SampleType>, String>,
    }

    impl<'a> NodesHotThreads<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                ignore_idle_threads: Ok(None),
                interval: Ok(None),
                snapshots: Ok(None),
                threads: Ok(None),
                timeout: Ok(None),
                type_: Ok(None),
            }
        }

        pub fn ignore_idle_threads<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_idle_threads = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_idle_threads failed".to_string());
            self
        }

        pub fn interval<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesHotThreadsInterval>,
        {
            self.interval = value.try_into().map(Some).map_err(|_| {
                "conversion to `NodesHotThreadsInterval` for interval failed".to_string()
            });
            self
        }

        pub fn snapshots<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.snapshots = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for snapshots failed".to_string());
            self
        }

        pub fn threads<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.threads = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for threads failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesHotThreadsTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `NodesHotThreadsTimeout` for timeout failed".to_string()
            });
            self
        }

        pub fn type_<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SampleType>,
        {
            self.type_ = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SampleType` for type_ failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_nodes/hot_threads`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                ignore_idle_threads,
                interval,
                snapshots,
                threads,
                timeout,
                type_,
            } = self;
            let ignore_idle_threads = ignore_idle_threads.map_err(Error::InvalidRequest)?;
            let interval = interval.map_err(Error::InvalidRequest)?;
            let snapshots = snapshots.map_err(Error::InvalidRequest)?;
            let threads = threads.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let type_ = type_.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_nodes/hot_threads", client.baseurl,);
            let mut query = Vec::with_capacity(6usize);
            if let Some(v) = &ignore_idle_threads {
                query.push(("ignore_idle_threads", v.to_string()));
            }
            if let Some(v) = &interval {
                query.push(("interval", v.to_string()));
            }
            if let Some(v) = &snapshots {
                query.push(("snapshots", v.to_string()));
            }
            if let Some(v) = &threads {
                query.push(("threads", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &type_ {
                query.push(("type", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::nodes_hot_threads_deprecated`]
    ///
    ///[`Client::nodes_hot_threads_deprecated`]: super::Client::nodes_hot_threads_deprecated
    #[derive(Debug, Clone)]
    pub struct NodesHotThreadsDeprecated<'a> {
        client: &'a super::Client,
        ignore_idle_threads: Result<Option<bool>, String>,
        interval: Result<Option<types::NodesHotThreadsDeprecatedInterval>, String>,
        snapshots: Result<Option<i32>, String>,
        threads: Result<Option<i32>, String>,
        timeout: Result<Option<types::NodesHotThreadsDeprecatedTimeout>, String>,
        type_: Result<Option<types::SampleType>, String>,
    }

    impl<'a> NodesHotThreadsDeprecated<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                ignore_idle_threads: Ok(None),
                interval: Ok(None),
                snapshots: Ok(None),
                threads: Ok(None),
                timeout: Ok(None),
                type_: Ok(None),
            }
        }

        pub fn ignore_idle_threads<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_idle_threads = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_idle_threads failed".to_string());
            self
        }

        pub fn interval<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesHotThreadsDeprecatedInterval>,
        {
            self.interval = value.try_into().map(Some).map_err(|_| {
                "conversion to `NodesHotThreadsDeprecatedInterval` for interval failed".to_string()
            });
            self
        }

        pub fn snapshots<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.snapshots = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for snapshots failed".to_string());
            self
        }

        pub fn threads<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.threads = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for threads failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesHotThreadsDeprecatedTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `NodesHotThreadsDeprecatedTimeout` for timeout failed".to_string()
            });
            self
        }

        pub fn type_<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SampleType>,
        {
            self.type_ = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SampleType` for type_ failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_nodes/hotthreads`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                ignore_idle_threads,
                interval,
                snapshots,
                threads,
                timeout,
                type_,
            } = self;
            let ignore_idle_threads = ignore_idle_threads.map_err(Error::InvalidRequest)?;
            let interval = interval.map_err(Error::InvalidRequest)?;
            let snapshots = snapshots.map_err(Error::InvalidRequest)?;
            let threads = threads.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let type_ = type_.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_nodes/hotthreads", client.baseurl,);
            let mut query = Vec::with_capacity(6usize);
            if let Some(v) = &ignore_idle_threads {
                query.push(("ignore_idle_threads", v.to_string()));
            }
            if let Some(v) = &interval {
                query.push(("interval", v.to_string()));
            }
            if let Some(v) = &snapshots {
                query.push(("snapshots", v.to_string()));
            }
            if let Some(v) = &threads {
                query.push(("threads", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &type_ {
                query.push(("type", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::nodes_reload_secure_settings`]
    ///
    ///[`Client::nodes_reload_secure_settings`]: super::Client::nodes_reload_secure_settings
    #[derive(Debug, Clone)]
    pub struct NodesReloadSecureSettings<'a> {
        client: &'a super::Client,
        timeout: Result<Option<types::NodesReloadSecureSettingsTimeout>, String>,
        body: Result<types::NodesReloadSecureSettingsBodyParams, String>,
    }

    impl<'a> NodesReloadSecureSettings<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                timeout: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesReloadSecureSettingsTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `NodesReloadSecureSettingsTimeout` for timeout failed".to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesReloadSecureSettingsBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `NodesReloadSecureSettingsBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `POST` request to `/_nodes/reload_secure_settings`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                timeout,
                body,
            } = self;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_nodes/reload_secure_settings", client.baseurl,);
            let mut query = Vec::with_capacity(1usize);
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::nodes_stats`]
    ///
    ///[`Client::nodes_stats`]: super::Client::nodes_stats
    #[derive(Debug, Clone)]
    pub struct NodesStats<'a> {
        client: &'a super::Client,
        completion_fields: Result<Option<Vec<String>>, String>,
        fielddata_fields: Result<Option<Vec<String>>, String>,
        fields: Result<Option<Vec<String>>, String>,
        groups: Result<Option<Vec<String>>, String>,
        include_segment_file_sizes: Result<Option<bool>, String>,
        level: Result<Option<types::NodesStatLevel>, String>,
        timeout: Result<Option<types::NodesStatsTimeout>, String>,
        types: Result<Option<Vec<String>>, String>,
    }

    impl<'a> NodesStats<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                completion_fields: Ok(None),
                fielddata_fields: Ok(None),
                fields: Ok(None),
                groups: Ok(None),
                include_segment_file_sizes: Ok(None),
                level: Ok(None),
                timeout: Ok(None),
                types: Ok(None),
            }
        }

        pub fn completion_fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.completion_fields = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for completion_fields failed".to_string()
            });
            self
        }

        pub fn fielddata_fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.fielddata_fields = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for fielddata_fields failed".to_string()
            });
            self
        }

        pub fn fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.fields = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
            self
        }

        pub fn groups<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.groups = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for groups failed".to_string());
            self
        }

        pub fn include_segment_file_sizes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.include_segment_file_sizes = value.try_into().map(Some).map_err(|_| {
                "conversion to `bool` for include_segment_file_sizes failed".to_string()
            });
            self
        }

        pub fn level<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesStatLevel>,
        {
            self.level = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NodesStatLevel` for level failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesStatsTimeout>,
        {
            self.timeout = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NodesStatsTimeout` for timeout failed".to_string());
            self
        }

        pub fn types<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.types = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for types failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_nodes/stats`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                completion_fields,
                fielddata_fields,
                fields,
                groups,
                include_segment_file_sizes,
                level,
                timeout,
                types,
            } = self;
            let completion_fields = completion_fields.map_err(Error::InvalidRequest)?;
            let fielddata_fields = fielddata_fields.map_err(Error::InvalidRequest)?;
            let fields = fields.map_err(Error::InvalidRequest)?;
            let groups = groups.map_err(Error::InvalidRequest)?;
            let include_segment_file_sizes =
                include_segment_file_sizes.map_err(Error::InvalidRequest)?;
            let level = level.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let types = types.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_nodes/stats", client.baseurl,);
            let mut query = Vec::with_capacity(8usize);
            if let Some(v) = &completion_fields {
                query.push(("completion_fields", v.to_string()));
            }
            if let Some(v) = &fielddata_fields {
                query.push(("fielddata_fields", v.to_string()));
            }
            if let Some(v) = &fields {
                query.push(("fields", v.to_string()));
            }
            if let Some(v) = &groups {
                query.push(("groups", v.to_string()));
            }
            if let Some(v) = &include_segment_file_sizes {
                query.push(("include_segment_file_sizes", v.to_string()));
            }
            if let Some(v) = &level {
                query.push(("level", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &types {
                query.push(("types", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::nodes_stats_with_metric`]
    ///
    ///[`Client::nodes_stats_with_metric`]: super::Client::nodes_stats_with_metric
    #[derive(Debug, Clone)]
    pub struct NodesStatsWithMetric<'a> {
        client: &'a super::Client,
        metric: Result<types::NodesStatsWithMetricMetric, String>,
        completion_fields: Result<Option<Vec<String>>, String>,
        fielddata_fields: Result<Option<Vec<String>>, String>,
        fields: Result<Option<Vec<String>>, String>,
        groups: Result<Option<Vec<String>>, String>,
        include_segment_file_sizes: Result<Option<bool>, String>,
        level: Result<Option<types::NodesStatLevel>, String>,
        timeout: Result<Option<types::NodesStatsWithMetricTimeout>, String>,
        types: Result<Option<Vec<String>>, String>,
    }

    impl<'a> NodesStatsWithMetric<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                metric: Err("metric was not initialized".to_string()),
                completion_fields: Ok(None),
                fielddata_fields: Ok(None),
                fields: Ok(None),
                groups: Ok(None),
                include_segment_file_sizes: Ok(None),
                level: Ok(None),
                timeout: Ok(None),
                types: Ok(None),
            }
        }

        pub fn metric<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesStatsWithMetricMetric>,
        {
            self.metric = value.try_into().map_err(|_| {
                "conversion to `NodesStatsWithMetricMetric` for metric failed".to_string()
            });
            self
        }

        pub fn completion_fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.completion_fields = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for completion_fields failed".to_string()
            });
            self
        }

        pub fn fielddata_fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.fielddata_fields = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for fielddata_fields failed".to_string()
            });
            self
        }

        pub fn fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.fields = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
            self
        }

        pub fn groups<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.groups = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for groups failed".to_string());
            self
        }

        pub fn include_segment_file_sizes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.include_segment_file_sizes = value.try_into().map(Some).map_err(|_| {
                "conversion to `bool` for include_segment_file_sizes failed".to_string()
            });
            self
        }

        pub fn level<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesStatLevel>,
        {
            self.level = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NodesStatLevel` for level failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesStatsWithMetricTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `NodesStatsWithMetricTimeout` for timeout failed".to_string()
            });
            self
        }

        pub fn types<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.types = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for types failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_nodes/stats/{metric}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                metric,
                completion_fields,
                fielddata_fields,
                fields,
                groups,
                include_segment_file_sizes,
                level,
                timeout,
                types,
            } = self;
            let metric = metric.map_err(Error::InvalidRequest)?;
            let completion_fields = completion_fields.map_err(Error::InvalidRequest)?;
            let fielddata_fields = fielddata_fields.map_err(Error::InvalidRequest)?;
            let fields = fields.map_err(Error::InvalidRequest)?;
            let groups = groups.map_err(Error::InvalidRequest)?;
            let include_segment_file_sizes =
                include_segment_file_sizes.map_err(Error::InvalidRequest)?;
            let level = level.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let types = types.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_nodes/stats/{}",
                client.baseurl,
                encode_path(&metric.to_string()),
            );
            let mut query = Vec::with_capacity(8usize);
            if let Some(v) = &completion_fields {
                query.push(("completion_fields", v.to_string()));
            }
            if let Some(v) = &fielddata_fields {
                query.push(("fielddata_fields", v.to_string()));
            }
            if let Some(v) = &fields {
                query.push(("fields", v.to_string()));
            }
            if let Some(v) = &groups {
                query.push(("groups", v.to_string()));
            }
            if let Some(v) = &include_segment_file_sizes {
                query.push(("include_segment_file_sizes", v.to_string()));
            }
            if let Some(v) = &level {
                query.push(("level", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &types {
                query.push(("types", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::nodes_stats_with_index_metric_metric`]
    ///
    ///[`Client::nodes_stats_with_index_metric_metric`]: super::Client::nodes_stats_with_index_metric_metric
    #[derive(Debug, Clone)]
    pub struct NodesStatsWithIndexMetricMetric<'a> {
        client: &'a super::Client,
        metric: Result<types::NodesStatsWithIndexMetricMetricMetric, String>,
        index_metric: Result<types::NodesStatsWithIndexMetricMetricIndexMetric, String>,
        completion_fields: Result<Option<Vec<String>>, String>,
        fielddata_fields: Result<Option<Vec<String>>, String>,
        fields: Result<Option<Vec<String>>, String>,
        groups: Result<Option<Vec<String>>, String>,
        include_segment_file_sizes: Result<Option<bool>, String>,
        level: Result<Option<types::NodesStatLevel>, String>,
        timeout: Result<Option<types::NodesStatsWithIndexMetricMetricTimeout>, String>,
        types: Result<Option<Vec<String>>, String>,
    }

    impl<'a> NodesStatsWithIndexMetricMetric<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                metric: Err("metric was not initialized".to_string()),
                index_metric: Err("index_metric was not initialized".to_string()),
                completion_fields: Ok(None),
                fielddata_fields: Ok(None),
                fields: Ok(None),
                groups: Ok(None),
                include_segment_file_sizes: Ok(None),
                level: Ok(None),
                timeout: Ok(None),
                types: Ok(None),
            }
        }

        pub fn metric<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesStatsWithIndexMetricMetricMetric>,
        {
            self.metric = value.try_into().map_err(|_| {
                "conversion to `NodesStatsWithIndexMetricMetricMetric` for metric failed"
                    .to_string()
            });
            self
        }

        pub fn index_metric<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesStatsWithIndexMetricMetricIndexMetric>,
        {
            self . index_metric = value . try_into () . map_err (| _ | "conversion to `NodesStatsWithIndexMetricMetricIndexMetric` for index_metric failed" . to_string ()) ;
            self
        }

        pub fn completion_fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.completion_fields = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for completion_fields failed".to_string()
            });
            self
        }

        pub fn fielddata_fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.fielddata_fields = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for fielddata_fields failed".to_string()
            });
            self
        }

        pub fn fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.fields = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
            self
        }

        pub fn groups<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.groups = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for groups failed".to_string());
            self
        }

        pub fn include_segment_file_sizes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.include_segment_file_sizes = value.try_into().map(Some).map_err(|_| {
                "conversion to `bool` for include_segment_file_sizes failed".to_string()
            });
            self
        }

        pub fn level<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesStatLevel>,
        {
            self.level = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NodesStatLevel` for level failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesStatsWithIndexMetricMetricTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `NodesStatsWithIndexMetricMetricTimeout` for timeout failed"
                    .to_string()
            });
            self
        }

        pub fn types<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.types = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for types failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_nodes/stats/{metric}/{index_metric}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                metric,
                index_metric,
                completion_fields,
                fielddata_fields,
                fields,
                groups,
                include_segment_file_sizes,
                level,
                timeout,
                types,
            } = self;
            let metric = metric.map_err(Error::InvalidRequest)?;
            let index_metric = index_metric.map_err(Error::InvalidRequest)?;
            let completion_fields = completion_fields.map_err(Error::InvalidRequest)?;
            let fielddata_fields = fielddata_fields.map_err(Error::InvalidRequest)?;
            let fields = fields.map_err(Error::InvalidRequest)?;
            let groups = groups.map_err(Error::InvalidRequest)?;
            let include_segment_file_sizes =
                include_segment_file_sizes.map_err(Error::InvalidRequest)?;
            let level = level.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let types = types.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_nodes/stats/{}/{}",
                client.baseurl,
                encode_path(&metric.to_string()),
                encode_path(&index_metric.to_string()),
            );
            let mut query = Vec::with_capacity(8usize);
            if let Some(v) = &completion_fields {
                query.push(("completion_fields", v.to_string()));
            }
            if let Some(v) = &fielddata_fields {
                query.push(("fielddata_fields", v.to_string()));
            }
            if let Some(v) = &fields {
                query.push(("fields", v.to_string()));
            }
            if let Some(v) = &groups {
                query.push(("groups", v.to_string()));
            }
            if let Some(v) = &include_segment_file_sizes {
                query.push(("include_segment_file_sizes", v.to_string()));
            }
            if let Some(v) = &level {
                query.push(("level", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &types {
                query.push(("types", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::nodes_usage`]
    ///
    ///[`Client::nodes_usage`]: super::Client::nodes_usage
    #[derive(Debug, Clone)]
    pub struct NodesUsage<'a> {
        client: &'a super::Client,
        timeout: Result<Option<types::NodesUsageTimeout>, String>,
    }

    impl<'a> NodesUsage<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                timeout: Ok(None),
            }
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesUsageTimeout>,
        {
            self.timeout = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NodesUsageTimeout` for timeout failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_nodes/usage`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, timeout } = self;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_nodes/usage", client.baseurl,);
            let mut query = Vec::with_capacity(1usize);
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::nodes_usage_with_metric`]
    ///
    ///[`Client::nodes_usage_with_metric`]: super::Client::nodes_usage_with_metric
    #[derive(Debug, Clone)]
    pub struct NodesUsageWithMetric<'a> {
        client: &'a super::Client,
        metric: Result<types::NodesUsageWithMetricMetric, String>,
        timeout: Result<Option<types::NodesUsageWithMetricTimeout>, String>,
    }

    impl<'a> NodesUsageWithMetric<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                metric: Err("metric was not initialized".to_string()),
                timeout: Ok(None),
            }
        }

        pub fn metric<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesUsageWithMetricMetric>,
        {
            self.metric = value.try_into().map_err(|_| {
                "conversion to `NodesUsageWithMetricMetric` for metric failed".to_string()
            });
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesUsageWithMetricTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `NodesUsageWithMetricTimeout` for timeout failed".to_string()
            });
            self
        }

        ///Sends a `GET` request to `/_nodes/usage/{metric}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                metric,
                timeout,
            } = self;
            let metric = metric.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_nodes/usage/{}",
                client.baseurl,
                encode_path(&metric.to_string()),
            );
            let mut query = Vec::with_capacity(1usize);
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::nodes_info_with_node_id`]
    ///
    ///[`Client::nodes_info_with_node_id`]: super::Client::nodes_info_with_node_id
    #[derive(Debug, Clone)]
    pub struct NodesInfoWithNodeId<'a> {
        client: &'a super::Client,
        node_id: Result<types::NodesInfoWithNodeIdNodeId, String>,
        flat_settings: Result<Option<bool>, String>,
        timeout: Result<Option<types::NodesInfoWithNodeIdTimeout>, String>,
    }

    impl<'a> NodesInfoWithNodeId<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                node_id: Err("node_id was not initialized".to_string()),
                flat_settings: Ok(None),
                timeout: Ok(None),
            }
        }

        pub fn node_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesInfoWithNodeIdNodeId>,
        {
            self.node_id = value.try_into().map_err(|_| {
                "conversion to `NodesInfoWithNodeIdNodeId` for node_id failed".to_string()
            });
            self
        }

        pub fn flat_settings<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.flat_settings = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesInfoWithNodeIdTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `NodesInfoWithNodeIdTimeout` for timeout failed".to_string()
            });
            self
        }

        ///Sends a `GET` request to `/_nodes/{node_id}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                node_id,
                flat_settings,
                timeout,
            } = self;
            let node_id = node_id.map_err(Error::InvalidRequest)?;
            let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_nodes/{}",
                client.baseurl,
                encode_path(&node_id.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &flat_settings {
                query.push(("flat_settings", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::nodes_hot_threads_with_node_id`]
    ///
    ///[`Client::nodes_hot_threads_with_node_id`]: super::Client::nodes_hot_threads_with_node_id
    #[derive(Debug, Clone)]
    pub struct NodesHotThreadsWithNodeId<'a> {
        client: &'a super::Client,
        node_id: Result<types::NodesHotThreadsWithNodeIdNodeId, String>,
        ignore_idle_threads: Result<Option<bool>, String>,
        interval: Result<Option<types::NodesHotThreadsWithNodeIdInterval>, String>,
        snapshots: Result<Option<i32>, String>,
        threads: Result<Option<i32>, String>,
        timeout: Result<Option<types::NodesHotThreadsWithNodeIdTimeout>, String>,
        type_: Result<Option<types::SampleType>, String>,
    }

    impl<'a> NodesHotThreadsWithNodeId<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                node_id: Err("node_id was not initialized".to_string()),
                ignore_idle_threads: Ok(None),
                interval: Ok(None),
                snapshots: Ok(None),
                threads: Ok(None),
                timeout: Ok(None),
                type_: Ok(None),
            }
        }

        pub fn node_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesHotThreadsWithNodeIdNodeId>,
        {
            self.node_id = value.try_into().map_err(|_| {
                "conversion to `NodesHotThreadsWithNodeIdNodeId` for node_id failed".to_string()
            });
            self
        }

        pub fn ignore_idle_threads<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_idle_threads = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_idle_threads failed".to_string());
            self
        }

        pub fn interval<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesHotThreadsWithNodeIdInterval>,
        {
            self.interval = value.try_into().map(Some).map_err(|_| {
                "conversion to `NodesHotThreadsWithNodeIdInterval` for interval failed".to_string()
            });
            self
        }

        pub fn snapshots<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.snapshots = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for snapshots failed".to_string());
            self
        }

        pub fn threads<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.threads = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for threads failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesHotThreadsWithNodeIdTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `NodesHotThreadsWithNodeIdTimeout` for timeout failed".to_string()
            });
            self
        }

        pub fn type_<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SampleType>,
        {
            self.type_ = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SampleType` for type_ failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_nodes/{node_id}/hot_threads`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                node_id,
                ignore_idle_threads,
                interval,
                snapshots,
                threads,
                timeout,
                type_,
            } = self;
            let node_id = node_id.map_err(Error::InvalidRequest)?;
            let ignore_idle_threads = ignore_idle_threads.map_err(Error::InvalidRequest)?;
            let interval = interval.map_err(Error::InvalidRequest)?;
            let snapshots = snapshots.map_err(Error::InvalidRequest)?;
            let threads = threads.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let type_ = type_.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_nodes/{}/hot_threads",
                client.baseurl,
                encode_path(&node_id.to_string()),
            );
            let mut query = Vec::with_capacity(6usize);
            if let Some(v) = &ignore_idle_threads {
                query.push(("ignore_idle_threads", v.to_string()));
            }
            if let Some(v) = &interval {
                query.push(("interval", v.to_string()));
            }
            if let Some(v) = &snapshots {
                query.push(("snapshots", v.to_string()));
            }
            if let Some(v) = &threads {
                query.push(("threads", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &type_ {
                query.push(("type", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::nodes_hot_threads_with_node_id_deprecated`]
    ///
    ///[`Client::nodes_hot_threads_with_node_id_deprecated`]: super::Client::nodes_hot_threads_with_node_id_deprecated
    #[derive(Debug, Clone)]
    pub struct NodesHotThreadsWithNodeIdDeprecated<'a> {
        client: &'a super::Client,
        node_id: Result<types::NodesHotThreadsWithNodeIdDeprecatedNodeId, String>,
        ignore_idle_threads: Result<Option<bool>, String>,
        interval: Result<Option<types::NodesHotThreadsWithNodeIdDeprecatedInterval>, String>,
        snapshots: Result<Option<i32>, String>,
        threads: Result<Option<i32>, String>,
        timeout: Result<Option<types::NodesHotThreadsWithNodeIdDeprecatedTimeout>, String>,
        type_: Result<Option<types::SampleType>, String>,
    }

    impl<'a> NodesHotThreadsWithNodeIdDeprecated<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                node_id: Err("node_id was not initialized".to_string()),
                ignore_idle_threads: Ok(None),
                interval: Ok(None),
                snapshots: Ok(None),
                threads: Ok(None),
                timeout: Ok(None),
                type_: Ok(None),
            }
        }

        pub fn node_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesHotThreadsWithNodeIdDeprecatedNodeId>,
        {
            self.node_id = value.try_into().map_err(|_| {
                "conversion to `NodesHotThreadsWithNodeIdDeprecatedNodeId` for node_id failed"
                    .to_string()
            });
            self
        }

        pub fn ignore_idle_threads<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_idle_threads = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_idle_threads failed".to_string());
            self
        }

        pub fn interval<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesHotThreadsWithNodeIdDeprecatedInterval>,
        {
            self . interval = value . try_into () . map (Some) . map_err (| _ | "conversion to `NodesHotThreadsWithNodeIdDeprecatedInterval` for interval failed" . to_string ()) ;
            self
        }

        pub fn snapshots<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.snapshots = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for snapshots failed".to_string());
            self
        }

        pub fn threads<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.threads = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for threads failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesHotThreadsWithNodeIdDeprecatedTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `NodesHotThreadsWithNodeIdDeprecatedTimeout` for timeout failed"
                    .to_string()
            });
            self
        }

        pub fn type_<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SampleType>,
        {
            self.type_ = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SampleType` for type_ failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_nodes/{node_id}/hotthreads`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                node_id,
                ignore_idle_threads,
                interval,
                snapshots,
                threads,
                timeout,
                type_,
            } = self;
            let node_id = node_id.map_err(Error::InvalidRequest)?;
            let ignore_idle_threads = ignore_idle_threads.map_err(Error::InvalidRequest)?;
            let interval = interval.map_err(Error::InvalidRequest)?;
            let snapshots = snapshots.map_err(Error::InvalidRequest)?;
            let threads = threads.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let type_ = type_.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_nodes/{}/hotthreads",
                client.baseurl,
                encode_path(&node_id.to_string()),
            );
            let mut query = Vec::with_capacity(6usize);
            if let Some(v) = &ignore_idle_threads {
                query.push(("ignore_idle_threads", v.to_string()));
            }
            if let Some(v) = &interval {
                query.push(("interval", v.to_string()));
            }
            if let Some(v) = &snapshots {
                query.push(("snapshots", v.to_string()));
            }
            if let Some(v) = &threads {
                query.push(("threads", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &type_ {
                query.push(("type", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::nodes_reload_secure_settings_with_node_id`]
    ///
    ///[`Client::nodes_reload_secure_settings_with_node_id`]: super::Client::nodes_reload_secure_settings_with_node_id
    #[derive(Debug, Clone)]
    pub struct NodesReloadSecureSettingsWithNodeId<'a> {
        client: &'a super::Client,
        node_id: Result<types::NodesReloadSecureSettingsWithNodeIdNodeId, String>,
        timeout: Result<Option<types::NodesReloadSecureSettingsWithNodeIdTimeout>, String>,
        body: Result<types::NodesReloadSecureSettingsBodyParams, String>,
    }

    impl<'a> NodesReloadSecureSettingsWithNodeId<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                node_id: Err("node_id was not initialized".to_string()),
                timeout: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn node_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesReloadSecureSettingsWithNodeIdNodeId>,
        {
            self.node_id = value.try_into().map_err(|_| {
                "conversion to `NodesReloadSecureSettingsWithNodeIdNodeId` for node_id failed"
                    .to_string()
            });
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesReloadSecureSettingsWithNodeIdTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `NodesReloadSecureSettingsWithNodeIdTimeout` for timeout failed"
                    .to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesReloadSecureSettingsBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `NodesReloadSecureSettingsBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `POST` request to `/_nodes/{node_id}/reload_secure_settings`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                node_id,
                timeout,
                body,
            } = self;
            let node_id = node_id.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_nodes/{}/reload_secure_settings",
                client.baseurl,
                encode_path(&node_id.to_string()),
            );
            let mut query = Vec::with_capacity(1usize);
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::nodes_stats_with_node_id`]
    ///
    ///[`Client::nodes_stats_with_node_id`]: super::Client::nodes_stats_with_node_id
    #[derive(Debug, Clone)]
    pub struct NodesStatsWithNodeId<'a> {
        client: &'a super::Client,
        node_id: Result<types::NodesStatsWithNodeIdNodeId, String>,
        completion_fields: Result<Option<Vec<String>>, String>,
        fielddata_fields: Result<Option<Vec<String>>, String>,
        fields: Result<Option<Vec<String>>, String>,
        groups: Result<Option<Vec<String>>, String>,
        include_segment_file_sizes: Result<Option<bool>, String>,
        level: Result<Option<types::NodesStatLevel>, String>,
        timeout: Result<Option<types::NodesStatsWithNodeIdTimeout>, String>,
        types: Result<Option<Vec<String>>, String>,
    }

    impl<'a> NodesStatsWithNodeId<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                node_id: Err("node_id was not initialized".to_string()),
                completion_fields: Ok(None),
                fielddata_fields: Ok(None),
                fields: Ok(None),
                groups: Ok(None),
                include_segment_file_sizes: Ok(None),
                level: Ok(None),
                timeout: Ok(None),
                types: Ok(None),
            }
        }

        pub fn node_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesStatsWithNodeIdNodeId>,
        {
            self.node_id = value.try_into().map_err(|_| {
                "conversion to `NodesStatsWithNodeIdNodeId` for node_id failed".to_string()
            });
            self
        }

        pub fn completion_fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.completion_fields = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for completion_fields failed".to_string()
            });
            self
        }

        pub fn fielddata_fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.fielddata_fields = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for fielddata_fields failed".to_string()
            });
            self
        }

        pub fn fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.fields = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
            self
        }

        pub fn groups<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.groups = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for groups failed".to_string());
            self
        }

        pub fn include_segment_file_sizes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.include_segment_file_sizes = value.try_into().map(Some).map_err(|_| {
                "conversion to `bool` for include_segment_file_sizes failed".to_string()
            });
            self
        }

        pub fn level<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesStatLevel>,
        {
            self.level = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NodesStatLevel` for level failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesStatsWithNodeIdTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `NodesStatsWithNodeIdTimeout` for timeout failed".to_string()
            });
            self
        }

        pub fn types<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.types = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for types failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_nodes/{node_id}/stats`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                node_id,
                completion_fields,
                fielddata_fields,
                fields,
                groups,
                include_segment_file_sizes,
                level,
                timeout,
                types,
            } = self;
            let node_id = node_id.map_err(Error::InvalidRequest)?;
            let completion_fields = completion_fields.map_err(Error::InvalidRequest)?;
            let fielddata_fields = fielddata_fields.map_err(Error::InvalidRequest)?;
            let fields = fields.map_err(Error::InvalidRequest)?;
            let groups = groups.map_err(Error::InvalidRequest)?;
            let include_segment_file_sizes =
                include_segment_file_sizes.map_err(Error::InvalidRequest)?;
            let level = level.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let types = types.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_nodes/{}/stats",
                client.baseurl,
                encode_path(&node_id.to_string()),
            );
            let mut query = Vec::with_capacity(8usize);
            if let Some(v) = &completion_fields {
                query.push(("completion_fields", v.to_string()));
            }
            if let Some(v) = &fielddata_fields {
                query.push(("fielddata_fields", v.to_string()));
            }
            if let Some(v) = &fields {
                query.push(("fields", v.to_string()));
            }
            if let Some(v) = &groups {
                query.push(("groups", v.to_string()));
            }
            if let Some(v) = &include_segment_file_sizes {
                query.push(("include_segment_file_sizes", v.to_string()));
            }
            if let Some(v) = &level {
                query.push(("level", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &types {
                query.push(("types", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::nodes_stats_with_metric_node_id`]
    ///
    ///[`Client::nodes_stats_with_metric_node_id`]: super::Client::nodes_stats_with_metric_node_id
    #[derive(Debug, Clone)]
    pub struct NodesStatsWithMetricNodeId<'a> {
        client: &'a super::Client,
        node_id: Result<types::NodesStatsWithMetricNodeIdNodeId, String>,
        metric: Result<types::NodesStatsWithMetricNodeIdMetric, String>,
        completion_fields: Result<Option<Vec<String>>, String>,
        fielddata_fields: Result<Option<Vec<String>>, String>,
        fields: Result<Option<Vec<String>>, String>,
        groups: Result<Option<Vec<String>>, String>,
        include_segment_file_sizes: Result<Option<bool>, String>,
        level: Result<Option<types::NodesStatLevel>, String>,
        timeout: Result<Option<types::NodesStatsWithMetricNodeIdTimeout>, String>,
        types: Result<Option<Vec<String>>, String>,
    }

    impl<'a> NodesStatsWithMetricNodeId<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                node_id: Err("node_id was not initialized".to_string()),
                metric: Err("metric was not initialized".to_string()),
                completion_fields: Ok(None),
                fielddata_fields: Ok(None),
                fields: Ok(None),
                groups: Ok(None),
                include_segment_file_sizes: Ok(None),
                level: Ok(None),
                timeout: Ok(None),
                types: Ok(None),
            }
        }

        pub fn node_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesStatsWithMetricNodeIdNodeId>,
        {
            self.node_id = value.try_into().map_err(|_| {
                "conversion to `NodesStatsWithMetricNodeIdNodeId` for node_id failed".to_string()
            });
            self
        }

        pub fn metric<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesStatsWithMetricNodeIdMetric>,
        {
            self.metric = value.try_into().map_err(|_| {
                "conversion to `NodesStatsWithMetricNodeIdMetric` for metric failed".to_string()
            });
            self
        }

        pub fn completion_fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.completion_fields = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for completion_fields failed".to_string()
            });
            self
        }

        pub fn fielddata_fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.fielddata_fields = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for fielddata_fields failed".to_string()
            });
            self
        }

        pub fn fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.fields = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
            self
        }

        pub fn groups<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.groups = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for groups failed".to_string());
            self
        }

        pub fn include_segment_file_sizes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.include_segment_file_sizes = value.try_into().map(Some).map_err(|_| {
                "conversion to `bool` for include_segment_file_sizes failed".to_string()
            });
            self
        }

        pub fn level<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesStatLevel>,
        {
            self.level = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NodesStatLevel` for level failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesStatsWithMetricNodeIdTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `NodesStatsWithMetricNodeIdTimeout` for timeout failed".to_string()
            });
            self
        }

        pub fn types<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.types = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for types failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_nodes/{node_id}/stats/{metric}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                node_id,
                metric,
                completion_fields,
                fielddata_fields,
                fields,
                groups,
                include_segment_file_sizes,
                level,
                timeout,
                types,
            } = self;
            let node_id = node_id.map_err(Error::InvalidRequest)?;
            let metric = metric.map_err(Error::InvalidRequest)?;
            let completion_fields = completion_fields.map_err(Error::InvalidRequest)?;
            let fielddata_fields = fielddata_fields.map_err(Error::InvalidRequest)?;
            let fields = fields.map_err(Error::InvalidRequest)?;
            let groups = groups.map_err(Error::InvalidRequest)?;
            let include_segment_file_sizes =
                include_segment_file_sizes.map_err(Error::InvalidRequest)?;
            let level = level.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let types = types.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_nodes/{}/stats/{}",
                client.baseurl,
                encode_path(&node_id.to_string()),
                encode_path(&metric.to_string()),
            );
            let mut query = Vec::with_capacity(8usize);
            if let Some(v) = &completion_fields {
                query.push(("completion_fields", v.to_string()));
            }
            if let Some(v) = &fielddata_fields {
                query.push(("fielddata_fields", v.to_string()));
            }
            if let Some(v) = &fields {
                query.push(("fields", v.to_string()));
            }
            if let Some(v) = &groups {
                query.push(("groups", v.to_string()));
            }
            if let Some(v) = &include_segment_file_sizes {
                query.push(("include_segment_file_sizes", v.to_string()));
            }
            if let Some(v) = &level {
                query.push(("level", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &types {
                query.push(("types", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::nodes_stats_with_index_metric_metric_node_id`]
    ///
    ///[`Client::nodes_stats_with_index_metric_metric_node_id`]: super::Client::nodes_stats_with_index_metric_metric_node_id
    #[derive(Debug, Clone)]
    pub struct NodesStatsWithIndexMetricMetricNodeId<'a> {
        client: &'a super::Client,
        node_id: Result<types::NodesStatsWithIndexMetricMetricNodeIdNodeId, String>,
        metric: Result<types::NodesStatsWithIndexMetricMetricNodeIdMetric, String>,
        index_metric: Result<types::NodesStatsWithIndexMetricMetricNodeIdIndexMetric, String>,
        completion_fields: Result<Option<Vec<String>>, String>,
        fielddata_fields: Result<Option<Vec<String>>, String>,
        fields: Result<Option<Vec<String>>, String>,
        groups: Result<Option<Vec<String>>, String>,
        include_segment_file_sizes: Result<Option<bool>, String>,
        level: Result<Option<types::NodesStatLevel>, String>,
        timeout: Result<Option<types::NodesStatsWithIndexMetricMetricNodeIdTimeout>, String>,
        types: Result<Option<Vec<String>>, String>,
    }

    impl<'a> NodesStatsWithIndexMetricMetricNodeId<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                node_id: Err("node_id was not initialized".to_string()),
                metric: Err("metric was not initialized".to_string()),
                index_metric: Err("index_metric was not initialized".to_string()),
                completion_fields: Ok(None),
                fielddata_fields: Ok(None),
                fields: Ok(None),
                groups: Ok(None),
                include_segment_file_sizes: Ok(None),
                level: Ok(None),
                timeout: Ok(None),
                types: Ok(None),
            }
        }

        pub fn node_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesStatsWithIndexMetricMetricNodeIdNodeId>,
        {
            self.node_id = value.try_into().map_err(|_| {
                "conversion to `NodesStatsWithIndexMetricMetricNodeIdNodeId` for node_id failed"
                    .to_string()
            });
            self
        }

        pub fn metric<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesStatsWithIndexMetricMetricNodeIdMetric>,
        {
            self.metric = value.try_into().map_err(|_| {
                "conversion to `NodesStatsWithIndexMetricMetricNodeIdMetric` for metric failed"
                    .to_string()
            });
            self
        }

        pub fn index_metric<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesStatsWithIndexMetricMetricNodeIdIndexMetric>,
        {
            self . index_metric = value . try_into () . map_err (| _ | "conversion to `NodesStatsWithIndexMetricMetricNodeIdIndexMetric` for index_metric failed" . to_string ()) ;
            self
        }

        pub fn completion_fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.completion_fields = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for completion_fields failed".to_string()
            });
            self
        }

        pub fn fielddata_fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.fielddata_fields = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for fielddata_fields failed".to_string()
            });
            self
        }

        pub fn fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.fields = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
            self
        }

        pub fn groups<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.groups = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for groups failed".to_string());
            self
        }

        pub fn include_segment_file_sizes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.include_segment_file_sizes = value.try_into().map(Some).map_err(|_| {
                "conversion to `bool` for include_segment_file_sizes failed".to_string()
            });
            self
        }

        pub fn level<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesStatLevel>,
        {
            self.level = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NodesStatLevel` for level failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesStatsWithIndexMetricMetricNodeIdTimeout>,
        {
            self . timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `NodesStatsWithIndexMetricMetricNodeIdTimeout` for timeout failed" . to_string ()) ;
            self
        }

        pub fn types<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.types = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for types failed".to_string());
            self
        }

        ///Sends a `GET` request to
        /// `/_nodes/{node_id}/stats/{metric}/{index_metric}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                node_id,
                metric,
                index_metric,
                completion_fields,
                fielddata_fields,
                fields,
                groups,
                include_segment_file_sizes,
                level,
                timeout,
                types,
            } = self;
            let node_id = node_id.map_err(Error::InvalidRequest)?;
            let metric = metric.map_err(Error::InvalidRequest)?;
            let index_metric = index_metric.map_err(Error::InvalidRequest)?;
            let completion_fields = completion_fields.map_err(Error::InvalidRequest)?;
            let fielddata_fields = fielddata_fields.map_err(Error::InvalidRequest)?;
            let fields = fields.map_err(Error::InvalidRequest)?;
            let groups = groups.map_err(Error::InvalidRequest)?;
            let include_segment_file_sizes =
                include_segment_file_sizes.map_err(Error::InvalidRequest)?;
            let level = level.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let types = types.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_nodes/{}/stats/{}/{}",
                client.baseurl,
                encode_path(&node_id.to_string()),
                encode_path(&metric.to_string()),
                encode_path(&index_metric.to_string()),
            );
            let mut query = Vec::with_capacity(8usize);
            if let Some(v) = &completion_fields {
                query.push(("completion_fields", v.to_string()));
            }
            if let Some(v) = &fielddata_fields {
                query.push(("fielddata_fields", v.to_string()));
            }
            if let Some(v) = &fields {
                query.push(("fields", v.to_string()));
            }
            if let Some(v) = &groups {
                query.push(("groups", v.to_string()));
            }
            if let Some(v) = &include_segment_file_sizes {
                query.push(("include_segment_file_sizes", v.to_string()));
            }
            if let Some(v) = &level {
                query.push(("level", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &types {
                query.push(("types", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::nodes_usage_with_node_id`]
    ///
    ///[`Client::nodes_usage_with_node_id`]: super::Client::nodes_usage_with_node_id
    #[derive(Debug, Clone)]
    pub struct NodesUsageWithNodeId<'a> {
        client: &'a super::Client,
        node_id: Result<types::NodesUsageWithNodeIdNodeId, String>,
        timeout: Result<Option<types::NodesUsageWithNodeIdTimeout>, String>,
    }

    impl<'a> NodesUsageWithNodeId<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                node_id: Err("node_id was not initialized".to_string()),
                timeout: Ok(None),
            }
        }

        pub fn node_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesUsageWithNodeIdNodeId>,
        {
            self.node_id = value.try_into().map_err(|_| {
                "conversion to `NodesUsageWithNodeIdNodeId` for node_id failed".to_string()
            });
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesUsageWithNodeIdTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `NodesUsageWithNodeIdTimeout` for timeout failed".to_string()
            });
            self
        }

        ///Sends a `GET` request to `/_nodes/{node_id}/usage`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                node_id,
                timeout,
            } = self;
            let node_id = node_id.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_nodes/{}/usage",
                client.baseurl,
                encode_path(&node_id.to_string()),
            );
            let mut query = Vec::with_capacity(1usize);
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::nodes_usage_with_metric_node_id`]
    ///
    ///[`Client::nodes_usage_with_metric_node_id`]: super::Client::nodes_usage_with_metric_node_id
    #[derive(Debug, Clone)]
    pub struct NodesUsageWithMetricNodeId<'a> {
        client: &'a super::Client,
        node_id: Result<types::NodesUsageWithMetricNodeIdNodeId, String>,
        metric: Result<types::NodesUsageWithMetricNodeIdMetric, String>,
        timeout: Result<Option<types::NodesUsageWithMetricNodeIdTimeout>, String>,
    }

    impl<'a> NodesUsageWithMetricNodeId<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                node_id: Err("node_id was not initialized".to_string()),
                metric: Err("metric was not initialized".to_string()),
                timeout: Ok(None),
            }
        }

        pub fn node_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesUsageWithMetricNodeIdNodeId>,
        {
            self.node_id = value.try_into().map_err(|_| {
                "conversion to `NodesUsageWithMetricNodeIdNodeId` for node_id failed".to_string()
            });
            self
        }

        pub fn metric<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesUsageWithMetricNodeIdMetric>,
        {
            self.metric = value.try_into().map_err(|_| {
                "conversion to `NodesUsageWithMetricNodeIdMetric` for metric failed".to_string()
            });
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesUsageWithMetricNodeIdTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `NodesUsageWithMetricNodeIdTimeout` for timeout failed".to_string()
            });
            self
        }

        ///Sends a `GET` request to `/_nodes/{node_id}/usage/{metric}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                node_id,
                metric,
                timeout,
            } = self;
            let node_id = node_id.map_err(Error::InvalidRequest)?;
            let metric = metric.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_nodes/{}/usage/{}",
                client.baseurl,
                encode_path(&node_id.to_string()),
                encode_path(&metric.to_string()),
            );
            let mut query = Vec::with_capacity(1usize);
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::nodes_info_with_metric_node_id`]
    ///
    ///[`Client::nodes_info_with_metric_node_id`]: super::Client::nodes_info_with_metric_node_id
    #[derive(Debug, Clone)]
    pub struct NodesInfoWithMetricNodeId<'a> {
        client: &'a super::Client,
        node_id: Result<types::NodesInfoWithMetricNodeIdNodeId, String>,
        metric: Result<types::NodesInfoWithMetricNodeIdMetric, String>,
        flat_settings: Result<Option<bool>, String>,
        timeout: Result<Option<types::NodesInfoWithMetricNodeIdTimeout>, String>,
    }

    impl<'a> NodesInfoWithMetricNodeId<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                node_id: Err("node_id was not initialized".to_string()),
                metric: Err("metric was not initialized".to_string()),
                flat_settings: Ok(None),
                timeout: Ok(None),
            }
        }

        pub fn node_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesInfoWithMetricNodeIdNodeId>,
        {
            self.node_id = value.try_into().map_err(|_| {
                "conversion to `NodesInfoWithMetricNodeIdNodeId` for node_id failed".to_string()
            });
            self
        }

        pub fn metric<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesInfoWithMetricNodeIdMetric>,
        {
            self.metric = value.try_into().map_err(|_| {
                "conversion to `NodesInfoWithMetricNodeIdMetric` for metric failed".to_string()
            });
            self
        }

        pub fn flat_settings<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.flat_settings = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NodesInfoWithMetricNodeIdTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `NodesInfoWithMetricNodeIdTimeout` for timeout failed".to_string()
            });
            self
        }

        ///Sends a `GET` request to `/_nodes/{node_id}/{metric}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                node_id,
                metric,
                flat_settings,
                timeout,
            } = self;
            let node_id = node_id.map_err(Error::InvalidRequest)?;
            let metric = metric.map_err(Error::InvalidRequest)?;
            let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_nodes/{}/{}",
                client.baseurl,
                encode_path(&node_id.to_string()),
                encode_path(&metric.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &flat_settings {
                query.push(("flat_settings", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::get_account_details`]
    ///
    ///[`Client::get_account_details`]: super::Client::get_account_details
    #[derive(Debug, Clone)]
    pub struct GetAccountDetails<'a> {
        client: &'a super::Client,
    }

    impl<'a> GetAccountDetails<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        ///Sends a `GET` request to `/_plugins/_security/api/account`
        pub async fn send(self) -> Result<ResponseValue<types::AccountDetails>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/_plugins/_security/api/account", client.baseurl,);
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::change_password`]
    ///
    ///[`Client::change_password`]: super::Client::change_password
    #[derive(Debug, Clone)]
    pub struct ChangePassword<'a> {
        client: &'a super::Client,
        body: Result<types::builder::ChangePasswordRequestContent, String>,
    }

    impl<'a> ChangePassword<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Ok(types::builder::ChangePasswordRequestContent::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ChangePasswordRequestContent>,
        {
            self.body = value.try_into().map(From::from).map_err(|_| {
                "conversion to `ChangePasswordRequestContent` for body failed".to_string()
            });
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::ChangePasswordRequestContent,
            ) -> types::builder::ChangePasswordRequestContent,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `PUT` request to `/_plugins/_security/api/account`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ChangePasswordResponseContent>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(std::convert::TryInto::<types::ChangePasswordRequestContent>::try_into)
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/_plugins/_security/api/account", client.baseurl,);
            let request = client
                .client
                .put(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::patch_action_groups`]
    ///
    ///[`Client::patch_action_groups`]: super::Client::patch_action_groups
    #[derive(Debug, Clone)]
    pub struct PatchActionGroups<'a> {
        client: &'a super::Client,
        body: Result<types::PatchActionGroupsInputPayload, String>,
    }

    impl<'a> PatchActionGroups<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PatchActionGroupsInputPayload>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `PatchActionGroupsInputPayload` for body failed".to_string()
            });
            self
        }

        ///Sends a `PATCH` request to `/_plugins/_security/api/actiongroups`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::PatchActionGroupsResponseContent>, Error<()>> {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_plugins/_security/api/actiongroups", client.baseurl,);
            let request = client
                .client
                .patch(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::get_action_groups`]
    ///
    ///[`Client::get_action_groups`]: super::Client::get_action_groups
    #[derive(Debug, Clone)]
    pub struct GetActionGroups<'a> {
        client: &'a super::Client,
    }

    impl<'a> GetActionGroups<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        ///Sends a `GET` request to `/_plugins/_security/api/actiongroups/`
        pub async fn send(self) -> Result<ResponseValue<types::ActionGroupsMap>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/_plugins/_security/api/actiongroups/", client.baseurl,);
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::get_action_group`]
    ///
    ///[`Client::get_action_group`]: super::Client::get_action_group
    #[derive(Debug, Clone)]
    pub struct GetActionGroup<'a> {
        client: &'a super::Client,
        action_group: Result<String, String>,
    }

    impl<'a> GetActionGroup<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                action_group: Err("action_group was not initialized".to_string()),
            }
        }

        pub fn action_group<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.action_group = value
                .try_into()
                .map_err(|_| "conversion to `String` for action_group failed".to_string());
            self
        }

        ///Sends a `GET` request to
        /// `/_plugins/_security/api/actiongroups/{action_group}`
        pub async fn send(self) -> Result<ResponseValue<types::ActionGroupsMap>, Error<()>> {
            let Self {
                client,
                action_group,
            } = self;
            let action_group = action_group.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_plugins/_security/api/actiongroups/{}",
                client.baseurl,
                encode_path(&action_group.to_string()),
            );
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::create_action_group`]
    ///
    ///[`Client::create_action_group`]: super::Client::create_action_group
    #[derive(Debug, Clone)]
    pub struct CreateActionGroup<'a> {
        client: &'a super::Client,
        action_group: Result<String, String>,
        body: Result<types::builder::ActionGroup, String>,
    }

    impl<'a> CreateActionGroup<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                action_group: Err("action_group was not initialized".to_string()),
                body: Ok(types::builder::ActionGroup::default()),
            }
        }

        pub fn action_group<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.action_group = value
                .try_into()
                .map_err(|_| "conversion to `String` for action_group failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ActionGroup>,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|_| "conversion to `ActionGroup` for body failed".to_string());
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::ActionGroup) -> types::builder::ActionGroup,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `PUT` request to
        /// `/_plugins/_security/api/actiongroups/{action_group}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::CreateActionGroupResponseContent>, Error<()>> {
            let Self {
                client,
                action_group,
                body,
            } = self;
            let action_group = action_group.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(std::convert::TryInto::<types::ActionGroup>::try_into)
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_plugins/_security/api/actiongroups/{}",
                client.baseurl,
                encode_path(&action_group.to_string()),
            );
            let request = client
                .client
                .put(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::delete_action_group`]
    ///
    ///[`Client::delete_action_group`]: super::Client::delete_action_group
    #[derive(Debug, Clone)]
    pub struct DeleteActionGroup<'a> {
        client: &'a super::Client,
        action_group: Result<String, String>,
    }

    impl<'a> DeleteActionGroup<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                action_group: Err("action_group was not initialized".to_string()),
            }
        }

        pub fn action_group<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.action_group = value
                .try_into()
                .map_err(|_| "conversion to `String` for action_group failed".to_string());
            self
        }

        ///Sends a `DELETE` request to
        /// `/_plugins/_security/api/actiongroups/{action_group}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::DeleteActionGroupResponseContent>, Error<()>> {
            let Self {
                client,
                action_group,
            } = self;
            let action_group = action_group.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_plugins/_security/api/actiongroups/{}",
                client.baseurl,
                encode_path(&action_group.to_string()),
            );
            let request = client
                .client
                .delete(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::patch_action_group`]
    ///
    ///[`Client::patch_action_group`]: super::Client::patch_action_group
    #[derive(Debug, Clone)]
    pub struct PatchActionGroup<'a> {
        client: &'a super::Client,
        action_group: Result<String, String>,
        body: Result<types::PatchActionGroupInputPayload, String>,
    }

    impl<'a> PatchActionGroup<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                action_group: Err("action_group was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn action_group<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.action_group = value
                .try_into()
                .map_err(|_| "conversion to `String` for action_group failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PatchActionGroupInputPayload>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `PatchActionGroupInputPayload` for body failed".to_string()
            });
            self
        }

        ///Sends a `PATCH` request to
        /// `/_plugins/_security/api/actiongroups/{action_group}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::PatchActionGroupResponseContent>, Error<()>> {
            let Self {
                client,
                action_group,
                body,
            } = self;
            let action_group = action_group.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_plugins/_security/api/actiongroups/{}",
                client.baseurl,
                encode_path(&action_group.to_string()),
            );
            let request = client
                .client
                .patch(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::get_audit_configuration`]
    ///
    ///[`Client::get_audit_configuration`]: super::Client::get_audit_configuration
    #[derive(Debug, Clone)]
    pub struct GetAuditConfiguration<'a> {
        client: &'a super::Client,
    }

    impl<'a> GetAuditConfiguration<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        ///Sends a `GET` request to `/_plugins/_security/api/audit`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::AuditConfigWithReadOnly>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/_plugins/_security/api/audit", client.baseurl,);
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::patch_audit_configuration`]
    ///
    ///[`Client::patch_audit_configuration`]: super::Client::patch_audit_configuration
    #[derive(Debug, Clone)]
    pub struct PatchAuditConfiguration<'a> {
        client: &'a super::Client,
        body: Result<types::PatchAuditConfigurationInputPayload, String>,
    }

    impl<'a> PatchAuditConfiguration<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PatchAuditConfigurationInputPayload>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `PatchAuditConfigurationInputPayload` for body failed".to_string()
            });
            self
        }

        ///Sends a `PATCH` request to `/_plugins/_security/api/audit`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_plugins/_security/api/audit", client.baseurl,);
            let request = client.client.patch(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::update_audit_configuration`]
    ///
    ///[`Client::update_audit_configuration`]: super::Client::update_audit_configuration
    #[derive(Debug, Clone)]
    pub struct UpdateAuditConfiguration<'a> {
        client: &'a super::Client,
        body: Result<types::builder::AuditConfig, String>,
    }

    impl<'a> UpdateAuditConfiguration<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Ok(types::builder::AuditConfig::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::AuditConfig>,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|_| "conversion to `AuditConfig` for body failed".to_string());
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::AuditConfig) -> types::builder::AuditConfig,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `PUT` request to `/_plugins/_security/api/audit/config`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::UpdateAuditConfigurationResponseContent>, Error<()>>
        {
            let Self { client, body } = self;
            let body = body
                .and_then(std::convert::TryInto::<types::AuditConfig>::try_into)
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/_plugins/_security/api/audit/config", client.baseurl,);
            let request = client
                .client
                .put(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::flush_cache`]
    ///
    ///[`Client::flush_cache`]: super::Client::flush_cache
    #[derive(Debug, Clone)]
    pub struct FlushCache<'a> {
        client: &'a super::Client,
    }

    impl<'a> FlushCache<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        ///Sends a `DELETE` request to `/_plugins/_security/api/cache`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::FlushCacheResponseContent>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/_plugins/_security/api/cache", client.baseurl,);
            let request = client
                .client
                .delete(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::get_users`]
    ///
    ///[`Client::get_users`]: super::Client::get_users
    #[derive(Debug, Clone)]
    pub struct GetUsers<'a> {
        client: &'a super::Client,
    }

    impl<'a> GetUsers<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        ///Sends a `GET` request to `/_plugins/_security/api/internalusers`
        pub async fn send(self) -> Result<ResponseValue<types::UsersMap>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/_plugins/_security/api/internalusers", client.baseurl,);
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::patch_users`]
    ///
    ///[`Client::patch_users`]: super::Client::patch_users
    #[derive(Debug, Clone)]
    pub struct PatchUsers<'a> {
        client: &'a super::Client,
        body: Result<types::PatchUsersInputPayload, String>,
    }

    impl<'a> PatchUsers<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PatchUsersInputPayload>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `PatchUsersInputPayload` for body failed".to_string());
            self
        }

        ///Sends a `PATCH` request to `/_plugins/_security/api/internalusers`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::PatchUsersResponseContent>, Error<()>> {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_plugins/_security/api/internalusers", client.baseurl,);
            let request = client
                .client
                .patch(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::get_user`]
    ///
    ///[`Client::get_user`]: super::Client::get_user
    #[derive(Debug, Clone)]
    pub struct GetUser<'a> {
        client: &'a super::Client,
        username: Result<String, String>,
    }

    impl<'a> GetUser<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                username: Err("username was not initialized".to_string()),
            }
        }

        pub fn username<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.username = value
                .try_into()
                .map_err(|_| "conversion to `String` for username failed".to_string());
            self
        }

        ///Sends a `GET` request to
        /// `/_plugins/_security/api/internalusers/{username}`
        pub async fn send(self) -> Result<ResponseValue<types::UsersMap>, Error<()>> {
            let Self { client, username } = self;
            let username = username.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_plugins/_security/api/internalusers/{}",
                client.baseurl,
                encode_path(&username.to_string()),
            );
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::create_user`]
    ///
    ///[`Client::create_user`]: super::Client::create_user
    #[derive(Debug, Clone)]
    pub struct CreateUser<'a> {
        client: &'a super::Client,
        username: Result<String, String>,
        body: Result<types::builder::User, String>,
    }

    impl<'a> CreateUser<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                username: Err("username was not initialized".to_string()),
                body: Ok(types::builder::User::default()),
            }
        }

        pub fn username<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.username = value
                .try_into()
                .map_err(|_| "conversion to `String` for username failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::User>,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|_| "conversion to `User` for body failed".to_string());
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::User) -> types::builder::User,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `PUT` request to
        /// `/_plugins/_security/api/internalusers/{username}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::CreateUserResponseContent>, Error<()>> {
            let Self {
                client,
                username,
                body,
            } = self;
            let username = username.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(std::convert::TryInto::<types::User>::try_into)
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_plugins/_security/api/internalusers/{}",
                client.baseurl,
                encode_path(&username.to_string()),
            );
            let request = client
                .client
                .put(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::delete_user`]
    ///
    ///[`Client::delete_user`]: super::Client::delete_user
    #[derive(Debug, Clone)]
    pub struct DeleteUser<'a> {
        client: &'a super::Client,
        username: Result<String, String>,
    }

    impl<'a> DeleteUser<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                username: Err("username was not initialized".to_string()),
            }
        }

        pub fn username<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.username = value
                .try_into()
                .map_err(|_| "conversion to `String` for username failed".to_string());
            self
        }

        ///Sends a `DELETE` request to
        /// `/_plugins/_security/api/internalusers/{username}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::DeleteUserResponseContent>, Error<()>> {
            let Self { client, username } = self;
            let username = username.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_plugins/_security/api/internalusers/{}",
                client.baseurl,
                encode_path(&username.to_string()),
            );
            let request = client
                .client
                .delete(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::patch_user`]
    ///
    ///[`Client::patch_user`]: super::Client::patch_user
    #[derive(Debug, Clone)]
    pub struct PatchUser<'a> {
        client: &'a super::Client,
        username: Result<String, String>,
        body: Result<types::PatchUserInputPayload, String>,
    }

    impl<'a> PatchUser<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                username: Err("username was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn username<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.username = value
                .try_into()
                .map_err(|_| "conversion to `String` for username failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PatchUserInputPayload>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `PatchUserInputPayload` for body failed".to_string());
            self
        }

        ///Sends a `PATCH` request to
        /// `/_plugins/_security/api/internalusers/{username}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::PatchUserResponseContent>, Error<()>> {
            let Self {
                client,
                username,
                body,
            } = self;
            let username = username.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_plugins/_security/api/internalusers/{}",
                client.baseurl,
                encode_path(&username.to_string()),
            );
            let request = client
                .client
                .patch(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::get_distinguished_names`]
    ///
    ///[`Client::get_distinguished_names`]: super::Client::get_distinguished_names
    #[derive(Debug, Clone)]
    pub struct GetDistinguishedNames<'a> {
        client: &'a super::Client,
    }

    impl<'a> GetDistinguishedNames<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        ///Sends a `GET` request to `/_plugins/_security/api/nodesdn`
        pub async fn send(self) -> Result<ResponseValue<types::DistinguishedNamesMap>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/_plugins/_security/api/nodesdn", client.baseurl,);
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::patch_distinguished_names`]
    ///
    ///[`Client::patch_distinguished_names`]: super::Client::patch_distinguished_names
    #[derive(Debug, Clone)]
    pub struct PatchDistinguishedNames<'a> {
        client: &'a super::Client,
        body: Result<types::PatchDistinguishedNamesInputPayload, String>,
    }

    impl<'a> PatchDistinguishedNames<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PatchDistinguishedNamesInputPayload>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `PatchDistinguishedNamesInputPayload` for body failed".to_string()
            });
            self
        }

        ///Sends a `PATCH` request to `/_plugins/_security/api/nodesdn`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::PatchDistinguishedNamesResponseContent>, Error<()>>
        {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_plugins/_security/api/nodesdn", client.baseurl,);
            let request = client
                .client
                .patch(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::get_distinguished_names_with_cluster_name`]
    ///
    ///[`Client::get_distinguished_names_with_cluster_name`]: super::Client::get_distinguished_names_with_cluster_name
    #[derive(Debug, Clone)]
    pub struct GetDistinguishedNamesWithClusterName<'a> {
        client: &'a super::Client,
        cluster_name: Result<String, String>,
    }

    impl<'a> GetDistinguishedNamesWithClusterName<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                cluster_name: Err("cluster_name was not initialized".to_string()),
            }
        }

        pub fn cluster_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.cluster_name = value
                .try_into()
                .map_err(|_| "conversion to `String` for cluster_name failed".to_string());
            self
        }

        ///Sends a `GET` request to
        /// `/_plugins/_security/api/nodesdn/{cluster_name}`
        pub async fn send(self) -> Result<ResponseValue<types::DistinguishedNamesMap>, Error<()>> {
            let Self {
                client,
                cluster_name,
            } = self;
            let cluster_name = cluster_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_plugins/_security/api/nodesdn/{}",
                client.baseurl,
                encode_path(&cluster_name.to_string()),
            );
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::update_distinguished_names`]
    ///
    ///[`Client::update_distinguished_names`]: super::Client::update_distinguished_names
    #[derive(Debug, Clone)]
    pub struct UpdateDistinguishedNames<'a> {
        client: &'a super::Client,
        cluster_name: Result<String, String>,
        body: Result<types::builder::DistinguishedNames, String>,
    }

    impl<'a> UpdateDistinguishedNames<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                cluster_name: Err("cluster_name was not initialized".to_string()),
                body: Ok(types::builder::DistinguishedNames::default()),
            }
        }

        pub fn cluster_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.cluster_name = value
                .try_into()
                .map_err(|_| "conversion to `String` for cluster_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DistinguishedNames>,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|_| "conversion to `DistinguishedNames` for body failed".to_string());
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::DistinguishedNames,
            ) -> types::builder::DistinguishedNames,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `PUT` request to
        /// `/_plugins/_security/api/nodesdn/{cluster_name}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::UpdateDistinguishedNamesResponseContent>, Error<()>>
        {
            let Self {
                client,
                cluster_name,
                body,
            } = self;
            let cluster_name = cluster_name.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(std::convert::TryInto::<types::DistinguishedNames>::try_into)
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_plugins/_security/api/nodesdn/{}",
                client.baseurl,
                encode_path(&cluster_name.to_string()),
            );
            let request = client
                .client
                .put(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::delete_distinguished_names`]
    ///
    ///[`Client::delete_distinguished_names`]: super::Client::delete_distinguished_names
    #[derive(Debug, Clone)]
    pub struct DeleteDistinguishedNames<'a> {
        client: &'a super::Client,
        cluster_name: Result<String, String>,
    }

    impl<'a> DeleteDistinguishedNames<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                cluster_name: Err("cluster_name was not initialized".to_string()),
            }
        }

        pub fn cluster_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.cluster_name = value
                .try_into()
                .map_err(|_| "conversion to `String` for cluster_name failed".to_string());
            self
        }

        ///Sends a `DELETE` request to
        /// `/_plugins/_security/api/nodesdn/{cluster_name}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::DeleteDistinguishedNamesResponseContent>, Error<()>>
        {
            let Self {
                client,
                cluster_name,
            } = self;
            let cluster_name = cluster_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_plugins/_security/api/nodesdn/{}",
                client.baseurl,
                encode_path(&cluster_name.to_string()),
            );
            let request = client
                .client
                .delete(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::patch_roles`]
    ///
    ///[`Client::patch_roles`]: super::Client::patch_roles
    #[derive(Debug, Clone)]
    pub struct PatchRoles<'a> {
        client: &'a super::Client,
        body: Result<types::PatchRolesInputPayload, String>,
    }

    impl<'a> PatchRoles<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PatchRolesInputPayload>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `PatchRolesInputPayload` for body failed".to_string());
            self
        }

        ///Sends a `PATCH` request to `/_plugins/_security/api/roles`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::PatchRolesResponseContent>, Error<()>> {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_plugins/_security/api/roles", client.baseurl,);
            let request = client
                .client
                .patch(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::get_roles`]
    ///
    ///[`Client::get_roles`]: super::Client::get_roles
    #[derive(Debug, Clone)]
    pub struct GetRoles<'a> {
        client: &'a super::Client,
    }

    impl<'a> GetRoles<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        ///Sends a `GET` request to `/_plugins/_security/api/roles/`
        pub async fn send(self) -> Result<ResponseValue<types::RolesMap>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/_plugins/_security/api/roles/", client.baseurl,);
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::get_role`]
    ///
    ///[`Client::get_role`]: super::Client::get_role
    #[derive(Debug, Clone)]
    pub struct GetRole<'a> {
        client: &'a super::Client,
        role: Result<String, String>,
    }

    impl<'a> GetRole<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                role: Err("role was not initialized".to_string()),
            }
        }

        pub fn role<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.role = value
                .try_into()
                .map_err(|_| "conversion to `String` for role failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_plugins/_security/api/roles/{role}`
        pub async fn send(self) -> Result<ResponseValue<types::RolesMap>, Error<()>> {
            let Self { client, role } = self;
            let role = role.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_plugins/_security/api/roles/{}",
                client.baseurl,
                encode_path(&role.to_string()),
            );
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::create_role`]
    ///
    ///[`Client::create_role`]: super::Client::create_role
    #[derive(Debug, Clone)]
    pub struct CreateRole<'a> {
        client: &'a super::Client,
        role: Result<String, String>,
        body: Result<types::builder::Role, String>,
    }

    impl<'a> CreateRole<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                role: Err("role was not initialized".to_string()),
                body: Ok(types::builder::Role::default()),
            }
        }

        pub fn role<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.role = value
                .try_into()
                .map_err(|_| "conversion to `String` for role failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Role>,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|_| "conversion to `Role` for body failed".to_string());
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::Role) -> types::builder::Role,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `PUT` request to `/_plugins/_security/api/roles/{role}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::CreateRoleResponseContent>, Error<()>> {
            let Self { client, role, body } = self;
            let role = role.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(std::convert::TryInto::<types::Role>::try_into)
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_plugins/_security/api/roles/{}",
                client.baseurl,
                encode_path(&role.to_string()),
            );
            let request = client
                .client
                .put(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::delete_role`]
    ///
    ///[`Client::delete_role`]: super::Client::delete_role
    #[derive(Debug, Clone)]
    pub struct DeleteRole<'a> {
        client: &'a super::Client,
        role: Result<String, String>,
    }

    impl<'a> DeleteRole<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                role: Err("role was not initialized".to_string()),
            }
        }

        pub fn role<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.role = value
                .try_into()
                .map_err(|_| "conversion to `String` for role failed".to_string());
            self
        }

        ///Sends a `DELETE` request to `/_plugins/_security/api/roles/{role}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::DeleteRoleResponseContent>, Error<()>> {
            let Self { client, role } = self;
            let role = role.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_plugins/_security/api/roles/{}",
                client.baseurl,
                encode_path(&role.to_string()),
            );
            let request = client
                .client
                .delete(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::patch_role`]
    ///
    ///[`Client::patch_role`]: super::Client::patch_role
    #[derive(Debug, Clone)]
    pub struct PatchRole<'a> {
        client: &'a super::Client,
        role: Result<String, String>,
        body: Result<types::PatchRoleInputPayload, String>,
    }

    impl<'a> PatchRole<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                role: Err("role was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn role<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.role = value
                .try_into()
                .map_err(|_| "conversion to `String` for role failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PatchRoleInputPayload>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `PatchRoleInputPayload` for body failed".to_string());
            self
        }

        ///Sends a `PATCH` request to `/_plugins/_security/api/roles/{role}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::PatchRoleResponseContent>, Error<()>> {
            let Self { client, role, body } = self;
            let role = role.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_plugins/_security/api/roles/{}",
                client.baseurl,
                encode_path(&role.to_string()),
            );
            let request = client
                .client
                .patch(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::get_role_mappings`]
    ///
    ///[`Client::get_role_mappings`]: super::Client::get_role_mappings
    #[derive(Debug, Clone)]
    pub struct GetRoleMappings<'a> {
        client: &'a super::Client,
    }

    impl<'a> GetRoleMappings<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        ///Sends a `GET` request to `/_plugins/_security/api/rolesmapping`
        pub async fn send(self) -> Result<ResponseValue<types::RoleMappings>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/_plugins/_security/api/rolesmapping", client.baseurl,);
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::patch_role_mappings`]
    ///
    ///[`Client::patch_role_mappings`]: super::Client::patch_role_mappings
    #[derive(Debug, Clone)]
    pub struct PatchRoleMappings<'a> {
        client: &'a super::Client,
        body: Result<types::PatchRoleMappingsInputPayload, String>,
    }

    impl<'a> PatchRoleMappings<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PatchRoleMappingsInputPayload>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `PatchRoleMappingsInputPayload` for body failed".to_string()
            });
            self
        }

        ///Sends a `PATCH` request to `/_plugins/_security/api/rolesmapping`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::PatchRoleMappingsResponseContent>, Error<()>> {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_plugins/_security/api/rolesmapping", client.baseurl,);
            let request = client
                .client
                .patch(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::get_role_mapping`]
    ///
    ///[`Client::get_role_mapping`]: super::Client::get_role_mapping
    #[derive(Debug, Clone)]
    pub struct GetRoleMapping<'a> {
        client: &'a super::Client,
        role: Result<String, String>,
    }

    impl<'a> GetRoleMapping<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                role: Err("role was not initialized".to_string()),
            }
        }

        pub fn role<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.role = value
                .try_into()
                .map_err(|_| "conversion to `String` for role failed".to_string());
            self
        }

        ///Sends a `GET` request to
        /// `/_plugins/_security/api/rolesmapping/{role}`
        pub async fn send(self) -> Result<ResponseValue<types::RoleMappings>, Error<()>> {
            let Self { client, role } = self;
            let role = role.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_plugins/_security/api/rolesmapping/{}",
                client.baseurl,
                encode_path(&role.to_string()),
            );
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::create_role_mapping`]
    ///
    ///[`Client::create_role_mapping`]: super::Client::create_role_mapping
    #[derive(Debug, Clone)]
    pub struct CreateRoleMapping<'a> {
        client: &'a super::Client,
        role: Result<String, String>,
        body: Result<types::builder::RoleMapping, String>,
    }

    impl<'a> CreateRoleMapping<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                role: Err("role was not initialized".to_string()),
                body: Ok(types::builder::RoleMapping::default()),
            }
        }

        pub fn role<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.role = value
                .try_into()
                .map_err(|_| "conversion to `String` for role failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RoleMapping>,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|_| "conversion to `RoleMapping` for body failed".to_string());
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::RoleMapping) -> types::builder::RoleMapping,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `PUT` request to
        /// `/_plugins/_security/api/rolesmapping/{role}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::CreateRoleMappingResponseContent>, Error<()>> {
            let Self { client, role, body } = self;
            let role = role.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(std::convert::TryInto::<types::RoleMapping>::try_into)
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_plugins/_security/api/rolesmapping/{}",
                client.baseurl,
                encode_path(&role.to_string()),
            );
            let request = client
                .client
                .put(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::delete_role_mapping`]
    ///
    ///[`Client::delete_role_mapping`]: super::Client::delete_role_mapping
    #[derive(Debug, Clone)]
    pub struct DeleteRoleMapping<'a> {
        client: &'a super::Client,
        role: Result<String, String>,
    }

    impl<'a> DeleteRoleMapping<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                role: Err("role was not initialized".to_string()),
            }
        }

        pub fn role<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.role = value
                .try_into()
                .map_err(|_| "conversion to `String` for role failed".to_string());
            self
        }

        ///Sends a `DELETE` request to
        /// `/_plugins/_security/api/rolesmapping/{role}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::DeleteRoleMappingResponseContent>, Error<()>> {
            let Self { client, role } = self;
            let role = role.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_plugins/_security/api/rolesmapping/{}",
                client.baseurl,
                encode_path(&role.to_string()),
            );
            let request = client
                .client
                .delete(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::patch_role_mapping`]
    ///
    ///[`Client::patch_role_mapping`]: super::Client::patch_role_mapping
    #[derive(Debug, Clone)]
    pub struct PatchRoleMapping<'a> {
        client: &'a super::Client,
        role: Result<String, String>,
        body: Result<types::PatchRoleMappingInputPayload, String>,
    }

    impl<'a> PatchRoleMapping<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                role: Err("role was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn role<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.role = value
                .try_into()
                .map_err(|_| "conversion to `String` for role failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PatchRoleMappingInputPayload>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `PatchRoleMappingInputPayload` for body failed".to_string()
            });
            self
        }

        ///Sends a `PATCH` request to
        /// `/_plugins/_security/api/rolesmapping/{role}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::PatchRoleMappingResponseContent>, Error<()>> {
            let Self { client, role, body } = self;
            let role = role.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_plugins/_security/api/rolesmapping/{}",
                client.baseurl,
                encode_path(&role.to_string()),
            );
            let request = client
                .client
                .patch(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::get_configuration`]
    ///
    ///[`Client::get_configuration`]: super::Client::get_configuration
    #[derive(Debug, Clone)]
    pub struct GetConfiguration<'a> {
        client: &'a super::Client,
    }

    impl<'a> GetConfiguration<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        ///Sends a `GET` request to `/_plugins/_security/api/securityconfig`
        pub async fn send(self) -> Result<ResponseValue<types::DynamicConfig>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/_plugins/_security/api/securityconfig", client.baseurl,);
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::patch_configuration`]
    ///
    ///[`Client::patch_configuration`]: super::Client::patch_configuration
    #[derive(Debug, Clone)]
    pub struct PatchConfiguration<'a> {
        client: &'a super::Client,
        body: Result<types::PatchConfigurationInputPayload, String>,
    }

    impl<'a> PatchConfiguration<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PatchConfigurationInputPayload>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `PatchConfigurationInputPayload` for body failed".to_string()
            });
            self
        }

        ///Sends a `PATCH` request to `/_plugins/_security/api/securityconfig`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::PatchConfigurationResponseContent>, Error<()>> {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_plugins/_security/api/securityconfig", client.baseurl,);
            let request = client
                .client
                .patch(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::update_configuration`]
    ///
    ///[`Client::update_configuration`]: super::Client::update_configuration
    #[derive(Debug, Clone)]
    pub struct UpdateConfiguration<'a> {
        client: &'a super::Client,
        body: Result<types::builder::DynamicConfig, String>,
    }

    impl<'a> UpdateConfiguration<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Ok(types::builder::DynamicConfig::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DynamicConfig>,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|_| "conversion to `DynamicConfig` for body failed".to_string());
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::DynamicConfig) -> types::builder::DynamicConfig,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `PUT` request to
        /// `/_plugins/_security/api/securityconfig/config`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::UpdateConfigurationResponseContent>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(std::convert::TryInto::<types::DynamicConfig>::try_into)
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_plugins/_security/api/securityconfig/config",
                client.baseurl,
            );
            let request = client
                .client
                .put(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::get_certificates`]
    ///
    ///[`Client::get_certificates`]: super::Client::get_certificates
    #[derive(Debug, Clone)]
    pub struct GetCertificates<'a> {
        client: &'a super::Client,
    }

    impl<'a> GetCertificates<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        ///Sends a `GET` request to `/_plugins/_security/api/ssl/certs`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::GetCertificatesResponseContent>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/_plugins/_security/api/ssl/certs", client.baseurl,);
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::reload_http_certificates`]
    ///
    ///[`Client::reload_http_certificates`]: super::Client::reload_http_certificates
    #[derive(Debug, Clone)]
    pub struct ReloadHttpCertificates<'a> {
        client: &'a super::Client,
    }

    impl<'a> ReloadHttpCertificates<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        ///Sends a `PUT` request to
        /// `/_plugins/_security/api/ssl/http/reloadcerts`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ReloadHttpCertificatesResponseContent>, Error<()>>
        {
            let Self { client } = self;
            let url = format!(
                "{}/_plugins/_security/api/ssl/http/reloadcerts",
                client.baseurl,
            );
            let request = client
                .client
                .put(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::reload_transport_certificates`]
    ///
    ///[`Client::reload_transport_certificates`]: super::Client::reload_transport_certificates
    #[derive(Debug, Clone)]
    pub struct ReloadTransportCertificates<'a> {
        client: &'a super::Client,
    }

    impl<'a> ReloadTransportCertificates<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        ///Sends a `PUT` request to
        /// `/_plugins/_security/api/ssl/transport/reloadcerts`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ReloadTransportCertificatesResponseContent>, Error<()>>
        {
            let Self { client } = self;
            let url = format!(
                "{}/_plugins/_security/api/ssl/transport/reloadcerts",
                client.baseurl,
            );
            let request = client
                .client
                .put(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::get_tenants`]
    ///
    ///[`Client::get_tenants`]: super::Client::get_tenants
    #[derive(Debug, Clone)]
    pub struct GetTenants<'a> {
        client: &'a super::Client,
    }

    impl<'a> GetTenants<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        ///Sends a `GET` request to `/_plugins/_security/api/tenants/`
        pub async fn send(self) -> Result<ResponseValue<types::TenantsMap>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/_plugins/_security/api/tenants/", client.baseurl,);
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::patch_tenants`]
    ///
    ///[`Client::patch_tenants`]: super::Client::patch_tenants
    #[derive(Debug, Clone)]
    pub struct PatchTenants<'a> {
        client: &'a super::Client,
        body: Result<types::PatchTenantsInputPayload, String>,
    }

    impl<'a> PatchTenants<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PatchTenantsInputPayload>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `PatchTenantsInputPayload` for body failed".to_string()
            });
            self
        }

        ///Sends a `PATCH` request to `/_plugins/_security/api/tenants/`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::PatchTenantsResponseContent>, Error<()>> {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_plugins/_security/api/tenants/", client.baseurl,);
            let request = client
                .client
                .patch(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::get_tenant`]
    ///
    ///[`Client::get_tenant`]: super::Client::get_tenant
    #[derive(Debug, Clone)]
    pub struct GetTenant<'a> {
        client: &'a super::Client,
        tenant: Result<String, String>,
    }

    impl<'a> GetTenant<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                tenant: Err("tenant was not initialized".to_string()),
            }
        }

        pub fn tenant<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.tenant = value
                .try_into()
                .map_err(|_| "conversion to `String` for tenant failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_plugins/_security/api/tenants/{tenant}`
        pub async fn send(self) -> Result<ResponseValue<types::TenantsMap>, Error<()>> {
            let Self { client, tenant } = self;
            let tenant = tenant.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_plugins/_security/api/tenants/{}",
                client.baseurl,
                encode_path(&tenant.to_string()),
            );
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::create_tenant`]
    ///
    ///[`Client::create_tenant`]: super::Client::create_tenant
    #[derive(Debug, Clone)]
    pub struct CreateTenant<'a> {
        client: &'a super::Client,
        tenant: Result<String, String>,
        body: Result<types::builder::CreateTenantParams, String>,
    }

    impl<'a> CreateTenant<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                tenant: Err("tenant was not initialized".to_string()),
                body: Ok(types::builder::CreateTenantParams::default()),
            }
        }

        pub fn tenant<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.tenant = value
                .try_into()
                .map_err(|_| "conversion to `String` for tenant failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateTenantParams>,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|_| "conversion to `CreateTenantParams` for body failed".to_string());
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::CreateTenantParams,
            ) -> types::builder::CreateTenantParams,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `PUT` request to `/_plugins/_security/api/tenants/{tenant}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::CreateTenantResponseContent>, Error<()>> {
            let Self {
                client,
                tenant,
                body,
            } = self;
            let tenant = tenant.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(std::convert::TryInto::<types::CreateTenantParams>::try_into)
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_plugins/_security/api/tenants/{}",
                client.baseurl,
                encode_path(&tenant.to_string()),
            );
            let request = client
                .client
                .put(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::delete_tenant`]
    ///
    ///[`Client::delete_tenant`]: super::Client::delete_tenant
    #[derive(Debug, Clone)]
    pub struct DeleteTenant<'a> {
        client: &'a super::Client,
        tenant: Result<String, String>,
    }

    impl<'a> DeleteTenant<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                tenant: Err("tenant was not initialized".to_string()),
            }
        }

        pub fn tenant<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.tenant = value
                .try_into()
                .map_err(|_| "conversion to `String` for tenant failed".to_string());
            self
        }

        ///Sends a `DELETE` request to
        /// `/_plugins/_security/api/tenants/{tenant}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::DeleteTenantResponseContent>, Error<()>> {
            let Self { client, tenant } = self;
            let tenant = tenant.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_plugins/_security/api/tenants/{}",
                client.baseurl,
                encode_path(&tenant.to_string()),
            );
            let request = client
                .client
                .delete(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::patch_tenant`]
    ///
    ///[`Client::patch_tenant`]: super::Client::patch_tenant
    #[derive(Debug, Clone)]
    pub struct PatchTenant<'a> {
        client: &'a super::Client,
        tenant: Result<String, String>,
        body: Result<types::PatchTenantInputPayload, String>,
    }

    impl<'a> PatchTenant<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                tenant: Err("tenant was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn tenant<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.tenant = value
                .try_into()
                .map_err(|_| "conversion to `String` for tenant failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PatchTenantInputPayload>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `PatchTenantInputPayload` for body failed".to_string());
            self
        }

        ///Sends a `PATCH` request to
        /// `/_plugins/_security/api/tenants/{tenant}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::PatchTenantResponseContent>, Error<()>> {
            let Self {
                client,
                tenant,
                body,
            } = self;
            let tenant = tenant.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_plugins/_security/api/tenants/{}",
                client.baseurl,
                encode_path(&tenant.to_string()),
            );
            let request = client
                .client
                .patch(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::security_health`]
    ///
    ///[`Client::security_health`]: super::Client::security_health
    #[derive(Debug, Clone)]
    pub struct SecurityHealth<'a> {
        client: &'a super::Client,
    }

    impl<'a> SecurityHealth<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        ///Sends a `GET` request to `/_plugins/_security/health`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SecurityHealthResponseContent>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/_plugins/_security/health", client.baseurl,);
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::rank_eval_get`]
    ///
    ///[`Client::rank_eval_get`]: super::Client::rank_eval_get
    #[derive(Debug, Clone)]
    pub struct RankEvalGet<'a> {
        client: &'a super::Client,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        search_type: Result<Option<types::SearchType>, String>,
    }

    impl<'a> RankEvalGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                ignore_unavailable: Ok(None),
                search_type: Ok(None),
            }
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn search_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchType>,
        {
            self.search_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SearchType` for search_type failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_rank_eval`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                allow_no_indices,
                expand_wildcards,
                ignore_unavailable,
                search_type,
            } = self;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let search_type = search_type.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_rank_eval", client.baseurl,);
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &search_type {
                query.push(("search_type", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::rank_eval_post`]
    ///
    ///[`Client::rank_eval_post`]: super::Client::rank_eval_post
    #[derive(Debug, Clone)]
    pub struct RankEvalPost<'a> {
        client: &'a super::Client,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        search_type: Result<Option<types::SearchType>, String>,
        body: Result<types::RankEvalBodyParams, String>,
    }

    impl<'a> RankEvalPost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                ignore_unavailable: Ok(None),
                search_type: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn search_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchType>,
        {
            self.search_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SearchType` for search_type failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RankEvalBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `RankEvalBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `POST` request to `/_rank_eval`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                allow_no_indices,
                expand_wildcards,
                ignore_unavailable,
                search_type,
                body,
            } = self;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let search_type = search_type.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_rank_eval", client.baseurl,);
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &search_type {
                query.push(("search_type", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_recovery`]
    ///
    ///[`Client::indices_recovery`]: super::Client::indices_recovery
    #[derive(Debug, Clone)]
    pub struct IndicesRecovery<'a> {
        client: &'a super::Client,
        active_only: Result<Option<bool>, String>,
        detailed: Result<Option<bool>, String>,
    }

    impl<'a> IndicesRecovery<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                active_only: Ok(None),
                detailed: Ok(None),
            }
        }

        pub fn active_only<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.active_only = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for active_only failed".to_string());
            self
        }

        pub fn detailed<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.detailed = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for detailed failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_recovery`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                active_only,
                detailed,
            } = self;
            let active_only = active_only.map_err(Error::InvalidRequest)?;
            let detailed = detailed.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_recovery", client.baseurl,);
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &active_only {
                query.push(("active_only", v.to_string()));
            }
            if let Some(v) = &detailed {
                query.push(("detailed", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_refresh_get`]
    ///
    ///[`Client::indices_refresh_get`]: super::Client::indices_refresh_get
    #[derive(Debug, Clone)]
    pub struct IndicesRefreshGet<'a> {
        client: &'a super::Client,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
    }

    impl<'a> IndicesRefreshGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                ignore_unavailable: Ok(None),
            }
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_refresh`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                allow_no_indices,
                expand_wildcards,
                ignore_unavailable,
            } = self;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_refresh", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_refresh_post`]
    ///
    ///[`Client::indices_refresh_post`]: super::Client::indices_refresh_post
    #[derive(Debug, Clone)]
    pub struct IndicesRefreshPost<'a> {
        client: &'a super::Client,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
    }

    impl<'a> IndicesRefreshPost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                ignore_unavailable: Ok(None),
            }
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        ///Sends a `POST` request to `/_refresh`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                allow_no_indices,
                expand_wildcards,
                ignore_unavailable,
            } = self;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_refresh", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            let request = client.client.post(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::reindex`]
    ///
    ///[`Client::reindex`]: super::Client::reindex
    #[derive(Debug, Clone)]
    pub struct Reindex<'a> {
        client: &'a super::Client,
        max_docs: Result<Option<i32>, String>,
        refresh: Result<Option<bool>, String>,
        requests_per_second: Result<Option<i32>, String>,
        scroll: Result<Option<types::ReindexScroll>, String>,
        slices: Result<Option<String>, String>,
        timeout: Result<Option<types::ReindexTimeout>, String>,
        wait_for_active_shards: Result<Option<String>, String>,
        wait_for_completion: Result<Option<bool>, String>,
        body: Result<types::ReindexBodyParams, String>,
    }

    impl<'a> Reindex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                max_docs: Ok(None),
                refresh: Ok(None),
                requests_per_second: Ok(None),
                scroll: Ok(None),
                slices: Ok(None),
                timeout: Ok(None),
                wait_for_active_shards: Ok(None),
                wait_for_completion: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn max_docs<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.max_docs = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for max_docs failed".to_string());
            self
        }

        pub fn refresh<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.refresh = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for refresh failed".to_string());
            self
        }

        pub fn requests_per_second<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.requests_per_second = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for requests_per_second failed".to_string());
            self
        }

        pub fn scroll<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ReindexScroll>,
        {
            self.scroll = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `ReindexScroll` for scroll failed".to_string());
            self
        }

        pub fn slices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.slices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for slices failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ReindexTimeout>,
        {
            self.timeout = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `ReindexTimeout` for timeout failed".to_string());
            self
        }

        pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.wait_for_active_shards = value.try_into().map(Some).map_err(|_| {
                "conversion to `String` for wait_for_active_shards failed".to_string()
            });
            self
        }

        pub fn wait_for_completion<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.wait_for_completion = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for wait_for_completion failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ReindexBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `ReindexBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `POST` request to `/_reindex`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                max_docs,
                refresh,
                requests_per_second,
                scroll,
                slices,
                timeout,
                wait_for_active_shards,
                wait_for_completion,
                body,
            } = self;
            let max_docs = max_docs.map_err(Error::InvalidRequest)?;
            let refresh = refresh.map_err(Error::InvalidRequest)?;
            let requests_per_second = requests_per_second.map_err(Error::InvalidRequest)?;
            let scroll = scroll.map_err(Error::InvalidRequest)?;
            let slices = slices.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
            let wait_for_completion = wait_for_completion.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_reindex", client.baseurl,);
            let mut query = Vec::with_capacity(8usize);
            if let Some(v) = &max_docs {
                query.push(("max_docs", v.to_string()));
            }
            if let Some(v) = &refresh {
                query.push(("refresh", v.to_string()));
            }
            if let Some(v) = &requests_per_second {
                query.push(("requests_per_second", v.to_string()));
            }
            if let Some(v) = &scroll {
                query.push(("scroll", v.to_string()));
            }
            if let Some(v) = &slices {
                query.push(("slices", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &wait_for_active_shards {
                query.push(("wait_for_active_shards", v.to_string()));
            }
            if let Some(v) = &wait_for_completion {
                query.push(("wait_for_completion", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::reindex_rethrottle`]
    ///
    ///[`Client::reindex_rethrottle`]: super::Client::reindex_rethrottle
    #[derive(Debug, Clone)]
    pub struct ReindexRethrottle<'a> {
        client: &'a super::Client,
        task_id: Result<types::ReindexRethrottleTaskId, String>,
        requests_per_second: Result<i32, String>,
    }

    impl<'a> ReindexRethrottle<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                task_id: Err("task_id was not initialized".to_string()),
                requests_per_second: Err("requests_per_second was not initialized".to_string()),
            }
        }

        pub fn task_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ReindexRethrottleTaskId>,
        {
            self.task_id = value.try_into().map_err(|_| {
                "conversion to `ReindexRethrottleTaskId` for task_id failed".to_string()
            });
            self
        }

        pub fn requests_per_second<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.requests_per_second = value
                .try_into()
                .map_err(|_| "conversion to `i32` for requests_per_second failed".to_string());
            self
        }

        ///Sends a `POST` request to `/_reindex/{task_id}/_rethrottle`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                task_id,
                requests_per_second,
            } = self;
            let task_id = task_id.map_err(Error::InvalidRequest)?;
            let requests_per_second = requests_per_second.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_reindex/{}/_rethrottle",
                client.baseurl,
                encode_path(&task_id.to_string()),
            );
            let mut query = Vec::with_capacity(1usize);
            query.push(("requests_per_second", requests_per_second.to_string()));
            let request = client.client.post(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::cluster_remote_info`]
    ///
    ///[`Client::cluster_remote_info`]: super::Client::cluster_remote_info
    #[derive(Debug, Clone)]
    pub struct ClusterRemoteInfo<'a> {
        client: &'a super::Client,
    }

    impl<'a> ClusterRemoteInfo<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        ///Sends a `GET` request to `/_remote/info`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/_remote/info", client.baseurl,);
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::remote_store_restore`]
    ///
    ///[`Client::remote_store_restore`]: super::Client::remote_store_restore
    #[derive(Debug, Clone)]
    pub struct RemoteStoreRestore<'a> {
        client: &'a super::Client,
        cluster_manager_timeout:
            Result<Option<types::RemoteStoreRestoreClusterManagerTimeout>, String>,
        wait_for_completion: Result<Option<bool>, String>,
        body: Result<types::builder::RemoteStoreRestoreBodyParams, String>,
    }

    impl<'a> RemoteStoreRestore<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                cluster_manager_timeout: Ok(None),
                wait_for_completion: Ok(None),
                body: Ok(types::builder::RemoteStoreRestoreBodyParams::default()),
            }
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RemoteStoreRestoreClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `RemoteStoreRestoreClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn wait_for_completion<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.wait_for_completion = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for wait_for_completion failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RemoteStoreRestoreBodyParams>,
        {
            self.body = value.try_into().map(From::from).map_err(|_| {
                "conversion to `RemoteStoreRestoreBodyParams` for body failed".to_string()
            });
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::RemoteStoreRestoreBodyParams,
            ) -> types::builder::RemoteStoreRestoreBodyParams,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to `/_remotestore/_restore`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::RemoteStoreRestoreResponseContent>, Error<()>> {
            let Self {
                client,
                cluster_manager_timeout,
                wait_for_completion,
                body,
            } = self;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let wait_for_completion = wait_for_completion.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(std::convert::TryInto::<types::RemoteStoreRestoreBodyParams>::try_into)
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/_remotestore/_restore", client.baseurl,);
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &wait_for_completion {
                query.push(("wait_for_completion", v.to_string()));
            }
            let request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::render_search_template_get`]
    ///
    ///[`Client::render_search_template_get`]: super::Client::render_search_template_get
    #[derive(Debug, Clone)]
    pub struct RenderSearchTemplateGet<'a> {
        client: &'a super::Client,
    }

    impl<'a> RenderSearchTemplateGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        ///Sends a `GET` request to `/_render/template`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/_render/template", client.baseurl,);
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::render_search_template_post`]
    ///
    ///[`Client::render_search_template_post`]: super::Client::render_search_template_post
    #[derive(Debug, Clone)]
    pub struct RenderSearchTemplatePost<'a> {
        client: &'a super::Client,
        body: Result<types::RenderSearchTemplateBodyParams, String>,
    }

    impl<'a> RenderSearchTemplatePost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RenderSearchTemplateBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `RenderSearchTemplateBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `POST` request to `/_render/template`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_render/template", client.baseurl,);
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::render_search_template_get_with_id`]
    ///
    ///[`Client::render_search_template_get_with_id`]: super::Client::render_search_template_get_with_id
    #[derive(Debug, Clone)]
    pub struct RenderSearchTemplateGetWithId<'a> {
        client: &'a super::Client,
        id: Result<types::RenderSearchTemplateGetWithIdId, String>,
    }

    impl<'a> RenderSearchTemplateGetWithId<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                id: Err("id was not initialized".to_string()),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RenderSearchTemplateGetWithIdId>,
        {
            self.id = value.try_into().map_err(|_| {
                "conversion to `RenderSearchTemplateGetWithIdId` for id failed".to_string()
            });
            self
        }

        ///Sends a `GET` request to `/_render/template/{id}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_render/template/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::render_search_template_post_with_id`]
    ///
    ///[`Client::render_search_template_post_with_id`]: super::Client::render_search_template_post_with_id
    #[derive(Debug, Clone)]
    pub struct RenderSearchTemplatePostWithId<'a> {
        client: &'a super::Client,
        id: Result<types::RenderSearchTemplatePostWithIdId, String>,
        body: Result<types::RenderSearchTemplateBodyParams, String>,
    }

    impl<'a> RenderSearchTemplatePostWithId<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                id: Err("id was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RenderSearchTemplatePostWithIdId>,
        {
            self.id = value.try_into().map_err(|_| {
                "conversion to `RenderSearchTemplatePostWithIdId` for id failed".to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RenderSearchTemplateBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `RenderSearchTemplateBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `POST` request to `/_render/template/{id}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, id, body } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_render/template/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_resolve_index`]
    ///
    ///[`Client::indices_resolve_index`]: super::Client::indices_resolve_index
    #[derive(Debug, Clone)]
    pub struct IndicesResolveIndex<'a> {
        client: &'a super::Client,
        name: Result<types::IndicesResolveIndexName, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
    }

    impl<'a> IndicesResolveIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                name: Err("name was not initialized".to_string()),
                expand_wildcards: Ok(None),
            }
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesResolveIndexName>,
        {
            self.name = value
                .try_into()
                .map_err(|_| "conversion to `IndicesResolveIndexName` for name failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        ///Sends a `GET` request to `/_resolve/index/{name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                name,
                expand_wildcards,
            } = self;
            let name = name.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_resolve/index/{}",
                client.baseurl,
                encode_path(&name.to_string()),
            );
            let mut query = Vec::with_capacity(1usize);
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::get_script_context`]
    ///
    ///[`Client::get_script_context`]: super::Client::get_script_context
    #[derive(Debug, Clone)]
    pub struct GetScriptContext<'a> {
        client: &'a super::Client,
    }

    impl<'a> GetScriptContext<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        ///Sends a `GET` request to `/_script_context`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/_script_context", client.baseurl,);
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::get_script_languages`]
    ///
    ///[`Client::get_script_languages`]: super::Client::get_script_languages
    #[derive(Debug, Clone)]
    pub struct GetScriptLanguages<'a> {
        client: &'a super::Client,
    }

    impl<'a> GetScriptLanguages<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        ///Sends a `GET` request to `/_script_language`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/_script_language", client.baseurl,);
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::scripts_painless_execute_get`]
    ///
    ///[`Client::scripts_painless_execute_get`]: super::Client::scripts_painless_execute_get
    #[derive(Debug, Clone)]
    pub struct ScriptsPainlessExecuteGet<'a> {
        client: &'a super::Client,
    }

    impl<'a> ScriptsPainlessExecuteGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        ///Sends a `GET` request to `/_scripts/painless/_execute`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/_scripts/painless/_execute", client.baseurl,);
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::scripts_painless_execute_post`]
    ///
    ///[`Client::scripts_painless_execute_post`]: super::Client::scripts_painless_execute_post
    #[derive(Debug, Clone)]
    pub struct ScriptsPainlessExecutePost<'a> {
        client: &'a super::Client,
        body: Result<types::ScriptsPainlessExecuteBodyParams, String>,
    }

    impl<'a> ScriptsPainlessExecutePost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ScriptsPainlessExecuteBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `ScriptsPainlessExecuteBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `POST` request to `/_scripts/painless/_execute`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_scripts/painless/_execute", client.baseurl,);
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::get_script`]
    ///
    ///[`Client::get_script`]: super::Client::get_script
    #[derive(Debug, Clone)]
    pub struct GetScript<'a> {
        client: &'a super::Client,
        id: Result<types::GetScriptId, String>,
        cluster_manager_timeout: Result<Option<types::GetScriptClusterManagerTimeout>, String>,
        master_timeout: Result<Option<types::GetScriptMasterTimeout>, String>,
    }

    impl<'a> GetScript<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                id: Err("id was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                master_timeout: Ok(None),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::GetScriptId>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `GetScriptId` for id failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::GetScriptClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `GetScriptClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::GetScriptMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `GetScriptMasterTimeout` for master_timeout failed".to_string()
            });
            self
        }

        ///Sends a `GET` request to `/_scripts/{id}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                id,
                cluster_manager_timeout,
                master_timeout,
            } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_scripts/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::put_script_put`]
    ///
    ///[`Client::put_script_put`]: super::Client::put_script_put
    #[derive(Debug, Clone)]
    pub struct PutScriptPut<'a> {
        client: &'a super::Client,
        id: Result<types::PutScriptPutId, String>,
        cluster_manager_timeout: Result<Option<types::PutScriptPutClusterManagerTimeout>, String>,
        master_timeout: Result<Option<types::PutScriptPutMasterTimeout>, String>,
        timeout: Result<Option<types::PutScriptPutTimeout>, String>,
        body: Result<types::PutScriptBodyParams, String>,
    }

    impl<'a> PutScriptPut<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                id: Err("id was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PutScriptPutId>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `PutScriptPutId` for id failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PutScriptPutClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `PutScriptPutClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PutScriptPutMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `PutScriptPutMasterTimeout` for master_timeout failed".to_string()
            });
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PutScriptPutTimeout>,
        {
            self.timeout = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `PutScriptPutTimeout` for timeout failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PutScriptBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `PutScriptBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `PUT` request to `/_scripts/{id}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                id,
                cluster_manager_timeout,
                master_timeout,
                timeout,
                body,
            } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_scripts/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client.client.put(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::put_script_post`]
    ///
    ///[`Client::put_script_post`]: super::Client::put_script_post
    #[derive(Debug, Clone)]
    pub struct PutScriptPost<'a> {
        client: &'a super::Client,
        id: Result<types::PutScriptPostId, String>,
        cluster_manager_timeout: Result<Option<types::PutScriptPostClusterManagerTimeout>, String>,
        master_timeout: Result<Option<types::PutScriptPostMasterTimeout>, String>,
        timeout: Result<Option<types::PutScriptPostTimeout>, String>,
        body: Result<types::PutScriptBodyParams, String>,
    }

    impl<'a> PutScriptPost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                id: Err("id was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PutScriptPostId>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `PutScriptPostId` for id failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PutScriptPostClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `PutScriptPostClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PutScriptPostMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `PutScriptPostMasterTimeout` for master_timeout failed".to_string()
            });
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PutScriptPostTimeout>,
        {
            self.timeout = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `PutScriptPostTimeout` for timeout failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PutScriptBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `PutScriptBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `POST` request to `/_scripts/{id}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                id,
                cluster_manager_timeout,
                master_timeout,
                timeout,
                body,
            } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_scripts/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::delete_script`]
    ///
    ///[`Client::delete_script`]: super::Client::delete_script
    #[derive(Debug, Clone)]
    pub struct DeleteScript<'a> {
        client: &'a super::Client,
        id: Result<types::DeleteScriptId, String>,
        cluster_manager_timeout: Result<Option<types::DeleteScriptClusterManagerTimeout>, String>,
        master_timeout: Result<Option<types::DeleteScriptMasterTimeout>, String>,
        timeout: Result<Option<types::DeleteScriptTimeout>, String>,
    }

    impl<'a> DeleteScript<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                id: Err("id was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DeleteScriptId>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `DeleteScriptId` for id failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DeleteScriptClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `DeleteScriptClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DeleteScriptMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `DeleteScriptMasterTimeout` for master_timeout failed".to_string()
            });
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DeleteScriptTimeout>,
        {
            self.timeout = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `DeleteScriptTimeout` for timeout failed".to_string());
            self
        }

        ///Sends a `DELETE` request to `/_scripts/{id}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                id,
                cluster_manager_timeout,
                master_timeout,
                timeout,
            } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_scripts/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client.client.delete(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::put_script_put_with_context`]
    ///
    ///[`Client::put_script_put_with_context`]: super::Client::put_script_put_with_context
    #[derive(Debug, Clone)]
    pub struct PutScriptPutWithContext<'a> {
        client: &'a super::Client,
        id: Result<types::PutScriptPutWithContextId, String>,
        context: Result<types::PutScriptPutWithContextContext, String>,
        cluster_manager_timeout:
            Result<Option<types::PutScriptPutWithContextClusterManagerTimeout>, String>,
        master_timeout: Result<Option<types::PutScriptPutWithContextMasterTimeout>, String>,
        timeout: Result<Option<types::PutScriptPutWithContextTimeout>, String>,
        body: Result<types::PutScriptBodyParams, String>,
    }

    impl<'a> PutScriptPutWithContext<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                id: Err("id was not initialized".to_string()),
                context: Err("context was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PutScriptPutWithContextId>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `PutScriptPutWithContextId` for id failed".to_string());
            self
        }

        pub fn context<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PutScriptPutWithContextContext>,
        {
            self.context = value.try_into().map_err(|_| {
                "conversion to `PutScriptPutWithContextContext` for context failed".to_string()
            });
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PutScriptPutWithContextClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `PutScriptPutWithContextClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PutScriptPutWithContextMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `PutScriptPutWithContextMasterTimeout` for master_timeout failed"
                    .to_string()
            });
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PutScriptPutWithContextTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `PutScriptPutWithContextTimeout` for timeout failed".to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PutScriptBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `PutScriptBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `PUT` request to `/_scripts/{id}/{context}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                id,
                context,
                cluster_manager_timeout,
                master_timeout,
                timeout,
                body,
            } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let context = context.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_scripts/{}/{}",
                client.baseurl,
                encode_path(&id.to_string()),
                encode_path(&context.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client.client.put(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::put_script_post_with_context`]
    ///
    ///[`Client::put_script_post_with_context`]: super::Client::put_script_post_with_context
    #[derive(Debug, Clone)]
    pub struct PutScriptPostWithContext<'a> {
        client: &'a super::Client,
        id: Result<types::PutScriptPostWithContextId, String>,
        context: Result<types::PutScriptPostWithContextContext, String>,
        cluster_manager_timeout:
            Result<Option<types::PutScriptPostWithContextClusterManagerTimeout>, String>,
        master_timeout: Result<Option<types::PutScriptPostWithContextMasterTimeout>, String>,
        timeout: Result<Option<types::PutScriptPostWithContextTimeout>, String>,
        body: Result<types::PutScriptBodyParams, String>,
    }

    impl<'a> PutScriptPostWithContext<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                id: Err("id was not initialized".to_string()),
                context: Err("context was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PutScriptPostWithContextId>,
        {
            self.id = value.try_into().map_err(|_| {
                "conversion to `PutScriptPostWithContextId` for id failed".to_string()
            });
            self
        }

        pub fn context<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PutScriptPostWithContextContext>,
        {
            self.context = value.try_into().map_err(|_| {
                "conversion to `PutScriptPostWithContextContext` for context failed".to_string()
            });
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PutScriptPostWithContextClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `PutScriptPostWithContextClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PutScriptPostWithContextMasterTimeout>,
        {
            self . master_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `PutScriptPostWithContextMasterTimeout` for master_timeout failed" . to_string ()) ;
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PutScriptPostWithContextTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `PutScriptPostWithContextTimeout` for timeout failed".to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PutScriptBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `PutScriptBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `POST` request to `/_scripts/{id}/{context}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                id,
                context,
                cluster_manager_timeout,
                master_timeout,
                timeout,
                body,
            } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let context = context.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_scripts/{}/{}",
                client.baseurl,
                encode_path(&id.to_string()),
                encode_path(&context.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::search_get`]
    ///
    ///[`Client::search_get`]: super::Client::search_get
    #[derive(Debug, Clone)]
    pub struct SearchGet<'a> {
        client: &'a super::Client,
        source: Result<Option<Vec<String>>, String>,
        source_excludes: Result<Option<Vec<String>>, String>,
        source_includes: Result<Option<Vec<String>>, String>,
        allow_no_indices: Result<Option<bool>, String>,
        allow_partial_search_results: Result<Option<bool>, String>,
        analyze_wildcard: Result<Option<bool>, String>,
        analyzer: Result<Option<String>, String>,
        batched_reduce_size: Result<Option<i32>, String>,
        ccs_minimize_roundtrips: Result<Option<bool>, String>,
        default_operator: Result<Option<types::DefaultOperator>, String>,
        df: Result<Option<String>, String>,
        docvalue_fields: Result<Option<Vec<String>>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        explain: Result<Option<bool>, String>,
        from: Result<Option<i32>, String>,
        ignore_throttled: Result<Option<bool>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        lenient: Result<Option<bool>, String>,
        max_concurrent_shard_requests: Result<Option<i32>, String>,
        pre_filter_shard_size: Result<Option<i32>, String>,
        preference: Result<Option<String>, String>,
        q: Result<Option<String>, String>,
        request_cache: Result<Option<bool>, String>,
        rest_total_hits_as_int: Result<Option<bool>, String>,
        routing: Result<Option<Vec<String>>, String>,
        scroll: Result<Option<types::SearchGetScroll>, String>,
        search_type: Result<Option<types::SearchType>, String>,
        seq_no_primary_term: Result<Option<bool>, String>,
        size: Result<Option<i32>, String>,
        sort: Result<Option<Vec<String>>, String>,
        stats: Result<Option<Vec<String>>, String>,
        stored_fields: Result<Option<Vec<String>>, String>,
        suggest_field: Result<Option<String>, String>,
        suggest_mode: Result<Option<types::SuggestMode>, String>,
        suggest_size: Result<Option<i32>, String>,
        suggest_text: Result<Option<String>, String>,
        terminate_after: Result<Option<i32>, String>,
        timeout: Result<Option<types::SearchGetTimeout>, String>,
        track_scores: Result<Option<bool>, String>,
        track_total_hits: Result<Option<bool>, String>,
        typed_keys: Result<Option<bool>, String>,
        version: Result<Option<bool>, String>,
    }

    impl<'a> SearchGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                source: Ok(None),
                source_excludes: Ok(None),
                source_includes: Ok(None),
                allow_no_indices: Ok(None),
                allow_partial_search_results: Ok(None),
                analyze_wildcard: Ok(None),
                analyzer: Ok(None),
                batched_reduce_size: Ok(None),
                ccs_minimize_roundtrips: Ok(None),
                default_operator: Ok(None),
                df: Ok(None),
                docvalue_fields: Ok(None),
                expand_wildcards: Ok(None),
                explain: Ok(None),
                from: Ok(None),
                ignore_throttled: Ok(None),
                ignore_unavailable: Ok(None),
                lenient: Ok(None),
                max_concurrent_shard_requests: Ok(None),
                pre_filter_shard_size: Ok(None),
                preference: Ok(None),
                q: Ok(None),
                request_cache: Ok(None),
                rest_total_hits_as_int: Ok(None),
                routing: Ok(None),
                scroll: Ok(None),
                search_type: Ok(None),
                seq_no_primary_term: Ok(None),
                size: Ok(None),
                sort: Ok(None),
                stats: Ok(None),
                stored_fields: Ok(None),
                suggest_field: Ok(None),
                suggest_mode: Ok(None),
                suggest_size: Ok(None),
                suggest_text: Ok(None),
                terminate_after: Ok(None),
                timeout: Ok(None),
                track_scores: Ok(None),
                track_total_hits: Ok(None),
                typed_keys: Ok(None),
                version: Ok(None),
            }
        }

        pub fn source<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for source failed".to_string());
            self
        }

        pub fn source_excludes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_excludes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_excludes failed".to_string()
            });
            self
        }

        pub fn source_includes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_includes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_includes failed".to_string()
            });
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn allow_partial_search_results<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_partial_search_results = value.try_into().map(Some).map_err(|_| {
                "conversion to `bool` for allow_partial_search_results failed".to_string()
            });
            self
        }

        pub fn analyze_wildcard<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.analyze_wildcard = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for analyze_wildcard failed".to_string());
            self
        }

        pub fn analyzer<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.analyzer = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for analyzer failed".to_string());
            self
        }

        pub fn batched_reduce_size<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.batched_reduce_size = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for batched_reduce_size failed".to_string());
            self
        }

        pub fn ccs_minimize_roundtrips<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ccs_minimize_roundtrips = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ccs_minimize_roundtrips failed".to_string());
            self
        }

        pub fn default_operator<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DefaultOperator>,
        {
            self.default_operator = value.try_into().map(Some).map_err(|_| {
                "conversion to `DefaultOperator` for default_operator failed".to_string()
            });
            self
        }

        pub fn df<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.df = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for df failed".to_string());
            self
        }

        pub fn docvalue_fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.docvalue_fields = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for docvalue_fields failed".to_string()
            });
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn explain<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.explain = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for explain failed".to_string());
            self
        }

        pub fn from<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.from = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for from failed".to_string());
            self
        }

        pub fn ignore_throttled<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_throttled = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_throttled failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn lenient<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.lenient = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for lenient failed".to_string());
            self
        }

        pub fn max_concurrent_shard_requests<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.max_concurrent_shard_requests = value.try_into().map(Some).map_err(|_| {
                "conversion to `i32` for max_concurrent_shard_requests failed".to_string()
            });
            self
        }

        pub fn pre_filter_shard_size<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.pre_filter_shard_size = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for pre_filter_shard_size failed".to_string());
            self
        }

        pub fn preference<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.preference = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for preference failed".to_string());
            self
        }

        pub fn q<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.q = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for q failed".to_string());
            self
        }

        pub fn request_cache<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.request_cache = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for request_cache failed".to_string());
            self
        }

        pub fn rest_total_hits_as_int<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.rest_total_hits_as_int = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for rest_total_hits_as_int failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for routing failed".to_string());
            self
        }

        pub fn scroll<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchGetScroll>,
        {
            self.scroll = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SearchGetScroll` for scroll failed".to_string());
            self
        }

        pub fn search_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchType>,
        {
            self.search_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SearchType` for search_type failed".to_string());
            self
        }

        pub fn seq_no_primary_term<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.seq_no_primary_term = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for seq_no_primary_term failed".to_string());
            self
        }

        pub fn size<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.size = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for size failed".to_string());
            self
        }

        pub fn sort<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.sort = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for sort failed".to_string());
            self
        }

        pub fn stats<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.stats = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for stats failed".to_string());
            self
        }

        pub fn stored_fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.stored_fields = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for stored_fields failed".to_string());
            self
        }

        pub fn suggest_field<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.suggest_field = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for suggest_field failed".to_string());
            self
        }

        pub fn suggest_mode<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SuggestMode>,
        {
            self.suggest_mode = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SuggestMode` for suggest_mode failed".to_string());
            self
        }

        pub fn suggest_size<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.suggest_size = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for suggest_size failed".to_string());
            self
        }

        pub fn suggest_text<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.suggest_text = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for suggest_text failed".to_string());
            self
        }

        pub fn terminate_after<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.terminate_after = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for terminate_after failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchGetTimeout>,
        {
            self.timeout = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SearchGetTimeout` for timeout failed".to_string());
            self
        }

        pub fn track_scores<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.track_scores = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for track_scores failed".to_string());
            self
        }

        pub fn track_total_hits<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.track_total_hits = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for track_total_hits failed".to_string());
            self
        }

        pub fn typed_keys<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.typed_keys = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for typed_keys failed".to_string());
            self
        }

        pub fn version<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.version = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for version failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_search`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SearchGetResponseContent>, Error<()>> {
            let Self {
                client,
                source,
                source_excludes,
                source_includes,
                allow_no_indices,
                allow_partial_search_results,
                analyze_wildcard,
                analyzer,
                batched_reduce_size,
                ccs_minimize_roundtrips,
                default_operator,
                df,
                docvalue_fields,
                expand_wildcards,
                explain,
                from,
                ignore_throttled,
                ignore_unavailable,
                lenient,
                max_concurrent_shard_requests,
                pre_filter_shard_size,
                preference,
                q,
                request_cache,
                rest_total_hits_as_int,
                routing,
                scroll,
                search_type,
                seq_no_primary_term,
                size,
                sort,
                stats,
                stored_fields,
                suggest_field,
                suggest_mode,
                suggest_size,
                suggest_text,
                terminate_after,
                timeout,
                track_scores,
                track_total_hits,
                typed_keys,
                version,
            } = self;
            let source = source.map_err(Error::InvalidRequest)?;
            let source_excludes = source_excludes.map_err(Error::InvalidRequest)?;
            let source_includes = source_includes.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let allow_partial_search_results =
                allow_partial_search_results.map_err(Error::InvalidRequest)?;
            let analyze_wildcard = analyze_wildcard.map_err(Error::InvalidRequest)?;
            let analyzer = analyzer.map_err(Error::InvalidRequest)?;
            let batched_reduce_size = batched_reduce_size.map_err(Error::InvalidRequest)?;
            let ccs_minimize_roundtrips = ccs_minimize_roundtrips.map_err(Error::InvalidRequest)?;
            let default_operator = default_operator.map_err(Error::InvalidRequest)?;
            let df = df.map_err(Error::InvalidRequest)?;
            let docvalue_fields = docvalue_fields.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let explain = explain.map_err(Error::InvalidRequest)?;
            let from = from.map_err(Error::InvalidRequest)?;
            let ignore_throttled = ignore_throttled.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let lenient = lenient.map_err(Error::InvalidRequest)?;
            let max_concurrent_shard_requests =
                max_concurrent_shard_requests.map_err(Error::InvalidRequest)?;
            let pre_filter_shard_size = pre_filter_shard_size.map_err(Error::InvalidRequest)?;
            let preference = preference.map_err(Error::InvalidRequest)?;
            let q = q.map_err(Error::InvalidRequest)?;
            let request_cache = request_cache.map_err(Error::InvalidRequest)?;
            let rest_total_hits_as_int = rest_total_hits_as_int.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let scroll = scroll.map_err(Error::InvalidRequest)?;
            let search_type = search_type.map_err(Error::InvalidRequest)?;
            let seq_no_primary_term = seq_no_primary_term.map_err(Error::InvalidRequest)?;
            let size = size.map_err(Error::InvalidRequest)?;
            let sort = sort.map_err(Error::InvalidRequest)?;
            let stats = stats.map_err(Error::InvalidRequest)?;
            let stored_fields = stored_fields.map_err(Error::InvalidRequest)?;
            let suggest_field = suggest_field.map_err(Error::InvalidRequest)?;
            let suggest_mode = suggest_mode.map_err(Error::InvalidRequest)?;
            let suggest_size = suggest_size.map_err(Error::InvalidRequest)?;
            let suggest_text = suggest_text.map_err(Error::InvalidRequest)?;
            let terminate_after = terminate_after.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let track_scores = track_scores.map_err(Error::InvalidRequest)?;
            let track_total_hits = track_total_hits.map_err(Error::InvalidRequest)?;
            let typed_keys = typed_keys.map_err(Error::InvalidRequest)?;
            let version = version.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_search", client.baseurl,);
            let mut query = Vec::with_capacity(42usize);
            if let Some(v) = &source {
                query.push(("_source", v.to_string()));
            }
            if let Some(v) = &source_excludes {
                query.push(("_source_excludes", v.to_string()));
            }
            if let Some(v) = &source_includes {
                query.push(("_source_includes", v.to_string()));
            }
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &allow_partial_search_results {
                query.push(("allow_partial_search_results", v.to_string()));
            }
            if let Some(v) = &analyze_wildcard {
                query.push(("analyze_wildcard", v.to_string()));
            }
            if let Some(v) = &analyzer {
                query.push(("analyzer", v.to_string()));
            }
            if let Some(v) = &batched_reduce_size {
                query.push(("batched_reduce_size", v.to_string()));
            }
            if let Some(v) = &ccs_minimize_roundtrips {
                query.push(("ccs_minimize_roundtrips", v.to_string()));
            }
            if let Some(v) = &default_operator {
                query.push(("default_operator", v.to_string()));
            }
            if let Some(v) = &df {
                query.push(("df", v.to_string()));
            }
            if let Some(v) = &docvalue_fields {
                query.push(("docvalue_fields", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &explain {
                query.push(("explain", v.to_string()));
            }
            if let Some(v) = &from {
                query.push(("from", v.to_string()));
            }
            if let Some(v) = &ignore_throttled {
                query.push(("ignore_throttled", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &lenient {
                query.push(("lenient", v.to_string()));
            }
            if let Some(v) = &max_concurrent_shard_requests {
                query.push(("max_concurrent_shard_requests", v.to_string()));
            }
            if let Some(v) = &pre_filter_shard_size {
                query.push(("pre_filter_shard_size", v.to_string()));
            }
            if let Some(v) = &preference {
                query.push(("preference", v.to_string()));
            }
            if let Some(v) = &q {
                query.push(("q", v.to_string()));
            }
            if let Some(v) = &request_cache {
                query.push(("request_cache", v.to_string()));
            }
            if let Some(v) = &rest_total_hits_as_int {
                query.push(("rest_total_hits_as_int", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &scroll {
                query.push(("scroll", v.to_string()));
            }
            if let Some(v) = &search_type {
                query.push(("search_type", v.to_string()));
            }
            if let Some(v) = &seq_no_primary_term {
                query.push(("seq_no_primary_term", v.to_string()));
            }
            if let Some(v) = &size {
                query.push(("size", v.to_string()));
            }
            if let Some(v) = &sort {
                query.push(("sort", v.to_string()));
            }
            if let Some(v) = &stats {
                query.push(("stats", v.to_string()));
            }
            if let Some(v) = &stored_fields {
                query.push(("stored_fields", v.to_string()));
            }
            if let Some(v) = &suggest_field {
                query.push(("suggest_field", v.to_string()));
            }
            if let Some(v) = &suggest_mode {
                query.push(("suggest_mode", v.to_string()));
            }
            if let Some(v) = &suggest_size {
                query.push(("suggest_size", v.to_string()));
            }
            if let Some(v) = &suggest_text {
                query.push(("suggest_text", v.to_string()));
            }
            if let Some(v) = &terminate_after {
                query.push(("terminate_after", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &track_scores {
                query.push(("track_scores", v.to_string()));
            }
            if let Some(v) = &track_total_hits {
                query.push(("track_total_hits", v.to_string()));
            }
            if let Some(v) = &typed_keys {
                query.push(("typed_keys", v.to_string()));
            }
            if let Some(v) = &version {
                query.push(("version", v.to_string()));
            }
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::search_post`]
    ///
    ///[`Client::search_post`]: super::Client::search_post
    #[derive(Debug, Clone)]
    pub struct SearchPost<'a> {
        client: &'a super::Client,
        source: Result<Option<Vec<String>>, String>,
        source_excludes: Result<Option<Vec<String>>, String>,
        source_includes: Result<Option<Vec<String>>, String>,
        allow_no_indices: Result<Option<bool>, String>,
        allow_partial_search_results: Result<Option<bool>, String>,
        analyze_wildcard: Result<Option<bool>, String>,
        analyzer: Result<Option<String>, String>,
        batched_reduce_size: Result<Option<i32>, String>,
        ccs_minimize_roundtrips: Result<Option<bool>, String>,
        default_operator: Result<Option<types::DefaultOperator>, String>,
        df: Result<Option<String>, String>,
        docvalue_fields: Result<Option<Vec<String>>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        explain: Result<Option<bool>, String>,
        from: Result<Option<i32>, String>,
        ignore_throttled: Result<Option<bool>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        lenient: Result<Option<bool>, String>,
        max_concurrent_shard_requests: Result<Option<i32>, String>,
        pre_filter_shard_size: Result<Option<i32>, String>,
        preference: Result<Option<String>, String>,
        q: Result<Option<String>, String>,
        request_cache: Result<Option<bool>, String>,
        rest_total_hits_as_int: Result<Option<bool>, String>,
        routing: Result<Option<Vec<String>>, String>,
        scroll: Result<Option<types::SearchPostScroll>, String>,
        search_type: Result<Option<types::SearchType>, String>,
        seq_no_primary_term: Result<Option<bool>, String>,
        size: Result<Option<i32>, String>,
        sort: Result<Option<Vec<String>>, String>,
        stats: Result<Option<Vec<String>>, String>,
        stored_fields: Result<Option<Vec<String>>, String>,
        suggest_field: Result<Option<String>, String>,
        suggest_mode: Result<Option<types::SuggestMode>, String>,
        suggest_size: Result<Option<i32>, String>,
        suggest_text: Result<Option<String>, String>,
        terminate_after: Result<Option<i32>, String>,
        timeout: Result<Option<types::SearchPostTimeout>, String>,
        track_scores: Result<Option<bool>, String>,
        track_total_hits: Result<Option<bool>, String>,
        typed_keys: Result<Option<bool>, String>,
        version: Result<Option<bool>, String>,
        body: Result<types::builder::SearchBodyParams, String>,
    }

    impl<'a> SearchPost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                source: Ok(None),
                source_excludes: Ok(None),
                source_includes: Ok(None),
                allow_no_indices: Ok(None),
                allow_partial_search_results: Ok(None),
                analyze_wildcard: Ok(None),
                analyzer: Ok(None),
                batched_reduce_size: Ok(None),
                ccs_minimize_roundtrips: Ok(None),
                default_operator: Ok(None),
                df: Ok(None),
                docvalue_fields: Ok(None),
                expand_wildcards: Ok(None),
                explain: Ok(None),
                from: Ok(None),
                ignore_throttled: Ok(None),
                ignore_unavailable: Ok(None),
                lenient: Ok(None),
                max_concurrent_shard_requests: Ok(None),
                pre_filter_shard_size: Ok(None),
                preference: Ok(None),
                q: Ok(None),
                request_cache: Ok(None),
                rest_total_hits_as_int: Ok(None),
                routing: Ok(None),
                scroll: Ok(None),
                search_type: Ok(None),
                seq_no_primary_term: Ok(None),
                size: Ok(None),
                sort: Ok(None),
                stats: Ok(None),
                stored_fields: Ok(None),
                suggest_field: Ok(None),
                suggest_mode: Ok(None),
                suggest_size: Ok(None),
                suggest_text: Ok(None),
                terminate_after: Ok(None),
                timeout: Ok(None),
                track_scores: Ok(None),
                track_total_hits: Ok(None),
                typed_keys: Ok(None),
                version: Ok(None),
                body: Ok(types::builder::SearchBodyParams::default()),
            }
        }

        pub fn source<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for source failed".to_string());
            self
        }

        pub fn source_excludes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_excludes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_excludes failed".to_string()
            });
            self
        }

        pub fn source_includes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_includes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_includes failed".to_string()
            });
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn allow_partial_search_results<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_partial_search_results = value.try_into().map(Some).map_err(|_| {
                "conversion to `bool` for allow_partial_search_results failed".to_string()
            });
            self
        }

        pub fn analyze_wildcard<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.analyze_wildcard = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for analyze_wildcard failed".to_string());
            self
        }

        pub fn analyzer<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.analyzer = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for analyzer failed".to_string());
            self
        }

        pub fn batched_reduce_size<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.batched_reduce_size = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for batched_reduce_size failed".to_string());
            self
        }

        pub fn ccs_minimize_roundtrips<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ccs_minimize_roundtrips = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ccs_minimize_roundtrips failed".to_string());
            self
        }

        pub fn default_operator<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DefaultOperator>,
        {
            self.default_operator = value.try_into().map(Some).map_err(|_| {
                "conversion to `DefaultOperator` for default_operator failed".to_string()
            });
            self
        }

        pub fn df<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.df = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for df failed".to_string());
            self
        }

        pub fn docvalue_fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.docvalue_fields = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for docvalue_fields failed".to_string()
            });
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn explain<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.explain = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for explain failed".to_string());
            self
        }

        pub fn from<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.from = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for from failed".to_string());
            self
        }

        pub fn ignore_throttled<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_throttled = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_throttled failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn lenient<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.lenient = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for lenient failed".to_string());
            self
        }

        pub fn max_concurrent_shard_requests<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.max_concurrent_shard_requests = value.try_into().map(Some).map_err(|_| {
                "conversion to `i32` for max_concurrent_shard_requests failed".to_string()
            });
            self
        }

        pub fn pre_filter_shard_size<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.pre_filter_shard_size = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for pre_filter_shard_size failed".to_string());
            self
        }

        pub fn preference<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.preference = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for preference failed".to_string());
            self
        }

        pub fn q<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.q = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for q failed".to_string());
            self
        }

        pub fn request_cache<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.request_cache = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for request_cache failed".to_string());
            self
        }

        pub fn rest_total_hits_as_int<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.rest_total_hits_as_int = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for rest_total_hits_as_int failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for routing failed".to_string());
            self
        }

        pub fn scroll<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchPostScroll>,
        {
            self.scroll = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SearchPostScroll` for scroll failed".to_string());
            self
        }

        pub fn search_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchType>,
        {
            self.search_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SearchType` for search_type failed".to_string());
            self
        }

        pub fn seq_no_primary_term<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.seq_no_primary_term = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for seq_no_primary_term failed".to_string());
            self
        }

        pub fn size<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.size = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for size failed".to_string());
            self
        }

        pub fn sort<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.sort = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for sort failed".to_string());
            self
        }

        pub fn stats<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.stats = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for stats failed".to_string());
            self
        }

        pub fn stored_fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.stored_fields = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for stored_fields failed".to_string());
            self
        }

        pub fn suggest_field<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.suggest_field = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for suggest_field failed".to_string());
            self
        }

        pub fn suggest_mode<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SuggestMode>,
        {
            self.suggest_mode = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SuggestMode` for suggest_mode failed".to_string());
            self
        }

        pub fn suggest_size<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.suggest_size = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for suggest_size failed".to_string());
            self
        }

        pub fn suggest_text<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.suggest_text = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for suggest_text failed".to_string());
            self
        }

        pub fn terminate_after<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.terminate_after = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for terminate_after failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchPostTimeout>,
        {
            self.timeout = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SearchPostTimeout` for timeout failed".to_string());
            self
        }

        pub fn track_scores<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.track_scores = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for track_scores failed".to_string());
            self
        }

        pub fn track_total_hits<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.track_total_hits = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for track_total_hits failed".to_string());
            self
        }

        pub fn typed_keys<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.typed_keys = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for typed_keys failed".to_string());
            self
        }

        pub fn version<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.version = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for version failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchBodyParams>,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|_| "conversion to `SearchBodyParams` for body failed".to_string());
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::SearchBodyParams,
            ) -> types::builder::SearchBodyParams,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to `/_search`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SearchPostResponseContent>, Error<()>> {
            let Self {
                client,
                source,
                source_excludes,
                source_includes,
                allow_no_indices,
                allow_partial_search_results,
                analyze_wildcard,
                analyzer,
                batched_reduce_size,
                ccs_minimize_roundtrips,
                default_operator,
                df,
                docvalue_fields,
                expand_wildcards,
                explain,
                from,
                ignore_throttled,
                ignore_unavailable,
                lenient,
                max_concurrent_shard_requests,
                pre_filter_shard_size,
                preference,
                q,
                request_cache,
                rest_total_hits_as_int,
                routing,
                scroll,
                search_type,
                seq_no_primary_term,
                size,
                sort,
                stats,
                stored_fields,
                suggest_field,
                suggest_mode,
                suggest_size,
                suggest_text,
                terminate_after,
                timeout,
                track_scores,
                track_total_hits,
                typed_keys,
                version,
                body,
            } = self;
            let source = source.map_err(Error::InvalidRequest)?;
            let source_excludes = source_excludes.map_err(Error::InvalidRequest)?;
            let source_includes = source_includes.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let allow_partial_search_results =
                allow_partial_search_results.map_err(Error::InvalidRequest)?;
            let analyze_wildcard = analyze_wildcard.map_err(Error::InvalidRequest)?;
            let analyzer = analyzer.map_err(Error::InvalidRequest)?;
            let batched_reduce_size = batched_reduce_size.map_err(Error::InvalidRequest)?;
            let ccs_minimize_roundtrips = ccs_minimize_roundtrips.map_err(Error::InvalidRequest)?;
            let default_operator = default_operator.map_err(Error::InvalidRequest)?;
            let df = df.map_err(Error::InvalidRequest)?;
            let docvalue_fields = docvalue_fields.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let explain = explain.map_err(Error::InvalidRequest)?;
            let from = from.map_err(Error::InvalidRequest)?;
            let ignore_throttled = ignore_throttled.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let lenient = lenient.map_err(Error::InvalidRequest)?;
            let max_concurrent_shard_requests =
                max_concurrent_shard_requests.map_err(Error::InvalidRequest)?;
            let pre_filter_shard_size = pre_filter_shard_size.map_err(Error::InvalidRequest)?;
            let preference = preference.map_err(Error::InvalidRequest)?;
            let q = q.map_err(Error::InvalidRequest)?;
            let request_cache = request_cache.map_err(Error::InvalidRequest)?;
            let rest_total_hits_as_int = rest_total_hits_as_int.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let scroll = scroll.map_err(Error::InvalidRequest)?;
            let search_type = search_type.map_err(Error::InvalidRequest)?;
            let seq_no_primary_term = seq_no_primary_term.map_err(Error::InvalidRequest)?;
            let size = size.map_err(Error::InvalidRequest)?;
            let sort = sort.map_err(Error::InvalidRequest)?;
            let stats = stats.map_err(Error::InvalidRequest)?;
            let stored_fields = stored_fields.map_err(Error::InvalidRequest)?;
            let suggest_field = suggest_field.map_err(Error::InvalidRequest)?;
            let suggest_mode = suggest_mode.map_err(Error::InvalidRequest)?;
            let suggest_size = suggest_size.map_err(Error::InvalidRequest)?;
            let suggest_text = suggest_text.map_err(Error::InvalidRequest)?;
            let terminate_after = terminate_after.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let track_scores = track_scores.map_err(Error::InvalidRequest)?;
            let track_total_hits = track_total_hits.map_err(Error::InvalidRequest)?;
            let typed_keys = typed_keys.map_err(Error::InvalidRequest)?;
            let version = version.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(std::convert::TryInto::<types::SearchBodyParams>::try_into)
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/_search", client.baseurl,);
            let mut query = Vec::with_capacity(42usize);
            if let Some(v) = &source {
                query.push(("_source", v.to_string()));
            }
            if let Some(v) = &source_excludes {
                query.push(("_source_excludes", v.to_string()));
            }
            if let Some(v) = &source_includes {
                query.push(("_source_includes", v.to_string()));
            }
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &allow_partial_search_results {
                query.push(("allow_partial_search_results", v.to_string()));
            }
            if let Some(v) = &analyze_wildcard {
                query.push(("analyze_wildcard", v.to_string()));
            }
            if let Some(v) = &analyzer {
                query.push(("analyzer", v.to_string()));
            }
            if let Some(v) = &batched_reduce_size {
                query.push(("batched_reduce_size", v.to_string()));
            }
            if let Some(v) = &ccs_minimize_roundtrips {
                query.push(("ccs_minimize_roundtrips", v.to_string()));
            }
            if let Some(v) = &default_operator {
                query.push(("default_operator", v.to_string()));
            }
            if let Some(v) = &df {
                query.push(("df", v.to_string()));
            }
            if let Some(v) = &docvalue_fields {
                query.push(("docvalue_fields", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &explain {
                query.push(("explain", v.to_string()));
            }
            if let Some(v) = &from {
                query.push(("from", v.to_string()));
            }
            if let Some(v) = &ignore_throttled {
                query.push(("ignore_throttled", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &lenient {
                query.push(("lenient", v.to_string()));
            }
            if let Some(v) = &max_concurrent_shard_requests {
                query.push(("max_concurrent_shard_requests", v.to_string()));
            }
            if let Some(v) = &pre_filter_shard_size {
                query.push(("pre_filter_shard_size", v.to_string()));
            }
            if let Some(v) = &preference {
                query.push(("preference", v.to_string()));
            }
            if let Some(v) = &q {
                query.push(("q", v.to_string()));
            }
            if let Some(v) = &request_cache {
                query.push(("request_cache", v.to_string()));
            }
            if let Some(v) = &rest_total_hits_as_int {
                query.push(("rest_total_hits_as_int", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &scroll {
                query.push(("scroll", v.to_string()));
            }
            if let Some(v) = &search_type {
                query.push(("search_type", v.to_string()));
            }
            if let Some(v) = &seq_no_primary_term {
                query.push(("seq_no_primary_term", v.to_string()));
            }
            if let Some(v) = &size {
                query.push(("size", v.to_string()));
            }
            if let Some(v) = &sort {
                query.push(("sort", v.to_string()));
            }
            if let Some(v) = &stats {
                query.push(("stats", v.to_string()));
            }
            if let Some(v) = &stored_fields {
                query.push(("stored_fields", v.to_string()));
            }
            if let Some(v) = &suggest_field {
                query.push(("suggest_field", v.to_string()));
            }
            if let Some(v) = &suggest_mode {
                query.push(("suggest_mode", v.to_string()));
            }
            if let Some(v) = &suggest_size {
                query.push(("suggest_size", v.to_string()));
            }
            if let Some(v) = &suggest_text {
                query.push(("suggest_text", v.to_string()));
            }
            if let Some(v) = &terminate_after {
                query.push(("terminate_after", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &track_scores {
                query.push(("track_scores", v.to_string()));
            }
            if let Some(v) = &track_total_hits {
                query.push(("track_total_hits", v.to_string()));
            }
            if let Some(v) = &typed_keys {
                query.push(("typed_keys", v.to_string()));
            }
            if let Some(v) = &version {
                query.push(("version", v.to_string()));
            }
            let request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::delete_pit`]
    ///
    ///[`Client::delete_pit`]: super::Client::delete_pit
    #[derive(Debug, Clone)]
    pub struct DeletePit<'a> {
        client: &'a super::Client,
        body: Result<types::builder::DeletePitBodyParams, String>,
    }

    impl<'a> DeletePit<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Ok(types::builder::DeletePitBodyParams::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DeletePitBodyParams>,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|_| "conversion to `DeletePitBodyParams` for body failed".to_string());
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::DeletePitBodyParams,
            ) -> types::builder::DeletePitBodyParams,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `DELETE` request to `/_search/point_in_time`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::DeletePitResponseContent>, Error<()>> {
            let Self { client, body } = self;
            let body = body
                .and_then(std::convert::TryInto::<types::DeletePitBodyParams>::try_into)
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/_search/point_in_time", client.baseurl,);
            let request = client
                .client
                .delete(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::get_all_pits`]
    ///
    ///[`Client::get_all_pits`]: super::Client::get_all_pits
    #[derive(Debug, Clone)]
    pub struct GetAllPits<'a> {
        client: &'a super::Client,
    }

    impl<'a> GetAllPits<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        ///Sends a `GET` request to `/_search/point_in_time/_all`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::GetAllPitsResponseContent>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/_search/point_in_time/_all", client.baseurl,);
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::delete_all_pits`]
    ///
    ///[`Client::delete_all_pits`]: super::Client::delete_all_pits
    #[derive(Debug, Clone)]
    pub struct DeleteAllPits<'a> {
        client: &'a super::Client,
    }

    impl<'a> DeleteAllPits<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        ///Sends a `DELETE` request to `/_search/point_in_time/_all`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::DeleteAllPitsResponseContent>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/_search/point_in_time/_all", client.baseurl,);
            let request = client
                .client
                .delete(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::scroll_get`]
    ///
    ///[`Client::scroll_get`]: super::Client::scroll_get
    #[derive(Debug, Clone)]
    pub struct ScrollGet<'a> {
        client: &'a super::Client,
        rest_total_hits_as_int: Result<Option<bool>, String>,
        scroll: Result<Option<types::ScrollGetScroll>, String>,
        scroll_id: Result<Option<String>, String>,
    }

    impl<'a> ScrollGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                rest_total_hits_as_int: Ok(None),
                scroll: Ok(None),
                scroll_id: Ok(None),
            }
        }

        pub fn rest_total_hits_as_int<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.rest_total_hits_as_int = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for rest_total_hits_as_int failed".to_string());
            self
        }

        pub fn scroll<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ScrollGetScroll>,
        {
            self.scroll = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `ScrollGetScroll` for scroll failed".to_string());
            self
        }

        pub fn scroll_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.scroll_id = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for scroll_id failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_search/scroll`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                rest_total_hits_as_int,
                scroll,
                scroll_id,
            } = self;
            let rest_total_hits_as_int = rest_total_hits_as_int.map_err(Error::InvalidRequest)?;
            let scroll = scroll.map_err(Error::InvalidRequest)?;
            let scroll_id = scroll_id.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_search/scroll", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &rest_total_hits_as_int {
                query.push(("rest_total_hits_as_int", v.to_string()));
            }
            if let Some(v) = &scroll {
                query.push(("scroll", v.to_string()));
            }
            if let Some(v) = &scroll_id {
                query.push(("scroll_id", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::scroll_post`]
    ///
    ///[`Client::scroll_post`]: super::Client::scroll_post
    #[derive(Debug, Clone)]
    pub struct ScrollPost<'a> {
        client: &'a super::Client,
        rest_total_hits_as_int: Result<Option<bool>, String>,
        scroll: Result<Option<types::ScrollPostScroll>, String>,
        scroll_id: Result<Option<String>, String>,
        body: Result<types::ScrollBodyParams, String>,
    }

    impl<'a> ScrollPost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                rest_total_hits_as_int: Ok(None),
                scroll: Ok(None),
                scroll_id: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn rest_total_hits_as_int<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.rest_total_hits_as_int = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for rest_total_hits_as_int failed".to_string());
            self
        }

        pub fn scroll<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ScrollPostScroll>,
        {
            self.scroll = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `ScrollPostScroll` for scroll failed".to_string());
            self
        }

        pub fn scroll_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.scroll_id = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for scroll_id failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ScrollBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `ScrollBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `POST` request to `/_search/scroll`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                rest_total_hits_as_int,
                scroll,
                scroll_id,
                body,
            } = self;
            let rest_total_hits_as_int = rest_total_hits_as_int.map_err(Error::InvalidRequest)?;
            let scroll = scroll.map_err(Error::InvalidRequest)?;
            let scroll_id = scroll_id.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_search/scroll", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &rest_total_hits_as_int {
                query.push(("rest_total_hits_as_int", v.to_string()));
            }
            if let Some(v) = &scroll {
                query.push(("scroll", v.to_string()));
            }
            if let Some(v) = &scroll_id {
                query.push(("scroll_id", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::clear_scroll`]
    ///
    ///[`Client::clear_scroll`]: super::Client::clear_scroll
    #[derive(Debug, Clone)]
    pub struct ClearScroll<'a> {
        client: &'a super::Client,
        body: Result<types::ClearScrollBodyParams, String>,
    }

    impl<'a> ClearScroll<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClearScrollBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `ClearScrollBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `DELETE` request to `/_search/scroll`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_search/scroll", client.baseurl,);
            let request = client.client.delete(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::scroll_get_with_scroll_id`]
    ///
    ///[`Client::scroll_get_with_scroll_id`]: super::Client::scroll_get_with_scroll_id
    #[derive(Debug, Clone)]
    pub struct ScrollGetWithScrollId<'a> {
        client: &'a super::Client,
        rest_total_hits_as_int: Result<Option<bool>, String>,
        scroll: Result<Option<types::ScrollGetWithScrollIdScroll>, String>,
        scroll_id: Result<Option<String>, String>,
    }

    impl<'a> ScrollGetWithScrollId<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                rest_total_hits_as_int: Ok(None),
                scroll: Ok(None),
                scroll_id: Ok(None),
            }
        }

        pub fn rest_total_hits_as_int<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.rest_total_hits_as_int = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for rest_total_hits_as_int failed".to_string());
            self
        }

        pub fn scroll<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ScrollGetWithScrollIdScroll>,
        {
            self.scroll = value.try_into().map(Some).map_err(|_| {
                "conversion to `ScrollGetWithScrollIdScroll` for scroll failed".to_string()
            });
            self
        }

        pub fn scroll_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.scroll_id = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for scroll_id failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_search/scroll/{scroll_id}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                rest_total_hits_as_int,
                scroll,
                scroll_id,
            } = self;
            let rest_total_hits_as_int = rest_total_hits_as_int.map_err(Error::InvalidRequest)?;
            let scroll = scroll.map_err(Error::InvalidRequest)?;
            let scroll_id = scroll_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_search/scroll/{}",
                client.baseurl,
                encode_path(&scroll_id.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &rest_total_hits_as_int {
                query.push(("rest_total_hits_as_int", v.to_string()));
            }
            if let Some(v) = &scroll {
                query.push(("scroll", v.to_string()));
            }
            if let Some(v) = &scroll_id {
                query.push(("scroll_id", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::scroll_post_with_scroll_id`]
    ///
    ///[`Client::scroll_post_with_scroll_id`]: super::Client::scroll_post_with_scroll_id
    #[derive(Debug, Clone)]
    pub struct ScrollPostWithScrollId<'a> {
        client: &'a super::Client,
        rest_total_hits_as_int: Result<Option<bool>, String>,
        scroll: Result<Option<types::ScrollPostWithScrollIdScroll>, String>,
        scroll_id: Result<Option<String>, String>,
        body: Result<types::ScrollBodyParams, String>,
    }

    impl<'a> ScrollPostWithScrollId<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                rest_total_hits_as_int: Ok(None),
                scroll: Ok(None),
                scroll_id: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn rest_total_hits_as_int<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.rest_total_hits_as_int = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for rest_total_hits_as_int failed".to_string());
            self
        }

        pub fn scroll<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ScrollPostWithScrollIdScroll>,
        {
            self.scroll = value.try_into().map(Some).map_err(|_| {
                "conversion to `ScrollPostWithScrollIdScroll` for scroll failed".to_string()
            });
            self
        }

        pub fn scroll_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.scroll_id = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for scroll_id failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ScrollBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `ScrollBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `POST` request to `/_search/scroll/{scroll_id}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                rest_total_hits_as_int,
                scroll,
                scroll_id,
                body,
            } = self;
            let rest_total_hits_as_int = rest_total_hits_as_int.map_err(Error::InvalidRequest)?;
            let scroll = scroll.map_err(Error::InvalidRequest)?;
            let scroll_id = scroll_id.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_search/scroll/{}",
                client.baseurl,
                encode_path(&scroll_id.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &rest_total_hits_as_int {
                query.push(("rest_total_hits_as_int", v.to_string()));
            }
            if let Some(v) = &scroll {
                query.push(("scroll", v.to_string()));
            }
            if let Some(v) = &scroll_id {
                query.push(("scroll_id", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::clear_scroll_with_scroll_id`]
    ///
    ///[`Client::clear_scroll_with_scroll_id`]: super::Client::clear_scroll_with_scroll_id
    #[derive(Debug, Clone)]
    pub struct ClearScrollWithScrollId<'a> {
        client: &'a super::Client,
        scroll_id: Result<types::ClearScrollWithScrollIdScrollId, String>,
        body: Result<types::ClearScrollBodyParams, String>,
    }

    impl<'a> ClearScrollWithScrollId<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                scroll_id: Err("scroll_id was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn scroll_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClearScrollWithScrollIdScrollId>,
        {
            self.scroll_id = value.try_into().map_err(|_| {
                "conversion to `ClearScrollWithScrollIdScrollId` for scroll_id failed".to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ClearScrollBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `ClearScrollBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `DELETE` request to `/_search/scroll/{scroll_id}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                scroll_id,
                body,
            } = self;
            let scroll_id = scroll_id.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_search/scroll/{}",
                client.baseurl,
                encode_path(&scroll_id.to_string()),
            );
            let request = client.client.delete(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::search_template_get`]
    ///
    ///[`Client::search_template_get`]: super::Client::search_template_get
    #[derive(Debug, Clone)]
    pub struct SearchTemplateGet<'a> {
        client: &'a super::Client,
        allow_no_indices: Result<Option<bool>, String>,
        ccs_minimize_roundtrips: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        explain: Result<Option<bool>, String>,
        ignore_throttled: Result<Option<bool>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        preference: Result<Option<String>, String>,
        profile: Result<Option<bool>, String>,
        rest_total_hits_as_int: Result<Option<bool>, String>,
        routing: Result<Option<Vec<String>>, String>,
        scroll: Result<Option<types::SearchTemplateGetScroll>, String>,
        search_type: Result<Option<types::SearchTypeMulti>, String>,
        typed_keys: Result<Option<bool>, String>,
    }

    impl<'a> SearchTemplateGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                allow_no_indices: Ok(None),
                ccs_minimize_roundtrips: Ok(None),
                expand_wildcards: Ok(None),
                explain: Ok(None),
                ignore_throttled: Ok(None),
                ignore_unavailable: Ok(None),
                preference: Ok(None),
                profile: Ok(None),
                rest_total_hits_as_int: Ok(None),
                routing: Ok(None),
                scroll: Ok(None),
                search_type: Ok(None),
                typed_keys: Ok(None),
            }
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn ccs_minimize_roundtrips<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ccs_minimize_roundtrips = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ccs_minimize_roundtrips failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn explain<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.explain = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for explain failed".to_string());
            self
        }

        pub fn ignore_throttled<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_throttled = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_throttled failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn preference<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.preference = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for preference failed".to_string());
            self
        }

        pub fn profile<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.profile = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for profile failed".to_string());
            self
        }

        pub fn rest_total_hits_as_int<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.rest_total_hits_as_int = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for rest_total_hits_as_int failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for routing failed".to_string());
            self
        }

        pub fn scroll<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchTemplateGetScroll>,
        {
            self.scroll = value.try_into().map(Some).map_err(|_| {
                "conversion to `SearchTemplateGetScroll` for scroll failed".to_string()
            });
            self
        }

        pub fn search_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchTypeMulti>,
        {
            self.search_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SearchTypeMulti` for search_type failed".to_string());
            self
        }

        pub fn typed_keys<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.typed_keys = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for typed_keys failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_search/template`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                allow_no_indices,
                ccs_minimize_roundtrips,
                expand_wildcards,
                explain,
                ignore_throttled,
                ignore_unavailable,
                preference,
                profile,
                rest_total_hits_as_int,
                routing,
                scroll,
                search_type,
                typed_keys,
            } = self;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let ccs_minimize_roundtrips = ccs_minimize_roundtrips.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let explain = explain.map_err(Error::InvalidRequest)?;
            let ignore_throttled = ignore_throttled.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let preference = preference.map_err(Error::InvalidRequest)?;
            let profile = profile.map_err(Error::InvalidRequest)?;
            let rest_total_hits_as_int = rest_total_hits_as_int.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let scroll = scroll.map_err(Error::InvalidRequest)?;
            let search_type = search_type.map_err(Error::InvalidRequest)?;
            let typed_keys = typed_keys.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_search/template", client.baseurl,);
            let mut query = Vec::with_capacity(13usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &ccs_minimize_roundtrips {
                query.push(("ccs_minimize_roundtrips", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &explain {
                query.push(("explain", v.to_string()));
            }
            if let Some(v) = &ignore_throttled {
                query.push(("ignore_throttled", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &preference {
                query.push(("preference", v.to_string()));
            }
            if let Some(v) = &profile {
                query.push(("profile", v.to_string()));
            }
            if let Some(v) = &rest_total_hits_as_int {
                query.push(("rest_total_hits_as_int", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &scroll {
                query.push(("scroll", v.to_string()));
            }
            if let Some(v) = &search_type {
                query.push(("search_type", v.to_string()));
            }
            if let Some(v) = &typed_keys {
                query.push(("typed_keys", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::search_template_post`]
    ///
    ///[`Client::search_template_post`]: super::Client::search_template_post
    #[derive(Debug, Clone)]
    pub struct SearchTemplatePost<'a> {
        client: &'a super::Client,
        allow_no_indices: Result<Option<bool>, String>,
        ccs_minimize_roundtrips: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        explain: Result<Option<bool>, String>,
        ignore_throttled: Result<Option<bool>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        preference: Result<Option<String>, String>,
        profile: Result<Option<bool>, String>,
        rest_total_hits_as_int: Result<Option<bool>, String>,
        routing: Result<Option<Vec<String>>, String>,
        scroll: Result<Option<types::SearchTemplatePostScroll>, String>,
        search_type: Result<Option<types::SearchTypeMulti>, String>,
        typed_keys: Result<Option<bool>, String>,
        body: Result<types::SearchTemplateBodyParams, String>,
    }

    impl<'a> SearchTemplatePost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                allow_no_indices: Ok(None),
                ccs_minimize_roundtrips: Ok(None),
                expand_wildcards: Ok(None),
                explain: Ok(None),
                ignore_throttled: Ok(None),
                ignore_unavailable: Ok(None),
                preference: Ok(None),
                profile: Ok(None),
                rest_total_hits_as_int: Ok(None),
                routing: Ok(None),
                scroll: Ok(None),
                search_type: Ok(None),
                typed_keys: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn ccs_minimize_roundtrips<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ccs_minimize_roundtrips = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ccs_minimize_roundtrips failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn explain<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.explain = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for explain failed".to_string());
            self
        }

        pub fn ignore_throttled<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_throttled = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_throttled failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn preference<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.preference = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for preference failed".to_string());
            self
        }

        pub fn profile<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.profile = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for profile failed".to_string());
            self
        }

        pub fn rest_total_hits_as_int<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.rest_total_hits_as_int = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for rest_total_hits_as_int failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for routing failed".to_string());
            self
        }

        pub fn scroll<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchTemplatePostScroll>,
        {
            self.scroll = value.try_into().map(Some).map_err(|_| {
                "conversion to `SearchTemplatePostScroll` for scroll failed".to_string()
            });
            self
        }

        pub fn search_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchTypeMulti>,
        {
            self.search_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SearchTypeMulti` for search_type failed".to_string());
            self
        }

        pub fn typed_keys<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.typed_keys = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for typed_keys failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchTemplateBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `SearchTemplateBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `POST` request to `/_search/template`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                allow_no_indices,
                ccs_minimize_roundtrips,
                expand_wildcards,
                explain,
                ignore_throttled,
                ignore_unavailable,
                preference,
                profile,
                rest_total_hits_as_int,
                routing,
                scroll,
                search_type,
                typed_keys,
                body,
            } = self;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let ccs_minimize_roundtrips = ccs_minimize_roundtrips.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let explain = explain.map_err(Error::InvalidRequest)?;
            let ignore_throttled = ignore_throttled.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let preference = preference.map_err(Error::InvalidRequest)?;
            let profile = profile.map_err(Error::InvalidRequest)?;
            let rest_total_hits_as_int = rest_total_hits_as_int.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let scroll = scroll.map_err(Error::InvalidRequest)?;
            let search_type = search_type.map_err(Error::InvalidRequest)?;
            let typed_keys = typed_keys.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_search/template", client.baseurl,);
            let mut query = Vec::with_capacity(13usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &ccs_minimize_roundtrips {
                query.push(("ccs_minimize_roundtrips", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &explain {
                query.push(("explain", v.to_string()));
            }
            if let Some(v) = &ignore_throttled {
                query.push(("ignore_throttled", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &preference {
                query.push(("preference", v.to_string()));
            }
            if let Some(v) = &profile {
                query.push(("profile", v.to_string()));
            }
            if let Some(v) = &rest_total_hits_as_int {
                query.push(("rest_total_hits_as_int", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &scroll {
                query.push(("scroll", v.to_string()));
            }
            if let Some(v) = &search_type {
                query.push(("search_type", v.to_string()));
            }
            if let Some(v) = &typed_keys {
                query.push(("typed_keys", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::search_shards_get`]
    ///
    ///[`Client::search_shards_get`]: super::Client::search_shards_get
    #[derive(Debug, Clone)]
    pub struct SearchShardsGet<'a> {
        client: &'a super::Client,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
        preference: Result<Option<String>, String>,
        routing: Result<Option<String>, String>,
    }

    impl<'a> SearchShardsGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                ignore_unavailable: Ok(None),
                local: Ok(None),
                preference: Ok(None),
                routing: Ok(None),
            }
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn preference<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.preference = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for preference failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for routing failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_search_shards`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                allow_no_indices,
                expand_wildcards,
                ignore_unavailable,
                local,
                preference,
                routing,
            } = self;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let preference = preference.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_search_shards", client.baseurl,);
            let mut query = Vec::with_capacity(6usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &preference {
                query.push(("preference", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::search_shards_post`]
    ///
    ///[`Client::search_shards_post`]: super::Client::search_shards_post
    #[derive(Debug, Clone)]
    pub struct SearchShardsPost<'a> {
        client: &'a super::Client,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
        preference: Result<Option<String>, String>,
        routing: Result<Option<String>, String>,
    }

    impl<'a> SearchShardsPost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                ignore_unavailable: Ok(None),
                local: Ok(None),
                preference: Ok(None),
                routing: Ok(None),
            }
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn preference<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.preference = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for preference failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for routing failed".to_string());
            self
        }

        ///Sends a `POST` request to `/_search_shards`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                allow_no_indices,
                expand_wildcards,
                ignore_unavailable,
                local,
                preference,
                routing,
            } = self;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let preference = preference.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_search_shards", client.baseurl,);
            let mut query = Vec::with_capacity(6usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &preference {
                query.push(("preference", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            let request = client.client.post(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_segments`]
    ///
    ///[`Client::indices_segments`]: super::Client::indices_segments
    #[derive(Debug, Clone)]
    pub struct IndicesSegments<'a> {
        client: &'a super::Client,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        verbose: Result<Option<bool>, String>,
    }

    impl<'a> IndicesSegments<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                ignore_unavailable: Ok(None),
                verbose: Ok(None),
            }
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn verbose<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.verbose = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for verbose failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_segments`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                allow_no_indices,
                expand_wildcards,
                ignore_unavailable,
                verbose,
            } = self;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let verbose = verbose.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_segments", client.baseurl,);
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &verbose {
                query.push(("verbose", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_get_settings`]
    ///
    ///[`Client::indices_get_settings`]: super::Client::indices_get_settings
    #[derive(Debug, Clone)]
    pub struct IndicesGetSettings<'a> {
        client: &'a super::Client,
        allow_no_indices: Result<Option<bool>, String>,
        cluster_manager_timeout:
            Result<Option<types::IndicesGetSettingsClusterManagerTimeout>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        flat_settings: Result<Option<bool>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        include_defaults: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::IndicesGetSettingsMasterTimeout>, String>,
    }

    impl<'a> IndicesGetSettings<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                allow_no_indices: Ok(None),
                cluster_manager_timeout: Ok(None),
                expand_wildcards: Ok(None),
                flat_settings: Ok(None),
                ignore_unavailable: Ok(None),
                include_defaults: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
            }
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesGetSettingsClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesGetSettingsClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn flat_settings<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.flat_settings = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn include_defaults<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.include_defaults = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for include_defaults failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesGetSettingsMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesGetSettingsMasterTimeout` for master_timeout failed"
                    .to_string()
            });
            self
        }

        ///Sends a `GET` request to `/_settings`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                allow_no_indices,
                cluster_manager_timeout,
                expand_wildcards,
                flat_settings,
                ignore_unavailable,
                include_defaults,
                local,
                master_timeout,
            } = self;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let include_defaults = include_defaults.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_settings", client.baseurl,);
            let mut query = Vec::with_capacity(8usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &flat_settings {
                query.push(("flat_settings", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &include_defaults {
                query.push(("include_defaults", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_put_settings`]
    ///
    ///[`Client::indices_put_settings`]: super::Client::indices_put_settings
    #[derive(Debug, Clone)]
    pub struct IndicesPutSettings<'a> {
        client: &'a super::Client,
        allow_no_indices: Result<Option<bool>, String>,
        cluster_manager_timeout:
            Result<Option<types::IndicesPutSettingsClusterManagerTimeout>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        flat_settings: Result<Option<bool>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::IndicesPutSettingsMasterTimeout>, String>,
        preserve_existing: Result<Option<bool>, String>,
        timeout: Result<Option<types::IndicesPutSettingsTimeout>, String>,
        body: Result<types::IndicesPutSettingsBodyParams, String>,
    }

    impl<'a> IndicesPutSettings<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                allow_no_indices: Ok(None),
                cluster_manager_timeout: Ok(None),
                expand_wildcards: Ok(None),
                flat_settings: Ok(None),
                ignore_unavailable: Ok(None),
                master_timeout: Ok(None),
                preserve_existing: Ok(None),
                timeout: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutSettingsClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesPutSettingsClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn flat_settings<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.flat_settings = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutSettingsMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesPutSettingsMasterTimeout` for master_timeout failed"
                    .to_string()
            });
            self
        }

        pub fn preserve_existing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.preserve_existing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for preserve_existing failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutSettingsTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesPutSettingsTimeout` for timeout failed".to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutSettingsBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `IndicesPutSettingsBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `PUT` request to `/_settings`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                allow_no_indices,
                cluster_manager_timeout,
                expand_wildcards,
                flat_settings,
                ignore_unavailable,
                master_timeout,
                preserve_existing,
                timeout,
                body,
            } = self;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let preserve_existing = preserve_existing.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_settings", client.baseurl,);
            let mut query = Vec::with_capacity(8usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &flat_settings {
                query.push(("flat_settings", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &preserve_existing {
                query.push(("preserve_existing", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client.client.put(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_get_settings_with_name`]
    ///
    ///[`Client::indices_get_settings_with_name`]: super::Client::indices_get_settings_with_name
    #[derive(Debug, Clone)]
    pub struct IndicesGetSettingsWithName<'a> {
        client: &'a super::Client,
        name: Result<types::IndicesGetSettingsWithNameName, String>,
        allow_no_indices: Result<Option<bool>, String>,
        cluster_manager_timeout:
            Result<Option<types::IndicesGetSettingsWithNameClusterManagerTimeout>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        flat_settings: Result<Option<bool>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        include_defaults: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::IndicesGetSettingsWithNameMasterTimeout>, String>,
    }

    impl<'a> IndicesGetSettingsWithName<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                name: Err("name was not initialized".to_string()),
                allow_no_indices: Ok(None),
                cluster_manager_timeout: Ok(None),
                expand_wildcards: Ok(None),
                flat_settings: Ok(None),
                ignore_unavailable: Ok(None),
                include_defaults: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
            }
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesGetSettingsWithNameName>,
        {
            self.name = value.try_into().map_err(|_| {
                "conversion to `IndicesGetSettingsWithNameName` for name failed".to_string()
            });
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesGetSettingsWithNameClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesGetSettingsWithNameClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn flat_settings<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.flat_settings = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn include_defaults<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.include_defaults = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for include_defaults failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesGetSettingsWithNameMasterTimeout>,
        {
            self . master_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesGetSettingsWithNameMasterTimeout` for master_timeout failed" . to_string ()) ;
            self
        }

        ///Sends a `GET` request to `/_settings/{name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                name,
                allow_no_indices,
                cluster_manager_timeout,
                expand_wildcards,
                flat_settings,
                ignore_unavailable,
                include_defaults,
                local,
                master_timeout,
            } = self;
            let name = name.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let include_defaults = include_defaults.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_settings/{}",
                client.baseurl,
                encode_path(&name.to_string()),
            );
            let mut query = Vec::with_capacity(8usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &flat_settings {
                query.push(("flat_settings", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &include_defaults {
                query.push(("include_defaults", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_shard_stores`]
    ///
    ///[`Client::indices_shard_stores`]: super::Client::indices_shard_stores
    #[derive(Debug, Clone)]
    pub struct IndicesShardStores<'a> {
        client: &'a super::Client,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        status: Result<Option<Vec<types::StatusMember>>, String>,
    }

    impl<'a> IndicesShardStores<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                ignore_unavailable: Ok(None),
                status: Ok(None),
            }
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn status<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<types::StatusMember>>,
        {
            self.status = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < StatusMember >` for status failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_shard_stores`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                allow_no_indices,
                expand_wildcards,
                ignore_unavailable,
                status,
            } = self;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let status = status.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_shard_stores", client.baseurl,);
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &status {
                query.push(("status", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::snapshot_get_repository`]
    ///
    ///[`Client::snapshot_get_repository`]: super::Client::snapshot_get_repository
    #[derive(Debug, Clone)]
    pub struct SnapshotGetRepository<'a> {
        client: &'a super::Client,
        cluster_manager_timeout:
            Result<Option<types::SnapshotGetRepositoryClusterManagerTimeout>, String>,
        local: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::SnapshotGetRepositoryMasterTimeout>, String>,
    }

    impl<'a> SnapshotGetRepository<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                cluster_manager_timeout: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
            }
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotGetRepositoryClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `SnapshotGetRepositoryClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotGetRepositoryMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `SnapshotGetRepositoryMasterTimeout` for master_timeout failed"
                    .to_string()
            });
            self
        }

        ///Sends a `GET` request to `/_snapshot`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                cluster_manager_timeout,
                local,
                master_timeout,
            } = self;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_snapshot", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::snapshot_status`]
    ///
    ///[`Client::snapshot_status`]: super::Client::snapshot_status
    #[derive(Debug, Clone)]
    pub struct SnapshotStatus<'a> {
        client: &'a super::Client,
        cluster_manager_timeout: Result<Option<types::SnapshotStatusClusterManagerTimeout>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::SnapshotStatusMasterTimeout>, String>,
    }

    impl<'a> SnapshotStatus<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                cluster_manager_timeout: Ok(None),
                ignore_unavailable: Ok(None),
                master_timeout: Ok(None),
            }
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotStatusClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `SnapshotStatusClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotStatusMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `SnapshotStatusMasterTimeout` for master_timeout failed".to_string()
            });
            self
        }

        ///Sends a `GET` request to `/_snapshot/_status`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                cluster_manager_timeout,
                ignore_unavailable,
                master_timeout,
            } = self;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_snapshot/_status", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::snapshot_get_repository_with_repository`]
    ///
    ///[`Client::snapshot_get_repository_with_repository`]: super::Client::snapshot_get_repository_with_repository
    #[derive(Debug, Clone)]
    pub struct SnapshotGetRepositoryWithRepository<'a> {
        client: &'a super::Client,
        repository: Result<types::SnapshotGetRepositoryWithRepositoryRepository, String>,
        cluster_manager_timeout:
            Result<Option<types::SnapshotGetRepositoryWithRepositoryClusterManagerTimeout>, String>,
        local: Result<Option<bool>, String>,
        master_timeout:
            Result<Option<types::SnapshotGetRepositoryWithRepositoryMasterTimeout>, String>,
    }

    impl<'a> SnapshotGetRepositoryWithRepository<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                repository: Err("repository was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
            }
        }

        pub fn repository<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotGetRepositoryWithRepositoryRepository>,
        {
            self . repository = value . try_into () . map_err (| _ | "conversion to `SnapshotGetRepositoryWithRepositoryRepository` for repository failed" . to_string ()) ;
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<
                types::SnapshotGetRepositoryWithRepositoryClusterManagerTimeout,
            >,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `SnapshotGetRepositoryWithRepositoryClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotGetRepositoryWithRepositoryMasterTimeout>,
        {
            self . master_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `SnapshotGetRepositoryWithRepositoryMasterTimeout` for master_timeout failed" . to_string ()) ;
            self
        }

        ///Sends a `GET` request to `/_snapshot/{repository}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                repository,
                cluster_manager_timeout,
                local,
                master_timeout,
            } = self;
            let repository = repository.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_snapshot/{}",
                client.baseurl,
                encode_path(&repository.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::snapshot_create_repository_put`]
    ///
    ///[`Client::snapshot_create_repository_put`]: super::Client::snapshot_create_repository_put
    #[derive(Debug, Clone)]
    pub struct SnapshotCreateRepositoryPut<'a> {
        client: &'a super::Client,
        repository: Result<types::SnapshotCreateRepositoryPutRepository, String>,
        cluster_manager_timeout:
            Result<Option<types::SnapshotCreateRepositoryPutClusterManagerTimeout>, String>,
        master_timeout: Result<Option<types::SnapshotCreateRepositoryPutMasterTimeout>, String>,
        timeout: Result<Option<types::SnapshotCreateRepositoryPutTimeout>, String>,
        verify: Result<Option<bool>, String>,
        body: Result<types::SnapshotCreateRepositoryBodyParams, String>,
    }

    impl<'a> SnapshotCreateRepositoryPut<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                repository: Err("repository was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
                verify: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn repository<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotCreateRepositoryPutRepository>,
        {
            self.repository = value.try_into().map_err(|_| {
                "conversion to `SnapshotCreateRepositoryPutRepository` for repository failed"
                    .to_string()
            });
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotCreateRepositoryPutClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `SnapshotCreateRepositoryPutClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotCreateRepositoryPutMasterTimeout>,
        {
            self . master_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `SnapshotCreateRepositoryPutMasterTimeout` for master_timeout failed" . to_string ()) ;
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotCreateRepositoryPutTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `SnapshotCreateRepositoryPutTimeout` for timeout failed".to_string()
            });
            self
        }

        pub fn verify<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.verify = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for verify failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotCreateRepositoryBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `SnapshotCreateRepositoryBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `PUT` request to `/_snapshot/{repository}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                repository,
                cluster_manager_timeout,
                master_timeout,
                timeout,
                verify,
                body,
            } = self;
            let repository = repository.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let verify = verify.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_snapshot/{}",
                client.baseurl,
                encode_path(&repository.to_string()),
            );
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &verify {
                query.push(("verify", v.to_string()));
            }
            let request = client.client.put(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::snapshot_create_repository_post`]
    ///
    ///[`Client::snapshot_create_repository_post`]: super::Client::snapshot_create_repository_post
    #[derive(Debug, Clone)]
    pub struct SnapshotCreateRepositoryPost<'a> {
        client: &'a super::Client,
        repository: Result<types::SnapshotCreateRepositoryPostRepository, String>,
        cluster_manager_timeout:
            Result<Option<types::SnapshotCreateRepositoryPostClusterManagerTimeout>, String>,
        master_timeout: Result<Option<types::SnapshotCreateRepositoryPostMasterTimeout>, String>,
        timeout: Result<Option<types::SnapshotCreateRepositoryPostTimeout>, String>,
        verify: Result<Option<bool>, String>,
        body: Result<types::SnapshotCreateRepositoryBodyParams, String>,
    }

    impl<'a> SnapshotCreateRepositoryPost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                repository: Err("repository was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
                verify: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn repository<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotCreateRepositoryPostRepository>,
        {
            self.repository = value.try_into().map_err(|_| {
                "conversion to `SnapshotCreateRepositoryPostRepository` for repository failed"
                    .to_string()
            });
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotCreateRepositoryPostClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `SnapshotCreateRepositoryPostClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotCreateRepositoryPostMasterTimeout>,
        {
            self . master_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `SnapshotCreateRepositoryPostMasterTimeout` for master_timeout failed" . to_string ()) ;
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotCreateRepositoryPostTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `SnapshotCreateRepositoryPostTimeout` for timeout failed".to_string()
            });
            self
        }

        pub fn verify<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.verify = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for verify failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotCreateRepositoryBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `SnapshotCreateRepositoryBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `POST` request to `/_snapshot/{repository}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                repository,
                cluster_manager_timeout,
                master_timeout,
                timeout,
                verify,
                body,
            } = self;
            let repository = repository.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let verify = verify.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_snapshot/{}",
                client.baseurl,
                encode_path(&repository.to_string()),
            );
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &verify {
                query.push(("verify", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::snapshot_delete_repository`]
    ///
    ///[`Client::snapshot_delete_repository`]: super::Client::snapshot_delete_repository
    #[derive(Debug, Clone)]
    pub struct SnapshotDeleteRepository<'a> {
        client: &'a super::Client,
        repository: Result<types::SnapshotDeleteRepositoryRepository, String>,
        cluster_manager_timeout:
            Result<Option<types::SnapshotDeleteRepositoryClusterManagerTimeout>, String>,
        master_timeout: Result<Option<types::SnapshotDeleteRepositoryMasterTimeout>, String>,
        timeout: Result<Option<types::SnapshotDeleteRepositoryTimeout>, String>,
    }

    impl<'a> SnapshotDeleteRepository<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                repository: Err("repository was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
            }
        }

        pub fn repository<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotDeleteRepositoryRepository>,
        {
            self.repository = value.try_into().map_err(|_| {
                "conversion to `SnapshotDeleteRepositoryRepository` for repository failed"
                    .to_string()
            });
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotDeleteRepositoryClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `SnapshotDeleteRepositoryClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotDeleteRepositoryMasterTimeout>,
        {
            self . master_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `SnapshotDeleteRepositoryMasterTimeout` for master_timeout failed" . to_string ()) ;
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotDeleteRepositoryTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `SnapshotDeleteRepositoryTimeout` for timeout failed".to_string()
            });
            self
        }

        ///Sends a `DELETE` request to `/_snapshot/{repository}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                repository,
                cluster_manager_timeout,
                master_timeout,
                timeout,
            } = self;
            let repository = repository.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_snapshot/{}",
                client.baseurl,
                encode_path(&repository.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client.client.delete(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::snapshot_cleanup_repository`]
    ///
    ///[`Client::snapshot_cleanup_repository`]: super::Client::snapshot_cleanup_repository
    #[derive(Debug, Clone)]
    pub struct SnapshotCleanupRepository<'a> {
        client: &'a super::Client,
        repository: Result<types::SnapshotCleanupRepositoryRepository, String>,
        cluster_manager_timeout:
            Result<Option<types::SnapshotCleanupRepositoryClusterManagerTimeout>, String>,
        master_timeout: Result<Option<types::SnapshotCleanupRepositoryMasterTimeout>, String>,
        timeout: Result<Option<types::SnapshotCleanupRepositoryTimeout>, String>,
    }

    impl<'a> SnapshotCleanupRepository<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                repository: Err("repository was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
            }
        }

        pub fn repository<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotCleanupRepositoryRepository>,
        {
            self.repository = value.try_into().map_err(|_| {
                "conversion to `SnapshotCleanupRepositoryRepository` for repository failed"
                    .to_string()
            });
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotCleanupRepositoryClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `SnapshotCleanupRepositoryClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotCleanupRepositoryMasterTimeout>,
        {
            self . master_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `SnapshotCleanupRepositoryMasterTimeout` for master_timeout failed" . to_string ()) ;
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotCleanupRepositoryTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `SnapshotCleanupRepositoryTimeout` for timeout failed".to_string()
            });
            self
        }

        ///Sends a `POST` request to `/_snapshot/{repository}/_cleanup`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                repository,
                cluster_manager_timeout,
                master_timeout,
                timeout,
            } = self;
            let repository = repository.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_snapshot/{}/_cleanup",
                client.baseurl,
                encode_path(&repository.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client.client.post(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::snapshot_status_with_repository`]
    ///
    ///[`Client::snapshot_status_with_repository`]: super::Client::snapshot_status_with_repository
    #[derive(Debug, Clone)]
    pub struct SnapshotStatusWithRepository<'a> {
        client: &'a super::Client,
        repository: Result<types::SnapshotStatusWithRepositoryRepository, String>,
        cluster_manager_timeout:
            Result<Option<types::SnapshotStatusWithRepositoryClusterManagerTimeout>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::SnapshotStatusWithRepositoryMasterTimeout>, String>,
    }

    impl<'a> SnapshotStatusWithRepository<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                repository: Err("repository was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                ignore_unavailable: Ok(None),
                master_timeout: Ok(None),
            }
        }

        pub fn repository<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotStatusWithRepositoryRepository>,
        {
            self.repository = value.try_into().map_err(|_| {
                "conversion to `SnapshotStatusWithRepositoryRepository` for repository failed"
                    .to_string()
            });
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotStatusWithRepositoryClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `SnapshotStatusWithRepositoryClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotStatusWithRepositoryMasterTimeout>,
        {
            self . master_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `SnapshotStatusWithRepositoryMasterTimeout` for master_timeout failed" . to_string ()) ;
            self
        }

        ///Sends a `GET` request to `/_snapshot/{repository}/_status`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                repository,
                cluster_manager_timeout,
                ignore_unavailable,
                master_timeout,
            } = self;
            let repository = repository.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_snapshot/{}/_status",
                client.baseurl,
                encode_path(&repository.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::snapshot_verify_repository`]
    ///
    ///[`Client::snapshot_verify_repository`]: super::Client::snapshot_verify_repository
    #[derive(Debug, Clone)]
    pub struct SnapshotVerifyRepository<'a> {
        client: &'a super::Client,
        repository: Result<types::SnapshotVerifyRepositoryRepository, String>,
        cluster_manager_timeout:
            Result<Option<types::SnapshotVerifyRepositoryClusterManagerTimeout>, String>,
        master_timeout: Result<Option<types::SnapshotVerifyRepositoryMasterTimeout>, String>,
        timeout: Result<Option<types::SnapshotVerifyRepositoryTimeout>, String>,
    }

    impl<'a> SnapshotVerifyRepository<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                repository: Err("repository was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
            }
        }

        pub fn repository<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotVerifyRepositoryRepository>,
        {
            self.repository = value.try_into().map_err(|_| {
                "conversion to `SnapshotVerifyRepositoryRepository` for repository failed"
                    .to_string()
            });
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotVerifyRepositoryClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `SnapshotVerifyRepositoryClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotVerifyRepositoryMasterTimeout>,
        {
            self . master_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `SnapshotVerifyRepositoryMasterTimeout` for master_timeout failed" . to_string ()) ;
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotVerifyRepositoryTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `SnapshotVerifyRepositoryTimeout` for timeout failed".to_string()
            });
            self
        }

        ///Sends a `POST` request to `/_snapshot/{repository}/_verify`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                repository,
                cluster_manager_timeout,
                master_timeout,
                timeout,
            } = self;
            let repository = repository.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_snapshot/{}/_verify",
                client.baseurl,
                encode_path(&repository.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client.client.post(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::snapshot_get`]
    ///
    ///[`Client::snapshot_get`]: super::Client::snapshot_get
    #[derive(Debug, Clone)]
    pub struct SnapshotGet<'a> {
        client: &'a super::Client,
        repository: Result<types::SnapshotGetRepository, String>,
        snapshot: Result<types::SnapshotGetSnapshot, String>,
        cluster_manager_timeout: Result<Option<types::SnapshotGetClusterManagerTimeout>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::SnapshotGetMasterTimeout>, String>,
        verbose: Result<Option<bool>, String>,
    }

    impl<'a> SnapshotGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                repository: Err("repository was not initialized".to_string()),
                snapshot: Err("snapshot was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                ignore_unavailable: Ok(None),
                master_timeout: Ok(None),
                verbose: Ok(None),
            }
        }

        pub fn repository<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotGetRepository>,
        {
            self.repository = value.try_into().map_err(|_| {
                "conversion to `SnapshotGetRepository` for repository failed".to_string()
            });
            self
        }

        pub fn snapshot<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotGetSnapshot>,
        {
            self.snapshot = value
                .try_into()
                .map_err(|_| "conversion to `SnapshotGetSnapshot` for snapshot failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotGetClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `SnapshotGetClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotGetMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `SnapshotGetMasterTimeout` for master_timeout failed".to_string()
            });
            self
        }

        pub fn verbose<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.verbose = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for verbose failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_snapshot/{repository}/{snapshot}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                repository,
                snapshot,
                cluster_manager_timeout,
                ignore_unavailable,
                master_timeout,
                verbose,
            } = self;
            let repository = repository.map_err(Error::InvalidRequest)?;
            let snapshot = snapshot.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let verbose = verbose.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_snapshot/{}/{}",
                client.baseurl,
                encode_path(&repository.to_string()),
                encode_path(&snapshot.to_string()),
            );
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &verbose {
                query.push(("verbose", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::snapshot_create_put`]
    ///
    ///[`Client::snapshot_create_put`]: super::Client::snapshot_create_put
    #[derive(Debug, Clone)]
    pub struct SnapshotCreatePut<'a> {
        client: &'a super::Client,
        repository: Result<types::SnapshotCreatePutRepository, String>,
        snapshot: Result<types::SnapshotCreatePutSnapshot, String>,
        cluster_manager_timeout:
            Result<Option<types::SnapshotCreatePutClusterManagerTimeout>, String>,
        master_timeout: Result<Option<types::SnapshotCreatePutMasterTimeout>, String>,
        wait_for_completion: Result<Option<bool>, String>,
        body: Result<types::SnapshotCreateBodyParams, String>,
    }

    impl<'a> SnapshotCreatePut<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                repository: Err("repository was not initialized".to_string()),
                snapshot: Err("snapshot was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                master_timeout: Ok(None),
                wait_for_completion: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn repository<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotCreatePutRepository>,
        {
            self.repository = value.try_into().map_err(|_| {
                "conversion to `SnapshotCreatePutRepository` for repository failed".to_string()
            });
            self
        }

        pub fn snapshot<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotCreatePutSnapshot>,
        {
            self.snapshot = value.try_into().map_err(|_| {
                "conversion to `SnapshotCreatePutSnapshot` for snapshot failed".to_string()
            });
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotCreatePutClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `SnapshotCreatePutClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotCreatePutMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `SnapshotCreatePutMasterTimeout` for master_timeout failed"
                    .to_string()
            });
            self
        }

        pub fn wait_for_completion<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.wait_for_completion = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for wait_for_completion failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotCreateBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `SnapshotCreateBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `PUT` request to `/_snapshot/{repository}/{snapshot}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                repository,
                snapshot,
                cluster_manager_timeout,
                master_timeout,
                wait_for_completion,
                body,
            } = self;
            let repository = repository.map_err(Error::InvalidRequest)?;
            let snapshot = snapshot.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let wait_for_completion = wait_for_completion.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_snapshot/{}/{}",
                client.baseurl,
                encode_path(&repository.to_string()),
                encode_path(&snapshot.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &wait_for_completion {
                query.push(("wait_for_completion", v.to_string()));
            }
            let request = client.client.put(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::snapshot_create_post`]
    ///
    ///[`Client::snapshot_create_post`]: super::Client::snapshot_create_post
    #[derive(Debug, Clone)]
    pub struct SnapshotCreatePost<'a> {
        client: &'a super::Client,
        repository: Result<types::SnapshotCreatePostRepository, String>,
        snapshot: Result<types::SnapshotCreatePostSnapshot, String>,
        cluster_manager_timeout:
            Result<Option<types::SnapshotCreatePostClusterManagerTimeout>, String>,
        master_timeout: Result<Option<types::SnapshotCreatePostMasterTimeout>, String>,
        wait_for_completion: Result<Option<bool>, String>,
        body: Result<types::SnapshotCreateBodyParams, String>,
    }

    impl<'a> SnapshotCreatePost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                repository: Err("repository was not initialized".to_string()),
                snapshot: Err("snapshot was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                master_timeout: Ok(None),
                wait_for_completion: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn repository<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotCreatePostRepository>,
        {
            self.repository = value.try_into().map_err(|_| {
                "conversion to `SnapshotCreatePostRepository` for repository failed".to_string()
            });
            self
        }

        pub fn snapshot<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotCreatePostSnapshot>,
        {
            self.snapshot = value.try_into().map_err(|_| {
                "conversion to `SnapshotCreatePostSnapshot` for snapshot failed".to_string()
            });
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotCreatePostClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `SnapshotCreatePostClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotCreatePostMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `SnapshotCreatePostMasterTimeout` for master_timeout failed"
                    .to_string()
            });
            self
        }

        pub fn wait_for_completion<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.wait_for_completion = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for wait_for_completion failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotCreateBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `SnapshotCreateBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `POST` request to `/_snapshot/{repository}/{snapshot}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                repository,
                snapshot,
                cluster_manager_timeout,
                master_timeout,
                wait_for_completion,
                body,
            } = self;
            let repository = repository.map_err(Error::InvalidRequest)?;
            let snapshot = snapshot.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let wait_for_completion = wait_for_completion.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_snapshot/{}/{}",
                client.baseurl,
                encode_path(&repository.to_string()),
                encode_path(&snapshot.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &wait_for_completion {
                query.push(("wait_for_completion", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::snapshot_delete`]
    ///
    ///[`Client::snapshot_delete`]: super::Client::snapshot_delete
    #[derive(Debug, Clone)]
    pub struct SnapshotDelete<'a> {
        client: &'a super::Client,
        repository: Result<types::SnapshotDeleteRepository, String>,
        snapshot: Result<types::SnapshotDeleteSnapshot, String>,
        cluster_manager_timeout: Result<Option<types::SnapshotDeleteClusterManagerTimeout>, String>,
        master_timeout: Result<Option<types::SnapshotDeleteMasterTimeout>, String>,
    }

    impl<'a> SnapshotDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                repository: Err("repository was not initialized".to_string()),
                snapshot: Err("snapshot was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                master_timeout: Ok(None),
            }
        }

        pub fn repository<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotDeleteRepository>,
        {
            self.repository = value.try_into().map_err(|_| {
                "conversion to `SnapshotDeleteRepository` for repository failed".to_string()
            });
            self
        }

        pub fn snapshot<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotDeleteSnapshot>,
        {
            self.snapshot = value.try_into().map_err(|_| {
                "conversion to `SnapshotDeleteSnapshot` for snapshot failed".to_string()
            });
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotDeleteClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `SnapshotDeleteClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotDeleteMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `SnapshotDeleteMasterTimeout` for master_timeout failed".to_string()
            });
            self
        }

        ///Sends a `DELETE` request to `/_snapshot/{repository}/{snapshot}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                repository,
                snapshot,
                cluster_manager_timeout,
                master_timeout,
            } = self;
            let repository = repository.map_err(Error::InvalidRequest)?;
            let snapshot = snapshot.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_snapshot/{}/{}",
                client.baseurl,
                encode_path(&repository.to_string()),
                encode_path(&snapshot.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            let request = client.client.delete(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::snapshot_clone`]
    ///
    ///[`Client::snapshot_clone`]: super::Client::snapshot_clone
    #[derive(Debug, Clone)]
    pub struct SnapshotClone<'a> {
        client: &'a super::Client,
        repository: Result<types::SnapshotCloneRepository, String>,
        snapshot: Result<types::SnapshotCloneSnapshot, String>,
        target_snapshot: Result<types::SnapshotCloneTargetSnapshot, String>,
        cluster_manager_timeout: Result<Option<types::SnapshotCloneClusterManagerTimeout>, String>,
        master_timeout: Result<Option<types::SnapshotCloneMasterTimeout>, String>,
        body: Result<types::SnapshotCloneBodyParams, String>,
    }

    impl<'a> SnapshotClone<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                repository: Err("repository was not initialized".to_string()),
                snapshot: Err("snapshot was not initialized".to_string()),
                target_snapshot: Err("target_snapshot was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                master_timeout: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn repository<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotCloneRepository>,
        {
            self.repository = value.try_into().map_err(|_| {
                "conversion to `SnapshotCloneRepository` for repository failed".to_string()
            });
            self
        }

        pub fn snapshot<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotCloneSnapshot>,
        {
            self.snapshot = value.try_into().map_err(|_| {
                "conversion to `SnapshotCloneSnapshot` for snapshot failed".to_string()
            });
            self
        }

        pub fn target_snapshot<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotCloneTargetSnapshot>,
        {
            self.target_snapshot = value.try_into().map_err(|_| {
                "conversion to `SnapshotCloneTargetSnapshot` for target_snapshot failed".to_string()
            });
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotCloneClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `SnapshotCloneClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotCloneMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `SnapshotCloneMasterTimeout` for master_timeout failed".to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotCloneBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `SnapshotCloneBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `PUT` request to
        /// `/_snapshot/{repository}/{snapshot}/_clone/{target_snapshot}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                repository,
                snapshot,
                target_snapshot,
                cluster_manager_timeout,
                master_timeout,
                body,
            } = self;
            let repository = repository.map_err(Error::InvalidRequest)?;
            let snapshot = snapshot.map_err(Error::InvalidRequest)?;
            let target_snapshot = target_snapshot.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_snapshot/{}/{}/_clone/{}",
                client.baseurl,
                encode_path(&repository.to_string()),
                encode_path(&snapshot.to_string()),
                encode_path(&target_snapshot.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            let request = client.client.put(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::snapshot_restore`]
    ///
    ///[`Client::snapshot_restore`]: super::Client::snapshot_restore
    #[derive(Debug, Clone)]
    pub struct SnapshotRestore<'a> {
        client: &'a super::Client,
        repository: Result<types::SnapshotRestoreRepository, String>,
        snapshot: Result<types::SnapshotRestoreSnapshot, String>,
        cluster_manager_timeout:
            Result<Option<types::SnapshotRestoreClusterManagerTimeout>, String>,
        master_timeout: Result<Option<types::SnapshotRestoreMasterTimeout>, String>,
        wait_for_completion: Result<Option<bool>, String>,
        body: Result<types::SnapshotRestoreBodyParams, String>,
    }

    impl<'a> SnapshotRestore<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                repository: Err("repository was not initialized".to_string()),
                snapshot: Err("snapshot was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                master_timeout: Ok(None),
                wait_for_completion: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn repository<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotRestoreRepository>,
        {
            self.repository = value.try_into().map_err(|_| {
                "conversion to `SnapshotRestoreRepository` for repository failed".to_string()
            });
            self
        }

        pub fn snapshot<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotRestoreSnapshot>,
        {
            self.snapshot = value.try_into().map_err(|_| {
                "conversion to `SnapshotRestoreSnapshot` for snapshot failed".to_string()
            });
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotRestoreClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `SnapshotRestoreClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotRestoreMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `SnapshotRestoreMasterTimeout` for master_timeout failed".to_string()
            });
            self
        }

        pub fn wait_for_completion<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.wait_for_completion = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for wait_for_completion failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotRestoreBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `SnapshotRestoreBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `POST` request to
        /// `/_snapshot/{repository}/{snapshot}/_restore`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                repository,
                snapshot,
                cluster_manager_timeout,
                master_timeout,
                wait_for_completion,
                body,
            } = self;
            let repository = repository.map_err(Error::InvalidRequest)?;
            let snapshot = snapshot.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let wait_for_completion = wait_for_completion.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_snapshot/{}/{}/_restore",
                client.baseurl,
                encode_path(&repository.to_string()),
                encode_path(&snapshot.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &wait_for_completion {
                query.push(("wait_for_completion", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::snapshot_status_with_repository_snapshot`]
    ///
    ///[`Client::snapshot_status_with_repository_snapshot`]: super::Client::snapshot_status_with_repository_snapshot
    #[derive(Debug, Clone)]
    pub struct SnapshotStatusWithRepositorySnapshot<'a> {
        client: &'a super::Client,
        repository: Result<types::SnapshotStatusWithRepositorySnapshotRepository, String>,
        snapshot: Result<types::SnapshotStatusWithRepositorySnapshotSnapshot, String>,
        cluster_manager_timeout: Result<
            Option<types::SnapshotStatusWithRepositorySnapshotClusterManagerTimeout>,
            String,
        >,
        ignore_unavailable: Result<Option<bool>, String>,
        master_timeout:
            Result<Option<types::SnapshotStatusWithRepositorySnapshotMasterTimeout>, String>,
    }

    impl<'a> SnapshotStatusWithRepositorySnapshot<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                repository: Err("repository was not initialized".to_string()),
                snapshot: Err("snapshot was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                ignore_unavailable: Ok(None),
                master_timeout: Ok(None),
            }
        }

        pub fn repository<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotStatusWithRepositorySnapshotRepository>,
        {
            self . repository = value . try_into () . map_err (| _ | "conversion to `SnapshotStatusWithRepositorySnapshotRepository` for repository failed" . to_string ()) ;
            self
        }

        pub fn snapshot<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotStatusWithRepositorySnapshotSnapshot>,
        {
            self . snapshot = value . try_into () . map_err (| _ | "conversion to `SnapshotStatusWithRepositorySnapshotSnapshot` for snapshot failed" . to_string ()) ;
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<
                types::SnapshotStatusWithRepositorySnapshotClusterManagerTimeout,
            >,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `SnapshotStatusWithRepositorySnapshotClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotStatusWithRepositorySnapshotMasterTimeout>,
        {
            self . master_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `SnapshotStatusWithRepositorySnapshotMasterTimeout` for master_timeout failed" . to_string ()) ;
            self
        }

        ///Sends a `GET` request to
        /// `/_snapshot/{repository}/{snapshot}/_status`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                repository,
                snapshot,
                cluster_manager_timeout,
                ignore_unavailable,
                master_timeout,
            } = self;
            let repository = repository.map_err(Error::InvalidRequest)?;
            let snapshot = snapshot.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_snapshot/{}/{}/_status",
                client.baseurl,
                encode_path(&repository.to_string()),
                encode_path(&snapshot.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_stats`]
    ///
    ///[`Client::indices_stats`]: super::Client::indices_stats
    #[derive(Debug, Clone)]
    pub struct IndicesStats<'a> {
        client: &'a super::Client,
        completion_fields: Result<Option<Vec<String>>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        fielddata_fields: Result<Option<Vec<String>>, String>,
        fields: Result<Option<Vec<String>>, String>,
        forbid_closed_indices: Result<Option<bool>, String>,
        groups: Result<Option<Vec<String>>, String>,
        include_segment_file_sizes: Result<Option<bool>, String>,
        include_unloaded_segments: Result<Option<bool>, String>,
        level: Result<Option<types::IndiciesStatLevel>, String>,
    }

    impl<'a> IndicesStats<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                completion_fields: Ok(None),
                expand_wildcards: Ok(None),
                fielddata_fields: Ok(None),
                fields: Ok(None),
                forbid_closed_indices: Ok(None),
                groups: Ok(None),
                include_segment_file_sizes: Ok(None),
                include_unloaded_segments: Ok(None),
                level: Ok(None),
            }
        }

        pub fn completion_fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.completion_fields = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for completion_fields failed".to_string()
            });
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn fielddata_fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.fielddata_fields = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for fielddata_fields failed".to_string()
            });
            self
        }

        pub fn fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.fields = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
            self
        }

        pub fn forbid_closed_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.forbid_closed_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for forbid_closed_indices failed".to_string());
            self
        }

        pub fn groups<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.groups = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for groups failed".to_string());
            self
        }

        pub fn include_segment_file_sizes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.include_segment_file_sizes = value.try_into().map(Some).map_err(|_| {
                "conversion to `bool` for include_segment_file_sizes failed".to_string()
            });
            self
        }

        pub fn include_unloaded_segments<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.include_unloaded_segments = value.try_into().map(Some).map_err(|_| {
                "conversion to `bool` for include_unloaded_segments failed".to_string()
            });
            self
        }

        pub fn level<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndiciesStatLevel>,
        {
            self.level = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IndiciesStatLevel` for level failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_stats`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                completion_fields,
                expand_wildcards,
                fielddata_fields,
                fields,
                forbid_closed_indices,
                groups,
                include_segment_file_sizes,
                include_unloaded_segments,
                level,
            } = self;
            let completion_fields = completion_fields.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let fielddata_fields = fielddata_fields.map_err(Error::InvalidRequest)?;
            let fields = fields.map_err(Error::InvalidRequest)?;
            let forbid_closed_indices = forbid_closed_indices.map_err(Error::InvalidRequest)?;
            let groups = groups.map_err(Error::InvalidRequest)?;
            let include_segment_file_sizes =
                include_segment_file_sizes.map_err(Error::InvalidRequest)?;
            let include_unloaded_segments =
                include_unloaded_segments.map_err(Error::InvalidRequest)?;
            let level = level.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_stats", client.baseurl,);
            let mut query = Vec::with_capacity(9usize);
            if let Some(v) = &completion_fields {
                query.push(("completion_fields", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &fielddata_fields {
                query.push(("fielddata_fields", v.to_string()));
            }
            if let Some(v) = &fields {
                query.push(("fields", v.to_string()));
            }
            if let Some(v) = &forbid_closed_indices {
                query.push(("forbid_closed_indices", v.to_string()));
            }
            if let Some(v) = &groups {
                query.push(("groups", v.to_string()));
            }
            if let Some(v) = &include_segment_file_sizes {
                query.push(("include_segment_file_sizes", v.to_string()));
            }
            if let Some(v) = &include_unloaded_segments {
                query.push(("include_unloaded_segments", v.to_string()));
            }
            if let Some(v) = &level {
                query.push(("level", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_stats_with_metric`]
    ///
    ///[`Client::indices_stats_with_metric`]: super::Client::indices_stats_with_metric
    #[derive(Debug, Clone)]
    pub struct IndicesStatsWithMetric<'a> {
        client: &'a super::Client,
        metric: Result<types::IndicesStatsWithMetricMetric, String>,
        completion_fields: Result<Option<Vec<String>>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        fielddata_fields: Result<Option<Vec<String>>, String>,
        fields: Result<Option<Vec<String>>, String>,
        forbid_closed_indices: Result<Option<bool>, String>,
        groups: Result<Option<Vec<String>>, String>,
        include_segment_file_sizes: Result<Option<bool>, String>,
        include_unloaded_segments: Result<Option<bool>, String>,
        level: Result<Option<types::IndiciesStatLevel>, String>,
    }

    impl<'a> IndicesStatsWithMetric<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                metric: Err("metric was not initialized".to_string()),
                completion_fields: Ok(None),
                expand_wildcards: Ok(None),
                fielddata_fields: Ok(None),
                fields: Ok(None),
                forbid_closed_indices: Ok(None),
                groups: Ok(None),
                include_segment_file_sizes: Ok(None),
                include_unloaded_segments: Ok(None),
                level: Ok(None),
            }
        }

        pub fn metric<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesStatsWithMetricMetric>,
        {
            self.metric = value.try_into().map_err(|_| {
                "conversion to `IndicesStatsWithMetricMetric` for metric failed".to_string()
            });
            self
        }

        pub fn completion_fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.completion_fields = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for completion_fields failed".to_string()
            });
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn fielddata_fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.fielddata_fields = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for fielddata_fields failed".to_string()
            });
            self
        }

        pub fn fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.fields = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
            self
        }

        pub fn forbid_closed_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.forbid_closed_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for forbid_closed_indices failed".to_string());
            self
        }

        pub fn groups<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.groups = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for groups failed".to_string());
            self
        }

        pub fn include_segment_file_sizes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.include_segment_file_sizes = value.try_into().map(Some).map_err(|_| {
                "conversion to `bool` for include_segment_file_sizes failed".to_string()
            });
            self
        }

        pub fn include_unloaded_segments<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.include_unloaded_segments = value.try_into().map(Some).map_err(|_| {
                "conversion to `bool` for include_unloaded_segments failed".to_string()
            });
            self
        }

        pub fn level<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndiciesStatLevel>,
        {
            self.level = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IndiciesStatLevel` for level failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_stats/{metric}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                metric,
                completion_fields,
                expand_wildcards,
                fielddata_fields,
                fields,
                forbid_closed_indices,
                groups,
                include_segment_file_sizes,
                include_unloaded_segments,
                level,
            } = self;
            let metric = metric.map_err(Error::InvalidRequest)?;
            let completion_fields = completion_fields.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let fielddata_fields = fielddata_fields.map_err(Error::InvalidRequest)?;
            let fields = fields.map_err(Error::InvalidRequest)?;
            let forbid_closed_indices = forbid_closed_indices.map_err(Error::InvalidRequest)?;
            let groups = groups.map_err(Error::InvalidRequest)?;
            let include_segment_file_sizes =
                include_segment_file_sizes.map_err(Error::InvalidRequest)?;
            let include_unloaded_segments =
                include_unloaded_segments.map_err(Error::InvalidRequest)?;
            let level = level.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_stats/{}",
                client.baseurl,
                encode_path(&metric.to_string()),
            );
            let mut query = Vec::with_capacity(9usize);
            if let Some(v) = &completion_fields {
                query.push(("completion_fields", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &fielddata_fields {
                query.push(("fielddata_fields", v.to_string()));
            }
            if let Some(v) = &fields {
                query.push(("fields", v.to_string()));
            }
            if let Some(v) = &forbid_closed_indices {
                query.push(("forbid_closed_indices", v.to_string()));
            }
            if let Some(v) = &groups {
                query.push(("groups", v.to_string()));
            }
            if let Some(v) = &include_segment_file_sizes {
                query.push(("include_segment_file_sizes", v.to_string()));
            }
            if let Some(v) = &include_unloaded_segments {
                query.push(("include_unloaded_segments", v.to_string()));
            }
            if let Some(v) = &level {
                query.push(("level", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::tasks_list`]
    ///
    ///[`Client::tasks_list`]: super::Client::tasks_list
    #[derive(Debug, Clone)]
    pub struct TasksList<'a> {
        client: &'a super::Client,
        actions: Result<Option<Vec<String>>, String>,
        detailed: Result<Option<bool>, String>,
        group_by: Result<Option<types::GroupBy>, String>,
        nodes: Result<Option<Vec<String>>, String>,
        parent_task_id: Result<Option<String>, String>,
        timeout: Result<Option<types::TasksListTimeout>, String>,
        wait_for_completion: Result<Option<bool>, String>,
    }

    impl<'a> TasksList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                actions: Ok(None),
                detailed: Ok(None),
                group_by: Ok(None),
                nodes: Ok(None),
                parent_task_id: Ok(None),
                timeout: Ok(None),
                wait_for_completion: Ok(None),
            }
        }

        pub fn actions<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.actions = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for actions failed".to_string());
            self
        }

        pub fn detailed<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.detailed = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for detailed failed".to_string());
            self
        }

        pub fn group_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::GroupBy>,
        {
            self.group_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `GroupBy` for group_by failed".to_string());
            self
        }

        pub fn nodes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.nodes = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for nodes failed".to_string());
            self
        }

        pub fn parent_task_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.parent_task_id = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for parent_task_id failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::TasksListTimeout>,
        {
            self.timeout = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `TasksListTimeout` for timeout failed".to_string());
            self
        }

        pub fn wait_for_completion<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.wait_for_completion = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for wait_for_completion failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_tasks`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                actions,
                detailed,
                group_by,
                nodes,
                parent_task_id,
                timeout,
                wait_for_completion,
            } = self;
            let actions = actions.map_err(Error::InvalidRequest)?;
            let detailed = detailed.map_err(Error::InvalidRequest)?;
            let group_by = group_by.map_err(Error::InvalidRequest)?;
            let nodes = nodes.map_err(Error::InvalidRequest)?;
            let parent_task_id = parent_task_id.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let wait_for_completion = wait_for_completion.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_tasks", client.baseurl,);
            let mut query = Vec::with_capacity(7usize);
            if let Some(v) = &actions {
                query.push(("actions", v.to_string()));
            }
            if let Some(v) = &detailed {
                query.push(("detailed", v.to_string()));
            }
            if let Some(v) = &group_by {
                query.push(("group_by", v.to_string()));
            }
            if let Some(v) = &nodes {
                query.push(("nodes", v.to_string()));
            }
            if let Some(v) = &parent_task_id {
                query.push(("parent_task_id", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &wait_for_completion {
                query.push(("wait_for_completion", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::tasks_cancel`]
    ///
    ///[`Client::tasks_cancel`]: super::Client::tasks_cancel
    #[derive(Debug, Clone)]
    pub struct TasksCancel<'a> {
        client: &'a super::Client,
        actions: Result<Option<Vec<String>>, String>,
        nodes: Result<Option<Vec<String>>, String>,
        parent_task_id: Result<Option<String>, String>,
        wait_for_completion: Result<Option<bool>, String>,
    }

    impl<'a> TasksCancel<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                actions: Ok(None),
                nodes: Ok(None),
                parent_task_id: Ok(None),
                wait_for_completion: Ok(None),
            }
        }

        pub fn actions<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.actions = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for actions failed".to_string());
            self
        }

        pub fn nodes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.nodes = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for nodes failed".to_string());
            self
        }

        pub fn parent_task_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.parent_task_id = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for parent_task_id failed".to_string());
            self
        }

        pub fn wait_for_completion<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.wait_for_completion = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for wait_for_completion failed".to_string());
            self
        }

        ///Sends a `POST` request to `/_tasks/_cancel`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                actions,
                nodes,
                parent_task_id,
                wait_for_completion,
            } = self;
            let actions = actions.map_err(Error::InvalidRequest)?;
            let nodes = nodes.map_err(Error::InvalidRequest)?;
            let parent_task_id = parent_task_id.map_err(Error::InvalidRequest)?;
            let wait_for_completion = wait_for_completion.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_tasks/_cancel", client.baseurl,);
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &actions {
                query.push(("actions", v.to_string()));
            }
            if let Some(v) = &nodes {
                query.push(("nodes", v.to_string()));
            }
            if let Some(v) = &parent_task_id {
                query.push(("parent_task_id", v.to_string()));
            }
            if let Some(v) = &wait_for_completion {
                query.push(("wait_for_completion", v.to_string()));
            }
            let request = client.client.post(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::tasks_get`]
    ///
    ///[`Client::tasks_get`]: super::Client::tasks_get
    #[derive(Debug, Clone)]
    pub struct TasksGet<'a> {
        client: &'a super::Client,
        task_id: Result<types::TasksGetTaskId, String>,
        timeout: Result<Option<types::TasksGetTimeout>, String>,
        wait_for_completion: Result<Option<bool>, String>,
    }

    impl<'a> TasksGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                task_id: Err("task_id was not initialized".to_string()),
                timeout: Ok(None),
                wait_for_completion: Ok(None),
            }
        }

        pub fn task_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::TasksGetTaskId>,
        {
            self.task_id = value
                .try_into()
                .map_err(|_| "conversion to `TasksGetTaskId` for task_id failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::TasksGetTimeout>,
        {
            self.timeout = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `TasksGetTimeout` for timeout failed".to_string());
            self
        }

        pub fn wait_for_completion<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.wait_for_completion = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for wait_for_completion failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_tasks/{task_id}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                task_id,
                timeout,
                wait_for_completion,
            } = self;
            let task_id = task_id.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let wait_for_completion = wait_for_completion.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_tasks/{}",
                client.baseurl,
                encode_path(&task_id.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &wait_for_completion {
                query.push(("wait_for_completion", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::tasks_cancel_with_task_id`]
    ///
    ///[`Client::tasks_cancel_with_task_id`]: super::Client::tasks_cancel_with_task_id
    #[derive(Debug, Clone)]
    pub struct TasksCancelWithTaskId<'a> {
        client: &'a super::Client,
        task_id: Result<types::TasksCancelWithTaskIdTaskId, String>,
        actions: Result<Option<Vec<String>>, String>,
        nodes: Result<Option<Vec<String>>, String>,
        parent_task_id: Result<Option<String>, String>,
        wait_for_completion: Result<Option<bool>, String>,
    }

    impl<'a> TasksCancelWithTaskId<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                task_id: Err("task_id was not initialized".to_string()),
                actions: Ok(None),
                nodes: Ok(None),
                parent_task_id: Ok(None),
                wait_for_completion: Ok(None),
            }
        }

        pub fn task_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::TasksCancelWithTaskIdTaskId>,
        {
            self.task_id = value.try_into().map_err(|_| {
                "conversion to `TasksCancelWithTaskIdTaskId` for task_id failed".to_string()
            });
            self
        }

        pub fn actions<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.actions = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for actions failed".to_string());
            self
        }

        pub fn nodes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.nodes = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for nodes failed".to_string());
            self
        }

        pub fn parent_task_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.parent_task_id = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for parent_task_id failed".to_string());
            self
        }

        pub fn wait_for_completion<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.wait_for_completion = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for wait_for_completion failed".to_string());
            self
        }

        ///Sends a `POST` request to `/_tasks/{task_id}/_cancel`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                task_id,
                actions,
                nodes,
                parent_task_id,
                wait_for_completion,
            } = self;
            let task_id = task_id.map_err(Error::InvalidRequest)?;
            let actions = actions.map_err(Error::InvalidRequest)?;
            let nodes = nodes.map_err(Error::InvalidRequest)?;
            let parent_task_id = parent_task_id.map_err(Error::InvalidRequest)?;
            let wait_for_completion = wait_for_completion.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_tasks/{}/_cancel",
                client.baseurl,
                encode_path(&task_id.to_string()),
            );
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &actions {
                query.push(("actions", v.to_string()));
            }
            if let Some(v) = &nodes {
                query.push(("nodes", v.to_string()));
            }
            if let Some(v) = &parent_task_id {
                query.push(("parent_task_id", v.to_string()));
            }
            if let Some(v) = &wait_for_completion {
                query.push(("wait_for_completion", v.to_string()));
            }
            let request = client.client.post(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_get_template`]
    ///
    ///[`Client::indices_get_template`]: super::Client::indices_get_template
    #[derive(Debug, Clone)]
    pub struct IndicesGetTemplate<'a> {
        client: &'a super::Client,
        cluster_manager_timeout:
            Result<Option<types::IndicesGetTemplateClusterManagerTimeout>, String>,
        flat_settings: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::IndicesGetTemplateMasterTimeout>, String>,
    }

    impl<'a> IndicesGetTemplate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                cluster_manager_timeout: Ok(None),
                flat_settings: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
            }
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesGetTemplateClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesGetTemplateClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn flat_settings<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.flat_settings = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesGetTemplateMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesGetTemplateMasterTimeout` for master_timeout failed"
                    .to_string()
            });
            self
        }

        ///Sends a `GET` request to `/_template`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                cluster_manager_timeout,
                flat_settings,
                local,
                master_timeout,
            } = self;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_template", client.baseurl,);
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &flat_settings {
                query.push(("flat_settings", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_get_template_with_name`]
    ///
    ///[`Client::indices_get_template_with_name`]: super::Client::indices_get_template_with_name
    #[derive(Debug, Clone)]
    pub struct IndicesGetTemplateWithName<'a> {
        client: &'a super::Client,
        name: Result<types::IndicesGetTemplateWithNameName, String>,
        cluster_manager_timeout:
            Result<Option<types::IndicesGetTemplateWithNameClusterManagerTimeout>, String>,
        flat_settings: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::IndicesGetTemplateWithNameMasterTimeout>, String>,
    }

    impl<'a> IndicesGetTemplateWithName<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                name: Err("name was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                flat_settings: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
            }
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesGetTemplateWithNameName>,
        {
            self.name = value.try_into().map_err(|_| {
                "conversion to `IndicesGetTemplateWithNameName` for name failed".to_string()
            });
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesGetTemplateWithNameClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesGetTemplateWithNameClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn flat_settings<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.flat_settings = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesGetTemplateWithNameMasterTimeout>,
        {
            self . master_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesGetTemplateWithNameMasterTimeout` for master_timeout failed" . to_string ()) ;
            self
        }

        ///Sends a `GET` request to `/_template/{name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                name,
                cluster_manager_timeout,
                flat_settings,
                local,
                master_timeout,
            } = self;
            let name = name.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_template/{}",
                client.baseurl,
                encode_path(&name.to_string()),
            );
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &flat_settings {
                query.push(("flat_settings", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_put_template_put`]
    ///
    ///[`Client::indices_put_template_put`]: super::Client::indices_put_template_put
    #[derive(Debug, Clone)]
    pub struct IndicesPutTemplatePut<'a> {
        client: &'a super::Client,
        name: Result<types::IndicesPutTemplatePutName, String>,
        cluster_manager_timeout:
            Result<Option<types::IndicesPutTemplatePutClusterManagerTimeout>, String>,
        create: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::IndicesPutTemplatePutMasterTimeout>, String>,
        order: Result<Option<i32>, String>,
        body: Result<types::IndicesPutTemplateBodyParams, String>,
    }

    impl<'a> IndicesPutTemplatePut<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                name: Err("name was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                create: Ok(None),
                master_timeout: Ok(None),
                order: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutTemplatePutName>,
        {
            self.name = value.try_into().map_err(|_| {
                "conversion to `IndicesPutTemplatePutName` for name failed".to_string()
            });
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutTemplatePutClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesPutTemplatePutClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn create<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.create = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for create failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutTemplatePutMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesPutTemplatePutMasterTimeout` for master_timeout failed"
                    .to_string()
            });
            self
        }

        pub fn order<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.order = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for order failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutTemplateBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `IndicesPutTemplateBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `PUT` request to `/_template/{name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                name,
                cluster_manager_timeout,
                create,
                master_timeout,
                order,
                body,
            } = self;
            let name = name.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let create = create.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let order = order.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_template/{}",
                client.baseurl,
                encode_path(&name.to_string()),
            );
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &create {
                query.push(("create", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &order {
                query.push(("order", v.to_string()));
            }
            let request = client.client.put(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_put_template_post`]
    ///
    ///[`Client::indices_put_template_post`]: super::Client::indices_put_template_post
    #[derive(Debug, Clone)]
    pub struct IndicesPutTemplatePost<'a> {
        client: &'a super::Client,
        name: Result<types::IndicesPutTemplatePostName, String>,
        cluster_manager_timeout:
            Result<Option<types::IndicesPutTemplatePostClusterManagerTimeout>, String>,
        create: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::IndicesPutTemplatePostMasterTimeout>, String>,
        order: Result<Option<i32>, String>,
        body: Result<types::IndicesPutTemplateBodyParams, String>,
    }

    impl<'a> IndicesPutTemplatePost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                name: Err("name was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                create: Ok(None),
                master_timeout: Ok(None),
                order: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutTemplatePostName>,
        {
            self.name = value.try_into().map_err(|_| {
                "conversion to `IndicesPutTemplatePostName` for name failed".to_string()
            });
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutTemplatePostClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesPutTemplatePostClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn create<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.create = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for create failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutTemplatePostMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesPutTemplatePostMasterTimeout` for master_timeout failed"
                    .to_string()
            });
            self
        }

        pub fn order<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.order = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for order failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutTemplateBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `IndicesPutTemplateBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `POST` request to `/_template/{name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                name,
                cluster_manager_timeout,
                create,
                master_timeout,
                order,
                body,
            } = self;
            let name = name.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let create = create.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let order = order.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_template/{}",
                client.baseurl,
                encode_path(&name.to_string()),
            );
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &create {
                query.push(("create", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &order {
                query.push(("order", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_delete_template`]
    ///
    ///[`Client::indices_delete_template`]: super::Client::indices_delete_template
    #[derive(Debug, Clone)]
    pub struct IndicesDeleteTemplate<'a> {
        client: &'a super::Client,
        name: Result<types::IndicesDeleteTemplateName, String>,
        cluster_manager_timeout:
            Result<Option<types::IndicesDeleteTemplateClusterManagerTimeout>, String>,
        master_timeout: Result<Option<types::IndicesDeleteTemplateMasterTimeout>, String>,
        timeout: Result<Option<types::IndicesDeleteTemplateTimeout>, String>,
    }

    impl<'a> IndicesDeleteTemplate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                name: Err("name was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
            }
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesDeleteTemplateName>,
        {
            self.name = value.try_into().map_err(|_| {
                "conversion to `IndicesDeleteTemplateName` for name failed".to_string()
            });
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesDeleteTemplateClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesDeleteTemplateClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesDeleteTemplateMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesDeleteTemplateMasterTimeout` for master_timeout failed"
                    .to_string()
            });
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesDeleteTemplateTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesDeleteTemplateTimeout` for timeout failed".to_string()
            });
            self
        }

        ///Sends a `DELETE` request to `/_template/{name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                name,
                cluster_manager_timeout,
                master_timeout,
                timeout,
            } = self;
            let name = name.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_template/{}",
                client.baseurl,
                encode_path(&name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client.client.delete(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_exists_template`]
    ///
    ///[`Client::indices_exists_template`]: super::Client::indices_exists_template
    #[derive(Debug, Clone)]
    pub struct IndicesExistsTemplate<'a> {
        client: &'a super::Client,
        name: Result<types::IndicesExistsTemplateName, String>,
        flat_settings: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::IndicesExistsTemplateMasterTimeout>, String>,
    }

    impl<'a> IndicesExistsTemplate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                name: Err("name was not initialized".to_string()),
                flat_settings: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
            }
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesExistsTemplateName>,
        {
            self.name = value.try_into().map_err(|_| {
                "conversion to `IndicesExistsTemplateName` for name failed".to_string()
            });
            self
        }

        pub fn flat_settings<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.flat_settings = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesExistsTemplateMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesExistsTemplateMasterTimeout` for master_timeout failed"
                    .to_string()
            });
            self
        }

        ///Sends a `HEAD` request to `/_template/{name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                name,
                flat_settings,
                local,
                master_timeout,
            } = self;
            let name = name.map_err(Error::InvalidRequest)?;
            let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_template/{}",
                client.baseurl,
                encode_path(&name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &flat_settings {
                query.push(("flat_settings", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            let request = client.client.head(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::update_by_query_rethrottle`]
    ///
    ///[`Client::update_by_query_rethrottle`]: super::Client::update_by_query_rethrottle
    #[derive(Debug, Clone)]
    pub struct UpdateByQueryRethrottle<'a> {
        client: &'a super::Client,
        task_id: Result<types::UpdateByQueryRethrottleTaskId, String>,
        requests_per_second: Result<i32, String>,
    }

    impl<'a> UpdateByQueryRethrottle<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                task_id: Err("task_id was not initialized".to_string()),
                requests_per_second: Err("requests_per_second was not initialized".to_string()),
            }
        }

        pub fn task_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdateByQueryRethrottleTaskId>,
        {
            self.task_id = value.try_into().map_err(|_| {
                "conversion to `UpdateByQueryRethrottleTaskId` for task_id failed".to_string()
            });
            self
        }

        pub fn requests_per_second<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.requests_per_second = value
                .try_into()
                .map_err(|_| "conversion to `i32` for requests_per_second failed".to_string());
            self
        }

        ///Sends a `POST` request to `/_update_by_query/{task_id}/_rethrottle`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                task_id,
                requests_per_second,
            } = self;
            let task_id = task_id.map_err(Error::InvalidRequest)?;
            let requests_per_second = requests_per_second.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/_update_by_query/{}/_rethrottle",
                client.baseurl,
                encode_path(&task_id.to_string()),
            );
            let mut query = Vec::with_capacity(1usize);
            query.push(("requests_per_second", requests_per_second.to_string()));
            let request = client.client.post(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_get_upgrade`]
    ///
    ///[`Client::indices_get_upgrade`]: super::Client::indices_get_upgrade
    #[derive(Debug, Clone)]
    pub struct IndicesGetUpgrade<'a> {
        client: &'a super::Client,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
    }

    impl<'a> IndicesGetUpgrade<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                ignore_unavailable: Ok(None),
            }
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_upgrade`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                allow_no_indices,
                expand_wildcards,
                ignore_unavailable,
            } = self;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_upgrade", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_upgrade`]
    ///
    ///[`Client::indices_upgrade`]: super::Client::indices_upgrade
    #[derive(Debug, Clone)]
    pub struct IndicesUpgrade<'a> {
        client: &'a super::Client,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        only_ancient_segments: Result<Option<bool>, String>,
        wait_for_completion: Result<Option<bool>, String>,
    }

    impl<'a> IndicesUpgrade<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                ignore_unavailable: Ok(None),
                only_ancient_segments: Ok(None),
                wait_for_completion: Ok(None),
            }
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn only_ancient_segments<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.only_ancient_segments = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for only_ancient_segments failed".to_string());
            self
        }

        pub fn wait_for_completion<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.wait_for_completion = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for wait_for_completion failed".to_string());
            self
        }

        ///Sends a `POST` request to `/_upgrade`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                allow_no_indices,
                expand_wildcards,
                ignore_unavailable,
                only_ancient_segments,
                wait_for_completion,
            } = self;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let only_ancient_segments = only_ancient_segments.map_err(Error::InvalidRequest)?;
            let wait_for_completion = wait_for_completion.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_upgrade", client.baseurl,);
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &only_ancient_segments {
                query.push(("only_ancient_segments", v.to_string()));
            }
            if let Some(v) = &wait_for_completion {
                query.push(("wait_for_completion", v.to_string()));
            }
            let request = client.client.post(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_validate_query_get`]
    ///
    ///[`Client::indices_validate_query_get`]: super::Client::indices_validate_query_get
    #[derive(Debug, Clone)]
    pub struct IndicesValidateQueryGet<'a> {
        client: &'a super::Client,
        all_shards: Result<Option<bool>, String>,
        allow_no_indices: Result<Option<bool>, String>,
        analyze_wildcard: Result<Option<bool>, String>,
        analyzer: Result<Option<String>, String>,
        default_operator: Result<Option<types::DefaultOperator>, String>,
        df: Result<Option<String>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        explain: Result<Option<bool>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        lenient: Result<Option<bool>, String>,
        q: Result<Option<String>, String>,
        rewrite: Result<Option<bool>, String>,
    }

    impl<'a> IndicesValidateQueryGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                all_shards: Ok(None),
                allow_no_indices: Ok(None),
                analyze_wildcard: Ok(None),
                analyzer: Ok(None),
                default_operator: Ok(None),
                df: Ok(None),
                expand_wildcards: Ok(None),
                explain: Ok(None),
                ignore_unavailable: Ok(None),
                lenient: Ok(None),
                q: Ok(None),
                rewrite: Ok(None),
            }
        }

        pub fn all_shards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.all_shards = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for all_shards failed".to_string());
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn analyze_wildcard<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.analyze_wildcard = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for analyze_wildcard failed".to_string());
            self
        }

        pub fn analyzer<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.analyzer = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for analyzer failed".to_string());
            self
        }

        pub fn default_operator<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DefaultOperator>,
        {
            self.default_operator = value.try_into().map(Some).map_err(|_| {
                "conversion to `DefaultOperator` for default_operator failed".to_string()
            });
            self
        }

        pub fn df<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.df = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for df failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn explain<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.explain = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for explain failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn lenient<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.lenient = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for lenient failed".to_string());
            self
        }

        pub fn q<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.q = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for q failed".to_string());
            self
        }

        pub fn rewrite<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.rewrite = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for rewrite failed".to_string());
            self
        }

        ///Sends a `GET` request to `/_validate/query`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                all_shards,
                allow_no_indices,
                analyze_wildcard,
                analyzer,
                default_operator,
                df,
                expand_wildcards,
                explain,
                ignore_unavailable,
                lenient,
                q,
                rewrite,
            } = self;
            let all_shards = all_shards.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let analyze_wildcard = analyze_wildcard.map_err(Error::InvalidRequest)?;
            let analyzer = analyzer.map_err(Error::InvalidRequest)?;
            let default_operator = default_operator.map_err(Error::InvalidRequest)?;
            let df = df.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let explain = explain.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let lenient = lenient.map_err(Error::InvalidRequest)?;
            let q = q.map_err(Error::InvalidRequest)?;
            let rewrite = rewrite.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_validate/query", client.baseurl,);
            let mut query = Vec::with_capacity(12usize);
            if let Some(v) = &all_shards {
                query.push(("all_shards", v.to_string()));
            }
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &analyze_wildcard {
                query.push(("analyze_wildcard", v.to_string()));
            }
            if let Some(v) = &analyzer {
                query.push(("analyzer", v.to_string()));
            }
            if let Some(v) = &default_operator {
                query.push(("default_operator", v.to_string()));
            }
            if let Some(v) = &df {
                query.push(("df", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &explain {
                query.push(("explain", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &lenient {
                query.push(("lenient", v.to_string()));
            }
            if let Some(v) = &q {
                query.push(("q", v.to_string()));
            }
            if let Some(v) = &rewrite {
                query.push(("rewrite", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_validate_query_post`]
    ///
    ///[`Client::indices_validate_query_post`]: super::Client::indices_validate_query_post
    #[derive(Debug, Clone)]
    pub struct IndicesValidateQueryPost<'a> {
        client: &'a super::Client,
        all_shards: Result<Option<bool>, String>,
        allow_no_indices: Result<Option<bool>, String>,
        analyze_wildcard: Result<Option<bool>, String>,
        analyzer: Result<Option<String>, String>,
        default_operator: Result<Option<types::DefaultOperator>, String>,
        df: Result<Option<String>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        explain: Result<Option<bool>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        lenient: Result<Option<bool>, String>,
        q: Result<Option<String>, String>,
        rewrite: Result<Option<bool>, String>,
        body: Result<types::IndicesValidateQueryBodyParams, String>,
    }

    impl<'a> IndicesValidateQueryPost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                all_shards: Ok(None),
                allow_no_indices: Ok(None),
                analyze_wildcard: Ok(None),
                analyzer: Ok(None),
                default_operator: Ok(None),
                df: Ok(None),
                expand_wildcards: Ok(None),
                explain: Ok(None),
                ignore_unavailable: Ok(None),
                lenient: Ok(None),
                q: Ok(None),
                rewrite: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn all_shards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.all_shards = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for all_shards failed".to_string());
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn analyze_wildcard<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.analyze_wildcard = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for analyze_wildcard failed".to_string());
            self
        }

        pub fn analyzer<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.analyzer = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for analyzer failed".to_string());
            self
        }

        pub fn default_operator<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DefaultOperator>,
        {
            self.default_operator = value.try_into().map(Some).map_err(|_| {
                "conversion to `DefaultOperator` for default_operator failed".to_string()
            });
            self
        }

        pub fn df<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.df = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for df failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn explain<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.explain = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for explain failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn lenient<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.lenient = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for lenient failed".to_string());
            self
        }

        pub fn q<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.q = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for q failed".to_string());
            self
        }

        pub fn rewrite<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.rewrite = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for rewrite failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesValidateQueryBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `IndicesValidateQueryBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `POST` request to `/_validate/query`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                all_shards,
                allow_no_indices,
                analyze_wildcard,
                analyzer,
                default_operator,
                df,
                expand_wildcards,
                explain,
                ignore_unavailable,
                lenient,
                q,
                rewrite,
                body,
            } = self;
            let all_shards = all_shards.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let analyze_wildcard = analyze_wildcard.map_err(Error::InvalidRequest)?;
            let analyzer = analyzer.map_err(Error::InvalidRequest)?;
            let default_operator = default_operator.map_err(Error::InvalidRequest)?;
            let df = df.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let explain = explain.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let lenient = lenient.map_err(Error::InvalidRequest)?;
            let q = q.map_err(Error::InvalidRequest)?;
            let rewrite = rewrite.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/_validate/query", client.baseurl,);
            let mut query = Vec::with_capacity(12usize);
            if let Some(v) = &all_shards {
                query.push(("all_shards", v.to_string()));
            }
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &analyze_wildcard {
                query.push(("analyze_wildcard", v.to_string()));
            }
            if let Some(v) = &analyzer {
                query.push(("analyzer", v.to_string()));
            }
            if let Some(v) = &default_operator {
                query.push(("default_operator", v.to_string()));
            }
            if let Some(v) = &df {
                query.push(("df", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &explain {
                query.push(("explain", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &lenient {
                query.push(("lenient", v.to_string()));
            }
            if let Some(v) = &q {
                query.push(("q", v.to_string()));
            }
            if let Some(v) = &rewrite {
                query.push(("rewrite", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_rollover`]
    ///
    ///[`Client::indices_rollover`]: super::Client::indices_rollover
    #[derive(Debug, Clone)]
    pub struct IndicesRollover<'a> {
        client: &'a super::Client,
        alias: Result<types::IndicesRolloverAlias, String>,
        cluster_manager_timeout:
            Result<Option<types::IndicesRolloverClusterManagerTimeout>, String>,
        dry_run: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::IndicesRolloverMasterTimeout>, String>,
        timeout: Result<Option<types::IndicesRolloverTimeout>, String>,
        wait_for_active_shards: Result<Option<String>, String>,
        body: Result<types::IndicesRolloverBodyParams, String>,
    }

    impl<'a> IndicesRollover<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                alias: Err("alias was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                dry_run: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
                wait_for_active_shards: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn alias<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesRolloverAlias>,
        {
            self.alias = value
                .try_into()
                .map_err(|_| "conversion to `IndicesRolloverAlias` for alias failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesRolloverClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesRolloverClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn dry_run<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.dry_run = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for dry_run failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesRolloverMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesRolloverMasterTimeout` for master_timeout failed".to_string()
            });
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesRolloverTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesRolloverTimeout` for timeout failed".to_string()
            });
            self
        }

        pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.wait_for_active_shards = value.try_into().map(Some).map_err(|_| {
                "conversion to `String` for wait_for_active_shards failed".to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesRolloverBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `IndicesRolloverBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `POST` request to `/{alias}/_rollover`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                alias,
                cluster_manager_timeout,
                dry_run,
                master_timeout,
                timeout,
                wait_for_active_shards,
                body,
            } = self;
            let alias = alias.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let dry_run = dry_run.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_rollover",
                client.baseurl,
                encode_path(&alias.to_string()),
            );
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &dry_run {
                query.push(("dry_run", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &wait_for_active_shards {
                query.push(("wait_for_active_shards", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_rollover_with_new_index`]
    ///
    ///[`Client::indices_rollover_with_new_index`]: super::Client::indices_rollover_with_new_index
    #[derive(Debug, Clone)]
    pub struct IndicesRolloverWithNewIndex<'a> {
        client: &'a super::Client,
        alias: Result<types::IndicesRolloverWithNewIndexAlias, String>,
        new_index: Result<types::IndicesRolloverWithNewIndexNewIndex, String>,
        cluster_manager_timeout:
            Result<Option<types::IndicesRolloverWithNewIndexClusterManagerTimeout>, String>,
        dry_run: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::IndicesRolloverWithNewIndexMasterTimeout>, String>,
        timeout: Result<Option<types::IndicesRolloverWithNewIndexTimeout>, String>,
        wait_for_active_shards: Result<Option<String>, String>,
        body: Result<types::IndicesRolloverBodyParams, String>,
    }

    impl<'a> IndicesRolloverWithNewIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                alias: Err("alias was not initialized".to_string()),
                new_index: Err("new_index was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                dry_run: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
                wait_for_active_shards: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn alias<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesRolloverWithNewIndexAlias>,
        {
            self.alias = value.try_into().map_err(|_| {
                "conversion to `IndicesRolloverWithNewIndexAlias` for alias failed".to_string()
            });
            self
        }

        pub fn new_index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesRolloverWithNewIndexNewIndex>,
        {
            self.new_index = value.try_into().map_err(|_| {
                "conversion to `IndicesRolloverWithNewIndexNewIndex` for new_index failed"
                    .to_string()
            });
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesRolloverWithNewIndexClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesRolloverWithNewIndexClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn dry_run<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.dry_run = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for dry_run failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesRolloverWithNewIndexMasterTimeout>,
        {
            self . master_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesRolloverWithNewIndexMasterTimeout` for master_timeout failed" . to_string ()) ;
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesRolloverWithNewIndexTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesRolloverWithNewIndexTimeout` for timeout failed".to_string()
            });
            self
        }

        pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.wait_for_active_shards = value.try_into().map(Some).map_err(|_| {
                "conversion to `String` for wait_for_active_shards failed".to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesRolloverBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `IndicesRolloverBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `POST` request to `/{alias}/_rollover/{new_index}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                alias,
                new_index,
                cluster_manager_timeout,
                dry_run,
                master_timeout,
                timeout,
                wait_for_active_shards,
                body,
            } = self;
            let alias = alias.map_err(Error::InvalidRequest)?;
            let new_index = new_index.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let dry_run = dry_run.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_rollover/{}",
                client.baseurl,
                encode_path(&alias.to_string()),
                encode_path(&new_index.to_string()),
            );
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &dry_run {
                query.push(("dry_run", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &wait_for_active_shards {
                query.push(("wait_for_active_shards", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_get`]
    ///
    ///[`Client::indices_get`]: super::Client::indices_get
    #[derive(Debug, Clone)]
    pub struct IndicesGet<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesGetIndex, String>,
        allow_no_indices: Result<Option<bool>, String>,
        cluster_manager_timeout: Result<Option<types::IndicesGetClusterManagerTimeout>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        flat_settings: Result<Option<bool>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        include_defaults: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::IndicesGetMasterTimeout>, String>,
    }

    impl<'a> IndicesGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                allow_no_indices: Ok(None),
                cluster_manager_timeout: Ok(None),
                expand_wildcards: Ok(None),
                flat_settings: Ok(None),
                ignore_unavailable: Ok(None),
                include_defaults: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesGetIndex>,
        {
            self.index = value
                .try_into()
                .map_err(|_| "conversion to `IndicesGetIndex` for index failed".to_string());
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesGetClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesGetClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn flat_settings<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.flat_settings = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn include_defaults<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.include_defaults = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for include_defaults failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesGetMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesGetMasterTimeout` for master_timeout failed".to_string()
            });
            self
        }

        ///Sends a `GET` request to `/{index}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                allow_no_indices,
                cluster_manager_timeout,
                expand_wildcards,
                flat_settings,
                ignore_unavailable,
                include_defaults,
                local,
                master_timeout,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let include_defaults = include_defaults.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let url = format!("{}/{}", client.baseurl, encode_path(&index.to_string()),);
            let mut query = Vec::with_capacity(8usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &flat_settings {
                query.push(("flat_settings", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &include_defaults {
                query.push(("include_defaults", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_create`]
    ///
    ///[`Client::indices_create`]: super::Client::indices_create
    #[derive(Debug, Clone)]
    pub struct IndicesCreate<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesCreateIndex, String>,
        cluster_manager_timeout: Result<Option<types::IndicesCreateClusterManagerTimeout>, String>,
        master_timeout: Result<Option<types::IndicesCreateMasterTimeout>, String>,
        timeout: Result<Option<types::IndicesCreateTimeout>, String>,
        wait_for_active_shards: Result<Option<String>, String>,
        body: Result<types::builder::IndicesCreateBodyParams, String>,
    }

    impl<'a> IndicesCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
                wait_for_active_shards: Ok(None),
                body: Ok(types::builder::IndicesCreateBodyParams::default()),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesCreateIndex>,
        {
            self.index = value
                .try_into()
                .map_err(|_| "conversion to `IndicesCreateIndex` for index failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesCreateClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesCreateClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesCreateMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesCreateMasterTimeout` for master_timeout failed".to_string()
            });
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesCreateTimeout>,
        {
            self.timeout = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IndicesCreateTimeout` for timeout failed".to_string());
            self
        }

        pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.wait_for_active_shards = value.try_into().map(Some).map_err(|_| {
                "conversion to `String` for wait_for_active_shards failed".to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesCreateBodyParams>,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|_| "conversion to `IndicesCreateBodyParams` for body failed".to_string());
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::IndicesCreateBodyParams,
            ) -> types::builder::IndicesCreateBodyParams,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `PUT` request to `/{index}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::IndicesCreateResponseContent>, Error<()>> {
            let Self {
                client,
                index,
                cluster_manager_timeout,
                master_timeout,
                timeout,
                wait_for_active_shards,
                body,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(std::convert::TryInto::<types::IndicesCreateBodyParams>::try_into)
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/{}", client.baseurl, encode_path(&index.to_string()),);
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &wait_for_active_shards {
                query.push(("wait_for_active_shards", v.to_string()));
            }
            let request = client
                .client
                .put(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_delete`]
    ///
    ///[`Client::indices_delete`]: super::Client::indices_delete
    #[derive(Debug, Clone)]
    pub struct IndicesDelete<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesDeleteIndex, String>,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::IndicesDeleteMasterTimeout>, String>,
        timeout: Result<Option<types::IndicesDeleteTimeout>, String>,
    }

    impl<'a> IndicesDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                ignore_unavailable: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesDeleteIndex>,
        {
            self.index = value
                .try_into()
                .map_err(|_| "conversion to `IndicesDeleteIndex` for index failed".to_string());
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesDeleteMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesDeleteMasterTimeout` for master_timeout failed".to_string()
            });
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesDeleteTimeout>,
        {
            self.timeout = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IndicesDeleteTimeout` for timeout failed".to_string());
            self
        }

        ///Sends a `DELETE` request to `/{index}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::IndicesDeleteResponseContent>, Error<()>> {
            let Self {
                client,
                index,
                allow_no_indices,
                expand_wildcards,
                ignore_unavailable,
                master_timeout,
                timeout,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let url = format!("{}/{}", client.baseurl, encode_path(&index.to_string()),);
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client
                .client
                .delete(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_exists`]
    ///
    ///[`Client::indices_exists`]: super::Client::indices_exists
    #[derive(Debug, Clone)]
    pub struct IndicesExists<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesExistsIndex, String>,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        flat_settings: Result<Option<bool>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        include_defaults: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
    }

    impl<'a> IndicesExists<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                flat_settings: Ok(None),
                ignore_unavailable: Ok(None),
                include_defaults: Ok(None),
                local: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesExistsIndex>,
        {
            self.index = value
                .try_into()
                .map_err(|_| "conversion to `IndicesExistsIndex` for index failed".to_string());
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn flat_settings<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.flat_settings = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn include_defaults<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.include_defaults = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for include_defaults failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        ///Sends a `HEAD` request to `/{index}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                allow_no_indices,
                expand_wildcards,
                flat_settings,
                ignore_unavailable,
                include_defaults,
                local,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let include_defaults = include_defaults.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let url = format!("{}/{}", client.baseurl, encode_path(&index.to_string()),);
            let mut query = Vec::with_capacity(6usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &flat_settings {
                query.push(("flat_settings", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &include_defaults {
                query.push(("include_defaults", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            let request = client.client.head(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_get_alias_with_index`]
    ///
    ///[`Client::indices_get_alias_with_index`]: super::Client::indices_get_alias_with_index
    #[derive(Debug, Clone)]
    pub struct IndicesGetAliasWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesGetAliasWithIndexIndex, String>,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
    }

    impl<'a> IndicesGetAliasWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                ignore_unavailable: Ok(None),
                local: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesGetAliasWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `IndicesGetAliasWithIndexIndex` for index failed".to_string()
            });
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        ///Sends a `GET` request to `/{index}/_alias`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                allow_no_indices,
                expand_wildcards,
                ignore_unavailable,
                local,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_alias",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_get_alias_with_index_name`]
    ///
    ///[`Client::indices_get_alias_with_index_name`]: super::Client::indices_get_alias_with_index_name
    #[derive(Debug, Clone)]
    pub struct IndicesGetAliasWithIndexName<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesGetAliasWithIndexNameIndex, String>,
        name: Result<types::IndicesGetAliasWithIndexNameName, String>,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
    }

    impl<'a> IndicesGetAliasWithIndexName<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                name: Err("name was not initialized".to_string()),
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                ignore_unavailable: Ok(None),
                local: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesGetAliasWithIndexNameIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `IndicesGetAliasWithIndexNameIndex` for index failed".to_string()
            });
            self
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesGetAliasWithIndexNameName>,
        {
            self.name = value.try_into().map_err(|_| {
                "conversion to `IndicesGetAliasWithIndexNameName` for name failed".to_string()
            });
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        ///Sends a `GET` request to `/{index}/_alias/{name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                name,
                allow_no_indices,
                expand_wildcards,
                ignore_unavailable,
                local,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let name = name.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_alias/{}",
                client.baseurl,
                encode_path(&index.to_string()),
                encode_path(&name.to_string()),
            );
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_put_alias_put`]
    ///
    ///[`Client::indices_put_alias_put`]: super::Client::indices_put_alias_put
    #[derive(Debug, Clone)]
    pub struct IndicesPutAliasPut<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesPutAliasPutIndex, String>,
        name: Result<types::IndicesPutAliasPutName, String>,
        cluster_manager_timeout:
            Result<Option<types::IndicesPutAliasPutClusterManagerTimeout>, String>,
        master_timeout: Result<Option<types::IndicesPutAliasPutMasterTimeout>, String>,
        timeout: Result<Option<types::IndicesPutAliasPutTimeout>, String>,
        body: Result<types::IndicesPutAliasBodyParams, String>,
    }

    impl<'a> IndicesPutAliasPut<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                name: Err("name was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutAliasPutIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `IndicesPutAliasPutIndex` for index failed".to_string()
            });
            self
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutAliasPutName>,
        {
            self.name = value
                .try_into()
                .map_err(|_| "conversion to `IndicesPutAliasPutName` for name failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutAliasPutClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesPutAliasPutClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutAliasPutMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesPutAliasPutMasterTimeout` for master_timeout failed"
                    .to_string()
            });
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutAliasPutTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesPutAliasPutTimeout` for timeout failed".to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutAliasBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `IndicesPutAliasBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `PUT` request to `/{index}/_alias/{name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                name,
                cluster_manager_timeout,
                master_timeout,
                timeout,
                body,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let name = name.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_alias/{}",
                client.baseurl,
                encode_path(&index.to_string()),
                encode_path(&name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client.client.put(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_put_alias_post`]
    ///
    ///[`Client::indices_put_alias_post`]: super::Client::indices_put_alias_post
    #[derive(Debug, Clone)]
    pub struct IndicesPutAliasPost<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesPutAliasPostIndex, String>,
        name: Result<types::IndicesPutAliasPostName, String>,
        cluster_manager_timeout:
            Result<Option<types::IndicesPutAliasPostClusterManagerTimeout>, String>,
        master_timeout: Result<Option<types::IndicesPutAliasPostMasterTimeout>, String>,
        timeout: Result<Option<types::IndicesPutAliasPostTimeout>, String>,
        body: Result<types::IndicesPutAliasBodyParams, String>,
    }

    impl<'a> IndicesPutAliasPost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                name: Err("name was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutAliasPostIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `IndicesPutAliasPostIndex` for index failed".to_string()
            });
            self
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutAliasPostName>,
        {
            self.name = value
                .try_into()
                .map_err(|_| "conversion to `IndicesPutAliasPostName` for name failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutAliasPostClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesPutAliasPostClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutAliasPostMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesPutAliasPostMasterTimeout` for master_timeout failed"
                    .to_string()
            });
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutAliasPostTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesPutAliasPostTimeout` for timeout failed".to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutAliasBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `IndicesPutAliasBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `POST` request to `/{index}/_alias/{name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                name,
                cluster_manager_timeout,
                master_timeout,
                timeout,
                body,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let name = name.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_alias/{}",
                client.baseurl,
                encode_path(&index.to_string()),
                encode_path(&name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_delete_alias`]
    ///
    ///[`Client::indices_delete_alias`]: super::Client::indices_delete_alias
    #[derive(Debug, Clone)]
    pub struct IndicesDeleteAlias<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesDeleteAliasIndex, String>,
        name: Result<types::IndicesDeleteAliasName, String>,
        cluster_manager_timeout:
            Result<Option<types::IndicesDeleteAliasClusterManagerTimeout>, String>,
        master_timeout: Result<Option<types::IndicesDeleteAliasMasterTimeout>, String>,
        timeout: Result<Option<types::IndicesDeleteAliasTimeout>, String>,
    }

    impl<'a> IndicesDeleteAlias<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                name: Err("name was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesDeleteAliasIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `IndicesDeleteAliasIndex` for index failed".to_string()
            });
            self
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesDeleteAliasName>,
        {
            self.name = value
                .try_into()
                .map_err(|_| "conversion to `IndicesDeleteAliasName` for name failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesDeleteAliasClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesDeleteAliasClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesDeleteAliasMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesDeleteAliasMasterTimeout` for master_timeout failed"
                    .to_string()
            });
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesDeleteAliasTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesDeleteAliasTimeout` for timeout failed".to_string()
            });
            self
        }

        ///Sends a `DELETE` request to `/{index}/_alias/{name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                name,
                cluster_manager_timeout,
                master_timeout,
                timeout,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let name = name.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_alias/{}",
                client.baseurl,
                encode_path(&index.to_string()),
                encode_path(&name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client.client.delete(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_exists_alias_with_index`]
    ///
    ///[`Client::indices_exists_alias_with_index`]: super::Client::indices_exists_alias_with_index
    #[derive(Debug, Clone)]
    pub struct IndicesExistsAliasWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesExistsAliasWithIndexIndex, String>,
        name: Result<types::IndicesExistsAliasWithIndexName, String>,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
    }

    impl<'a> IndicesExistsAliasWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                name: Err("name was not initialized".to_string()),
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                ignore_unavailable: Ok(None),
                local: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesExistsAliasWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `IndicesExistsAliasWithIndexIndex` for index failed".to_string()
            });
            self
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesExistsAliasWithIndexName>,
        {
            self.name = value.try_into().map_err(|_| {
                "conversion to `IndicesExistsAliasWithIndexName` for name failed".to_string()
            });
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        ///Sends a `HEAD` request to `/{index}/_alias/{name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                name,
                allow_no_indices,
                expand_wildcards,
                ignore_unavailable,
                local,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let name = name.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_alias/{}",
                client.baseurl,
                encode_path(&index.to_string()),
                encode_path(&name.to_string()),
            );
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            let request = client.client.head(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_put_alias_put_plural`]
    ///
    ///[`Client::indices_put_alias_put_plural`]: super::Client::indices_put_alias_put_plural
    #[derive(Debug, Clone)]
    pub struct IndicesPutAliasPutPlural<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesPutAliasPutPluralIndex, String>,
        name: Result<types::IndicesPutAliasPutPluralName, String>,
        cluster_manager_timeout:
            Result<Option<types::IndicesPutAliasPutPluralClusterManagerTimeout>, String>,
        master_timeout: Result<Option<types::IndicesPutAliasPutPluralMasterTimeout>, String>,
        timeout: Result<Option<types::IndicesPutAliasPutPluralTimeout>, String>,
        body: Result<types::IndicesPutAliasBodyParams, String>,
    }

    impl<'a> IndicesPutAliasPutPlural<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                name: Err("name was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutAliasPutPluralIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `IndicesPutAliasPutPluralIndex` for index failed".to_string()
            });
            self
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutAliasPutPluralName>,
        {
            self.name = value.try_into().map_err(|_| {
                "conversion to `IndicesPutAliasPutPluralName` for name failed".to_string()
            });
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutAliasPutPluralClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesPutAliasPutPluralClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutAliasPutPluralMasterTimeout>,
        {
            self . master_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesPutAliasPutPluralMasterTimeout` for master_timeout failed" . to_string ()) ;
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutAliasPutPluralTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesPutAliasPutPluralTimeout` for timeout failed".to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutAliasBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `IndicesPutAliasBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `PUT` request to `/{index}/_aliases/{name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                name,
                cluster_manager_timeout,
                master_timeout,
                timeout,
                body,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let name = name.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_aliases/{}",
                client.baseurl,
                encode_path(&index.to_string()),
                encode_path(&name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client.client.put(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_put_alias_post_plural`]
    ///
    ///[`Client::indices_put_alias_post_plural`]: super::Client::indices_put_alias_post_plural
    #[derive(Debug, Clone)]
    pub struct IndicesPutAliasPostPlural<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesPutAliasPostPluralIndex, String>,
        name: Result<types::IndicesPutAliasPostPluralName, String>,
        cluster_manager_timeout:
            Result<Option<types::IndicesPutAliasPostPluralClusterManagerTimeout>, String>,
        master_timeout: Result<Option<types::IndicesPutAliasPostPluralMasterTimeout>, String>,
        timeout: Result<Option<types::IndicesPutAliasPostPluralTimeout>, String>,
        body: Result<types::IndicesPutAliasBodyParams, String>,
    }

    impl<'a> IndicesPutAliasPostPlural<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                name: Err("name was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutAliasPostPluralIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `IndicesPutAliasPostPluralIndex` for index failed".to_string()
            });
            self
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutAliasPostPluralName>,
        {
            self.name = value.try_into().map_err(|_| {
                "conversion to `IndicesPutAliasPostPluralName` for name failed".to_string()
            });
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutAliasPostPluralClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesPutAliasPostPluralClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutAliasPostPluralMasterTimeout>,
        {
            self . master_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesPutAliasPostPluralMasterTimeout` for master_timeout failed" . to_string ()) ;
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutAliasPostPluralTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesPutAliasPostPluralTimeout` for timeout failed".to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutAliasBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `IndicesPutAliasBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `POST` request to `/{index}/_aliases/{name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                name,
                cluster_manager_timeout,
                master_timeout,
                timeout,
                body,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let name = name.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_aliases/{}",
                client.baseurl,
                encode_path(&index.to_string()),
                encode_path(&name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_delete_alias_plural`]
    ///
    ///[`Client::indices_delete_alias_plural`]: super::Client::indices_delete_alias_plural
    #[derive(Debug, Clone)]
    pub struct IndicesDeleteAliasPlural<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesDeleteAliasPluralIndex, String>,
        name: Result<types::IndicesDeleteAliasPluralName, String>,
        cluster_manager_timeout:
            Result<Option<types::IndicesDeleteAliasPluralClusterManagerTimeout>, String>,
        master_timeout: Result<Option<types::IndicesDeleteAliasPluralMasterTimeout>, String>,
        timeout: Result<Option<types::IndicesDeleteAliasPluralTimeout>, String>,
    }

    impl<'a> IndicesDeleteAliasPlural<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                name: Err("name was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesDeleteAliasPluralIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `IndicesDeleteAliasPluralIndex` for index failed".to_string()
            });
            self
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesDeleteAliasPluralName>,
        {
            self.name = value.try_into().map_err(|_| {
                "conversion to `IndicesDeleteAliasPluralName` for name failed".to_string()
            });
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesDeleteAliasPluralClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesDeleteAliasPluralClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesDeleteAliasPluralMasterTimeout>,
        {
            self . master_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesDeleteAliasPluralMasterTimeout` for master_timeout failed" . to_string ()) ;
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesDeleteAliasPluralTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesDeleteAliasPluralTimeout` for timeout failed".to_string()
            });
            self
        }

        ///Sends a `DELETE` request to `/{index}/_aliases/{name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                name,
                cluster_manager_timeout,
                master_timeout,
                timeout,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let name = name.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_aliases/{}",
                client.baseurl,
                encode_path(&index.to_string()),
                encode_path(&name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client.client.delete(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_analyze_get_with_index`]
    ///
    ///[`Client::indices_analyze_get_with_index`]: super::Client::indices_analyze_get_with_index
    #[derive(Debug, Clone)]
    pub struct IndicesAnalyzeGetWithIndex<'a> {
        client: &'a super::Client,
        index: Result<Option<String>, String>,
    }

    impl<'a> IndicesAnalyzeGetWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.index = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for index failed".to_string());
            self
        }

        ///Sends a `GET` request to `/{index}/_analyze`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self { client, index } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_analyze",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(1usize);
            if let Some(v) = &index {
                query.push(("index", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_analyze_post_with_index`]
    ///
    ///[`Client::indices_analyze_post_with_index`]: super::Client::indices_analyze_post_with_index
    #[derive(Debug, Clone)]
    pub struct IndicesAnalyzePostWithIndex<'a> {
        client: &'a super::Client,
        index: Result<Option<String>, String>,
        body: Result<types::IndicesAnalyzeBodyParams, String>,
    }

    impl<'a> IndicesAnalyzePostWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.index = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for index failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesAnalyzeBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `IndicesAnalyzeBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `POST` request to `/{index}/_analyze`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                body,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_analyze",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(1usize);
            if let Some(v) = &index {
                query.push(("index", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_add_block`]
    ///
    ///[`Client::indices_add_block`]: super::Client::indices_add_block
    #[derive(Debug, Clone)]
    pub struct IndicesAddBlock<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesAddBlockIndex, String>,
        block: Result<types::IndicesAddBlockBlock, String>,
        allow_no_indices: Result<Option<bool>, String>,
        cluster_manager_timeout:
            Result<Option<types::IndicesAddBlockClusterManagerTimeout>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::IndicesAddBlockMasterTimeout>, String>,
        timeout: Result<Option<types::IndicesAddBlockTimeout>, String>,
    }

    impl<'a> IndicesAddBlock<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                block: Err("block was not initialized".to_string()),
                allow_no_indices: Ok(None),
                cluster_manager_timeout: Ok(None),
                expand_wildcards: Ok(None),
                ignore_unavailable: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesAddBlockIndex>,
        {
            self.index = value
                .try_into()
                .map_err(|_| "conversion to `IndicesAddBlockIndex` for index failed".to_string());
            self
        }

        pub fn block<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesAddBlockBlock>,
        {
            self.block = value
                .try_into()
                .map_err(|_| "conversion to `IndicesAddBlockBlock` for block failed".to_string());
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesAddBlockClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesAddBlockClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesAddBlockMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesAddBlockMasterTimeout` for master_timeout failed".to_string()
            });
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesAddBlockTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesAddBlockTimeout` for timeout failed".to_string()
            });
            self
        }

        ///Sends a `PUT` request to `/{index}/_block/{block}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                block,
                allow_no_indices,
                cluster_manager_timeout,
                expand_wildcards,
                ignore_unavailable,
                master_timeout,
                timeout,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let block = block.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_block/{}",
                client.baseurl,
                encode_path(&index.to_string()),
                encode_path(&block.to_string()),
            );
            let mut query = Vec::with_capacity(6usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client.client.put(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::bulk_put_with_index`]
    ///
    ///[`Client::bulk_put_with_index`]: super::Client::bulk_put_with_index
    #[derive(Debug, Clone)]
    pub struct BulkPutWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::BulkPutWithIndexIndex, String>,
        source: Result<Option<Vec<String>>, String>,
        source_excludes: Result<Option<Vec<String>>, String>,
        source_includes: Result<Option<Vec<String>>, String>,
        pipeline: Result<Option<String>, String>,
        refresh: Result<Option<types::RefreshEnum>, String>,
        require_alias: Result<Option<bool>, String>,
        routing: Result<Option<String>, String>,
        timeout: Result<Option<types::BulkPutWithIndexTimeout>, String>,
        type_: Result<Option<String>, String>,
        wait_for_active_shards: Result<Option<String>, String>,
        body: Result<types::BulkBodyParams, String>,
    }

    impl<'a> BulkPutWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                source: Ok(None),
                source_excludes: Ok(None),
                source_includes: Ok(None),
                pipeline: Ok(None),
                refresh: Ok(None),
                require_alias: Ok(None),
                routing: Ok(None),
                timeout: Ok(None),
                type_: Ok(None),
                wait_for_active_shards: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::BulkPutWithIndexIndex>,
        {
            self.index = value
                .try_into()
                .map_err(|_| "conversion to `BulkPutWithIndexIndex` for index failed".to_string());
            self
        }

        pub fn source<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for source failed".to_string());
            self
        }

        pub fn source_excludes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_excludes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_excludes failed".to_string()
            });
            self
        }

        pub fn source_includes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_includes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_includes failed".to_string()
            });
            self
        }

        pub fn pipeline<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.pipeline = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for pipeline failed".to_string());
            self
        }

        pub fn refresh<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RefreshEnum>,
        {
            self.refresh = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `RefreshEnum` for refresh failed".to_string());
            self
        }

        pub fn require_alias<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.require_alias = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for require_alias failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for routing failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::BulkPutWithIndexTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `BulkPutWithIndexTimeout` for timeout failed".to_string()
            });
            self
        }

        pub fn type_<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.type_ = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for type_ failed".to_string());
            self
        }

        pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.wait_for_active_shards = value.try_into().map(Some).map_err(|_| {
                "conversion to `String` for wait_for_active_shards failed".to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::BulkBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `BulkBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `PUT` request to `/{index}/_bulk`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                source,
                source_excludes,
                source_includes,
                pipeline,
                refresh,
                require_alias,
                routing,
                timeout,
                type_,
                wait_for_active_shards,
                body,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let source = source.map_err(Error::InvalidRequest)?;
            let source_excludes = source_excludes.map_err(Error::InvalidRequest)?;
            let source_includes = source_includes.map_err(Error::InvalidRequest)?;
            let pipeline = pipeline.map_err(Error::InvalidRequest)?;
            let refresh = refresh.map_err(Error::InvalidRequest)?;
            let require_alias = require_alias.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let type_ = type_.map_err(Error::InvalidRequest)?;
            let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_bulk",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(10usize);
            if let Some(v) = &source {
                query.push(("_source", v.to_string()));
            }
            if let Some(v) = &source_excludes {
                query.push(("_source_excludes", v.to_string()));
            }
            if let Some(v) = &source_includes {
                query.push(("_source_includes", v.to_string()));
            }
            if let Some(v) = &pipeline {
                query.push(("pipeline", v.to_string()));
            }
            if let Some(v) = &refresh {
                query.push(("refresh", v.to_string()));
            }
            if let Some(v) = &require_alias {
                query.push(("require_alias", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &type_ {
                query.push(("type", v.to_string()));
            }
            if let Some(v) = &wait_for_active_shards {
                query.push(("wait_for_active_shards", v.to_string()));
            }
            let request = client.client.put(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::bulk_post_with_index`]
    ///
    ///[`Client::bulk_post_with_index`]: super::Client::bulk_post_with_index
    #[derive(Debug, Clone)]
    pub struct BulkPostWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::BulkPostWithIndexIndex, String>,
        source: Result<Option<Vec<String>>, String>,
        source_excludes: Result<Option<Vec<String>>, String>,
        source_includes: Result<Option<Vec<String>>, String>,
        pipeline: Result<Option<String>, String>,
        refresh: Result<Option<types::RefreshEnum>, String>,
        require_alias: Result<Option<bool>, String>,
        routing: Result<Option<String>, String>,
        timeout: Result<Option<types::BulkPostWithIndexTimeout>, String>,
        type_: Result<Option<String>, String>,
        wait_for_active_shards: Result<Option<String>, String>,
        body: Result<types::BulkBodyParams, String>,
    }

    impl<'a> BulkPostWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                source: Ok(None),
                source_excludes: Ok(None),
                source_includes: Ok(None),
                pipeline: Ok(None),
                refresh: Ok(None),
                require_alias: Ok(None),
                routing: Ok(None),
                timeout: Ok(None),
                type_: Ok(None),
                wait_for_active_shards: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::BulkPostWithIndexIndex>,
        {
            self.index = value
                .try_into()
                .map_err(|_| "conversion to `BulkPostWithIndexIndex` for index failed".to_string());
            self
        }

        pub fn source<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for source failed".to_string());
            self
        }

        pub fn source_excludes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_excludes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_excludes failed".to_string()
            });
            self
        }

        pub fn source_includes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_includes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_includes failed".to_string()
            });
            self
        }

        pub fn pipeline<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.pipeline = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for pipeline failed".to_string());
            self
        }

        pub fn refresh<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RefreshEnum>,
        {
            self.refresh = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `RefreshEnum` for refresh failed".to_string());
            self
        }

        pub fn require_alias<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.require_alias = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for require_alias failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for routing failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::BulkPostWithIndexTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `BulkPostWithIndexTimeout` for timeout failed".to_string()
            });
            self
        }

        pub fn type_<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.type_ = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for type_ failed".to_string());
            self
        }

        pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.wait_for_active_shards = value.try_into().map(Some).map_err(|_| {
                "conversion to `String` for wait_for_active_shards failed".to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::BulkBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `BulkBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `POST` request to `/{index}/_bulk`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                source,
                source_excludes,
                source_includes,
                pipeline,
                refresh,
                require_alias,
                routing,
                timeout,
                type_,
                wait_for_active_shards,
                body,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let source = source.map_err(Error::InvalidRequest)?;
            let source_excludes = source_excludes.map_err(Error::InvalidRequest)?;
            let source_includes = source_includes.map_err(Error::InvalidRequest)?;
            let pipeline = pipeline.map_err(Error::InvalidRequest)?;
            let refresh = refresh.map_err(Error::InvalidRequest)?;
            let require_alias = require_alias.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let type_ = type_.map_err(Error::InvalidRequest)?;
            let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_bulk",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(10usize);
            if let Some(v) = &source {
                query.push(("_source", v.to_string()));
            }
            if let Some(v) = &source_excludes {
                query.push(("_source_excludes", v.to_string()));
            }
            if let Some(v) = &source_includes {
                query.push(("_source_includes", v.to_string()));
            }
            if let Some(v) = &pipeline {
                query.push(("pipeline", v.to_string()));
            }
            if let Some(v) = &refresh {
                query.push(("refresh", v.to_string()));
            }
            if let Some(v) = &require_alias {
                query.push(("require_alias", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &type_ {
                query.push(("type", v.to_string()));
            }
            if let Some(v) = &wait_for_active_shards {
                query.push(("wait_for_active_shards", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_clear_cache_with_index`]
    ///
    ///[`Client::indices_clear_cache_with_index`]: super::Client::indices_clear_cache_with_index
    #[derive(Debug, Clone)]
    pub struct IndicesClearCacheWithIndex<'a> {
        client: &'a super::Client,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        fielddata: Result<Option<bool>, String>,
        fields: Result<Option<Vec<String>>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        index: Result<Option<Vec<String>>, String>,
        query: Result<Option<bool>, String>,
        request: Result<Option<bool>, String>,
    }

    impl<'a> IndicesClearCacheWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                fielddata: Ok(None),
                fields: Ok(None),
                ignore_unavailable: Ok(None),
                index: Ok(None),
                query: Ok(None),
                request: Ok(None),
            }
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn fielddata<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.fielddata = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for fielddata failed".to_string());
            self
        }

        pub fn fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.fields = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.index = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for index failed".to_string());
            self
        }

        pub fn query<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.query = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for query failed".to_string());
            self
        }

        pub fn request<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.request = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for request failed".to_string());
            self
        }

        ///Sends a `POST` request to `/{index}/_cache/clear`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                allow_no_indices,
                expand_wildcards,
                fielddata,
                fields,
                ignore_unavailable,
                index,
                query,
                request,
            } = self;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let fielddata = fielddata.map_err(Error::InvalidRequest)?;
            let fields = fields.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let index = index.map_err(Error::InvalidRequest)?;
            let query = query.map_err(Error::InvalidRequest)?;
            let request = request.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_cache/clear",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(8usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &fielddata {
                query.push(("fielddata", v.to_string()));
            }
            if let Some(v) = &fields {
                query.push(("fields", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &index {
                query.push(("index", v.to_string()));
            }
            if let Some(v) = &query {
                query.push(("query", v.to_string()));
            }
            if let Some(v) = &request {
                query.push(("request", v.to_string()));
            }
            let request = client.client.post(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_clone_put`]
    ///
    ///[`Client::indices_clone_put`]: super::Client::indices_clone_put
    #[derive(Debug, Clone)]
    pub struct IndicesClonePut<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesClonePutIndex, String>,
        target: Result<types::IndicesClonePutTarget, String>,
        cluster_manager_timeout:
            Result<Option<types::IndicesClonePutClusterManagerTimeout>, String>,
        master_timeout: Result<Option<types::IndicesClonePutMasterTimeout>, String>,
        timeout: Result<Option<types::IndicesClonePutTimeout>, String>,
        wait_for_active_shards: Result<Option<String>, String>,
        body: Result<types::IndicesCloneBodyParams, String>,
    }

    impl<'a> IndicesClonePut<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                target: Err("target was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
                wait_for_active_shards: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesClonePutIndex>,
        {
            self.index = value
                .try_into()
                .map_err(|_| "conversion to `IndicesClonePutIndex` for index failed".to_string());
            self
        }

        pub fn target<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesClonePutTarget>,
        {
            self.target = value
                .try_into()
                .map_err(|_| "conversion to `IndicesClonePutTarget` for target failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesClonePutClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesClonePutClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesClonePutMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesClonePutMasterTimeout` for master_timeout failed".to_string()
            });
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesClonePutTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesClonePutTimeout` for timeout failed".to_string()
            });
            self
        }

        pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.wait_for_active_shards = value.try_into().map(Some).map_err(|_| {
                "conversion to `String` for wait_for_active_shards failed".to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesCloneBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `IndicesCloneBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `PUT` request to `/{index}/_clone/{target}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                target,
                cluster_manager_timeout,
                master_timeout,
                timeout,
                wait_for_active_shards,
                body,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let target = target.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_clone/{}",
                client.baseurl,
                encode_path(&index.to_string()),
                encode_path(&target.to_string()),
            );
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &wait_for_active_shards {
                query.push(("wait_for_active_shards", v.to_string()));
            }
            let request = client.client.put(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_clone_post`]
    ///
    ///[`Client::indices_clone_post`]: super::Client::indices_clone_post
    #[derive(Debug, Clone)]
    pub struct IndicesClonePost<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesClonePostIndex, String>,
        target: Result<types::IndicesClonePostTarget, String>,
        cluster_manager_timeout:
            Result<Option<types::IndicesClonePostClusterManagerTimeout>, String>,
        master_timeout: Result<Option<types::IndicesClonePostMasterTimeout>, String>,
        timeout: Result<Option<types::IndicesClonePostTimeout>, String>,
        wait_for_active_shards: Result<Option<String>, String>,
        body: Result<types::IndicesCloneBodyParams, String>,
    }

    impl<'a> IndicesClonePost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                target: Err("target was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
                wait_for_active_shards: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesClonePostIndex>,
        {
            self.index = value
                .try_into()
                .map_err(|_| "conversion to `IndicesClonePostIndex` for index failed".to_string());
            self
        }

        pub fn target<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesClonePostTarget>,
        {
            self.target = value.try_into().map_err(|_| {
                "conversion to `IndicesClonePostTarget` for target failed".to_string()
            });
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesClonePostClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesClonePostClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesClonePostMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesClonePostMasterTimeout` for master_timeout failed"
                    .to_string()
            });
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesClonePostTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesClonePostTimeout` for timeout failed".to_string()
            });
            self
        }

        pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.wait_for_active_shards = value.try_into().map(Some).map_err(|_| {
                "conversion to `String` for wait_for_active_shards failed".to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesCloneBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `IndicesCloneBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `POST` request to `/{index}/_clone/{target}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                target,
                cluster_manager_timeout,
                master_timeout,
                timeout,
                wait_for_active_shards,
                body,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let target = target.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_clone/{}",
                client.baseurl,
                encode_path(&index.to_string()),
                encode_path(&target.to_string()),
            );
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &wait_for_active_shards {
                query.push(("wait_for_active_shards", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_close`]
    ///
    ///[`Client::indices_close`]: super::Client::indices_close
    #[derive(Debug, Clone)]
    pub struct IndicesClose<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesCloseIndex, String>,
        allow_no_indices: Result<Option<bool>, String>,
        cluster_manager_timeout: Result<Option<types::IndicesCloseClusterManagerTimeout>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::IndicesCloseMasterTimeout>, String>,
        timeout: Result<Option<types::IndicesCloseTimeout>, String>,
        wait_for_active_shards: Result<Option<String>, String>,
    }

    impl<'a> IndicesClose<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                allow_no_indices: Ok(None),
                cluster_manager_timeout: Ok(None),
                expand_wildcards: Ok(None),
                ignore_unavailable: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
                wait_for_active_shards: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesCloseIndex>,
        {
            self.index = value
                .try_into()
                .map_err(|_| "conversion to `IndicesCloseIndex` for index failed".to_string());
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesCloseClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesCloseClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesCloseMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesCloseMasterTimeout` for master_timeout failed".to_string()
            });
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesCloseTimeout>,
        {
            self.timeout = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IndicesCloseTimeout` for timeout failed".to_string());
            self
        }

        pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.wait_for_active_shards = value.try_into().map(Some).map_err(|_| {
                "conversion to `String` for wait_for_active_shards failed".to_string()
            });
            self
        }

        ///Sends a `POST` request to `/{index}/_close`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                allow_no_indices,
                cluster_manager_timeout,
                expand_wildcards,
                ignore_unavailable,
                master_timeout,
                timeout,
                wait_for_active_shards,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_close",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(7usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &wait_for_active_shards {
                query.push(("wait_for_active_shards", v.to_string()));
            }
            let request = client.client.post(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::count_get_with_index`]
    ///
    ///[`Client::count_get_with_index`]: super::Client::count_get_with_index
    #[derive(Debug, Clone)]
    pub struct CountGetWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::CountGetWithIndexIndex, String>,
        allow_no_indices: Result<Option<bool>, String>,
        analyze_wildcard: Result<Option<bool>, String>,
        analyzer: Result<Option<String>, String>,
        default_operator: Result<Option<types::DefaultOperator>, String>,
        df: Result<Option<String>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_throttled: Result<Option<bool>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        lenient: Result<Option<bool>, String>,
        min_score: Result<Option<i32>, String>,
        preference: Result<Option<String>, String>,
        q: Result<Option<String>, String>,
        routing: Result<Option<Vec<String>>, String>,
        terminate_after: Result<Option<i32>, String>,
    }

    impl<'a> CountGetWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                allow_no_indices: Ok(None),
                analyze_wildcard: Ok(None),
                analyzer: Ok(None),
                default_operator: Ok(None),
                df: Ok(None),
                expand_wildcards: Ok(None),
                ignore_throttled: Ok(None),
                ignore_unavailable: Ok(None),
                lenient: Ok(None),
                min_score: Ok(None),
                preference: Ok(None),
                q: Ok(None),
                routing: Ok(None),
                terminate_after: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CountGetWithIndexIndex>,
        {
            self.index = value
                .try_into()
                .map_err(|_| "conversion to `CountGetWithIndexIndex` for index failed".to_string());
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn analyze_wildcard<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.analyze_wildcard = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for analyze_wildcard failed".to_string());
            self
        }

        pub fn analyzer<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.analyzer = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for analyzer failed".to_string());
            self
        }

        pub fn default_operator<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DefaultOperator>,
        {
            self.default_operator = value.try_into().map(Some).map_err(|_| {
                "conversion to `DefaultOperator` for default_operator failed".to_string()
            });
            self
        }

        pub fn df<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.df = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for df failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_throttled<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_throttled = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_throttled failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn lenient<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.lenient = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for lenient failed".to_string());
            self
        }

        pub fn min_score<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.min_score = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for min_score failed".to_string());
            self
        }

        pub fn preference<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.preference = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for preference failed".to_string());
            self
        }

        pub fn q<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.q = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for q failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for routing failed".to_string());
            self
        }

        pub fn terminate_after<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.terminate_after = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for terminate_after failed".to_string());
            self
        }

        ///Sends a `GET` request to `/{index}/_count`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                allow_no_indices,
                analyze_wildcard,
                analyzer,
                default_operator,
                df,
                expand_wildcards,
                ignore_throttled,
                ignore_unavailable,
                lenient,
                min_score,
                preference,
                q,
                routing,
                terminate_after,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let analyze_wildcard = analyze_wildcard.map_err(Error::InvalidRequest)?;
            let analyzer = analyzer.map_err(Error::InvalidRequest)?;
            let default_operator = default_operator.map_err(Error::InvalidRequest)?;
            let df = df.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_throttled = ignore_throttled.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let lenient = lenient.map_err(Error::InvalidRequest)?;
            let min_score = min_score.map_err(Error::InvalidRequest)?;
            let preference = preference.map_err(Error::InvalidRequest)?;
            let q = q.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let terminate_after = terminate_after.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_count",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(14usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &analyze_wildcard {
                query.push(("analyze_wildcard", v.to_string()));
            }
            if let Some(v) = &analyzer {
                query.push(("analyzer", v.to_string()));
            }
            if let Some(v) = &default_operator {
                query.push(("default_operator", v.to_string()));
            }
            if let Some(v) = &df {
                query.push(("df", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_throttled {
                query.push(("ignore_throttled", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &lenient {
                query.push(("lenient", v.to_string()));
            }
            if let Some(v) = &min_score {
                query.push(("min_score", v.to_string()));
            }
            if let Some(v) = &preference {
                query.push(("preference", v.to_string()));
            }
            if let Some(v) = &q {
                query.push(("q", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &terminate_after {
                query.push(("terminate_after", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::count_post_with_index`]
    ///
    ///[`Client::count_post_with_index`]: super::Client::count_post_with_index
    #[derive(Debug, Clone)]
    pub struct CountPostWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::CountPostWithIndexIndex, String>,
        allow_no_indices: Result<Option<bool>, String>,
        analyze_wildcard: Result<Option<bool>, String>,
        analyzer: Result<Option<String>, String>,
        default_operator: Result<Option<types::DefaultOperator>, String>,
        df: Result<Option<String>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_throttled: Result<Option<bool>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        lenient: Result<Option<bool>, String>,
        min_score: Result<Option<i32>, String>,
        preference: Result<Option<String>, String>,
        q: Result<Option<String>, String>,
        routing: Result<Option<Vec<String>>, String>,
        terminate_after: Result<Option<i32>, String>,
        body: Result<types::CountBodyParams, String>,
    }

    impl<'a> CountPostWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                allow_no_indices: Ok(None),
                analyze_wildcard: Ok(None),
                analyzer: Ok(None),
                default_operator: Ok(None),
                df: Ok(None),
                expand_wildcards: Ok(None),
                ignore_throttled: Ok(None),
                ignore_unavailable: Ok(None),
                lenient: Ok(None),
                min_score: Ok(None),
                preference: Ok(None),
                q: Ok(None),
                routing: Ok(None),
                terminate_after: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CountPostWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `CountPostWithIndexIndex` for index failed".to_string()
            });
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn analyze_wildcard<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.analyze_wildcard = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for analyze_wildcard failed".to_string());
            self
        }

        pub fn analyzer<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.analyzer = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for analyzer failed".to_string());
            self
        }

        pub fn default_operator<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DefaultOperator>,
        {
            self.default_operator = value.try_into().map(Some).map_err(|_| {
                "conversion to `DefaultOperator` for default_operator failed".to_string()
            });
            self
        }

        pub fn df<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.df = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for df failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_throttled<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_throttled = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_throttled failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn lenient<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.lenient = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for lenient failed".to_string());
            self
        }

        pub fn min_score<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.min_score = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for min_score failed".to_string());
            self
        }

        pub fn preference<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.preference = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for preference failed".to_string());
            self
        }

        pub fn q<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.q = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for q failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for routing failed".to_string());
            self
        }

        pub fn terminate_after<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.terminate_after = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for terminate_after failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CountBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `CountBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `POST` request to `/{index}/_count`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                allow_no_indices,
                analyze_wildcard,
                analyzer,
                default_operator,
                df,
                expand_wildcards,
                ignore_throttled,
                ignore_unavailable,
                lenient,
                min_score,
                preference,
                q,
                routing,
                terminate_after,
                body,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let analyze_wildcard = analyze_wildcard.map_err(Error::InvalidRequest)?;
            let analyzer = analyzer.map_err(Error::InvalidRequest)?;
            let default_operator = default_operator.map_err(Error::InvalidRequest)?;
            let df = df.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_throttled = ignore_throttled.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let lenient = lenient.map_err(Error::InvalidRequest)?;
            let min_score = min_score.map_err(Error::InvalidRequest)?;
            let preference = preference.map_err(Error::InvalidRequest)?;
            let q = q.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let terminate_after = terminate_after.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_count",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(14usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &analyze_wildcard {
                query.push(("analyze_wildcard", v.to_string()));
            }
            if let Some(v) = &analyzer {
                query.push(("analyzer", v.to_string()));
            }
            if let Some(v) = &default_operator {
                query.push(("default_operator", v.to_string()));
            }
            if let Some(v) = &df {
                query.push(("df", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_throttled {
                query.push(("ignore_throttled", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &lenient {
                query.push(("lenient", v.to_string()));
            }
            if let Some(v) = &min_score {
                query.push(("min_score", v.to_string()));
            }
            if let Some(v) = &preference {
                query.push(("preference", v.to_string()));
            }
            if let Some(v) = &q {
                query.push(("q", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &terminate_after {
                query.push(("terminate_after", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::create_put`]
    ///
    ///[`Client::create_put`]: super::Client::create_put
    #[derive(Debug, Clone)]
    pub struct CreatePut<'a> {
        client: &'a super::Client,
        index: Result<types::CreatePutIndex, String>,
        id: Result<types::CreatePutId, String>,
        pipeline: Result<Option<String>, String>,
        refresh: Result<Option<types::RefreshEnum>, String>,
        routing: Result<Option<String>, String>,
        timeout: Result<Option<types::CreatePutTimeout>, String>,
        version: Result<Option<i32>, String>,
        version_type: Result<Option<types::VersionType>, String>,
        wait_for_active_shards: Result<Option<String>, String>,
        body: Result<types::CreateBodyParams, String>,
    }

    impl<'a> CreatePut<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                id: Err("id was not initialized".to_string()),
                pipeline: Ok(None),
                refresh: Ok(None),
                routing: Ok(None),
                timeout: Ok(None),
                version: Ok(None),
                version_type: Ok(None),
                wait_for_active_shards: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreatePutIndex>,
        {
            self.index = value
                .try_into()
                .map_err(|_| "conversion to `CreatePutIndex` for index failed".to_string());
            self
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreatePutId>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `CreatePutId` for id failed".to_string());
            self
        }

        pub fn pipeline<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.pipeline = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for pipeline failed".to_string());
            self
        }

        pub fn refresh<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RefreshEnum>,
        {
            self.refresh = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `RefreshEnum` for refresh failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for routing failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreatePutTimeout>,
        {
            self.timeout = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `CreatePutTimeout` for timeout failed".to_string());
            self
        }

        pub fn version<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.version = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for version failed".to_string());
            self
        }

        pub fn version_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VersionType>,
        {
            self.version_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `VersionType` for version_type failed".to_string());
            self
        }

        pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.wait_for_active_shards = value.try_into().map(Some).map_err(|_| {
                "conversion to `String` for wait_for_active_shards failed".to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `CreateBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `PUT` request to `/{index}/_create/{id}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                id,
                pipeline,
                refresh,
                routing,
                timeout,
                version,
                version_type,
                wait_for_active_shards,
                body,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let id = id.map_err(Error::InvalidRequest)?;
            let pipeline = pipeline.map_err(Error::InvalidRequest)?;
            let refresh = refresh.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let version = version.map_err(Error::InvalidRequest)?;
            let version_type = version_type.map_err(Error::InvalidRequest)?;
            let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_create/{}",
                client.baseurl,
                encode_path(&index.to_string()),
                encode_path(&id.to_string()),
            );
            let mut query = Vec::with_capacity(7usize);
            if let Some(v) = &pipeline {
                query.push(("pipeline", v.to_string()));
            }
            if let Some(v) = &refresh {
                query.push(("refresh", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &version {
                query.push(("version", v.to_string()));
            }
            if let Some(v) = &version_type {
                query.push(("version_type", v.to_string()));
            }
            if let Some(v) = &wait_for_active_shards {
                query.push(("wait_for_active_shards", v.to_string()));
            }
            let request = client.client.put(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::create_post`]
    ///
    ///[`Client::create_post`]: super::Client::create_post
    #[derive(Debug, Clone)]
    pub struct CreatePost<'a> {
        client: &'a super::Client,
        index: Result<types::CreatePostIndex, String>,
        id: Result<types::CreatePostId, String>,
        pipeline: Result<Option<String>, String>,
        refresh: Result<Option<types::RefreshEnum>, String>,
        routing: Result<Option<String>, String>,
        timeout: Result<Option<types::CreatePostTimeout>, String>,
        version: Result<Option<i32>, String>,
        version_type: Result<Option<types::VersionType>, String>,
        wait_for_active_shards: Result<Option<String>, String>,
        body: Result<types::CreateBodyParams, String>,
    }

    impl<'a> CreatePost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                id: Err("id was not initialized".to_string()),
                pipeline: Ok(None),
                refresh: Ok(None),
                routing: Ok(None),
                timeout: Ok(None),
                version: Ok(None),
                version_type: Ok(None),
                wait_for_active_shards: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreatePostIndex>,
        {
            self.index = value
                .try_into()
                .map_err(|_| "conversion to `CreatePostIndex` for index failed".to_string());
            self
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreatePostId>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `CreatePostId` for id failed".to_string());
            self
        }

        pub fn pipeline<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.pipeline = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for pipeline failed".to_string());
            self
        }

        pub fn refresh<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RefreshEnum>,
        {
            self.refresh = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `RefreshEnum` for refresh failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for routing failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreatePostTimeout>,
        {
            self.timeout = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `CreatePostTimeout` for timeout failed".to_string());
            self
        }

        pub fn version<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.version = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for version failed".to_string());
            self
        }

        pub fn version_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VersionType>,
        {
            self.version_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `VersionType` for version_type failed".to_string());
            self
        }

        pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.wait_for_active_shards = value.try_into().map(Some).map_err(|_| {
                "conversion to `String` for wait_for_active_shards failed".to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `CreateBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `POST` request to `/{index}/_create/{id}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                id,
                pipeline,
                refresh,
                routing,
                timeout,
                version,
                version_type,
                wait_for_active_shards,
                body,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let id = id.map_err(Error::InvalidRequest)?;
            let pipeline = pipeline.map_err(Error::InvalidRequest)?;
            let refresh = refresh.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let version = version.map_err(Error::InvalidRequest)?;
            let version_type = version_type.map_err(Error::InvalidRequest)?;
            let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_create/{}",
                client.baseurl,
                encode_path(&index.to_string()),
                encode_path(&id.to_string()),
            );
            let mut query = Vec::with_capacity(7usize);
            if let Some(v) = &pipeline {
                query.push(("pipeline", v.to_string()));
            }
            if let Some(v) = &refresh {
                query.push(("refresh", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &version {
                query.push(("version", v.to_string()));
            }
            if let Some(v) = &version_type {
                query.push(("version_type", v.to_string()));
            }
            if let Some(v) = &wait_for_active_shards {
                query.push(("wait_for_active_shards", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::delete_by_query`]
    ///
    ///[`Client::delete_by_query`]: super::Client::delete_by_query
    #[derive(Debug, Clone)]
    pub struct DeleteByQuery<'a> {
        client: &'a super::Client,
        index: Result<types::DeleteByQueryIndex, String>,
        source: Result<Option<Vec<String>>, String>,
        source_excludes: Result<Option<Vec<String>>, String>,
        source_includes: Result<Option<Vec<String>>, String>,
        allow_no_indices: Result<Option<bool>, String>,
        analyze_wildcard: Result<Option<bool>, String>,
        analyzer: Result<Option<String>, String>,
        conflicts: Result<Option<types::Conflicts>, String>,
        default_operator: Result<Option<types::DefaultOperator>, String>,
        df: Result<Option<String>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        from: Result<Option<i32>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        lenient: Result<Option<bool>, String>,
        max_docs: Result<Option<i32>, String>,
        preference: Result<Option<String>, String>,
        q: Result<Option<String>, String>,
        refresh: Result<Option<bool>, String>,
        request_cache: Result<Option<bool>, String>,
        requests_per_second: Result<Option<i32>, String>,
        routing: Result<Option<Vec<String>>, String>,
        scroll: Result<Option<types::DeleteByQueryScroll>, String>,
        scroll_size: Result<Option<i32>, String>,
        search_timeout: Result<Option<types::DeleteByQuerySearchTimeout>, String>,
        search_type: Result<Option<types::SearchType>, String>,
        size: Result<Option<i32>, String>,
        slices: Result<Option<String>, String>,
        sort: Result<Option<Vec<String>>, String>,
        stats: Result<Option<Vec<String>>, String>,
        terminate_after: Result<Option<i32>, String>,
        timeout: Result<Option<types::DeleteByQueryTimeout>, String>,
        version: Result<Option<bool>, String>,
        wait_for_active_shards: Result<Option<String>, String>,
        wait_for_completion: Result<Option<bool>, String>,
        body: Result<types::DeleteByQueryBodyParams, String>,
    }

    impl<'a> DeleteByQuery<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                source: Ok(None),
                source_excludes: Ok(None),
                source_includes: Ok(None),
                allow_no_indices: Ok(None),
                analyze_wildcard: Ok(None),
                analyzer: Ok(None),
                conflicts: Ok(None),
                default_operator: Ok(None),
                df: Ok(None),
                expand_wildcards: Ok(None),
                from: Ok(None),
                ignore_unavailable: Ok(None),
                lenient: Ok(None),
                max_docs: Ok(None),
                preference: Ok(None),
                q: Ok(None),
                refresh: Ok(None),
                request_cache: Ok(None),
                requests_per_second: Ok(None),
                routing: Ok(None),
                scroll: Ok(None),
                scroll_size: Ok(None),
                search_timeout: Ok(None),
                search_type: Ok(None),
                size: Ok(None),
                slices: Ok(None),
                sort: Ok(None),
                stats: Ok(None),
                terminate_after: Ok(None),
                timeout: Ok(None),
                version: Ok(None),
                wait_for_active_shards: Ok(None),
                wait_for_completion: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DeleteByQueryIndex>,
        {
            self.index = value
                .try_into()
                .map_err(|_| "conversion to `DeleteByQueryIndex` for index failed".to_string());
            self
        }

        pub fn source<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for source failed".to_string());
            self
        }

        pub fn source_excludes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_excludes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_excludes failed".to_string()
            });
            self
        }

        pub fn source_includes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_includes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_includes failed".to_string()
            });
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn analyze_wildcard<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.analyze_wildcard = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for analyze_wildcard failed".to_string());
            self
        }

        pub fn analyzer<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.analyzer = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for analyzer failed".to_string());
            self
        }

        pub fn conflicts<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Conflicts>,
        {
            self.conflicts = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Conflicts` for conflicts failed".to_string());
            self
        }

        pub fn default_operator<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DefaultOperator>,
        {
            self.default_operator = value.try_into().map(Some).map_err(|_| {
                "conversion to `DefaultOperator` for default_operator failed".to_string()
            });
            self
        }

        pub fn df<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.df = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for df failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn from<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.from = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for from failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn lenient<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.lenient = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for lenient failed".to_string());
            self
        }

        pub fn max_docs<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.max_docs = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for max_docs failed".to_string());
            self
        }

        pub fn preference<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.preference = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for preference failed".to_string());
            self
        }

        pub fn q<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.q = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for q failed".to_string());
            self
        }

        pub fn refresh<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.refresh = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for refresh failed".to_string());
            self
        }

        pub fn request_cache<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.request_cache = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for request_cache failed".to_string());
            self
        }

        pub fn requests_per_second<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.requests_per_second = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for requests_per_second failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for routing failed".to_string());
            self
        }

        pub fn scroll<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DeleteByQueryScroll>,
        {
            self.scroll = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `DeleteByQueryScroll` for scroll failed".to_string());
            self
        }

        pub fn scroll_size<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.scroll_size = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for scroll_size failed".to_string());
            self
        }

        pub fn search_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DeleteByQuerySearchTimeout>,
        {
            self.search_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `DeleteByQuerySearchTimeout` for search_timeout failed".to_string()
            });
            self
        }

        pub fn search_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchType>,
        {
            self.search_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SearchType` for search_type failed".to_string());
            self
        }

        pub fn size<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.size = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for size failed".to_string());
            self
        }

        pub fn slices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.slices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for slices failed".to_string());
            self
        }

        pub fn sort<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.sort = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for sort failed".to_string());
            self
        }

        pub fn stats<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.stats = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for stats failed".to_string());
            self
        }

        pub fn terminate_after<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.terminate_after = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for terminate_after failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DeleteByQueryTimeout>,
        {
            self.timeout = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `DeleteByQueryTimeout` for timeout failed".to_string());
            self
        }

        pub fn version<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.version = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for version failed".to_string());
            self
        }

        pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.wait_for_active_shards = value.try_into().map(Some).map_err(|_| {
                "conversion to `String` for wait_for_active_shards failed".to_string()
            });
            self
        }

        pub fn wait_for_completion<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.wait_for_completion = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for wait_for_completion failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DeleteByQueryBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `DeleteByQueryBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `POST` request to `/{index}/_delete_by_query`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                source,
                source_excludes,
                source_includes,
                allow_no_indices,
                analyze_wildcard,
                analyzer,
                conflicts,
                default_operator,
                df,
                expand_wildcards,
                from,
                ignore_unavailable,
                lenient,
                max_docs,
                preference,
                q,
                refresh,
                request_cache,
                requests_per_second,
                routing,
                scroll,
                scroll_size,
                search_timeout,
                search_type,
                size,
                slices,
                sort,
                stats,
                terminate_after,
                timeout,
                version,
                wait_for_active_shards,
                wait_for_completion,
                body,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let source = source.map_err(Error::InvalidRequest)?;
            let source_excludes = source_excludes.map_err(Error::InvalidRequest)?;
            let source_includes = source_includes.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let analyze_wildcard = analyze_wildcard.map_err(Error::InvalidRequest)?;
            let analyzer = analyzer.map_err(Error::InvalidRequest)?;
            let conflicts = conflicts.map_err(Error::InvalidRequest)?;
            let default_operator = default_operator.map_err(Error::InvalidRequest)?;
            let df = df.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let from = from.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let lenient = lenient.map_err(Error::InvalidRequest)?;
            let max_docs = max_docs.map_err(Error::InvalidRequest)?;
            let preference = preference.map_err(Error::InvalidRequest)?;
            let q = q.map_err(Error::InvalidRequest)?;
            let refresh = refresh.map_err(Error::InvalidRequest)?;
            let request_cache = request_cache.map_err(Error::InvalidRequest)?;
            let requests_per_second = requests_per_second.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let scroll = scroll.map_err(Error::InvalidRequest)?;
            let scroll_size = scroll_size.map_err(Error::InvalidRequest)?;
            let search_timeout = search_timeout.map_err(Error::InvalidRequest)?;
            let search_type = search_type.map_err(Error::InvalidRequest)?;
            let size = size.map_err(Error::InvalidRequest)?;
            let slices = slices.map_err(Error::InvalidRequest)?;
            let sort = sort.map_err(Error::InvalidRequest)?;
            let stats = stats.map_err(Error::InvalidRequest)?;
            let terminate_after = terminate_after.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let version = version.map_err(Error::InvalidRequest)?;
            let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
            let wait_for_completion = wait_for_completion.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_delete_by_query",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(33usize);
            if let Some(v) = &source {
                query.push(("_source", v.to_string()));
            }
            if let Some(v) = &source_excludes {
                query.push(("_source_excludes", v.to_string()));
            }
            if let Some(v) = &source_includes {
                query.push(("_source_includes", v.to_string()));
            }
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &analyze_wildcard {
                query.push(("analyze_wildcard", v.to_string()));
            }
            if let Some(v) = &analyzer {
                query.push(("analyzer", v.to_string()));
            }
            if let Some(v) = &conflicts {
                query.push(("conflicts", v.to_string()));
            }
            if let Some(v) = &default_operator {
                query.push(("default_operator", v.to_string()));
            }
            if let Some(v) = &df {
                query.push(("df", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &from {
                query.push(("from", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &lenient {
                query.push(("lenient", v.to_string()));
            }
            if let Some(v) = &max_docs {
                query.push(("max_docs", v.to_string()));
            }
            if let Some(v) = &preference {
                query.push(("preference", v.to_string()));
            }
            if let Some(v) = &q {
                query.push(("q", v.to_string()));
            }
            if let Some(v) = &refresh {
                query.push(("refresh", v.to_string()));
            }
            if let Some(v) = &request_cache {
                query.push(("request_cache", v.to_string()));
            }
            if let Some(v) = &requests_per_second {
                query.push(("requests_per_second", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &scroll {
                query.push(("scroll", v.to_string()));
            }
            if let Some(v) = &scroll_size {
                query.push(("scroll_size", v.to_string()));
            }
            if let Some(v) = &search_timeout {
                query.push(("search_timeout", v.to_string()));
            }
            if let Some(v) = &search_type {
                query.push(("search_type", v.to_string()));
            }
            if let Some(v) = &size {
                query.push(("size", v.to_string()));
            }
            if let Some(v) = &slices {
                query.push(("slices", v.to_string()));
            }
            if let Some(v) = &sort {
                query.push(("sort", v.to_string()));
            }
            if let Some(v) = &stats {
                query.push(("stats", v.to_string()));
            }
            if let Some(v) = &terminate_after {
                query.push(("terminate_after", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &version {
                query.push(("version", v.to_string()));
            }
            if let Some(v) = &wait_for_active_shards {
                query.push(("wait_for_active_shards", v.to_string()));
            }
            if let Some(v) = &wait_for_completion {
                query.push(("wait_for_completion", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::index_post`]
    ///
    ///[`Client::index_post`]: super::Client::index_post
    #[derive(Debug, Clone)]
    pub struct IndexPost<'a> {
        client: &'a super::Client,
        index: Result<types::IndexPostIndex, String>,
        if_primary_term: Result<Option<i32>, String>,
        if_seq_no: Result<Option<i32>, String>,
        op_type: Result<Option<types::OpType>, String>,
        pipeline: Result<Option<String>, String>,
        refresh: Result<Option<types::RefreshEnum>, String>,
        require_alias: Result<Option<bool>, String>,
        routing: Result<Option<String>, String>,
        timeout: Result<Option<types::IndexPostTimeout>, String>,
        version: Result<Option<i32>, String>,
        version_type: Result<Option<types::VersionType>, String>,
        wait_for_active_shards: Result<Option<String>, String>,
        body: Result<types::IndexBodyParams, String>,
    }

    impl<'a> IndexPost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                if_primary_term: Ok(None),
                if_seq_no: Ok(None),
                op_type: Ok(None),
                pipeline: Ok(None),
                refresh: Ok(None),
                require_alias: Ok(None),
                routing: Ok(None),
                timeout: Ok(None),
                version: Ok(None),
                version_type: Ok(None),
                wait_for_active_shards: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndexPostIndex>,
        {
            self.index = value
                .try_into()
                .map_err(|_| "conversion to `IndexPostIndex` for index failed".to_string());
            self
        }

        pub fn if_primary_term<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.if_primary_term = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for if_primary_term failed".to_string());
            self
        }

        pub fn if_seq_no<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.if_seq_no = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for if_seq_no failed".to_string());
            self
        }

        pub fn op_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::OpType>,
        {
            self.op_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `OpType` for op_type failed".to_string());
            self
        }

        pub fn pipeline<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.pipeline = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for pipeline failed".to_string());
            self
        }

        pub fn refresh<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RefreshEnum>,
        {
            self.refresh = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `RefreshEnum` for refresh failed".to_string());
            self
        }

        pub fn require_alias<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.require_alias = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for require_alias failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for routing failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndexPostTimeout>,
        {
            self.timeout = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IndexPostTimeout` for timeout failed".to_string());
            self
        }

        pub fn version<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.version = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for version failed".to_string());
            self
        }

        pub fn version_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VersionType>,
        {
            self.version_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `VersionType` for version_type failed".to_string());
            self
        }

        pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.wait_for_active_shards = value.try_into().map(Some).map_err(|_| {
                "conversion to `String` for wait_for_active_shards failed".to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndexBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `IndexBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `POST` request to `/{index}/_doc`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                if_primary_term,
                if_seq_no,
                op_type,
                pipeline,
                refresh,
                require_alias,
                routing,
                timeout,
                version,
                version_type,
                wait_for_active_shards,
                body,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let if_primary_term = if_primary_term.map_err(Error::InvalidRequest)?;
            let if_seq_no = if_seq_no.map_err(Error::InvalidRequest)?;
            let op_type = op_type.map_err(Error::InvalidRequest)?;
            let pipeline = pipeline.map_err(Error::InvalidRequest)?;
            let refresh = refresh.map_err(Error::InvalidRequest)?;
            let require_alias = require_alias.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let version = version.map_err(Error::InvalidRequest)?;
            let version_type = version_type.map_err(Error::InvalidRequest)?;
            let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_doc",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(11usize);
            if let Some(v) = &if_primary_term {
                query.push(("if_primary_term", v.to_string()));
            }
            if let Some(v) = &if_seq_no {
                query.push(("if_seq_no", v.to_string()));
            }
            if let Some(v) = &op_type {
                query.push(("op_type", v.to_string()));
            }
            if let Some(v) = &pipeline {
                query.push(("pipeline", v.to_string()));
            }
            if let Some(v) = &refresh {
                query.push(("refresh", v.to_string()));
            }
            if let Some(v) = &require_alias {
                query.push(("require_alias", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &version {
                query.push(("version", v.to_string()));
            }
            if let Some(v) = &version_type {
                query.push(("version_type", v.to_string()));
            }
            if let Some(v) = &wait_for_active_shards {
                query.push(("wait_for_active_shards", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::get`]
    ///
    ///[`Client::get`]: super::Client::get
    #[derive(Debug, Clone)]
    pub struct Get<'a> {
        client: &'a super::Client,
        index: Result<types::GetIndex, String>,
        id: Result<types::GetId, String>,
        source: Result<Option<Vec<String>>, String>,
        source_excludes: Result<Option<Vec<String>>, String>,
        source_includes: Result<Option<Vec<String>>, String>,
        preference: Result<Option<String>, String>,
        realtime: Result<Option<bool>, String>,
        refresh: Result<Option<bool>, String>,
        routing: Result<Option<String>, String>,
        stored_fields: Result<Option<Vec<String>>, String>,
        version: Result<Option<i32>, String>,
        version_type: Result<Option<types::VersionType>, String>,
    }

    impl<'a> Get<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                id: Err("id was not initialized".to_string()),
                source: Ok(None),
                source_excludes: Ok(None),
                source_includes: Ok(None),
                preference: Ok(None),
                realtime: Ok(None),
                refresh: Ok(None),
                routing: Ok(None),
                stored_fields: Ok(None),
                version: Ok(None),
                version_type: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::GetIndex>,
        {
            self.index = value
                .try_into()
                .map_err(|_| "conversion to `GetIndex` for index failed".to_string());
            self
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::GetId>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `GetId` for id failed".to_string());
            self
        }

        pub fn source<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for source failed".to_string());
            self
        }

        pub fn source_excludes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_excludes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_excludes failed".to_string()
            });
            self
        }

        pub fn source_includes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_includes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_includes failed".to_string()
            });
            self
        }

        pub fn preference<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.preference = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for preference failed".to_string());
            self
        }

        pub fn realtime<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.realtime = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for realtime failed".to_string());
            self
        }

        pub fn refresh<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.refresh = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for refresh failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for routing failed".to_string());
            self
        }

        pub fn stored_fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.stored_fields = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for stored_fields failed".to_string());
            self
        }

        pub fn version<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.version = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for version failed".to_string());
            self
        }

        pub fn version_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VersionType>,
        {
            self.version_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `VersionType` for version_type failed".to_string());
            self
        }

        ///Sends a `GET` request to `/{index}/_doc/{id}`
        pub async fn send(self) -> Result<ResponseValue<types::GetResponseContent>, Error<()>> {
            let Self {
                client,
                index,
                id,
                source,
                source_excludes,
                source_includes,
                preference,
                realtime,
                refresh,
                routing,
                stored_fields,
                version,
                version_type,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let id = id.map_err(Error::InvalidRequest)?;
            let source = source.map_err(Error::InvalidRequest)?;
            let source_excludes = source_excludes.map_err(Error::InvalidRequest)?;
            let source_includes = source_includes.map_err(Error::InvalidRequest)?;
            let preference = preference.map_err(Error::InvalidRequest)?;
            let realtime = realtime.map_err(Error::InvalidRequest)?;
            let refresh = refresh.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let stored_fields = stored_fields.map_err(Error::InvalidRequest)?;
            let version = version.map_err(Error::InvalidRequest)?;
            let version_type = version_type.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_doc/{}",
                client.baseurl,
                encode_path(&index.to_string()),
                encode_path(&id.to_string()),
            );
            let mut query = Vec::with_capacity(10usize);
            if let Some(v) = &source {
                query.push(("_source", v.to_string()));
            }
            if let Some(v) = &source_excludes {
                query.push(("_source_excludes", v.to_string()));
            }
            if let Some(v) = &source_includes {
                query.push(("_source_includes", v.to_string()));
            }
            if let Some(v) = &preference {
                query.push(("preference", v.to_string()));
            }
            if let Some(v) = &realtime {
                query.push(("realtime", v.to_string()));
            }
            if let Some(v) = &refresh {
                query.push(("refresh", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &stored_fields {
                query.push(("stored_fields", v.to_string()));
            }
            if let Some(v) = &version {
                query.push(("version", v.to_string()));
            }
            if let Some(v) = &version_type {
                query.push(("version_type", v.to_string()));
            }
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::index_put_with_id`]
    ///
    ///[`Client::index_put_with_id`]: super::Client::index_put_with_id
    #[derive(Debug, Clone)]
    pub struct IndexPutWithId<'a> {
        client: &'a super::Client,
        index: Result<types::IndexPutWithIdIndex, String>,
        id: Result<types::IndexPutWithIdId, String>,
        if_primary_term: Result<Option<i32>, String>,
        if_seq_no: Result<Option<i32>, String>,
        op_type: Result<Option<types::OpType>, String>,
        pipeline: Result<Option<String>, String>,
        refresh: Result<Option<types::RefreshEnum>, String>,
        require_alias: Result<Option<bool>, String>,
        routing: Result<Option<String>, String>,
        timeout: Result<Option<types::IndexPutWithIdTimeout>, String>,
        version: Result<Option<i32>, String>,
        version_type: Result<Option<types::VersionType>, String>,
        wait_for_active_shards: Result<Option<String>, String>,
        body: Result<types::IndexBodyParams, String>,
    }

    impl<'a> IndexPutWithId<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                id: Err("id was not initialized".to_string()),
                if_primary_term: Ok(None),
                if_seq_no: Ok(None),
                op_type: Ok(None),
                pipeline: Ok(None),
                refresh: Ok(None),
                require_alias: Ok(None),
                routing: Ok(None),
                timeout: Ok(None),
                version: Ok(None),
                version_type: Ok(None),
                wait_for_active_shards: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndexPutWithIdIndex>,
        {
            self.index = value
                .try_into()
                .map_err(|_| "conversion to `IndexPutWithIdIndex` for index failed".to_string());
            self
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndexPutWithIdId>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `IndexPutWithIdId` for id failed".to_string());
            self
        }

        pub fn if_primary_term<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.if_primary_term = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for if_primary_term failed".to_string());
            self
        }

        pub fn if_seq_no<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.if_seq_no = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for if_seq_no failed".to_string());
            self
        }

        pub fn op_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::OpType>,
        {
            self.op_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `OpType` for op_type failed".to_string());
            self
        }

        pub fn pipeline<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.pipeline = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for pipeline failed".to_string());
            self
        }

        pub fn refresh<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RefreshEnum>,
        {
            self.refresh = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `RefreshEnum` for refresh failed".to_string());
            self
        }

        pub fn require_alias<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.require_alias = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for require_alias failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for routing failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndexPutWithIdTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndexPutWithIdTimeout` for timeout failed".to_string()
            });
            self
        }

        pub fn version<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.version = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for version failed".to_string());
            self
        }

        pub fn version_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VersionType>,
        {
            self.version_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `VersionType` for version_type failed".to_string());
            self
        }

        pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.wait_for_active_shards = value.try_into().map(Some).map_err(|_| {
                "conversion to `String` for wait_for_active_shards failed".to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndexBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `IndexBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `PUT` request to `/{index}/_doc/{id}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                id,
                if_primary_term,
                if_seq_no,
                op_type,
                pipeline,
                refresh,
                require_alias,
                routing,
                timeout,
                version,
                version_type,
                wait_for_active_shards,
                body,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let id = id.map_err(Error::InvalidRequest)?;
            let if_primary_term = if_primary_term.map_err(Error::InvalidRequest)?;
            let if_seq_no = if_seq_no.map_err(Error::InvalidRequest)?;
            let op_type = op_type.map_err(Error::InvalidRequest)?;
            let pipeline = pipeline.map_err(Error::InvalidRequest)?;
            let refresh = refresh.map_err(Error::InvalidRequest)?;
            let require_alias = require_alias.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let version = version.map_err(Error::InvalidRequest)?;
            let version_type = version_type.map_err(Error::InvalidRequest)?;
            let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_doc/{}",
                client.baseurl,
                encode_path(&index.to_string()),
                encode_path(&id.to_string()),
            );
            let mut query = Vec::with_capacity(11usize);
            if let Some(v) = &if_primary_term {
                query.push(("if_primary_term", v.to_string()));
            }
            if let Some(v) = &if_seq_no {
                query.push(("if_seq_no", v.to_string()));
            }
            if let Some(v) = &op_type {
                query.push(("op_type", v.to_string()));
            }
            if let Some(v) = &pipeline {
                query.push(("pipeline", v.to_string()));
            }
            if let Some(v) = &refresh {
                query.push(("refresh", v.to_string()));
            }
            if let Some(v) = &require_alias {
                query.push(("require_alias", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &version {
                query.push(("version", v.to_string()));
            }
            if let Some(v) = &version_type {
                query.push(("version_type", v.to_string()));
            }
            if let Some(v) = &wait_for_active_shards {
                query.push(("wait_for_active_shards", v.to_string()));
            }
            let request = client.client.put(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::index_post_with_id`]
    ///
    ///[`Client::index_post_with_id`]: super::Client::index_post_with_id
    #[derive(Debug, Clone)]
    pub struct IndexPostWithId<'a> {
        client: &'a super::Client,
        index: Result<types::IndexPostWithIdIndex, String>,
        id: Result<types::IndexPostWithIdId, String>,
        if_primary_term: Result<Option<i32>, String>,
        if_seq_no: Result<Option<i32>, String>,
        op_type: Result<Option<types::OpType>, String>,
        pipeline: Result<Option<String>, String>,
        refresh: Result<Option<types::RefreshEnum>, String>,
        require_alias: Result<Option<bool>, String>,
        routing: Result<Option<String>, String>,
        timeout: Result<Option<types::IndexPostWithIdTimeout>, String>,
        version: Result<Option<i32>, String>,
        version_type: Result<Option<types::VersionType>, String>,
        wait_for_active_shards: Result<Option<String>, String>,
        body: Result<types::IndexBodyParams, String>,
    }

    impl<'a> IndexPostWithId<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                id: Err("id was not initialized".to_string()),
                if_primary_term: Ok(None),
                if_seq_no: Ok(None),
                op_type: Ok(None),
                pipeline: Ok(None),
                refresh: Ok(None),
                require_alias: Ok(None),
                routing: Ok(None),
                timeout: Ok(None),
                version: Ok(None),
                version_type: Ok(None),
                wait_for_active_shards: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndexPostWithIdIndex>,
        {
            self.index = value
                .try_into()
                .map_err(|_| "conversion to `IndexPostWithIdIndex` for index failed".to_string());
            self
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndexPostWithIdId>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `IndexPostWithIdId` for id failed".to_string());
            self
        }

        pub fn if_primary_term<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.if_primary_term = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for if_primary_term failed".to_string());
            self
        }

        pub fn if_seq_no<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.if_seq_no = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for if_seq_no failed".to_string());
            self
        }

        pub fn op_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::OpType>,
        {
            self.op_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `OpType` for op_type failed".to_string());
            self
        }

        pub fn pipeline<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.pipeline = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for pipeline failed".to_string());
            self
        }

        pub fn refresh<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RefreshEnum>,
        {
            self.refresh = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `RefreshEnum` for refresh failed".to_string());
            self
        }

        pub fn require_alias<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.require_alias = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for require_alias failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for routing failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndexPostWithIdTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndexPostWithIdTimeout` for timeout failed".to_string()
            });
            self
        }

        pub fn version<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.version = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for version failed".to_string());
            self
        }

        pub fn version_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VersionType>,
        {
            self.version_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `VersionType` for version_type failed".to_string());
            self
        }

        pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.wait_for_active_shards = value.try_into().map(Some).map_err(|_| {
                "conversion to `String` for wait_for_active_shards failed".to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndexBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `IndexBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `POST` request to `/{index}/_doc/{id}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                id,
                if_primary_term,
                if_seq_no,
                op_type,
                pipeline,
                refresh,
                require_alias,
                routing,
                timeout,
                version,
                version_type,
                wait_for_active_shards,
                body,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let id = id.map_err(Error::InvalidRequest)?;
            let if_primary_term = if_primary_term.map_err(Error::InvalidRequest)?;
            let if_seq_no = if_seq_no.map_err(Error::InvalidRequest)?;
            let op_type = op_type.map_err(Error::InvalidRequest)?;
            let pipeline = pipeline.map_err(Error::InvalidRequest)?;
            let refresh = refresh.map_err(Error::InvalidRequest)?;
            let require_alias = require_alias.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let version = version.map_err(Error::InvalidRequest)?;
            let version_type = version_type.map_err(Error::InvalidRequest)?;
            let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_doc/{}",
                client.baseurl,
                encode_path(&index.to_string()),
                encode_path(&id.to_string()),
            );
            let mut query = Vec::with_capacity(11usize);
            if let Some(v) = &if_primary_term {
                query.push(("if_primary_term", v.to_string()));
            }
            if let Some(v) = &if_seq_no {
                query.push(("if_seq_no", v.to_string()));
            }
            if let Some(v) = &op_type {
                query.push(("op_type", v.to_string()));
            }
            if let Some(v) = &pipeline {
                query.push(("pipeline", v.to_string()));
            }
            if let Some(v) = &refresh {
                query.push(("refresh", v.to_string()));
            }
            if let Some(v) = &require_alias {
                query.push(("require_alias", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &version {
                query.push(("version", v.to_string()));
            }
            if let Some(v) = &version_type {
                query.push(("version_type", v.to_string()));
            }
            if let Some(v) = &wait_for_active_shards {
                query.push(("wait_for_active_shards", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::delete`]
    ///
    ///[`Client::delete`]: super::Client::delete
    #[derive(Debug, Clone)]
    pub struct Delete<'a> {
        client: &'a super::Client,
        index: Result<types::DeleteIndex, String>,
        id: Result<types::DeleteId, String>,
        if_primary_term: Result<Option<i32>, String>,
        if_seq_no: Result<Option<i32>, String>,
        refresh: Result<Option<types::RefreshEnum>, String>,
        routing: Result<Option<String>, String>,
        timeout: Result<Option<types::DeleteTimeout>, String>,
        version: Result<Option<i32>, String>,
        version_type: Result<Option<types::VersionType>, String>,
        wait_for_active_shards: Result<Option<String>, String>,
    }

    impl<'a> Delete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                id: Err("id was not initialized".to_string()),
                if_primary_term: Ok(None),
                if_seq_no: Ok(None),
                refresh: Ok(None),
                routing: Ok(None),
                timeout: Ok(None),
                version: Ok(None),
                version_type: Ok(None),
                wait_for_active_shards: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DeleteIndex>,
        {
            self.index = value
                .try_into()
                .map_err(|_| "conversion to `DeleteIndex` for index failed".to_string());
            self
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DeleteId>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `DeleteId` for id failed".to_string());
            self
        }

        pub fn if_primary_term<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.if_primary_term = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for if_primary_term failed".to_string());
            self
        }

        pub fn if_seq_no<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.if_seq_no = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for if_seq_no failed".to_string());
            self
        }

        pub fn refresh<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RefreshEnum>,
        {
            self.refresh = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `RefreshEnum` for refresh failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for routing failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DeleteTimeout>,
        {
            self.timeout = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `DeleteTimeout` for timeout failed".to_string());
            self
        }

        pub fn version<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.version = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for version failed".to_string());
            self
        }

        pub fn version_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VersionType>,
        {
            self.version_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `VersionType` for version_type failed".to_string());
            self
        }

        pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.wait_for_active_shards = value.try_into().map(Some).map_err(|_| {
                "conversion to `String` for wait_for_active_shards failed".to_string()
            });
            self
        }

        ///Sends a `DELETE` request to `/{index}/_doc/{id}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                id,
                if_primary_term,
                if_seq_no,
                refresh,
                routing,
                timeout,
                version,
                version_type,
                wait_for_active_shards,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let id = id.map_err(Error::InvalidRequest)?;
            let if_primary_term = if_primary_term.map_err(Error::InvalidRequest)?;
            let if_seq_no = if_seq_no.map_err(Error::InvalidRequest)?;
            let refresh = refresh.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let version = version.map_err(Error::InvalidRequest)?;
            let version_type = version_type.map_err(Error::InvalidRequest)?;
            let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_doc/{}",
                client.baseurl,
                encode_path(&index.to_string()),
                encode_path(&id.to_string()),
            );
            let mut query = Vec::with_capacity(8usize);
            if let Some(v) = &if_primary_term {
                query.push(("if_primary_term", v.to_string()));
            }
            if let Some(v) = &if_seq_no {
                query.push(("if_seq_no", v.to_string()));
            }
            if let Some(v) = &refresh {
                query.push(("refresh", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &version {
                query.push(("version", v.to_string()));
            }
            if let Some(v) = &version_type {
                query.push(("version_type", v.to_string()));
            }
            if let Some(v) = &wait_for_active_shards {
                query.push(("wait_for_active_shards", v.to_string()));
            }
            let request = client.client.delete(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::exists`]
    ///
    ///[`Client::exists`]: super::Client::exists
    #[derive(Debug, Clone)]
    pub struct Exists<'a> {
        client: &'a super::Client,
        index: Result<types::ExistsIndex, String>,
        id: Result<types::ExistsId, String>,
        source: Result<Option<Vec<String>>, String>,
        source_excludes: Result<Option<Vec<String>>, String>,
        source_includes: Result<Option<Vec<String>>, String>,
        preference: Result<Option<String>, String>,
        realtime: Result<Option<bool>, String>,
        refresh: Result<Option<bool>, String>,
        routing: Result<Option<String>, String>,
        stored_fields: Result<Option<Vec<String>>, String>,
        version: Result<Option<i32>, String>,
        version_type: Result<Option<types::VersionType>, String>,
    }

    impl<'a> Exists<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                id: Err("id was not initialized".to_string()),
                source: Ok(None),
                source_excludes: Ok(None),
                source_includes: Ok(None),
                preference: Ok(None),
                realtime: Ok(None),
                refresh: Ok(None),
                routing: Ok(None),
                stored_fields: Ok(None),
                version: Ok(None),
                version_type: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExistsIndex>,
        {
            self.index = value
                .try_into()
                .map_err(|_| "conversion to `ExistsIndex` for index failed".to_string());
            self
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExistsId>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `ExistsId` for id failed".to_string());
            self
        }

        pub fn source<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for source failed".to_string());
            self
        }

        pub fn source_excludes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_excludes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_excludes failed".to_string()
            });
            self
        }

        pub fn source_includes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_includes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_includes failed".to_string()
            });
            self
        }

        pub fn preference<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.preference = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for preference failed".to_string());
            self
        }

        pub fn realtime<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.realtime = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for realtime failed".to_string());
            self
        }

        pub fn refresh<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.refresh = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for refresh failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for routing failed".to_string());
            self
        }

        pub fn stored_fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.stored_fields = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for stored_fields failed".to_string());
            self
        }

        pub fn version<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.version = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for version failed".to_string());
            self
        }

        pub fn version_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VersionType>,
        {
            self.version_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `VersionType` for version_type failed".to_string());
            self
        }

        ///Sends a `HEAD` request to `/{index}/_doc/{id}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                id,
                source,
                source_excludes,
                source_includes,
                preference,
                realtime,
                refresh,
                routing,
                stored_fields,
                version,
                version_type,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let id = id.map_err(Error::InvalidRequest)?;
            let source = source.map_err(Error::InvalidRequest)?;
            let source_excludes = source_excludes.map_err(Error::InvalidRequest)?;
            let source_includes = source_includes.map_err(Error::InvalidRequest)?;
            let preference = preference.map_err(Error::InvalidRequest)?;
            let realtime = realtime.map_err(Error::InvalidRequest)?;
            let refresh = refresh.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let stored_fields = stored_fields.map_err(Error::InvalidRequest)?;
            let version = version.map_err(Error::InvalidRequest)?;
            let version_type = version_type.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_doc/{}",
                client.baseurl,
                encode_path(&index.to_string()),
                encode_path(&id.to_string()),
            );
            let mut query = Vec::with_capacity(10usize);
            if let Some(v) = &source {
                query.push(("_source", v.to_string()));
            }
            if let Some(v) = &source_excludes {
                query.push(("_source_excludes", v.to_string()));
            }
            if let Some(v) = &source_includes {
                query.push(("_source_includes", v.to_string()));
            }
            if let Some(v) = &preference {
                query.push(("preference", v.to_string()));
            }
            if let Some(v) = &realtime {
                query.push(("realtime", v.to_string()));
            }
            if let Some(v) = &refresh {
                query.push(("refresh", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &stored_fields {
                query.push(("stored_fields", v.to_string()));
            }
            if let Some(v) = &version {
                query.push(("version", v.to_string()));
            }
            if let Some(v) = &version_type {
                query.push(("version_type", v.to_string()));
            }
            let request = client.client.head(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::explain_get`]
    ///
    ///[`Client::explain_get`]: super::Client::explain_get
    #[derive(Debug, Clone)]
    pub struct ExplainGet<'a> {
        client: &'a super::Client,
        index: Result<types::ExplainGetIndex, String>,
        id: Result<types::ExplainGetId, String>,
        source: Result<Option<Vec<String>>, String>,
        source_excludes: Result<Option<Vec<String>>, String>,
        source_includes: Result<Option<Vec<String>>, String>,
        analyze_wildcard: Result<Option<bool>, String>,
        analyzer: Result<Option<String>, String>,
        default_operator: Result<Option<types::DefaultOperator>, String>,
        df: Result<Option<String>, String>,
        lenient: Result<Option<bool>, String>,
        preference: Result<Option<String>, String>,
        q: Result<Option<String>, String>,
        routing: Result<Option<String>, String>,
        stored_fields: Result<Option<Vec<String>>, String>,
    }

    impl<'a> ExplainGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                id: Err("id was not initialized".to_string()),
                source: Ok(None),
                source_excludes: Ok(None),
                source_includes: Ok(None),
                analyze_wildcard: Ok(None),
                analyzer: Ok(None),
                default_operator: Ok(None),
                df: Ok(None),
                lenient: Ok(None),
                preference: Ok(None),
                q: Ok(None),
                routing: Ok(None),
                stored_fields: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExplainGetIndex>,
        {
            self.index = value
                .try_into()
                .map_err(|_| "conversion to `ExplainGetIndex` for index failed".to_string());
            self
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExplainGetId>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `ExplainGetId` for id failed".to_string());
            self
        }

        pub fn source<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for source failed".to_string());
            self
        }

        pub fn source_excludes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_excludes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_excludes failed".to_string()
            });
            self
        }

        pub fn source_includes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_includes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_includes failed".to_string()
            });
            self
        }

        pub fn analyze_wildcard<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.analyze_wildcard = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for analyze_wildcard failed".to_string());
            self
        }

        pub fn analyzer<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.analyzer = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for analyzer failed".to_string());
            self
        }

        pub fn default_operator<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DefaultOperator>,
        {
            self.default_operator = value.try_into().map(Some).map_err(|_| {
                "conversion to `DefaultOperator` for default_operator failed".to_string()
            });
            self
        }

        pub fn df<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.df = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for df failed".to_string());
            self
        }

        pub fn lenient<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.lenient = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for lenient failed".to_string());
            self
        }

        pub fn preference<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.preference = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for preference failed".to_string());
            self
        }

        pub fn q<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.q = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for q failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for routing failed".to_string());
            self
        }

        pub fn stored_fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.stored_fields = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for stored_fields failed".to_string());
            self
        }

        ///Sends a `GET` request to `/{index}/_explain/{id}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                id,
                source,
                source_excludes,
                source_includes,
                analyze_wildcard,
                analyzer,
                default_operator,
                df,
                lenient,
                preference,
                q,
                routing,
                stored_fields,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let id = id.map_err(Error::InvalidRequest)?;
            let source = source.map_err(Error::InvalidRequest)?;
            let source_excludes = source_excludes.map_err(Error::InvalidRequest)?;
            let source_includes = source_includes.map_err(Error::InvalidRequest)?;
            let analyze_wildcard = analyze_wildcard.map_err(Error::InvalidRequest)?;
            let analyzer = analyzer.map_err(Error::InvalidRequest)?;
            let default_operator = default_operator.map_err(Error::InvalidRequest)?;
            let df = df.map_err(Error::InvalidRequest)?;
            let lenient = lenient.map_err(Error::InvalidRequest)?;
            let preference = preference.map_err(Error::InvalidRequest)?;
            let q = q.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let stored_fields = stored_fields.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_explain/{}",
                client.baseurl,
                encode_path(&index.to_string()),
                encode_path(&id.to_string()),
            );
            let mut query = Vec::with_capacity(12usize);
            if let Some(v) = &source {
                query.push(("_source", v.to_string()));
            }
            if let Some(v) = &source_excludes {
                query.push(("_source_excludes", v.to_string()));
            }
            if let Some(v) = &source_includes {
                query.push(("_source_includes", v.to_string()));
            }
            if let Some(v) = &analyze_wildcard {
                query.push(("analyze_wildcard", v.to_string()));
            }
            if let Some(v) = &analyzer {
                query.push(("analyzer", v.to_string()));
            }
            if let Some(v) = &default_operator {
                query.push(("default_operator", v.to_string()));
            }
            if let Some(v) = &df {
                query.push(("df", v.to_string()));
            }
            if let Some(v) = &lenient {
                query.push(("lenient", v.to_string()));
            }
            if let Some(v) = &preference {
                query.push(("preference", v.to_string()));
            }
            if let Some(v) = &q {
                query.push(("q", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &stored_fields {
                query.push(("stored_fields", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::explain_post`]
    ///
    ///[`Client::explain_post`]: super::Client::explain_post
    #[derive(Debug, Clone)]
    pub struct ExplainPost<'a> {
        client: &'a super::Client,
        index: Result<types::ExplainPostIndex, String>,
        id: Result<types::ExplainPostId, String>,
        source: Result<Option<Vec<String>>, String>,
        source_excludes: Result<Option<Vec<String>>, String>,
        source_includes: Result<Option<Vec<String>>, String>,
        analyze_wildcard: Result<Option<bool>, String>,
        analyzer: Result<Option<String>, String>,
        default_operator: Result<Option<types::DefaultOperator>, String>,
        df: Result<Option<String>, String>,
        lenient: Result<Option<bool>, String>,
        preference: Result<Option<String>, String>,
        q: Result<Option<String>, String>,
        routing: Result<Option<String>, String>,
        stored_fields: Result<Option<Vec<String>>, String>,
        body: Result<types::ExplainBodyParams, String>,
    }

    impl<'a> ExplainPost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                id: Err("id was not initialized".to_string()),
                source: Ok(None),
                source_excludes: Ok(None),
                source_includes: Ok(None),
                analyze_wildcard: Ok(None),
                analyzer: Ok(None),
                default_operator: Ok(None),
                df: Ok(None),
                lenient: Ok(None),
                preference: Ok(None),
                q: Ok(None),
                routing: Ok(None),
                stored_fields: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExplainPostIndex>,
        {
            self.index = value
                .try_into()
                .map_err(|_| "conversion to `ExplainPostIndex` for index failed".to_string());
            self
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExplainPostId>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `ExplainPostId` for id failed".to_string());
            self
        }

        pub fn source<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for source failed".to_string());
            self
        }

        pub fn source_excludes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_excludes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_excludes failed".to_string()
            });
            self
        }

        pub fn source_includes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_includes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_includes failed".to_string()
            });
            self
        }

        pub fn analyze_wildcard<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.analyze_wildcard = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for analyze_wildcard failed".to_string());
            self
        }

        pub fn analyzer<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.analyzer = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for analyzer failed".to_string());
            self
        }

        pub fn default_operator<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DefaultOperator>,
        {
            self.default_operator = value.try_into().map(Some).map_err(|_| {
                "conversion to `DefaultOperator` for default_operator failed".to_string()
            });
            self
        }

        pub fn df<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.df = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for df failed".to_string());
            self
        }

        pub fn lenient<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.lenient = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for lenient failed".to_string());
            self
        }

        pub fn preference<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.preference = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for preference failed".to_string());
            self
        }

        pub fn q<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.q = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for q failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for routing failed".to_string());
            self
        }

        pub fn stored_fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.stored_fields = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for stored_fields failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExplainBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `ExplainBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `POST` request to `/{index}/_explain/{id}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                id,
                source,
                source_excludes,
                source_includes,
                analyze_wildcard,
                analyzer,
                default_operator,
                df,
                lenient,
                preference,
                q,
                routing,
                stored_fields,
                body,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let id = id.map_err(Error::InvalidRequest)?;
            let source = source.map_err(Error::InvalidRequest)?;
            let source_excludes = source_excludes.map_err(Error::InvalidRequest)?;
            let source_includes = source_includes.map_err(Error::InvalidRequest)?;
            let analyze_wildcard = analyze_wildcard.map_err(Error::InvalidRequest)?;
            let analyzer = analyzer.map_err(Error::InvalidRequest)?;
            let default_operator = default_operator.map_err(Error::InvalidRequest)?;
            let df = df.map_err(Error::InvalidRequest)?;
            let lenient = lenient.map_err(Error::InvalidRequest)?;
            let preference = preference.map_err(Error::InvalidRequest)?;
            let q = q.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let stored_fields = stored_fields.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_explain/{}",
                client.baseurl,
                encode_path(&index.to_string()),
                encode_path(&id.to_string()),
            );
            let mut query = Vec::with_capacity(12usize);
            if let Some(v) = &source {
                query.push(("_source", v.to_string()));
            }
            if let Some(v) = &source_excludes {
                query.push(("_source_excludes", v.to_string()));
            }
            if let Some(v) = &source_includes {
                query.push(("_source_includes", v.to_string()));
            }
            if let Some(v) = &analyze_wildcard {
                query.push(("analyze_wildcard", v.to_string()));
            }
            if let Some(v) = &analyzer {
                query.push(("analyzer", v.to_string()));
            }
            if let Some(v) = &default_operator {
                query.push(("default_operator", v.to_string()));
            }
            if let Some(v) = &df {
                query.push(("df", v.to_string()));
            }
            if let Some(v) = &lenient {
                query.push(("lenient", v.to_string()));
            }
            if let Some(v) = &preference {
                query.push(("preference", v.to_string()));
            }
            if let Some(v) = &q {
                query.push(("q", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &stored_fields {
                query.push(("stored_fields", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::field_caps_get_with_index`]
    ///
    ///[`Client::field_caps_get_with_index`]: super::Client::field_caps_get_with_index
    #[derive(Debug, Clone)]
    pub struct FieldCapsGetWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::FieldCapsGetWithIndexIndex, String>,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        fields: Result<Option<Vec<String>>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        include_unmapped: Result<Option<bool>, String>,
    }

    impl<'a> FieldCapsGetWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                fields: Ok(None),
                ignore_unavailable: Ok(None),
                include_unmapped: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::FieldCapsGetWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `FieldCapsGetWithIndexIndex` for index failed".to_string()
            });
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.fields = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn include_unmapped<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.include_unmapped = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for include_unmapped failed".to_string());
            self
        }

        ///Sends a `GET` request to `/{index}/_field_caps`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                allow_no_indices,
                expand_wildcards,
                fields,
                ignore_unavailable,
                include_unmapped,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let fields = fields.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let include_unmapped = include_unmapped.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_field_caps",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &fields {
                query.push(("fields", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &include_unmapped {
                query.push(("include_unmapped", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::field_caps_post_with_index`]
    ///
    ///[`Client::field_caps_post_with_index`]: super::Client::field_caps_post_with_index
    #[derive(Debug, Clone)]
    pub struct FieldCapsPostWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::FieldCapsPostWithIndexIndex, String>,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        fields: Result<Option<Vec<String>>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        include_unmapped: Result<Option<bool>, String>,
        body: Result<types::FieldCapsBodyParams, String>,
    }

    impl<'a> FieldCapsPostWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                fields: Ok(None),
                ignore_unavailable: Ok(None),
                include_unmapped: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::FieldCapsPostWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `FieldCapsPostWithIndexIndex` for index failed".to_string()
            });
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.fields = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn include_unmapped<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.include_unmapped = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for include_unmapped failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::FieldCapsBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `FieldCapsBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `POST` request to `/{index}/_field_caps`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                allow_no_indices,
                expand_wildcards,
                fields,
                ignore_unavailable,
                include_unmapped,
                body,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let fields = fields.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let include_unmapped = include_unmapped.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_field_caps",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &fields {
                query.push(("fields", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &include_unmapped {
                query.push(("include_unmapped", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_flush_get_with_index`]
    ///
    ///[`Client::indices_flush_get_with_index`]: super::Client::indices_flush_get_with_index
    #[derive(Debug, Clone)]
    pub struct IndicesFlushGetWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesFlushGetWithIndexIndex, String>,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        force: Result<Option<bool>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        wait_if_ongoing: Result<Option<bool>, String>,
    }

    impl<'a> IndicesFlushGetWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                force: Ok(None),
                ignore_unavailable: Ok(None),
                wait_if_ongoing: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesFlushGetWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `IndicesFlushGetWithIndexIndex` for index failed".to_string()
            });
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn force<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.force = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for force failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn wait_if_ongoing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.wait_if_ongoing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for wait_if_ongoing failed".to_string());
            self
        }

        ///Sends a `GET` request to `/{index}/_flush`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                allow_no_indices,
                expand_wildcards,
                force,
                ignore_unavailable,
                wait_if_ongoing,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let force = force.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let wait_if_ongoing = wait_if_ongoing.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_flush",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &force {
                query.push(("force", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &wait_if_ongoing {
                query.push(("wait_if_ongoing", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_flush_post_with_index`]
    ///
    ///[`Client::indices_flush_post_with_index`]: super::Client::indices_flush_post_with_index
    #[derive(Debug, Clone)]
    pub struct IndicesFlushPostWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesFlushPostWithIndexIndex, String>,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        force: Result<Option<bool>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        wait_if_ongoing: Result<Option<bool>, String>,
    }

    impl<'a> IndicesFlushPostWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                force: Ok(None),
                ignore_unavailable: Ok(None),
                wait_if_ongoing: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesFlushPostWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `IndicesFlushPostWithIndexIndex` for index failed".to_string()
            });
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn force<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.force = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for force failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn wait_if_ongoing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.wait_if_ongoing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for wait_if_ongoing failed".to_string());
            self
        }

        ///Sends a `POST` request to `/{index}/_flush`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                allow_no_indices,
                expand_wildcards,
                force,
                ignore_unavailable,
                wait_if_ongoing,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let force = force.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let wait_if_ongoing = wait_if_ongoing.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_flush",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &force {
                query.push(("force", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &wait_if_ongoing {
                query.push(("wait_if_ongoing", v.to_string()));
            }
            let request = client.client.post(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_forcemerge_with_index`]
    ///
    ///[`Client::indices_forcemerge_with_index`]: super::Client::indices_forcemerge_with_index
    #[derive(Debug, Clone)]
    pub struct IndicesForcemergeWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesForcemergeWithIndexIndex, String>,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        flush: Result<Option<bool>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        max_num_segments: Result<Option<i32>, String>,
        only_expunge_deletes: Result<Option<bool>, String>,
    }

    impl<'a> IndicesForcemergeWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                flush: Ok(None),
                ignore_unavailable: Ok(None),
                max_num_segments: Ok(None),
                only_expunge_deletes: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesForcemergeWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `IndicesForcemergeWithIndexIndex` for index failed".to_string()
            });
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn flush<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.flush = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for flush failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn max_num_segments<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.max_num_segments = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for max_num_segments failed".to_string());
            self
        }

        pub fn only_expunge_deletes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.only_expunge_deletes = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for only_expunge_deletes failed".to_string());
            self
        }

        ///Sends a `POST` request to `/{index}/_forcemerge`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                allow_no_indices,
                expand_wildcards,
                flush,
                ignore_unavailable,
                max_num_segments,
                only_expunge_deletes,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let flush = flush.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let max_num_segments = max_num_segments.map_err(Error::InvalidRequest)?;
            let only_expunge_deletes = only_expunge_deletes.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_forcemerge",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(6usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &flush {
                query.push(("flush", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &max_num_segments {
                query.push(("max_num_segments", v.to_string()));
            }
            if let Some(v) = &only_expunge_deletes {
                query.push(("only_expunge_deletes", v.to_string()));
            }
            let request = client.client.post(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_get_mapping_with_index`]
    ///
    ///[`Client::indices_get_mapping_with_index`]: super::Client::indices_get_mapping_with_index
    #[derive(Debug, Clone)]
    pub struct IndicesGetMappingWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesGetMappingWithIndexIndex, String>,
        allow_no_indices: Result<Option<bool>, String>,
        cluster_manager_timeout:
            Result<Option<types::IndicesGetMappingWithIndexClusterManagerTimeout>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::IndicesGetMappingWithIndexMasterTimeout>, String>,
    }

    impl<'a> IndicesGetMappingWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                allow_no_indices: Ok(None),
                cluster_manager_timeout: Ok(None),
                expand_wildcards: Ok(None),
                ignore_unavailable: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesGetMappingWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `IndicesGetMappingWithIndexIndex` for index failed".to_string()
            });
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesGetMappingWithIndexClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesGetMappingWithIndexClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesGetMappingWithIndexMasterTimeout>,
        {
            self . master_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesGetMappingWithIndexMasterTimeout` for master_timeout failed" . to_string ()) ;
            self
        }

        ///Sends a `GET` request to `/{index}/_mapping`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                allow_no_indices,
                cluster_manager_timeout,
                expand_wildcards,
                ignore_unavailable,
                local,
                master_timeout,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_mapping",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(6usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_put_mapping_put`]
    ///
    ///[`Client::indices_put_mapping_put`]: super::Client::indices_put_mapping_put
    #[derive(Debug, Clone)]
    pub struct IndicesPutMappingPut<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesPutMappingPutIndex, String>,
        allow_no_indices: Result<Option<bool>, String>,
        cluster_manager_timeout:
            Result<Option<types::IndicesPutMappingPutClusterManagerTimeout>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::IndicesPutMappingPutMasterTimeout>, String>,
        timeout: Result<Option<types::IndicesPutMappingPutTimeout>, String>,
        write_index_only: Result<Option<bool>, String>,
        body: Result<types::IndicesPutMappingBodyParams, String>,
    }

    impl<'a> IndicesPutMappingPut<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                allow_no_indices: Ok(None),
                cluster_manager_timeout: Ok(None),
                expand_wildcards: Ok(None),
                ignore_unavailable: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
                write_index_only: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutMappingPutIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `IndicesPutMappingPutIndex` for index failed".to_string()
            });
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutMappingPutClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesPutMappingPutClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutMappingPutMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesPutMappingPutMasterTimeout` for master_timeout failed"
                    .to_string()
            });
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutMappingPutTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesPutMappingPutTimeout` for timeout failed".to_string()
            });
            self
        }

        pub fn write_index_only<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.write_index_only = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for write_index_only failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutMappingBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `IndicesPutMappingBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `PUT` request to `/{index}/_mapping`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::IndicesPutMappingPutResponseContent>, Error<()>> {
            let Self {
                client,
                index,
                allow_no_indices,
                cluster_manager_timeout,
                expand_wildcards,
                ignore_unavailable,
                master_timeout,
                timeout,
                write_index_only,
                body,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let write_index_only = write_index_only.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_mapping",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(7usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &write_index_only {
                query.push(("write_index_only", v.to_string()));
            }
            let request = client
                .client
                .put(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_put_mapping_post`]
    ///
    ///[`Client::indices_put_mapping_post`]: super::Client::indices_put_mapping_post
    #[derive(Debug, Clone)]
    pub struct IndicesPutMappingPost<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesPutMappingPostIndex, String>,
        allow_no_indices: Result<Option<bool>, String>,
        cluster_manager_timeout:
            Result<Option<types::IndicesPutMappingPostClusterManagerTimeout>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::IndicesPutMappingPostMasterTimeout>, String>,
        timeout: Result<Option<types::IndicesPutMappingPostTimeout>, String>,
        write_index_only: Result<Option<bool>, String>,
        body: Result<types::IndicesPutMappingBodyParams, String>,
    }

    impl<'a> IndicesPutMappingPost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                allow_no_indices: Ok(None),
                cluster_manager_timeout: Ok(None),
                expand_wildcards: Ok(None),
                ignore_unavailable: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
                write_index_only: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutMappingPostIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `IndicesPutMappingPostIndex` for index failed".to_string()
            });
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutMappingPostClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesPutMappingPostClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutMappingPostMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesPutMappingPostMasterTimeout` for master_timeout failed"
                    .to_string()
            });
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutMappingPostTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesPutMappingPostTimeout` for timeout failed".to_string()
            });
            self
        }

        pub fn write_index_only<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.write_index_only = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for write_index_only failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutMappingBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `IndicesPutMappingBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `POST` request to `/{index}/_mapping`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::IndicesPutMappingPostResponseContent>, Error<()>> {
            let Self {
                client,
                index,
                allow_no_indices,
                cluster_manager_timeout,
                expand_wildcards,
                ignore_unavailable,
                master_timeout,
                timeout,
                write_index_only,
                body,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let write_index_only = write_index_only.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_mapping",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(7usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &write_index_only {
                query.push(("write_index_only", v.to_string()));
            }
            let request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_get_field_mapping_with_index`]
    ///
    ///[`Client::indices_get_field_mapping_with_index`]: super::Client::indices_get_field_mapping_with_index
    #[derive(Debug, Clone)]
    pub struct IndicesGetFieldMappingWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesGetFieldMappingWithIndexIndex, String>,
        fields: Result<types::IndicesGetFieldMappingWithIndexFields, String>,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        include_defaults: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
    }

    impl<'a> IndicesGetFieldMappingWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                fields: Err("fields was not initialized".to_string()),
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                ignore_unavailable: Ok(None),
                include_defaults: Ok(None),
                local: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesGetFieldMappingWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `IndicesGetFieldMappingWithIndexIndex` for index failed".to_string()
            });
            self
        }

        pub fn fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesGetFieldMappingWithIndexFields>,
        {
            self.fields = value.try_into().map_err(|_| {
                "conversion to `IndicesGetFieldMappingWithIndexFields` for fields failed"
                    .to_string()
            });
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn include_defaults<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.include_defaults = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for include_defaults failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        ///Sends a `GET` request to `/{index}/_mapping/field/{fields}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                fields,
                allow_no_indices,
                expand_wildcards,
                ignore_unavailable,
                include_defaults,
                local,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let fields = fields.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let include_defaults = include_defaults.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_mapping/field/{}",
                client.baseurl,
                encode_path(&index.to_string()),
                encode_path(&fields.to_string()),
            );
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &include_defaults {
                query.push(("include_defaults", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::mget_get_with_index`]
    ///
    ///[`Client::mget_get_with_index`]: super::Client::mget_get_with_index
    #[derive(Debug, Clone)]
    pub struct MgetGetWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::MgetGetWithIndexIndex, String>,
        source: Result<Option<Vec<String>>, String>,
        source_excludes: Result<Option<Vec<String>>, String>,
        source_includes: Result<Option<Vec<String>>, String>,
        preference: Result<Option<String>, String>,
        realtime: Result<Option<bool>, String>,
        refresh: Result<Option<bool>, String>,
        routing: Result<Option<String>, String>,
        stored_fields: Result<Option<Vec<String>>, String>,
    }

    impl<'a> MgetGetWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                source: Ok(None),
                source_excludes: Ok(None),
                source_includes: Ok(None),
                preference: Ok(None),
                realtime: Ok(None),
                refresh: Ok(None),
                routing: Ok(None),
                stored_fields: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::MgetGetWithIndexIndex>,
        {
            self.index = value
                .try_into()
                .map_err(|_| "conversion to `MgetGetWithIndexIndex` for index failed".to_string());
            self
        }

        pub fn source<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for source failed".to_string());
            self
        }

        pub fn source_excludes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_excludes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_excludes failed".to_string()
            });
            self
        }

        pub fn source_includes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_includes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_includes failed".to_string()
            });
            self
        }

        pub fn preference<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.preference = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for preference failed".to_string());
            self
        }

        pub fn realtime<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.realtime = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for realtime failed".to_string());
            self
        }

        pub fn refresh<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.refresh = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for refresh failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for routing failed".to_string());
            self
        }

        pub fn stored_fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.stored_fields = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for stored_fields failed".to_string());
            self
        }

        ///Sends a `GET` request to `/{index}/_mget`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                source,
                source_excludes,
                source_includes,
                preference,
                realtime,
                refresh,
                routing,
                stored_fields,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let source = source.map_err(Error::InvalidRequest)?;
            let source_excludes = source_excludes.map_err(Error::InvalidRequest)?;
            let source_includes = source_includes.map_err(Error::InvalidRequest)?;
            let preference = preference.map_err(Error::InvalidRequest)?;
            let realtime = realtime.map_err(Error::InvalidRequest)?;
            let refresh = refresh.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let stored_fields = stored_fields.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_mget",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(8usize);
            if let Some(v) = &source {
                query.push(("_source", v.to_string()));
            }
            if let Some(v) = &source_excludes {
                query.push(("_source_excludes", v.to_string()));
            }
            if let Some(v) = &source_includes {
                query.push(("_source_includes", v.to_string()));
            }
            if let Some(v) = &preference {
                query.push(("preference", v.to_string()));
            }
            if let Some(v) = &realtime {
                query.push(("realtime", v.to_string()));
            }
            if let Some(v) = &refresh {
                query.push(("refresh", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &stored_fields {
                query.push(("stored_fields", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::mget_post_with_index`]
    ///
    ///[`Client::mget_post_with_index`]: super::Client::mget_post_with_index
    #[derive(Debug, Clone)]
    pub struct MgetPostWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::MgetPostWithIndexIndex, String>,
        source: Result<Option<Vec<String>>, String>,
        source_excludes: Result<Option<Vec<String>>, String>,
        source_includes: Result<Option<Vec<String>>, String>,
        preference: Result<Option<String>, String>,
        realtime: Result<Option<bool>, String>,
        refresh: Result<Option<bool>, String>,
        routing: Result<Option<String>, String>,
        stored_fields: Result<Option<Vec<String>>, String>,
        body: Result<types::MgetBodyParams, String>,
    }

    impl<'a> MgetPostWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                source: Ok(None),
                source_excludes: Ok(None),
                source_includes: Ok(None),
                preference: Ok(None),
                realtime: Ok(None),
                refresh: Ok(None),
                routing: Ok(None),
                stored_fields: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::MgetPostWithIndexIndex>,
        {
            self.index = value
                .try_into()
                .map_err(|_| "conversion to `MgetPostWithIndexIndex` for index failed".to_string());
            self
        }

        pub fn source<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for source failed".to_string());
            self
        }

        pub fn source_excludes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_excludes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_excludes failed".to_string()
            });
            self
        }

        pub fn source_includes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_includes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_includes failed".to_string()
            });
            self
        }

        pub fn preference<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.preference = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for preference failed".to_string());
            self
        }

        pub fn realtime<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.realtime = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for realtime failed".to_string());
            self
        }

        pub fn refresh<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.refresh = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for refresh failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for routing failed".to_string());
            self
        }

        pub fn stored_fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.stored_fields = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for stored_fields failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::MgetBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `MgetBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `POST` request to `/{index}/_mget`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                source,
                source_excludes,
                source_includes,
                preference,
                realtime,
                refresh,
                routing,
                stored_fields,
                body,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let source = source.map_err(Error::InvalidRequest)?;
            let source_excludes = source_excludes.map_err(Error::InvalidRequest)?;
            let source_includes = source_includes.map_err(Error::InvalidRequest)?;
            let preference = preference.map_err(Error::InvalidRequest)?;
            let realtime = realtime.map_err(Error::InvalidRequest)?;
            let refresh = refresh.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let stored_fields = stored_fields.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_mget",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(8usize);
            if let Some(v) = &source {
                query.push(("_source", v.to_string()));
            }
            if let Some(v) = &source_excludes {
                query.push(("_source_excludes", v.to_string()));
            }
            if let Some(v) = &source_includes {
                query.push(("_source_includes", v.to_string()));
            }
            if let Some(v) = &preference {
                query.push(("preference", v.to_string()));
            }
            if let Some(v) = &realtime {
                query.push(("realtime", v.to_string()));
            }
            if let Some(v) = &refresh {
                query.push(("refresh", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &stored_fields {
                query.push(("stored_fields", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::msearch_get_with_index`]
    ///
    ///[`Client::msearch_get_with_index`]: super::Client::msearch_get_with_index
    #[derive(Debug, Clone)]
    pub struct MsearchGetWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::MsearchGetWithIndexIndex, String>,
        ccs_minimize_roundtrips: Result<Option<bool>, String>,
        max_concurrent_searches: Result<Option<i32>, String>,
        max_concurrent_shard_requests: Result<Option<i32>, String>,
        pre_filter_shard_size: Result<Option<i32>, String>,
        rest_total_hits_as_int: Result<Option<bool>, String>,
        search_type: Result<Option<types::SearchTypeMulti>, String>,
        typed_keys: Result<Option<bool>, String>,
    }

    impl<'a> MsearchGetWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                ccs_minimize_roundtrips: Ok(None),
                max_concurrent_searches: Ok(None),
                max_concurrent_shard_requests: Ok(None),
                pre_filter_shard_size: Ok(None),
                rest_total_hits_as_int: Ok(None),
                search_type: Ok(None),
                typed_keys: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::MsearchGetWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `MsearchGetWithIndexIndex` for index failed".to_string()
            });
            self
        }

        pub fn ccs_minimize_roundtrips<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ccs_minimize_roundtrips = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ccs_minimize_roundtrips failed".to_string());
            self
        }

        pub fn max_concurrent_searches<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.max_concurrent_searches = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for max_concurrent_searches failed".to_string());
            self
        }

        pub fn max_concurrent_shard_requests<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.max_concurrent_shard_requests = value.try_into().map(Some).map_err(|_| {
                "conversion to `i32` for max_concurrent_shard_requests failed".to_string()
            });
            self
        }

        pub fn pre_filter_shard_size<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.pre_filter_shard_size = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for pre_filter_shard_size failed".to_string());
            self
        }

        pub fn rest_total_hits_as_int<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.rest_total_hits_as_int = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for rest_total_hits_as_int failed".to_string());
            self
        }

        pub fn search_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchTypeMulti>,
        {
            self.search_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SearchTypeMulti` for search_type failed".to_string());
            self
        }

        pub fn typed_keys<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.typed_keys = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for typed_keys failed".to_string());
            self
        }

        ///Sends a `GET` request to `/{index}/_msearch`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                ccs_minimize_roundtrips,
                max_concurrent_searches,
                max_concurrent_shard_requests,
                pre_filter_shard_size,
                rest_total_hits_as_int,
                search_type,
                typed_keys,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let ccs_minimize_roundtrips = ccs_minimize_roundtrips.map_err(Error::InvalidRequest)?;
            let max_concurrent_searches = max_concurrent_searches.map_err(Error::InvalidRequest)?;
            let max_concurrent_shard_requests =
                max_concurrent_shard_requests.map_err(Error::InvalidRequest)?;
            let pre_filter_shard_size = pre_filter_shard_size.map_err(Error::InvalidRequest)?;
            let rest_total_hits_as_int = rest_total_hits_as_int.map_err(Error::InvalidRequest)?;
            let search_type = search_type.map_err(Error::InvalidRequest)?;
            let typed_keys = typed_keys.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_msearch",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(7usize);
            if let Some(v) = &ccs_minimize_roundtrips {
                query.push(("ccs_minimize_roundtrips", v.to_string()));
            }
            if let Some(v) = &max_concurrent_searches {
                query.push(("max_concurrent_searches", v.to_string()));
            }
            if let Some(v) = &max_concurrent_shard_requests {
                query.push(("max_concurrent_shard_requests", v.to_string()));
            }
            if let Some(v) = &pre_filter_shard_size {
                query.push(("pre_filter_shard_size", v.to_string()));
            }
            if let Some(v) = &rest_total_hits_as_int {
                query.push(("rest_total_hits_as_int", v.to_string()));
            }
            if let Some(v) = &search_type {
                query.push(("search_type", v.to_string()));
            }
            if let Some(v) = &typed_keys {
                query.push(("typed_keys", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::msearch_post_with_index`]
    ///
    ///[`Client::msearch_post_with_index`]: super::Client::msearch_post_with_index
    #[derive(Debug, Clone)]
    pub struct MsearchPostWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::MsearchPostWithIndexIndex, String>,
        ccs_minimize_roundtrips: Result<Option<bool>, String>,
        max_concurrent_searches: Result<Option<i32>, String>,
        max_concurrent_shard_requests: Result<Option<i32>, String>,
        pre_filter_shard_size: Result<Option<i32>, String>,
        rest_total_hits_as_int: Result<Option<bool>, String>,
        search_type: Result<Option<types::SearchTypeMulti>, String>,
        typed_keys: Result<Option<bool>, String>,
        body: Result<types::MsearchBodyParams, String>,
    }

    impl<'a> MsearchPostWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                ccs_minimize_roundtrips: Ok(None),
                max_concurrent_searches: Ok(None),
                max_concurrent_shard_requests: Ok(None),
                pre_filter_shard_size: Ok(None),
                rest_total_hits_as_int: Ok(None),
                search_type: Ok(None),
                typed_keys: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::MsearchPostWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `MsearchPostWithIndexIndex` for index failed".to_string()
            });
            self
        }

        pub fn ccs_minimize_roundtrips<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ccs_minimize_roundtrips = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ccs_minimize_roundtrips failed".to_string());
            self
        }

        pub fn max_concurrent_searches<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.max_concurrent_searches = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for max_concurrent_searches failed".to_string());
            self
        }

        pub fn max_concurrent_shard_requests<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.max_concurrent_shard_requests = value.try_into().map(Some).map_err(|_| {
                "conversion to `i32` for max_concurrent_shard_requests failed".to_string()
            });
            self
        }

        pub fn pre_filter_shard_size<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.pre_filter_shard_size = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for pre_filter_shard_size failed".to_string());
            self
        }

        pub fn rest_total_hits_as_int<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.rest_total_hits_as_int = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for rest_total_hits_as_int failed".to_string());
            self
        }

        pub fn search_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchTypeMulti>,
        {
            self.search_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SearchTypeMulti` for search_type failed".to_string());
            self
        }

        pub fn typed_keys<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.typed_keys = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for typed_keys failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::MsearchBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `MsearchBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `POST` request to `/{index}/_msearch`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                ccs_minimize_roundtrips,
                max_concurrent_searches,
                max_concurrent_shard_requests,
                pre_filter_shard_size,
                rest_total_hits_as_int,
                search_type,
                typed_keys,
                body,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let ccs_minimize_roundtrips = ccs_minimize_roundtrips.map_err(Error::InvalidRequest)?;
            let max_concurrent_searches = max_concurrent_searches.map_err(Error::InvalidRequest)?;
            let max_concurrent_shard_requests =
                max_concurrent_shard_requests.map_err(Error::InvalidRequest)?;
            let pre_filter_shard_size = pre_filter_shard_size.map_err(Error::InvalidRequest)?;
            let rest_total_hits_as_int = rest_total_hits_as_int.map_err(Error::InvalidRequest)?;
            let search_type = search_type.map_err(Error::InvalidRequest)?;
            let typed_keys = typed_keys.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_msearch",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(7usize);
            if let Some(v) = &ccs_minimize_roundtrips {
                query.push(("ccs_minimize_roundtrips", v.to_string()));
            }
            if let Some(v) = &max_concurrent_searches {
                query.push(("max_concurrent_searches", v.to_string()));
            }
            if let Some(v) = &max_concurrent_shard_requests {
                query.push(("max_concurrent_shard_requests", v.to_string()));
            }
            if let Some(v) = &pre_filter_shard_size {
                query.push(("pre_filter_shard_size", v.to_string()));
            }
            if let Some(v) = &rest_total_hits_as_int {
                query.push(("rest_total_hits_as_int", v.to_string()));
            }
            if let Some(v) = &search_type {
                query.push(("search_type", v.to_string()));
            }
            if let Some(v) = &typed_keys {
                query.push(("typed_keys", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::msearch_template_get_with_index`]
    ///
    ///[`Client::msearch_template_get_with_index`]: super::Client::msearch_template_get_with_index
    #[derive(Debug, Clone)]
    pub struct MsearchTemplateGetWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::MsearchTemplateGetWithIndexIndex, String>,
        ccs_minimize_roundtrips: Result<Option<bool>, String>,
        max_concurrent_searches: Result<Option<i32>, String>,
        rest_total_hits_as_int: Result<Option<bool>, String>,
        search_type: Result<Option<types::SearchTypeMulti>, String>,
        typed_keys: Result<Option<bool>, String>,
    }

    impl<'a> MsearchTemplateGetWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                ccs_minimize_roundtrips: Ok(None),
                max_concurrent_searches: Ok(None),
                rest_total_hits_as_int: Ok(None),
                search_type: Ok(None),
                typed_keys: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::MsearchTemplateGetWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `MsearchTemplateGetWithIndexIndex` for index failed".to_string()
            });
            self
        }

        pub fn ccs_minimize_roundtrips<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ccs_minimize_roundtrips = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ccs_minimize_roundtrips failed".to_string());
            self
        }

        pub fn max_concurrent_searches<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.max_concurrent_searches = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for max_concurrent_searches failed".to_string());
            self
        }

        pub fn rest_total_hits_as_int<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.rest_total_hits_as_int = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for rest_total_hits_as_int failed".to_string());
            self
        }

        pub fn search_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchTypeMulti>,
        {
            self.search_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SearchTypeMulti` for search_type failed".to_string());
            self
        }

        pub fn typed_keys<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.typed_keys = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for typed_keys failed".to_string());
            self
        }

        ///Sends a `GET` request to `/{index}/_msearch/template`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                ccs_minimize_roundtrips,
                max_concurrent_searches,
                rest_total_hits_as_int,
                search_type,
                typed_keys,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let ccs_minimize_roundtrips = ccs_minimize_roundtrips.map_err(Error::InvalidRequest)?;
            let max_concurrent_searches = max_concurrent_searches.map_err(Error::InvalidRequest)?;
            let rest_total_hits_as_int = rest_total_hits_as_int.map_err(Error::InvalidRequest)?;
            let search_type = search_type.map_err(Error::InvalidRequest)?;
            let typed_keys = typed_keys.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_msearch/template",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &ccs_minimize_roundtrips {
                query.push(("ccs_minimize_roundtrips", v.to_string()));
            }
            if let Some(v) = &max_concurrent_searches {
                query.push(("max_concurrent_searches", v.to_string()));
            }
            if let Some(v) = &rest_total_hits_as_int {
                query.push(("rest_total_hits_as_int", v.to_string()));
            }
            if let Some(v) = &search_type {
                query.push(("search_type", v.to_string()));
            }
            if let Some(v) = &typed_keys {
                query.push(("typed_keys", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::msearch_template_post_with_index`]
    ///
    ///[`Client::msearch_template_post_with_index`]: super::Client::msearch_template_post_with_index
    #[derive(Debug, Clone)]
    pub struct MsearchTemplatePostWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::MsearchTemplatePostWithIndexIndex, String>,
        ccs_minimize_roundtrips: Result<Option<bool>, String>,
        max_concurrent_searches: Result<Option<i32>, String>,
        rest_total_hits_as_int: Result<Option<bool>, String>,
        search_type: Result<Option<types::SearchTypeMulti>, String>,
        typed_keys: Result<Option<bool>, String>,
        body: Result<types::MsearchTemplateBodyParams, String>,
    }

    impl<'a> MsearchTemplatePostWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                ccs_minimize_roundtrips: Ok(None),
                max_concurrent_searches: Ok(None),
                rest_total_hits_as_int: Ok(None),
                search_type: Ok(None),
                typed_keys: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::MsearchTemplatePostWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `MsearchTemplatePostWithIndexIndex` for index failed".to_string()
            });
            self
        }

        pub fn ccs_minimize_roundtrips<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ccs_minimize_roundtrips = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ccs_minimize_roundtrips failed".to_string());
            self
        }

        pub fn max_concurrent_searches<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.max_concurrent_searches = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for max_concurrent_searches failed".to_string());
            self
        }

        pub fn rest_total_hits_as_int<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.rest_total_hits_as_int = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for rest_total_hits_as_int failed".to_string());
            self
        }

        pub fn search_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchTypeMulti>,
        {
            self.search_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SearchTypeMulti` for search_type failed".to_string());
            self
        }

        pub fn typed_keys<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.typed_keys = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for typed_keys failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::MsearchTemplateBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `MsearchTemplateBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `POST` request to `/{index}/_msearch/template`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                ccs_minimize_roundtrips,
                max_concurrent_searches,
                rest_total_hits_as_int,
                search_type,
                typed_keys,
                body,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let ccs_minimize_roundtrips = ccs_minimize_roundtrips.map_err(Error::InvalidRequest)?;
            let max_concurrent_searches = max_concurrent_searches.map_err(Error::InvalidRequest)?;
            let rest_total_hits_as_int = rest_total_hits_as_int.map_err(Error::InvalidRequest)?;
            let search_type = search_type.map_err(Error::InvalidRequest)?;
            let typed_keys = typed_keys.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_msearch/template",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &ccs_minimize_roundtrips {
                query.push(("ccs_minimize_roundtrips", v.to_string()));
            }
            if let Some(v) = &max_concurrent_searches {
                query.push(("max_concurrent_searches", v.to_string()));
            }
            if let Some(v) = &rest_total_hits_as_int {
                query.push(("rest_total_hits_as_int", v.to_string()));
            }
            if let Some(v) = &search_type {
                query.push(("search_type", v.to_string()));
            }
            if let Some(v) = &typed_keys {
                query.push(("typed_keys", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::mtermvectors_get_with_index`]
    ///
    ///[`Client::mtermvectors_get_with_index`]: super::Client::mtermvectors_get_with_index
    #[derive(Debug, Clone)]
    pub struct MtermvectorsGetWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::MtermvectorsGetWithIndexIndex, String>,
        field_statistics: Result<Option<bool>, String>,
        fields: Result<Option<Vec<String>>, String>,
        ids: Result<Option<Vec<String>>, String>,
        offsets: Result<Option<bool>, String>,
        payloads: Result<Option<bool>, String>,
        positions: Result<Option<bool>, String>,
        preference: Result<Option<String>, String>,
        realtime: Result<Option<bool>, String>,
        routing: Result<Option<String>, String>,
        term_statistics: Result<Option<bool>, String>,
        version: Result<Option<i32>, String>,
        version_type: Result<Option<types::VersionType>, String>,
    }

    impl<'a> MtermvectorsGetWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                field_statistics: Ok(None),
                fields: Ok(None),
                ids: Ok(None),
                offsets: Ok(None),
                payloads: Ok(None),
                positions: Ok(None),
                preference: Ok(None),
                realtime: Ok(None),
                routing: Ok(None),
                term_statistics: Ok(None),
                version: Ok(None),
                version_type: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::MtermvectorsGetWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `MtermvectorsGetWithIndexIndex` for index failed".to_string()
            });
            self
        }

        pub fn field_statistics<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.field_statistics = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for field_statistics failed".to_string());
            self
        }

        pub fn fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.fields = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
            self
        }

        pub fn ids<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.ids = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for ids failed".to_string());
            self
        }

        pub fn offsets<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.offsets = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for offsets failed".to_string());
            self
        }

        pub fn payloads<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.payloads = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for payloads failed".to_string());
            self
        }

        pub fn positions<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.positions = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for positions failed".to_string());
            self
        }

        pub fn preference<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.preference = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for preference failed".to_string());
            self
        }

        pub fn realtime<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.realtime = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for realtime failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for routing failed".to_string());
            self
        }

        pub fn term_statistics<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.term_statistics = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for term_statistics failed".to_string());
            self
        }

        pub fn version<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.version = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for version failed".to_string());
            self
        }

        pub fn version_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VersionType>,
        {
            self.version_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `VersionType` for version_type failed".to_string());
            self
        }

        ///Sends a `GET` request to `/{index}/_mtermvectors`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                field_statistics,
                fields,
                ids,
                offsets,
                payloads,
                positions,
                preference,
                realtime,
                routing,
                term_statistics,
                version,
                version_type,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let field_statistics = field_statistics.map_err(Error::InvalidRequest)?;
            let fields = fields.map_err(Error::InvalidRequest)?;
            let ids = ids.map_err(Error::InvalidRequest)?;
            let offsets = offsets.map_err(Error::InvalidRequest)?;
            let payloads = payloads.map_err(Error::InvalidRequest)?;
            let positions = positions.map_err(Error::InvalidRequest)?;
            let preference = preference.map_err(Error::InvalidRequest)?;
            let realtime = realtime.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let term_statistics = term_statistics.map_err(Error::InvalidRequest)?;
            let version = version.map_err(Error::InvalidRequest)?;
            let version_type = version_type.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_mtermvectors",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(12usize);
            if let Some(v) = &field_statistics {
                query.push(("field_statistics", v.to_string()));
            }
            if let Some(v) = &fields {
                query.push(("fields", v.to_string()));
            }
            if let Some(v) = &ids {
                query.push(("ids", v.to_string()));
            }
            if let Some(v) = &offsets {
                query.push(("offsets", v.to_string()));
            }
            if let Some(v) = &payloads {
                query.push(("payloads", v.to_string()));
            }
            if let Some(v) = &positions {
                query.push(("positions", v.to_string()));
            }
            if let Some(v) = &preference {
                query.push(("preference", v.to_string()));
            }
            if let Some(v) = &realtime {
                query.push(("realtime", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &term_statistics {
                query.push(("term_statistics", v.to_string()));
            }
            if let Some(v) = &version {
                query.push(("version", v.to_string()));
            }
            if let Some(v) = &version_type {
                query.push(("version_type", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::mtermvectors_post_with_index`]
    ///
    ///[`Client::mtermvectors_post_with_index`]: super::Client::mtermvectors_post_with_index
    #[derive(Debug, Clone)]
    pub struct MtermvectorsPostWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::MtermvectorsPostWithIndexIndex, String>,
        field_statistics: Result<Option<bool>, String>,
        fields: Result<Option<Vec<String>>, String>,
        ids: Result<Option<Vec<String>>, String>,
        offsets: Result<Option<bool>, String>,
        payloads: Result<Option<bool>, String>,
        positions: Result<Option<bool>, String>,
        preference: Result<Option<String>, String>,
        realtime: Result<Option<bool>, String>,
        routing: Result<Option<String>, String>,
        term_statistics: Result<Option<bool>, String>,
        version: Result<Option<i32>, String>,
        version_type: Result<Option<types::VersionType>, String>,
        body: Result<types::MtermvectorsBodyParams, String>,
    }

    impl<'a> MtermvectorsPostWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                field_statistics: Ok(None),
                fields: Ok(None),
                ids: Ok(None),
                offsets: Ok(None),
                payloads: Ok(None),
                positions: Ok(None),
                preference: Ok(None),
                realtime: Ok(None),
                routing: Ok(None),
                term_statistics: Ok(None),
                version: Ok(None),
                version_type: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::MtermvectorsPostWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `MtermvectorsPostWithIndexIndex` for index failed".to_string()
            });
            self
        }

        pub fn field_statistics<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.field_statistics = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for field_statistics failed".to_string());
            self
        }

        pub fn fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.fields = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
            self
        }

        pub fn ids<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.ids = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for ids failed".to_string());
            self
        }

        pub fn offsets<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.offsets = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for offsets failed".to_string());
            self
        }

        pub fn payloads<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.payloads = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for payloads failed".to_string());
            self
        }

        pub fn positions<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.positions = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for positions failed".to_string());
            self
        }

        pub fn preference<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.preference = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for preference failed".to_string());
            self
        }

        pub fn realtime<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.realtime = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for realtime failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for routing failed".to_string());
            self
        }

        pub fn term_statistics<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.term_statistics = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for term_statistics failed".to_string());
            self
        }

        pub fn version<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.version = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for version failed".to_string());
            self
        }

        pub fn version_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VersionType>,
        {
            self.version_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `VersionType` for version_type failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::MtermvectorsBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `MtermvectorsBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `POST` request to `/{index}/_mtermvectors`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                field_statistics,
                fields,
                ids,
                offsets,
                payloads,
                positions,
                preference,
                realtime,
                routing,
                term_statistics,
                version,
                version_type,
                body,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let field_statistics = field_statistics.map_err(Error::InvalidRequest)?;
            let fields = fields.map_err(Error::InvalidRequest)?;
            let ids = ids.map_err(Error::InvalidRequest)?;
            let offsets = offsets.map_err(Error::InvalidRequest)?;
            let payloads = payloads.map_err(Error::InvalidRequest)?;
            let positions = positions.map_err(Error::InvalidRequest)?;
            let preference = preference.map_err(Error::InvalidRequest)?;
            let realtime = realtime.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let term_statistics = term_statistics.map_err(Error::InvalidRequest)?;
            let version = version.map_err(Error::InvalidRequest)?;
            let version_type = version_type.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_mtermvectors",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(12usize);
            if let Some(v) = &field_statistics {
                query.push(("field_statistics", v.to_string()));
            }
            if let Some(v) = &fields {
                query.push(("fields", v.to_string()));
            }
            if let Some(v) = &ids {
                query.push(("ids", v.to_string()));
            }
            if let Some(v) = &offsets {
                query.push(("offsets", v.to_string()));
            }
            if let Some(v) = &payloads {
                query.push(("payloads", v.to_string()));
            }
            if let Some(v) = &positions {
                query.push(("positions", v.to_string()));
            }
            if let Some(v) = &preference {
                query.push(("preference", v.to_string()));
            }
            if let Some(v) = &realtime {
                query.push(("realtime", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &term_statistics {
                query.push(("term_statistics", v.to_string()));
            }
            if let Some(v) = &version {
                query.push(("version", v.to_string()));
            }
            if let Some(v) = &version_type {
                query.push(("version_type", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_open`]
    ///
    ///[`Client::indices_open`]: super::Client::indices_open
    #[derive(Debug, Clone)]
    pub struct IndicesOpen<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesOpenIndex, String>,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::IndicesOpenMasterTimeout>, String>,
        timeout: Result<Option<types::IndicesOpenTimeout>, String>,
        wait_for_active_shards: Result<Option<String>, String>,
    }

    impl<'a> IndicesOpen<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                ignore_unavailable: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
                wait_for_active_shards: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesOpenIndex>,
        {
            self.index = value
                .try_into()
                .map_err(|_| "conversion to `IndicesOpenIndex` for index failed".to_string());
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesOpenMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesOpenMasterTimeout` for master_timeout failed".to_string()
            });
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesOpenTimeout>,
        {
            self.timeout = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IndicesOpenTimeout` for timeout failed".to_string());
            self
        }

        pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.wait_for_active_shards = value.try_into().map(Some).map_err(|_| {
                "conversion to `String` for wait_for_active_shards failed".to_string()
            });
            self
        }

        ///Sends a `POST` request to `/{index}/_open`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                allow_no_indices,
                expand_wildcards,
                ignore_unavailable,
                master_timeout,
                timeout,
                wait_for_active_shards,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_open",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(6usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &wait_for_active_shards {
                query.push(("wait_for_active_shards", v.to_string()));
            }
            let request = client.client.post(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::rank_eval_get_with_index`]
    ///
    ///[`Client::rank_eval_get_with_index`]: super::Client::rank_eval_get_with_index
    #[derive(Debug, Clone)]
    pub struct RankEvalGetWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::RankEvalGetWithIndexIndex, String>,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        search_type: Result<Option<types::SearchType>, String>,
    }

    impl<'a> RankEvalGetWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                ignore_unavailable: Ok(None),
                search_type: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RankEvalGetWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `RankEvalGetWithIndexIndex` for index failed".to_string()
            });
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn search_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchType>,
        {
            self.search_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SearchType` for search_type failed".to_string());
            self
        }

        ///Sends a `GET` request to `/{index}/_rank_eval`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                allow_no_indices,
                expand_wildcards,
                ignore_unavailable,
                search_type,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let search_type = search_type.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_rank_eval",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &search_type {
                query.push(("search_type", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::rank_eval_post_with_index`]
    ///
    ///[`Client::rank_eval_post_with_index`]: super::Client::rank_eval_post_with_index
    #[derive(Debug, Clone)]
    pub struct RankEvalPostWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::RankEvalPostWithIndexIndex, String>,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        search_type: Result<Option<types::SearchType>, String>,
        body: Result<types::RankEvalBodyParams, String>,
    }

    impl<'a> RankEvalPostWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                ignore_unavailable: Ok(None),
                search_type: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RankEvalPostWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `RankEvalPostWithIndexIndex` for index failed".to_string()
            });
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn search_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchType>,
        {
            self.search_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SearchType` for search_type failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RankEvalBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `RankEvalBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `POST` request to `/{index}/_rank_eval`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                allow_no_indices,
                expand_wildcards,
                ignore_unavailable,
                search_type,
                body,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let search_type = search_type.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_rank_eval",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &search_type {
                query.push(("search_type", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_recovery_with_index`]
    ///
    ///[`Client::indices_recovery_with_index`]: super::Client::indices_recovery_with_index
    #[derive(Debug, Clone)]
    pub struct IndicesRecoveryWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesRecoveryWithIndexIndex, String>,
        active_only: Result<Option<bool>, String>,
        detailed: Result<Option<bool>, String>,
    }

    impl<'a> IndicesRecoveryWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                active_only: Ok(None),
                detailed: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesRecoveryWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `IndicesRecoveryWithIndexIndex` for index failed".to_string()
            });
            self
        }

        pub fn active_only<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.active_only = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for active_only failed".to_string());
            self
        }

        pub fn detailed<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.detailed = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for detailed failed".to_string());
            self
        }

        ///Sends a `GET` request to `/{index}/_recovery`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                active_only,
                detailed,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let active_only = active_only.map_err(Error::InvalidRequest)?;
            let detailed = detailed.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_recovery",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &active_only {
                query.push(("active_only", v.to_string()));
            }
            if let Some(v) = &detailed {
                query.push(("detailed", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_refresh_get_with_index`]
    ///
    ///[`Client::indices_refresh_get_with_index`]: super::Client::indices_refresh_get_with_index
    #[derive(Debug, Clone)]
    pub struct IndicesRefreshGetWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesRefreshGetWithIndexIndex, String>,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
    }

    impl<'a> IndicesRefreshGetWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                ignore_unavailable: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesRefreshGetWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `IndicesRefreshGetWithIndexIndex` for index failed".to_string()
            });
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        ///Sends a `GET` request to `/{index}/_refresh`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                allow_no_indices,
                expand_wildcards,
                ignore_unavailable,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_refresh",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_refresh_post_with_index`]
    ///
    ///[`Client::indices_refresh_post_with_index`]: super::Client::indices_refresh_post_with_index
    #[derive(Debug, Clone)]
    pub struct IndicesRefreshPostWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesRefreshPostWithIndexIndex, String>,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
    }

    impl<'a> IndicesRefreshPostWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                ignore_unavailable: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesRefreshPostWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `IndicesRefreshPostWithIndexIndex` for index failed".to_string()
            });
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        ///Sends a `POST` request to `/{index}/_refresh`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                allow_no_indices,
                expand_wildcards,
                ignore_unavailable,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_refresh",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            let request = client.client.post(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::search_get_with_index`]
    ///
    ///[`Client::search_get_with_index`]: super::Client::search_get_with_index
    #[derive(Debug, Clone)]
    pub struct SearchGetWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::SearchGetWithIndexIndex, String>,
        source: Result<Option<Vec<String>>, String>,
        source_excludes: Result<Option<Vec<String>>, String>,
        source_includes: Result<Option<Vec<String>>, String>,
        allow_no_indices: Result<Option<bool>, String>,
        allow_partial_search_results: Result<Option<bool>, String>,
        analyze_wildcard: Result<Option<bool>, String>,
        analyzer: Result<Option<String>, String>,
        batched_reduce_size: Result<Option<i32>, String>,
        ccs_minimize_roundtrips: Result<Option<bool>, String>,
        default_operator: Result<Option<types::DefaultOperator>, String>,
        df: Result<Option<String>, String>,
        docvalue_fields: Result<Option<Vec<String>>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        explain: Result<Option<bool>, String>,
        from: Result<Option<i32>, String>,
        ignore_throttled: Result<Option<bool>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        lenient: Result<Option<bool>, String>,
        max_concurrent_shard_requests: Result<Option<i32>, String>,
        pre_filter_shard_size: Result<Option<i32>, String>,
        preference: Result<Option<String>, String>,
        q: Result<Option<String>, String>,
        request_cache: Result<Option<bool>, String>,
        rest_total_hits_as_int: Result<Option<bool>, String>,
        routing: Result<Option<Vec<String>>, String>,
        scroll: Result<Option<types::SearchGetWithIndexScroll>, String>,
        search_type: Result<Option<types::SearchType>, String>,
        seq_no_primary_term: Result<Option<bool>, String>,
        size: Result<Option<i32>, String>,
        sort: Result<Option<Vec<String>>, String>,
        stats: Result<Option<Vec<String>>, String>,
        stored_fields: Result<Option<Vec<String>>, String>,
        suggest_field: Result<Option<String>, String>,
        suggest_mode: Result<Option<types::SuggestMode>, String>,
        suggest_size: Result<Option<i32>, String>,
        suggest_text: Result<Option<String>, String>,
        terminate_after: Result<Option<i32>, String>,
        timeout: Result<Option<types::SearchGetWithIndexTimeout>, String>,
        track_scores: Result<Option<bool>, String>,
        track_total_hits: Result<Option<bool>, String>,
        typed_keys: Result<Option<bool>, String>,
        version: Result<Option<bool>, String>,
    }

    impl<'a> SearchGetWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                source: Ok(None),
                source_excludes: Ok(None),
                source_includes: Ok(None),
                allow_no_indices: Ok(None),
                allow_partial_search_results: Ok(None),
                analyze_wildcard: Ok(None),
                analyzer: Ok(None),
                batched_reduce_size: Ok(None),
                ccs_minimize_roundtrips: Ok(None),
                default_operator: Ok(None),
                df: Ok(None),
                docvalue_fields: Ok(None),
                expand_wildcards: Ok(None),
                explain: Ok(None),
                from: Ok(None),
                ignore_throttled: Ok(None),
                ignore_unavailable: Ok(None),
                lenient: Ok(None),
                max_concurrent_shard_requests: Ok(None),
                pre_filter_shard_size: Ok(None),
                preference: Ok(None),
                q: Ok(None),
                request_cache: Ok(None),
                rest_total_hits_as_int: Ok(None),
                routing: Ok(None),
                scroll: Ok(None),
                search_type: Ok(None),
                seq_no_primary_term: Ok(None),
                size: Ok(None),
                sort: Ok(None),
                stats: Ok(None),
                stored_fields: Ok(None),
                suggest_field: Ok(None),
                suggest_mode: Ok(None),
                suggest_size: Ok(None),
                suggest_text: Ok(None),
                terminate_after: Ok(None),
                timeout: Ok(None),
                track_scores: Ok(None),
                track_total_hits: Ok(None),
                typed_keys: Ok(None),
                version: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchGetWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `SearchGetWithIndexIndex` for index failed".to_string()
            });
            self
        }

        pub fn source<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for source failed".to_string());
            self
        }

        pub fn source_excludes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_excludes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_excludes failed".to_string()
            });
            self
        }

        pub fn source_includes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_includes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_includes failed".to_string()
            });
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn allow_partial_search_results<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_partial_search_results = value.try_into().map(Some).map_err(|_| {
                "conversion to `bool` for allow_partial_search_results failed".to_string()
            });
            self
        }

        pub fn analyze_wildcard<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.analyze_wildcard = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for analyze_wildcard failed".to_string());
            self
        }

        pub fn analyzer<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.analyzer = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for analyzer failed".to_string());
            self
        }

        pub fn batched_reduce_size<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.batched_reduce_size = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for batched_reduce_size failed".to_string());
            self
        }

        pub fn ccs_minimize_roundtrips<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ccs_minimize_roundtrips = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ccs_minimize_roundtrips failed".to_string());
            self
        }

        pub fn default_operator<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DefaultOperator>,
        {
            self.default_operator = value.try_into().map(Some).map_err(|_| {
                "conversion to `DefaultOperator` for default_operator failed".to_string()
            });
            self
        }

        pub fn df<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.df = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for df failed".to_string());
            self
        }

        pub fn docvalue_fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.docvalue_fields = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for docvalue_fields failed".to_string()
            });
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn explain<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.explain = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for explain failed".to_string());
            self
        }

        pub fn from<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.from = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for from failed".to_string());
            self
        }

        pub fn ignore_throttled<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_throttled = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_throttled failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn lenient<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.lenient = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for lenient failed".to_string());
            self
        }

        pub fn max_concurrent_shard_requests<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.max_concurrent_shard_requests = value.try_into().map(Some).map_err(|_| {
                "conversion to `i32` for max_concurrent_shard_requests failed".to_string()
            });
            self
        }

        pub fn pre_filter_shard_size<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.pre_filter_shard_size = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for pre_filter_shard_size failed".to_string());
            self
        }

        pub fn preference<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.preference = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for preference failed".to_string());
            self
        }

        pub fn q<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.q = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for q failed".to_string());
            self
        }

        pub fn request_cache<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.request_cache = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for request_cache failed".to_string());
            self
        }

        pub fn rest_total_hits_as_int<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.rest_total_hits_as_int = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for rest_total_hits_as_int failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for routing failed".to_string());
            self
        }

        pub fn scroll<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchGetWithIndexScroll>,
        {
            self.scroll = value.try_into().map(Some).map_err(|_| {
                "conversion to `SearchGetWithIndexScroll` for scroll failed".to_string()
            });
            self
        }

        pub fn search_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchType>,
        {
            self.search_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SearchType` for search_type failed".to_string());
            self
        }

        pub fn seq_no_primary_term<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.seq_no_primary_term = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for seq_no_primary_term failed".to_string());
            self
        }

        pub fn size<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.size = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for size failed".to_string());
            self
        }

        pub fn sort<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.sort = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for sort failed".to_string());
            self
        }

        pub fn stats<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.stats = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for stats failed".to_string());
            self
        }

        pub fn stored_fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.stored_fields = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for stored_fields failed".to_string());
            self
        }

        pub fn suggest_field<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.suggest_field = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for suggest_field failed".to_string());
            self
        }

        pub fn suggest_mode<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SuggestMode>,
        {
            self.suggest_mode = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SuggestMode` for suggest_mode failed".to_string());
            self
        }

        pub fn suggest_size<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.suggest_size = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for suggest_size failed".to_string());
            self
        }

        pub fn suggest_text<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.suggest_text = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for suggest_text failed".to_string());
            self
        }

        pub fn terminate_after<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.terminate_after = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for terminate_after failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchGetWithIndexTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `SearchGetWithIndexTimeout` for timeout failed".to_string()
            });
            self
        }

        pub fn track_scores<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.track_scores = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for track_scores failed".to_string());
            self
        }

        pub fn track_total_hits<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.track_total_hits = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for track_total_hits failed".to_string());
            self
        }

        pub fn typed_keys<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.typed_keys = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for typed_keys failed".to_string());
            self
        }

        pub fn version<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.version = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for version failed".to_string());
            self
        }

        ///Sends a `GET` request to `/{index}/_search`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SearchGetWithIndexResponseContent>, Error<()>> {
            let Self {
                client,
                index,
                source,
                source_excludes,
                source_includes,
                allow_no_indices,
                allow_partial_search_results,
                analyze_wildcard,
                analyzer,
                batched_reduce_size,
                ccs_minimize_roundtrips,
                default_operator,
                df,
                docvalue_fields,
                expand_wildcards,
                explain,
                from,
                ignore_throttled,
                ignore_unavailable,
                lenient,
                max_concurrent_shard_requests,
                pre_filter_shard_size,
                preference,
                q,
                request_cache,
                rest_total_hits_as_int,
                routing,
                scroll,
                search_type,
                seq_no_primary_term,
                size,
                sort,
                stats,
                stored_fields,
                suggest_field,
                suggest_mode,
                suggest_size,
                suggest_text,
                terminate_after,
                timeout,
                track_scores,
                track_total_hits,
                typed_keys,
                version,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let source = source.map_err(Error::InvalidRequest)?;
            let source_excludes = source_excludes.map_err(Error::InvalidRequest)?;
            let source_includes = source_includes.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let allow_partial_search_results =
                allow_partial_search_results.map_err(Error::InvalidRequest)?;
            let analyze_wildcard = analyze_wildcard.map_err(Error::InvalidRequest)?;
            let analyzer = analyzer.map_err(Error::InvalidRequest)?;
            let batched_reduce_size = batched_reduce_size.map_err(Error::InvalidRequest)?;
            let ccs_minimize_roundtrips = ccs_minimize_roundtrips.map_err(Error::InvalidRequest)?;
            let default_operator = default_operator.map_err(Error::InvalidRequest)?;
            let df = df.map_err(Error::InvalidRequest)?;
            let docvalue_fields = docvalue_fields.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let explain = explain.map_err(Error::InvalidRequest)?;
            let from = from.map_err(Error::InvalidRequest)?;
            let ignore_throttled = ignore_throttled.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let lenient = lenient.map_err(Error::InvalidRequest)?;
            let max_concurrent_shard_requests =
                max_concurrent_shard_requests.map_err(Error::InvalidRequest)?;
            let pre_filter_shard_size = pre_filter_shard_size.map_err(Error::InvalidRequest)?;
            let preference = preference.map_err(Error::InvalidRequest)?;
            let q = q.map_err(Error::InvalidRequest)?;
            let request_cache = request_cache.map_err(Error::InvalidRequest)?;
            let rest_total_hits_as_int = rest_total_hits_as_int.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let scroll = scroll.map_err(Error::InvalidRequest)?;
            let search_type = search_type.map_err(Error::InvalidRequest)?;
            let seq_no_primary_term = seq_no_primary_term.map_err(Error::InvalidRequest)?;
            let size = size.map_err(Error::InvalidRequest)?;
            let sort = sort.map_err(Error::InvalidRequest)?;
            let stats = stats.map_err(Error::InvalidRequest)?;
            let stored_fields = stored_fields.map_err(Error::InvalidRequest)?;
            let suggest_field = suggest_field.map_err(Error::InvalidRequest)?;
            let suggest_mode = suggest_mode.map_err(Error::InvalidRequest)?;
            let suggest_size = suggest_size.map_err(Error::InvalidRequest)?;
            let suggest_text = suggest_text.map_err(Error::InvalidRequest)?;
            let terminate_after = terminate_after.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let track_scores = track_scores.map_err(Error::InvalidRequest)?;
            let track_total_hits = track_total_hits.map_err(Error::InvalidRequest)?;
            let typed_keys = typed_keys.map_err(Error::InvalidRequest)?;
            let version = version.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_search",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(42usize);
            if let Some(v) = &source {
                query.push(("_source", v.to_string()));
            }
            if let Some(v) = &source_excludes {
                query.push(("_source_excludes", v.to_string()));
            }
            if let Some(v) = &source_includes {
                query.push(("_source_includes", v.to_string()));
            }
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &allow_partial_search_results {
                query.push(("allow_partial_search_results", v.to_string()));
            }
            if let Some(v) = &analyze_wildcard {
                query.push(("analyze_wildcard", v.to_string()));
            }
            if let Some(v) = &analyzer {
                query.push(("analyzer", v.to_string()));
            }
            if let Some(v) = &batched_reduce_size {
                query.push(("batched_reduce_size", v.to_string()));
            }
            if let Some(v) = &ccs_minimize_roundtrips {
                query.push(("ccs_minimize_roundtrips", v.to_string()));
            }
            if let Some(v) = &default_operator {
                query.push(("default_operator", v.to_string()));
            }
            if let Some(v) = &df {
                query.push(("df", v.to_string()));
            }
            if let Some(v) = &docvalue_fields {
                query.push(("docvalue_fields", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &explain {
                query.push(("explain", v.to_string()));
            }
            if let Some(v) = &from {
                query.push(("from", v.to_string()));
            }
            if let Some(v) = &ignore_throttled {
                query.push(("ignore_throttled", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &lenient {
                query.push(("lenient", v.to_string()));
            }
            if let Some(v) = &max_concurrent_shard_requests {
                query.push(("max_concurrent_shard_requests", v.to_string()));
            }
            if let Some(v) = &pre_filter_shard_size {
                query.push(("pre_filter_shard_size", v.to_string()));
            }
            if let Some(v) = &preference {
                query.push(("preference", v.to_string()));
            }
            if let Some(v) = &q {
                query.push(("q", v.to_string()));
            }
            if let Some(v) = &request_cache {
                query.push(("request_cache", v.to_string()));
            }
            if let Some(v) = &rest_total_hits_as_int {
                query.push(("rest_total_hits_as_int", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &scroll {
                query.push(("scroll", v.to_string()));
            }
            if let Some(v) = &search_type {
                query.push(("search_type", v.to_string()));
            }
            if let Some(v) = &seq_no_primary_term {
                query.push(("seq_no_primary_term", v.to_string()));
            }
            if let Some(v) = &size {
                query.push(("size", v.to_string()));
            }
            if let Some(v) = &sort {
                query.push(("sort", v.to_string()));
            }
            if let Some(v) = &stats {
                query.push(("stats", v.to_string()));
            }
            if let Some(v) = &stored_fields {
                query.push(("stored_fields", v.to_string()));
            }
            if let Some(v) = &suggest_field {
                query.push(("suggest_field", v.to_string()));
            }
            if let Some(v) = &suggest_mode {
                query.push(("suggest_mode", v.to_string()));
            }
            if let Some(v) = &suggest_size {
                query.push(("suggest_size", v.to_string()));
            }
            if let Some(v) = &suggest_text {
                query.push(("suggest_text", v.to_string()));
            }
            if let Some(v) = &terminate_after {
                query.push(("terminate_after", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &track_scores {
                query.push(("track_scores", v.to_string()));
            }
            if let Some(v) = &track_total_hits {
                query.push(("track_total_hits", v.to_string()));
            }
            if let Some(v) = &typed_keys {
                query.push(("typed_keys", v.to_string()));
            }
            if let Some(v) = &version {
                query.push(("version", v.to_string()));
            }
            let request = client
                .client
                .get(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::search_post_with_index`]
    ///
    ///[`Client::search_post_with_index`]: super::Client::search_post_with_index
    #[derive(Debug, Clone)]
    pub struct SearchPostWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::SearchPostWithIndexIndex, String>,
        source: Result<Option<Vec<String>>, String>,
        source_excludes: Result<Option<Vec<String>>, String>,
        source_includes: Result<Option<Vec<String>>, String>,
        allow_no_indices: Result<Option<bool>, String>,
        allow_partial_search_results: Result<Option<bool>, String>,
        analyze_wildcard: Result<Option<bool>, String>,
        analyzer: Result<Option<String>, String>,
        batched_reduce_size: Result<Option<i32>, String>,
        ccs_minimize_roundtrips: Result<Option<bool>, String>,
        default_operator: Result<Option<types::DefaultOperator>, String>,
        df: Result<Option<String>, String>,
        docvalue_fields: Result<Option<Vec<String>>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        explain: Result<Option<bool>, String>,
        from: Result<Option<i32>, String>,
        ignore_throttled: Result<Option<bool>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        lenient: Result<Option<bool>, String>,
        max_concurrent_shard_requests: Result<Option<i32>, String>,
        pre_filter_shard_size: Result<Option<i32>, String>,
        preference: Result<Option<String>, String>,
        q: Result<Option<String>, String>,
        request_cache: Result<Option<bool>, String>,
        rest_total_hits_as_int: Result<Option<bool>, String>,
        routing: Result<Option<Vec<String>>, String>,
        scroll: Result<Option<types::SearchPostWithIndexScroll>, String>,
        search_type: Result<Option<types::SearchType>, String>,
        seq_no_primary_term: Result<Option<bool>, String>,
        size: Result<Option<i32>, String>,
        sort: Result<Option<Vec<String>>, String>,
        stats: Result<Option<Vec<String>>, String>,
        stored_fields: Result<Option<Vec<String>>, String>,
        suggest_field: Result<Option<String>, String>,
        suggest_mode: Result<Option<types::SuggestMode>, String>,
        suggest_size: Result<Option<i32>, String>,
        suggest_text: Result<Option<String>, String>,
        terminate_after: Result<Option<i32>, String>,
        timeout: Result<Option<types::SearchPostWithIndexTimeout>, String>,
        track_scores: Result<Option<bool>, String>,
        track_total_hits: Result<Option<bool>, String>,
        typed_keys: Result<Option<bool>, String>,
        version: Result<Option<bool>, String>,
        body: Result<types::builder::SearchBodyParams, String>,
    }

    impl<'a> SearchPostWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                source: Ok(None),
                source_excludes: Ok(None),
                source_includes: Ok(None),
                allow_no_indices: Ok(None),
                allow_partial_search_results: Ok(None),
                analyze_wildcard: Ok(None),
                analyzer: Ok(None),
                batched_reduce_size: Ok(None),
                ccs_minimize_roundtrips: Ok(None),
                default_operator: Ok(None),
                df: Ok(None),
                docvalue_fields: Ok(None),
                expand_wildcards: Ok(None),
                explain: Ok(None),
                from: Ok(None),
                ignore_throttled: Ok(None),
                ignore_unavailable: Ok(None),
                lenient: Ok(None),
                max_concurrent_shard_requests: Ok(None),
                pre_filter_shard_size: Ok(None),
                preference: Ok(None),
                q: Ok(None),
                request_cache: Ok(None),
                rest_total_hits_as_int: Ok(None),
                routing: Ok(None),
                scroll: Ok(None),
                search_type: Ok(None),
                seq_no_primary_term: Ok(None),
                size: Ok(None),
                sort: Ok(None),
                stats: Ok(None),
                stored_fields: Ok(None),
                suggest_field: Ok(None),
                suggest_mode: Ok(None),
                suggest_size: Ok(None),
                suggest_text: Ok(None),
                terminate_after: Ok(None),
                timeout: Ok(None),
                track_scores: Ok(None),
                track_total_hits: Ok(None),
                typed_keys: Ok(None),
                version: Ok(None),
                body: Ok(types::builder::SearchBodyParams::default()),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchPostWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `SearchPostWithIndexIndex` for index failed".to_string()
            });
            self
        }

        pub fn source<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for source failed".to_string());
            self
        }

        pub fn source_excludes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_excludes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_excludes failed".to_string()
            });
            self
        }

        pub fn source_includes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_includes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_includes failed".to_string()
            });
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn allow_partial_search_results<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_partial_search_results = value.try_into().map(Some).map_err(|_| {
                "conversion to `bool` for allow_partial_search_results failed".to_string()
            });
            self
        }

        pub fn analyze_wildcard<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.analyze_wildcard = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for analyze_wildcard failed".to_string());
            self
        }

        pub fn analyzer<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.analyzer = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for analyzer failed".to_string());
            self
        }

        pub fn batched_reduce_size<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.batched_reduce_size = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for batched_reduce_size failed".to_string());
            self
        }

        pub fn ccs_minimize_roundtrips<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ccs_minimize_roundtrips = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ccs_minimize_roundtrips failed".to_string());
            self
        }

        pub fn default_operator<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DefaultOperator>,
        {
            self.default_operator = value.try_into().map(Some).map_err(|_| {
                "conversion to `DefaultOperator` for default_operator failed".to_string()
            });
            self
        }

        pub fn df<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.df = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for df failed".to_string());
            self
        }

        pub fn docvalue_fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.docvalue_fields = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for docvalue_fields failed".to_string()
            });
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn explain<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.explain = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for explain failed".to_string());
            self
        }

        pub fn from<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.from = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for from failed".to_string());
            self
        }

        pub fn ignore_throttled<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_throttled = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_throttled failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn lenient<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.lenient = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for lenient failed".to_string());
            self
        }

        pub fn max_concurrent_shard_requests<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.max_concurrent_shard_requests = value.try_into().map(Some).map_err(|_| {
                "conversion to `i32` for max_concurrent_shard_requests failed".to_string()
            });
            self
        }

        pub fn pre_filter_shard_size<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.pre_filter_shard_size = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for pre_filter_shard_size failed".to_string());
            self
        }

        pub fn preference<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.preference = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for preference failed".to_string());
            self
        }

        pub fn q<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.q = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for q failed".to_string());
            self
        }

        pub fn request_cache<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.request_cache = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for request_cache failed".to_string());
            self
        }

        pub fn rest_total_hits_as_int<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.rest_total_hits_as_int = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for rest_total_hits_as_int failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for routing failed".to_string());
            self
        }

        pub fn scroll<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchPostWithIndexScroll>,
        {
            self.scroll = value.try_into().map(Some).map_err(|_| {
                "conversion to `SearchPostWithIndexScroll` for scroll failed".to_string()
            });
            self
        }

        pub fn search_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchType>,
        {
            self.search_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SearchType` for search_type failed".to_string());
            self
        }

        pub fn seq_no_primary_term<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.seq_no_primary_term = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for seq_no_primary_term failed".to_string());
            self
        }

        pub fn size<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.size = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for size failed".to_string());
            self
        }

        pub fn sort<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.sort = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for sort failed".to_string());
            self
        }

        pub fn stats<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.stats = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for stats failed".to_string());
            self
        }

        pub fn stored_fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.stored_fields = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for stored_fields failed".to_string());
            self
        }

        pub fn suggest_field<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.suggest_field = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for suggest_field failed".to_string());
            self
        }

        pub fn suggest_mode<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SuggestMode>,
        {
            self.suggest_mode = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SuggestMode` for suggest_mode failed".to_string());
            self
        }

        pub fn suggest_size<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.suggest_size = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for suggest_size failed".to_string());
            self
        }

        pub fn suggest_text<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.suggest_text = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for suggest_text failed".to_string());
            self
        }

        pub fn terminate_after<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.terminate_after = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for terminate_after failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchPostWithIndexTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `SearchPostWithIndexTimeout` for timeout failed".to_string()
            });
            self
        }

        pub fn track_scores<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.track_scores = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for track_scores failed".to_string());
            self
        }

        pub fn track_total_hits<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.track_total_hits = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for track_total_hits failed".to_string());
            self
        }

        pub fn typed_keys<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.typed_keys = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for typed_keys failed".to_string());
            self
        }

        pub fn version<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.version = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for version failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchBodyParams>,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|_| "conversion to `SearchBodyParams` for body failed".to_string());
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::SearchBodyParams,
            ) -> types::builder::SearchBodyParams,
        {
            self.body = self.body.map(f);
            self
        }

        ///Sends a `POST` request to `/{index}/_search`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SearchPostWithIndexResponseContent>, Error<()>> {
            let Self {
                client,
                index,
                source,
                source_excludes,
                source_includes,
                allow_no_indices,
                allow_partial_search_results,
                analyze_wildcard,
                analyzer,
                batched_reduce_size,
                ccs_minimize_roundtrips,
                default_operator,
                df,
                docvalue_fields,
                expand_wildcards,
                explain,
                from,
                ignore_throttled,
                ignore_unavailable,
                lenient,
                max_concurrent_shard_requests,
                pre_filter_shard_size,
                preference,
                q,
                request_cache,
                rest_total_hits_as_int,
                routing,
                scroll,
                search_type,
                seq_no_primary_term,
                size,
                sort,
                stats,
                stored_fields,
                suggest_field,
                suggest_mode,
                suggest_size,
                suggest_text,
                terminate_after,
                timeout,
                track_scores,
                track_total_hits,
                typed_keys,
                version,
                body,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let source = source.map_err(Error::InvalidRequest)?;
            let source_excludes = source_excludes.map_err(Error::InvalidRequest)?;
            let source_includes = source_includes.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let allow_partial_search_results =
                allow_partial_search_results.map_err(Error::InvalidRequest)?;
            let analyze_wildcard = analyze_wildcard.map_err(Error::InvalidRequest)?;
            let analyzer = analyzer.map_err(Error::InvalidRequest)?;
            let batched_reduce_size = batched_reduce_size.map_err(Error::InvalidRequest)?;
            let ccs_minimize_roundtrips = ccs_minimize_roundtrips.map_err(Error::InvalidRequest)?;
            let default_operator = default_operator.map_err(Error::InvalidRequest)?;
            let df = df.map_err(Error::InvalidRequest)?;
            let docvalue_fields = docvalue_fields.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let explain = explain.map_err(Error::InvalidRequest)?;
            let from = from.map_err(Error::InvalidRequest)?;
            let ignore_throttled = ignore_throttled.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let lenient = lenient.map_err(Error::InvalidRequest)?;
            let max_concurrent_shard_requests =
                max_concurrent_shard_requests.map_err(Error::InvalidRequest)?;
            let pre_filter_shard_size = pre_filter_shard_size.map_err(Error::InvalidRequest)?;
            let preference = preference.map_err(Error::InvalidRequest)?;
            let q = q.map_err(Error::InvalidRequest)?;
            let request_cache = request_cache.map_err(Error::InvalidRequest)?;
            let rest_total_hits_as_int = rest_total_hits_as_int.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let scroll = scroll.map_err(Error::InvalidRequest)?;
            let search_type = search_type.map_err(Error::InvalidRequest)?;
            let seq_no_primary_term = seq_no_primary_term.map_err(Error::InvalidRequest)?;
            let size = size.map_err(Error::InvalidRequest)?;
            let sort = sort.map_err(Error::InvalidRequest)?;
            let stats = stats.map_err(Error::InvalidRequest)?;
            let stored_fields = stored_fields.map_err(Error::InvalidRequest)?;
            let suggest_field = suggest_field.map_err(Error::InvalidRequest)?;
            let suggest_mode = suggest_mode.map_err(Error::InvalidRequest)?;
            let suggest_size = suggest_size.map_err(Error::InvalidRequest)?;
            let suggest_text = suggest_text.map_err(Error::InvalidRequest)?;
            let terminate_after = terminate_after.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let track_scores = track_scores.map_err(Error::InvalidRequest)?;
            let track_total_hits = track_total_hits.map_err(Error::InvalidRequest)?;
            let typed_keys = typed_keys.map_err(Error::InvalidRequest)?;
            let version = version.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(std::convert::TryInto::<types::SearchBodyParams>::try_into)
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_search",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(42usize);
            if let Some(v) = &source {
                query.push(("_source", v.to_string()));
            }
            if let Some(v) = &source_excludes {
                query.push(("_source_excludes", v.to_string()));
            }
            if let Some(v) = &source_includes {
                query.push(("_source_includes", v.to_string()));
            }
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &allow_partial_search_results {
                query.push(("allow_partial_search_results", v.to_string()));
            }
            if let Some(v) = &analyze_wildcard {
                query.push(("analyze_wildcard", v.to_string()));
            }
            if let Some(v) = &analyzer {
                query.push(("analyzer", v.to_string()));
            }
            if let Some(v) = &batched_reduce_size {
                query.push(("batched_reduce_size", v.to_string()));
            }
            if let Some(v) = &ccs_minimize_roundtrips {
                query.push(("ccs_minimize_roundtrips", v.to_string()));
            }
            if let Some(v) = &default_operator {
                query.push(("default_operator", v.to_string()));
            }
            if let Some(v) = &df {
                query.push(("df", v.to_string()));
            }
            if let Some(v) = &docvalue_fields {
                query.push(("docvalue_fields", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &explain {
                query.push(("explain", v.to_string()));
            }
            if let Some(v) = &from {
                query.push(("from", v.to_string()));
            }
            if let Some(v) = &ignore_throttled {
                query.push(("ignore_throttled", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &lenient {
                query.push(("lenient", v.to_string()));
            }
            if let Some(v) = &max_concurrent_shard_requests {
                query.push(("max_concurrent_shard_requests", v.to_string()));
            }
            if let Some(v) = &pre_filter_shard_size {
                query.push(("pre_filter_shard_size", v.to_string()));
            }
            if let Some(v) = &preference {
                query.push(("preference", v.to_string()));
            }
            if let Some(v) = &q {
                query.push(("q", v.to_string()));
            }
            if let Some(v) = &request_cache {
                query.push(("request_cache", v.to_string()));
            }
            if let Some(v) = &rest_total_hits_as_int {
                query.push(("rest_total_hits_as_int", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &scroll {
                query.push(("scroll", v.to_string()));
            }
            if let Some(v) = &search_type {
                query.push(("search_type", v.to_string()));
            }
            if let Some(v) = &seq_no_primary_term {
                query.push(("seq_no_primary_term", v.to_string()));
            }
            if let Some(v) = &size {
                query.push(("size", v.to_string()));
            }
            if let Some(v) = &sort {
                query.push(("sort", v.to_string()));
            }
            if let Some(v) = &stats {
                query.push(("stats", v.to_string()));
            }
            if let Some(v) = &stored_fields {
                query.push(("stored_fields", v.to_string()));
            }
            if let Some(v) = &suggest_field {
                query.push(("suggest_field", v.to_string()));
            }
            if let Some(v) = &suggest_mode {
                query.push(("suggest_mode", v.to_string()));
            }
            if let Some(v) = &suggest_size {
                query.push(("suggest_size", v.to_string()));
            }
            if let Some(v) = &suggest_text {
                query.push(("suggest_text", v.to_string()));
            }
            if let Some(v) = &terminate_after {
                query.push(("terminate_after", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &track_scores {
                query.push(("track_scores", v.to_string()));
            }
            if let Some(v) = &track_total_hits {
                query.push(("track_total_hits", v.to_string()));
            }
            if let Some(v) = &typed_keys {
                query.push(("typed_keys", v.to_string()));
            }
            if let Some(v) = &version {
                query.push(("version", v.to_string()));
            }
            let request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::create_pit`]
    ///
    ///[`Client::create_pit`]: super::Client::create_pit
    #[derive(Debug, Clone)]
    pub struct CreatePit<'a> {
        client: &'a super::Client,
        index: Result<types::CreatePitIndex, String>,
        allow_partial_pit_creation: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        keep_alive: Result<Option<String>, String>,
        preference: Result<Option<String>, String>,
        routing: Result<Option<Vec<String>>, String>,
    }

    impl<'a> CreatePit<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                allow_partial_pit_creation: Ok(None),
                expand_wildcards: Ok(None),
                keep_alive: Ok(None),
                preference: Ok(None),
                routing: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreatePitIndex>,
        {
            self.index = value
                .try_into()
                .map_err(|_| "conversion to `CreatePitIndex` for index failed".to_string());
            self
        }

        pub fn allow_partial_pit_creation<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_partial_pit_creation = value.try_into().map(Some).map_err(|_| {
                "conversion to `bool` for allow_partial_pit_creation failed".to_string()
            });
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn keep_alive<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.keep_alive = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for keep_alive failed".to_string());
            self
        }

        pub fn preference<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.preference = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for preference failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for routing failed".to_string());
            self
        }

        ///Sends a `POST` request to `/{index}/_search/point_in_time`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::CreatePitResponseContent>, Error<()>> {
            let Self {
                client,
                index,
                allow_partial_pit_creation,
                expand_wildcards,
                keep_alive,
                preference,
                routing,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let allow_partial_pit_creation =
                allow_partial_pit_creation.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let keep_alive = keep_alive.map_err(Error::InvalidRequest)?;
            let preference = preference.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_search/point_in_time",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &allow_partial_pit_creation {
                query.push(("allow_partial_pit_creation", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &keep_alive {
                query.push(("keep_alive", v.to_string()));
            }
            if let Some(v) = &preference {
                query.push(("preference", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            let request = client
                .client
                .post(url)
                .header(
                    reqwest::header::ACCEPT,
                    reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&query)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::search_template_get_with_index`]
    ///
    ///[`Client::search_template_get_with_index`]: super::Client::search_template_get_with_index
    #[derive(Debug, Clone)]
    pub struct SearchTemplateGetWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::SearchTemplateGetWithIndexIndex, String>,
        allow_no_indices: Result<Option<bool>, String>,
        ccs_minimize_roundtrips: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        explain: Result<Option<bool>, String>,
        ignore_throttled: Result<Option<bool>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        preference: Result<Option<String>, String>,
        profile: Result<Option<bool>, String>,
        rest_total_hits_as_int: Result<Option<bool>, String>,
        routing: Result<Option<Vec<String>>, String>,
        scroll: Result<Option<types::SearchTemplateGetWithIndexScroll>, String>,
        search_type: Result<Option<types::SearchTypeMulti>, String>,
        typed_keys: Result<Option<bool>, String>,
    }

    impl<'a> SearchTemplateGetWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                allow_no_indices: Ok(None),
                ccs_minimize_roundtrips: Ok(None),
                expand_wildcards: Ok(None),
                explain: Ok(None),
                ignore_throttled: Ok(None),
                ignore_unavailable: Ok(None),
                preference: Ok(None),
                profile: Ok(None),
                rest_total_hits_as_int: Ok(None),
                routing: Ok(None),
                scroll: Ok(None),
                search_type: Ok(None),
                typed_keys: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchTemplateGetWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `SearchTemplateGetWithIndexIndex` for index failed".to_string()
            });
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn ccs_minimize_roundtrips<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ccs_minimize_roundtrips = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ccs_minimize_roundtrips failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn explain<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.explain = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for explain failed".to_string());
            self
        }

        pub fn ignore_throttled<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_throttled = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_throttled failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn preference<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.preference = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for preference failed".to_string());
            self
        }

        pub fn profile<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.profile = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for profile failed".to_string());
            self
        }

        pub fn rest_total_hits_as_int<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.rest_total_hits_as_int = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for rest_total_hits_as_int failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for routing failed".to_string());
            self
        }

        pub fn scroll<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchTemplateGetWithIndexScroll>,
        {
            self.scroll = value.try_into().map(Some).map_err(|_| {
                "conversion to `SearchTemplateGetWithIndexScroll` for scroll failed".to_string()
            });
            self
        }

        pub fn search_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchTypeMulti>,
        {
            self.search_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SearchTypeMulti` for search_type failed".to_string());
            self
        }

        pub fn typed_keys<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.typed_keys = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for typed_keys failed".to_string());
            self
        }

        ///Sends a `GET` request to `/{index}/_search/template`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                allow_no_indices,
                ccs_minimize_roundtrips,
                expand_wildcards,
                explain,
                ignore_throttled,
                ignore_unavailable,
                preference,
                profile,
                rest_total_hits_as_int,
                routing,
                scroll,
                search_type,
                typed_keys,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let ccs_minimize_roundtrips = ccs_minimize_roundtrips.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let explain = explain.map_err(Error::InvalidRequest)?;
            let ignore_throttled = ignore_throttled.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let preference = preference.map_err(Error::InvalidRequest)?;
            let profile = profile.map_err(Error::InvalidRequest)?;
            let rest_total_hits_as_int = rest_total_hits_as_int.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let scroll = scroll.map_err(Error::InvalidRequest)?;
            let search_type = search_type.map_err(Error::InvalidRequest)?;
            let typed_keys = typed_keys.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_search/template",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(13usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &ccs_minimize_roundtrips {
                query.push(("ccs_minimize_roundtrips", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &explain {
                query.push(("explain", v.to_string()));
            }
            if let Some(v) = &ignore_throttled {
                query.push(("ignore_throttled", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &preference {
                query.push(("preference", v.to_string()));
            }
            if let Some(v) = &profile {
                query.push(("profile", v.to_string()));
            }
            if let Some(v) = &rest_total_hits_as_int {
                query.push(("rest_total_hits_as_int", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &scroll {
                query.push(("scroll", v.to_string()));
            }
            if let Some(v) = &search_type {
                query.push(("search_type", v.to_string()));
            }
            if let Some(v) = &typed_keys {
                query.push(("typed_keys", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::search_template_post_with_index`]
    ///
    ///[`Client::search_template_post_with_index`]: super::Client::search_template_post_with_index
    #[derive(Debug, Clone)]
    pub struct SearchTemplatePostWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::SearchTemplatePostWithIndexIndex, String>,
        allow_no_indices: Result<Option<bool>, String>,
        ccs_minimize_roundtrips: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        explain: Result<Option<bool>, String>,
        ignore_throttled: Result<Option<bool>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        preference: Result<Option<String>, String>,
        profile: Result<Option<bool>, String>,
        rest_total_hits_as_int: Result<Option<bool>, String>,
        routing: Result<Option<Vec<String>>, String>,
        scroll: Result<Option<types::SearchTemplatePostWithIndexScroll>, String>,
        search_type: Result<Option<types::SearchTypeMulti>, String>,
        typed_keys: Result<Option<bool>, String>,
        body: Result<types::SearchTemplateBodyParams, String>,
    }

    impl<'a> SearchTemplatePostWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                allow_no_indices: Ok(None),
                ccs_minimize_roundtrips: Ok(None),
                expand_wildcards: Ok(None),
                explain: Ok(None),
                ignore_throttled: Ok(None),
                ignore_unavailable: Ok(None),
                preference: Ok(None),
                profile: Ok(None),
                rest_total_hits_as_int: Ok(None),
                routing: Ok(None),
                scroll: Ok(None),
                search_type: Ok(None),
                typed_keys: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchTemplatePostWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `SearchTemplatePostWithIndexIndex` for index failed".to_string()
            });
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn ccs_minimize_roundtrips<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ccs_minimize_roundtrips = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ccs_minimize_roundtrips failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn explain<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.explain = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for explain failed".to_string());
            self
        }

        pub fn ignore_throttled<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_throttled = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_throttled failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn preference<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.preference = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for preference failed".to_string());
            self
        }

        pub fn profile<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.profile = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for profile failed".to_string());
            self
        }

        pub fn rest_total_hits_as_int<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.rest_total_hits_as_int = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for rest_total_hits_as_int failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for routing failed".to_string());
            self
        }

        pub fn scroll<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchTemplatePostWithIndexScroll>,
        {
            self.scroll = value.try_into().map(Some).map_err(|_| {
                "conversion to `SearchTemplatePostWithIndexScroll` for scroll failed".to_string()
            });
            self
        }

        pub fn search_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchTypeMulti>,
        {
            self.search_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SearchTypeMulti` for search_type failed".to_string());
            self
        }

        pub fn typed_keys<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.typed_keys = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for typed_keys failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchTemplateBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `SearchTemplateBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `POST` request to `/{index}/_search/template`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                allow_no_indices,
                ccs_minimize_roundtrips,
                expand_wildcards,
                explain,
                ignore_throttled,
                ignore_unavailable,
                preference,
                profile,
                rest_total_hits_as_int,
                routing,
                scroll,
                search_type,
                typed_keys,
                body,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let ccs_minimize_roundtrips = ccs_minimize_roundtrips.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let explain = explain.map_err(Error::InvalidRequest)?;
            let ignore_throttled = ignore_throttled.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let preference = preference.map_err(Error::InvalidRequest)?;
            let profile = profile.map_err(Error::InvalidRequest)?;
            let rest_total_hits_as_int = rest_total_hits_as_int.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let scroll = scroll.map_err(Error::InvalidRequest)?;
            let search_type = search_type.map_err(Error::InvalidRequest)?;
            let typed_keys = typed_keys.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_search/template",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(13usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &ccs_minimize_roundtrips {
                query.push(("ccs_minimize_roundtrips", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &explain {
                query.push(("explain", v.to_string()));
            }
            if let Some(v) = &ignore_throttled {
                query.push(("ignore_throttled", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &preference {
                query.push(("preference", v.to_string()));
            }
            if let Some(v) = &profile {
                query.push(("profile", v.to_string()));
            }
            if let Some(v) = &rest_total_hits_as_int {
                query.push(("rest_total_hits_as_int", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &scroll {
                query.push(("scroll", v.to_string()));
            }
            if let Some(v) = &search_type {
                query.push(("search_type", v.to_string()));
            }
            if let Some(v) = &typed_keys {
                query.push(("typed_keys", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::search_shards_get_with_index`]
    ///
    ///[`Client::search_shards_get_with_index`]: super::Client::search_shards_get_with_index
    #[derive(Debug, Clone)]
    pub struct SearchShardsGetWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::SearchShardsGetWithIndexIndex, String>,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
        preference: Result<Option<String>, String>,
        routing: Result<Option<String>, String>,
    }

    impl<'a> SearchShardsGetWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                ignore_unavailable: Ok(None),
                local: Ok(None),
                preference: Ok(None),
                routing: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchShardsGetWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `SearchShardsGetWithIndexIndex` for index failed".to_string()
            });
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn preference<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.preference = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for preference failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for routing failed".to_string());
            self
        }

        ///Sends a `GET` request to `/{index}/_search_shards`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                allow_no_indices,
                expand_wildcards,
                ignore_unavailable,
                local,
                preference,
                routing,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let preference = preference.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_search_shards",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(6usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &preference {
                query.push(("preference", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::search_shards_post_with_index`]
    ///
    ///[`Client::search_shards_post_with_index`]: super::Client::search_shards_post_with_index
    #[derive(Debug, Clone)]
    pub struct SearchShardsPostWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::SearchShardsPostWithIndexIndex, String>,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
        preference: Result<Option<String>, String>,
        routing: Result<Option<String>, String>,
    }

    impl<'a> SearchShardsPostWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                ignore_unavailable: Ok(None),
                local: Ok(None),
                preference: Ok(None),
                routing: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchShardsPostWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `SearchShardsPostWithIndexIndex` for index failed".to_string()
            });
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn preference<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.preference = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for preference failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for routing failed".to_string());
            self
        }

        ///Sends a `POST` request to `/{index}/_search_shards`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                allow_no_indices,
                expand_wildcards,
                ignore_unavailable,
                local,
                preference,
                routing,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let preference = preference.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_search_shards",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(6usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &preference {
                query.push(("preference", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            let request = client.client.post(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_segments_with_index`]
    ///
    ///[`Client::indices_segments_with_index`]: super::Client::indices_segments_with_index
    #[derive(Debug, Clone)]
    pub struct IndicesSegmentsWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesSegmentsWithIndexIndex, String>,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        verbose: Result<Option<bool>, String>,
    }

    impl<'a> IndicesSegmentsWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                ignore_unavailable: Ok(None),
                verbose: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesSegmentsWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `IndicesSegmentsWithIndexIndex` for index failed".to_string()
            });
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn verbose<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.verbose = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for verbose failed".to_string());
            self
        }

        ///Sends a `GET` request to `/{index}/_segments`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                allow_no_indices,
                expand_wildcards,
                ignore_unavailable,
                verbose,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let verbose = verbose.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_segments",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &verbose {
                query.push(("verbose", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_get_settings_with_index`]
    ///
    ///[`Client::indices_get_settings_with_index`]: super::Client::indices_get_settings_with_index
    #[derive(Debug, Clone)]
    pub struct IndicesGetSettingsWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesGetSettingsWithIndexIndex, String>,
        allow_no_indices: Result<Option<bool>, String>,
        cluster_manager_timeout:
            Result<Option<types::IndicesGetSettingsWithIndexClusterManagerTimeout>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        flat_settings: Result<Option<bool>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        include_defaults: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::IndicesGetSettingsWithIndexMasterTimeout>, String>,
    }

    impl<'a> IndicesGetSettingsWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                allow_no_indices: Ok(None),
                cluster_manager_timeout: Ok(None),
                expand_wildcards: Ok(None),
                flat_settings: Ok(None),
                ignore_unavailable: Ok(None),
                include_defaults: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesGetSettingsWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `IndicesGetSettingsWithIndexIndex` for index failed".to_string()
            });
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesGetSettingsWithIndexClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesGetSettingsWithIndexClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn flat_settings<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.flat_settings = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn include_defaults<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.include_defaults = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for include_defaults failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesGetSettingsWithIndexMasterTimeout>,
        {
            self . master_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesGetSettingsWithIndexMasterTimeout` for master_timeout failed" . to_string ()) ;
            self
        }

        ///Sends a `GET` request to `/{index}/_settings`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                allow_no_indices,
                cluster_manager_timeout,
                expand_wildcards,
                flat_settings,
                ignore_unavailable,
                include_defaults,
                local,
                master_timeout,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let include_defaults = include_defaults.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_settings",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(8usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &flat_settings {
                query.push(("flat_settings", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &include_defaults {
                query.push(("include_defaults", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_put_settings_with_index`]
    ///
    ///[`Client::indices_put_settings_with_index`]: super::Client::indices_put_settings_with_index
    #[derive(Debug, Clone)]
    pub struct IndicesPutSettingsWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesPutSettingsWithIndexIndex, String>,
        allow_no_indices: Result<Option<bool>, String>,
        cluster_manager_timeout:
            Result<Option<types::IndicesPutSettingsWithIndexClusterManagerTimeout>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        flat_settings: Result<Option<bool>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::IndicesPutSettingsWithIndexMasterTimeout>, String>,
        preserve_existing: Result<Option<bool>, String>,
        timeout: Result<Option<types::IndicesPutSettingsWithIndexTimeout>, String>,
        body: Result<types::IndicesPutSettingsBodyParams, String>,
    }

    impl<'a> IndicesPutSettingsWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                allow_no_indices: Ok(None),
                cluster_manager_timeout: Ok(None),
                expand_wildcards: Ok(None),
                flat_settings: Ok(None),
                ignore_unavailable: Ok(None),
                master_timeout: Ok(None),
                preserve_existing: Ok(None),
                timeout: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutSettingsWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `IndicesPutSettingsWithIndexIndex` for index failed".to_string()
            });
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutSettingsWithIndexClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesPutSettingsWithIndexClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn flat_settings<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.flat_settings = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutSettingsWithIndexMasterTimeout>,
        {
            self . master_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesPutSettingsWithIndexMasterTimeout` for master_timeout failed" . to_string ()) ;
            self
        }

        pub fn preserve_existing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.preserve_existing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for preserve_existing failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutSettingsWithIndexTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesPutSettingsWithIndexTimeout` for timeout failed".to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesPutSettingsBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `IndicesPutSettingsBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `PUT` request to `/{index}/_settings`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                allow_no_indices,
                cluster_manager_timeout,
                expand_wildcards,
                flat_settings,
                ignore_unavailable,
                master_timeout,
                preserve_existing,
                timeout,
                body,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let preserve_existing = preserve_existing.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_settings",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(8usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &flat_settings {
                query.push(("flat_settings", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &preserve_existing {
                query.push(("preserve_existing", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            let request = client.client.put(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_get_settings_with_index_name`]
    ///
    ///[`Client::indices_get_settings_with_index_name`]: super::Client::indices_get_settings_with_index_name
    #[derive(Debug, Clone)]
    pub struct IndicesGetSettingsWithIndexName<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesGetSettingsWithIndexNameIndex, String>,
        name: Result<types::IndicesGetSettingsWithIndexNameName, String>,
        allow_no_indices: Result<Option<bool>, String>,
        cluster_manager_timeout:
            Result<Option<types::IndicesGetSettingsWithIndexNameClusterManagerTimeout>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        flat_settings: Result<Option<bool>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        include_defaults: Result<Option<bool>, String>,
        local: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::IndicesGetSettingsWithIndexNameMasterTimeout>, String>,
    }

    impl<'a> IndicesGetSettingsWithIndexName<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                name: Err("name was not initialized".to_string()),
                allow_no_indices: Ok(None),
                cluster_manager_timeout: Ok(None),
                expand_wildcards: Ok(None),
                flat_settings: Ok(None),
                ignore_unavailable: Ok(None),
                include_defaults: Ok(None),
                local: Ok(None),
                master_timeout: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesGetSettingsWithIndexNameIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `IndicesGetSettingsWithIndexNameIndex` for index failed".to_string()
            });
            self
        }

        pub fn name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesGetSettingsWithIndexNameName>,
        {
            self.name = value.try_into().map_err(|_| {
                "conversion to `IndicesGetSettingsWithIndexNameName` for name failed".to_string()
            });
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesGetSettingsWithIndexNameClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesGetSettingsWithIndexNameClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn flat_settings<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.flat_settings = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for flat_settings failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn include_defaults<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.include_defaults = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for include_defaults failed".to_string());
            self
        }

        pub fn local<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.local = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for local failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesGetSettingsWithIndexNameMasterTimeout>,
        {
            self . master_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesGetSettingsWithIndexNameMasterTimeout` for master_timeout failed" . to_string ()) ;
            self
        }

        ///Sends a `GET` request to `/{index}/_settings/{name}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                name,
                allow_no_indices,
                cluster_manager_timeout,
                expand_wildcards,
                flat_settings,
                ignore_unavailable,
                include_defaults,
                local,
                master_timeout,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let name = name.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let flat_settings = flat_settings.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let include_defaults = include_defaults.map_err(Error::InvalidRequest)?;
            let local = local.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_settings/{}",
                client.baseurl,
                encode_path(&index.to_string()),
                encode_path(&name.to_string()),
            );
            let mut query = Vec::with_capacity(8usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &flat_settings {
                query.push(("flat_settings", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &include_defaults {
                query.push(("include_defaults", v.to_string()));
            }
            if let Some(v) = &local {
                query.push(("local", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_shard_stores_with_index`]
    ///
    ///[`Client::indices_shard_stores_with_index`]: super::Client::indices_shard_stores_with_index
    #[derive(Debug, Clone)]
    pub struct IndicesShardStoresWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesShardStoresWithIndexIndex, String>,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        status: Result<Option<Vec<types::StatusMember>>, String>,
    }

    impl<'a> IndicesShardStoresWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                ignore_unavailable: Ok(None),
                status: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesShardStoresWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `IndicesShardStoresWithIndexIndex` for index failed".to_string()
            });
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn status<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<types::StatusMember>>,
        {
            self.status = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < StatusMember >` for status failed".to_string());
            self
        }

        ///Sends a `GET` request to `/{index}/_shard_stores`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                allow_no_indices,
                expand_wildcards,
                ignore_unavailable,
                status,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let status = status.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_shard_stores",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &status {
                query.push(("status", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_shrink_put`]
    ///
    ///[`Client::indices_shrink_put`]: super::Client::indices_shrink_put
    #[derive(Debug, Clone)]
    pub struct IndicesShrinkPut<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesShrinkPutIndex, String>,
        target: Result<types::IndicesShrinkPutTarget, String>,
        cluster_manager_timeout:
            Result<Option<types::IndicesShrinkPutClusterManagerTimeout>, String>,
        copy_settings: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::IndicesShrinkPutMasterTimeout>, String>,
        timeout: Result<Option<types::IndicesShrinkPutTimeout>, String>,
        wait_for_active_shards: Result<Option<String>, String>,
        body: Result<types::IndicesShrinkBodyParams, String>,
    }

    impl<'a> IndicesShrinkPut<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                target: Err("target was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                copy_settings: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
                wait_for_active_shards: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesShrinkPutIndex>,
        {
            self.index = value
                .try_into()
                .map_err(|_| "conversion to `IndicesShrinkPutIndex` for index failed".to_string());
            self
        }

        pub fn target<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesShrinkPutTarget>,
        {
            self.target = value.try_into().map_err(|_| {
                "conversion to `IndicesShrinkPutTarget` for target failed".to_string()
            });
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesShrinkPutClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesShrinkPutClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn copy_settings<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.copy_settings = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for copy_settings failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesShrinkPutMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesShrinkPutMasterTimeout` for master_timeout failed"
                    .to_string()
            });
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesShrinkPutTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesShrinkPutTimeout` for timeout failed".to_string()
            });
            self
        }

        pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.wait_for_active_shards = value.try_into().map(Some).map_err(|_| {
                "conversion to `String` for wait_for_active_shards failed".to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesShrinkBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `IndicesShrinkBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `PUT` request to `/{index}/_shrink/{target}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                target,
                cluster_manager_timeout,
                copy_settings,
                master_timeout,
                timeout,
                wait_for_active_shards,
                body,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let target = target.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let copy_settings = copy_settings.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_shrink/{}",
                client.baseurl,
                encode_path(&index.to_string()),
                encode_path(&target.to_string()),
            );
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &copy_settings {
                query.push(("copy_settings", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &wait_for_active_shards {
                query.push(("wait_for_active_shards", v.to_string()));
            }
            let request = client.client.put(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_shrink_post`]
    ///
    ///[`Client::indices_shrink_post`]: super::Client::indices_shrink_post
    #[derive(Debug, Clone)]
    pub struct IndicesShrinkPost<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesShrinkPostIndex, String>,
        target: Result<types::IndicesShrinkPostTarget, String>,
        cluster_manager_timeout:
            Result<Option<types::IndicesShrinkPostClusterManagerTimeout>, String>,
        copy_settings: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::IndicesShrinkPostMasterTimeout>, String>,
        timeout: Result<Option<types::IndicesShrinkPostTimeout>, String>,
        wait_for_active_shards: Result<Option<String>, String>,
        body: Result<types::IndicesShrinkBodyParams, String>,
    }

    impl<'a> IndicesShrinkPost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                target: Err("target was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                copy_settings: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
                wait_for_active_shards: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesShrinkPostIndex>,
        {
            self.index = value
                .try_into()
                .map_err(|_| "conversion to `IndicesShrinkPostIndex` for index failed".to_string());
            self
        }

        pub fn target<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesShrinkPostTarget>,
        {
            self.target = value.try_into().map_err(|_| {
                "conversion to `IndicesShrinkPostTarget` for target failed".to_string()
            });
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesShrinkPostClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesShrinkPostClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn copy_settings<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.copy_settings = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for copy_settings failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesShrinkPostMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesShrinkPostMasterTimeout` for master_timeout failed"
                    .to_string()
            });
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesShrinkPostTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesShrinkPostTimeout` for timeout failed".to_string()
            });
            self
        }

        pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.wait_for_active_shards = value.try_into().map(Some).map_err(|_| {
                "conversion to `String` for wait_for_active_shards failed".to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesShrinkBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `IndicesShrinkBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `POST` request to `/{index}/_shrink/{target}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                target,
                cluster_manager_timeout,
                copy_settings,
                master_timeout,
                timeout,
                wait_for_active_shards,
                body,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let target = target.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let copy_settings = copy_settings.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_shrink/{}",
                client.baseurl,
                encode_path(&index.to_string()),
                encode_path(&target.to_string()),
            );
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &copy_settings {
                query.push(("copy_settings", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &wait_for_active_shards {
                query.push(("wait_for_active_shards", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::get_source`]
    ///
    ///[`Client::get_source`]: super::Client::get_source
    #[derive(Debug, Clone)]
    pub struct GetSource<'a> {
        client: &'a super::Client,
        index: Result<types::GetSourceIndex, String>,
        id: Result<types::GetSourceId, String>,
        source: Result<Option<Vec<String>>, String>,
        source_excludes: Result<Option<Vec<String>>, String>,
        source_includes: Result<Option<Vec<String>>, String>,
        preference: Result<Option<String>, String>,
        realtime: Result<Option<bool>, String>,
        refresh: Result<Option<bool>, String>,
        routing: Result<Option<String>, String>,
        version: Result<Option<i32>, String>,
        version_type: Result<Option<types::VersionType>, String>,
    }

    impl<'a> GetSource<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                id: Err("id was not initialized".to_string()),
                source: Ok(None),
                source_excludes: Ok(None),
                source_includes: Ok(None),
                preference: Ok(None),
                realtime: Ok(None),
                refresh: Ok(None),
                routing: Ok(None),
                version: Ok(None),
                version_type: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::GetSourceIndex>,
        {
            self.index = value
                .try_into()
                .map_err(|_| "conversion to `GetSourceIndex` for index failed".to_string());
            self
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::GetSourceId>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `GetSourceId` for id failed".to_string());
            self
        }

        pub fn source<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for source failed".to_string());
            self
        }

        pub fn source_excludes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_excludes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_excludes failed".to_string()
            });
            self
        }

        pub fn source_includes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_includes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_includes failed".to_string()
            });
            self
        }

        pub fn preference<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.preference = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for preference failed".to_string());
            self
        }

        pub fn realtime<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.realtime = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for realtime failed".to_string());
            self
        }

        pub fn refresh<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.refresh = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for refresh failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for routing failed".to_string());
            self
        }

        pub fn version<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.version = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for version failed".to_string());
            self
        }

        pub fn version_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VersionType>,
        {
            self.version_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `VersionType` for version_type failed".to_string());
            self
        }

        ///Sends a `GET` request to `/{index}/_source/{id}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                id,
                source,
                source_excludes,
                source_includes,
                preference,
                realtime,
                refresh,
                routing,
                version,
                version_type,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let id = id.map_err(Error::InvalidRequest)?;
            let source = source.map_err(Error::InvalidRequest)?;
            let source_excludes = source_excludes.map_err(Error::InvalidRequest)?;
            let source_includes = source_includes.map_err(Error::InvalidRequest)?;
            let preference = preference.map_err(Error::InvalidRequest)?;
            let realtime = realtime.map_err(Error::InvalidRequest)?;
            let refresh = refresh.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let version = version.map_err(Error::InvalidRequest)?;
            let version_type = version_type.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_source/{}",
                client.baseurl,
                encode_path(&index.to_string()),
                encode_path(&id.to_string()),
            );
            let mut query = Vec::with_capacity(9usize);
            if let Some(v) = &source {
                query.push(("_source", v.to_string()));
            }
            if let Some(v) = &source_excludes {
                query.push(("_source_excludes", v.to_string()));
            }
            if let Some(v) = &source_includes {
                query.push(("_source_includes", v.to_string()));
            }
            if let Some(v) = &preference {
                query.push(("preference", v.to_string()));
            }
            if let Some(v) = &realtime {
                query.push(("realtime", v.to_string()));
            }
            if let Some(v) = &refresh {
                query.push(("refresh", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &version {
                query.push(("version", v.to_string()));
            }
            if let Some(v) = &version_type {
                query.push(("version_type", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::exists_source`]
    ///
    ///[`Client::exists_source`]: super::Client::exists_source
    #[derive(Debug, Clone)]
    pub struct ExistsSource<'a> {
        client: &'a super::Client,
        index: Result<types::ExistsSourceIndex, String>,
        id: Result<types::ExistsSourceId, String>,
        source: Result<Option<Vec<String>>, String>,
        source_excludes: Result<Option<Vec<String>>, String>,
        source_includes: Result<Option<Vec<String>>, String>,
        preference: Result<Option<String>, String>,
        realtime: Result<Option<bool>, String>,
        refresh: Result<Option<bool>, String>,
        routing: Result<Option<String>, String>,
        version: Result<Option<i32>, String>,
        version_type: Result<Option<types::VersionType>, String>,
    }

    impl<'a> ExistsSource<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                id: Err("id was not initialized".to_string()),
                source: Ok(None),
                source_excludes: Ok(None),
                source_includes: Ok(None),
                preference: Ok(None),
                realtime: Ok(None),
                refresh: Ok(None),
                routing: Ok(None),
                version: Ok(None),
                version_type: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExistsSourceIndex>,
        {
            self.index = value
                .try_into()
                .map_err(|_| "conversion to `ExistsSourceIndex` for index failed".to_string());
            self
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExistsSourceId>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `ExistsSourceId` for id failed".to_string());
            self
        }

        pub fn source<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for source failed".to_string());
            self
        }

        pub fn source_excludes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_excludes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_excludes failed".to_string()
            });
            self
        }

        pub fn source_includes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_includes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_includes failed".to_string()
            });
            self
        }

        pub fn preference<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.preference = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for preference failed".to_string());
            self
        }

        pub fn realtime<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.realtime = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for realtime failed".to_string());
            self
        }

        pub fn refresh<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.refresh = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for refresh failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for routing failed".to_string());
            self
        }

        pub fn version<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.version = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for version failed".to_string());
            self
        }

        pub fn version_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VersionType>,
        {
            self.version_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `VersionType` for version_type failed".to_string());
            self
        }

        ///Sends a `HEAD` request to `/{index}/_source/{id}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                id,
                source,
                source_excludes,
                source_includes,
                preference,
                realtime,
                refresh,
                routing,
                version,
                version_type,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let id = id.map_err(Error::InvalidRequest)?;
            let source = source.map_err(Error::InvalidRequest)?;
            let source_excludes = source_excludes.map_err(Error::InvalidRequest)?;
            let source_includes = source_includes.map_err(Error::InvalidRequest)?;
            let preference = preference.map_err(Error::InvalidRequest)?;
            let realtime = realtime.map_err(Error::InvalidRequest)?;
            let refresh = refresh.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let version = version.map_err(Error::InvalidRequest)?;
            let version_type = version_type.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_source/{}",
                client.baseurl,
                encode_path(&index.to_string()),
                encode_path(&id.to_string()),
            );
            let mut query = Vec::with_capacity(9usize);
            if let Some(v) = &source {
                query.push(("_source", v.to_string()));
            }
            if let Some(v) = &source_excludes {
                query.push(("_source_excludes", v.to_string()));
            }
            if let Some(v) = &source_includes {
                query.push(("_source_includes", v.to_string()));
            }
            if let Some(v) = &preference {
                query.push(("preference", v.to_string()));
            }
            if let Some(v) = &realtime {
                query.push(("realtime", v.to_string()));
            }
            if let Some(v) = &refresh {
                query.push(("refresh", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &version {
                query.push(("version", v.to_string()));
            }
            if let Some(v) = &version_type {
                query.push(("version_type", v.to_string()));
            }
            let request = client.client.head(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_split_put`]
    ///
    ///[`Client::indices_split_put`]: super::Client::indices_split_put
    #[derive(Debug, Clone)]
    pub struct IndicesSplitPut<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesSplitPutIndex, String>,
        target: Result<types::IndicesSplitPutTarget, String>,
        cluster_manager_timeout:
            Result<Option<types::IndicesSplitPutClusterManagerTimeout>, String>,
        copy_settings: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::IndicesSplitPutMasterTimeout>, String>,
        timeout: Result<Option<types::IndicesSplitPutTimeout>, String>,
        wait_for_active_shards: Result<Option<String>, String>,
        body: Result<types::IndicesSplitBodyParams, String>,
    }

    impl<'a> IndicesSplitPut<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                target: Err("target was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                copy_settings: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
                wait_for_active_shards: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesSplitPutIndex>,
        {
            self.index = value
                .try_into()
                .map_err(|_| "conversion to `IndicesSplitPutIndex` for index failed".to_string());
            self
        }

        pub fn target<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesSplitPutTarget>,
        {
            self.target = value
                .try_into()
                .map_err(|_| "conversion to `IndicesSplitPutTarget` for target failed".to_string());
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesSplitPutClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesSplitPutClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn copy_settings<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.copy_settings = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for copy_settings failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesSplitPutMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesSplitPutMasterTimeout` for master_timeout failed".to_string()
            });
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesSplitPutTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesSplitPutTimeout` for timeout failed".to_string()
            });
            self
        }

        pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.wait_for_active_shards = value.try_into().map(Some).map_err(|_| {
                "conversion to `String` for wait_for_active_shards failed".to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesSplitBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `IndicesSplitBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `PUT` request to `/{index}/_split/{target}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                target,
                cluster_manager_timeout,
                copy_settings,
                master_timeout,
                timeout,
                wait_for_active_shards,
                body,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let target = target.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let copy_settings = copy_settings.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_split/{}",
                client.baseurl,
                encode_path(&index.to_string()),
                encode_path(&target.to_string()),
            );
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &copy_settings {
                query.push(("copy_settings", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &wait_for_active_shards {
                query.push(("wait_for_active_shards", v.to_string()));
            }
            let request = client.client.put(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_split_post`]
    ///
    ///[`Client::indices_split_post`]: super::Client::indices_split_post
    #[derive(Debug, Clone)]
    pub struct IndicesSplitPost<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesSplitPostIndex, String>,
        target: Result<types::IndicesSplitPostTarget, String>,
        cluster_manager_timeout:
            Result<Option<types::IndicesSplitPostClusterManagerTimeout>, String>,
        copy_settings: Result<Option<bool>, String>,
        master_timeout: Result<Option<types::IndicesSplitPostMasterTimeout>, String>,
        timeout: Result<Option<types::IndicesSplitPostTimeout>, String>,
        wait_for_active_shards: Result<Option<String>, String>,
        body: Result<types::IndicesSplitBodyParams, String>,
    }

    impl<'a> IndicesSplitPost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                target: Err("target was not initialized".to_string()),
                cluster_manager_timeout: Ok(None),
                copy_settings: Ok(None),
                master_timeout: Ok(None),
                timeout: Ok(None),
                wait_for_active_shards: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesSplitPostIndex>,
        {
            self.index = value
                .try_into()
                .map_err(|_| "conversion to `IndicesSplitPostIndex` for index failed".to_string());
            self
        }

        pub fn target<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesSplitPostTarget>,
        {
            self.target = value.try_into().map_err(|_| {
                "conversion to `IndicesSplitPostTarget` for target failed".to_string()
            });
            self
        }

        pub fn cluster_manager_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesSplitPostClusterManagerTimeout>,
        {
            self . cluster_manager_timeout = value . try_into () . map (Some) . map_err (| _ | "conversion to `IndicesSplitPostClusterManagerTimeout` for cluster_manager_timeout failed" . to_string ()) ;
            self
        }

        pub fn copy_settings<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.copy_settings = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for copy_settings failed".to_string());
            self
        }

        pub fn master_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesSplitPostMasterTimeout>,
        {
            self.master_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesSplitPostMasterTimeout` for master_timeout failed"
                    .to_string()
            });
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesSplitPostTimeout>,
        {
            self.timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `IndicesSplitPostTimeout` for timeout failed".to_string()
            });
            self
        }

        pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.wait_for_active_shards = value.try_into().map(Some).map_err(|_| {
                "conversion to `String` for wait_for_active_shards failed".to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesSplitBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `IndicesSplitBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `POST` request to `/{index}/_split/{target}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                target,
                cluster_manager_timeout,
                copy_settings,
                master_timeout,
                timeout,
                wait_for_active_shards,
                body,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let target = target.map_err(Error::InvalidRequest)?;
            let cluster_manager_timeout = cluster_manager_timeout.map_err(Error::InvalidRequest)?;
            let copy_settings = copy_settings.map_err(Error::InvalidRequest)?;
            let master_timeout = master_timeout.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_split/{}",
                client.baseurl,
                encode_path(&index.to_string()),
                encode_path(&target.to_string()),
            );
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &cluster_manager_timeout {
                query.push(("cluster_manager_timeout", v.to_string()));
            }
            if let Some(v) = &copy_settings {
                query.push(("copy_settings", v.to_string()));
            }
            if let Some(v) = &master_timeout {
                query.push(("master_timeout", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &wait_for_active_shards {
                query.push(("wait_for_active_shards", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_stats_with_index`]
    ///
    ///[`Client::indices_stats_with_index`]: super::Client::indices_stats_with_index
    #[derive(Debug, Clone)]
    pub struct IndicesStatsWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesStatsWithIndexIndex, String>,
        completion_fields: Result<Option<Vec<String>>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        fielddata_fields: Result<Option<Vec<String>>, String>,
        fields: Result<Option<Vec<String>>, String>,
        forbid_closed_indices: Result<Option<bool>, String>,
        groups: Result<Option<Vec<String>>, String>,
        include_segment_file_sizes: Result<Option<bool>, String>,
        include_unloaded_segments: Result<Option<bool>, String>,
        level: Result<Option<types::IndiciesStatLevel>, String>,
    }

    impl<'a> IndicesStatsWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                completion_fields: Ok(None),
                expand_wildcards: Ok(None),
                fielddata_fields: Ok(None),
                fields: Ok(None),
                forbid_closed_indices: Ok(None),
                groups: Ok(None),
                include_segment_file_sizes: Ok(None),
                include_unloaded_segments: Ok(None),
                level: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesStatsWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `IndicesStatsWithIndexIndex` for index failed".to_string()
            });
            self
        }

        pub fn completion_fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.completion_fields = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for completion_fields failed".to_string()
            });
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn fielddata_fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.fielddata_fields = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for fielddata_fields failed".to_string()
            });
            self
        }

        pub fn fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.fields = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
            self
        }

        pub fn forbid_closed_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.forbid_closed_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for forbid_closed_indices failed".to_string());
            self
        }

        pub fn groups<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.groups = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for groups failed".to_string());
            self
        }

        pub fn include_segment_file_sizes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.include_segment_file_sizes = value.try_into().map(Some).map_err(|_| {
                "conversion to `bool` for include_segment_file_sizes failed".to_string()
            });
            self
        }

        pub fn include_unloaded_segments<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.include_unloaded_segments = value.try_into().map(Some).map_err(|_| {
                "conversion to `bool` for include_unloaded_segments failed".to_string()
            });
            self
        }

        pub fn level<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndiciesStatLevel>,
        {
            self.level = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IndiciesStatLevel` for level failed".to_string());
            self
        }

        ///Sends a `GET` request to `/{index}/_stats`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                completion_fields,
                expand_wildcards,
                fielddata_fields,
                fields,
                forbid_closed_indices,
                groups,
                include_segment_file_sizes,
                include_unloaded_segments,
                level,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let completion_fields = completion_fields.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let fielddata_fields = fielddata_fields.map_err(Error::InvalidRequest)?;
            let fields = fields.map_err(Error::InvalidRequest)?;
            let forbid_closed_indices = forbid_closed_indices.map_err(Error::InvalidRequest)?;
            let groups = groups.map_err(Error::InvalidRequest)?;
            let include_segment_file_sizes =
                include_segment_file_sizes.map_err(Error::InvalidRequest)?;
            let include_unloaded_segments =
                include_unloaded_segments.map_err(Error::InvalidRequest)?;
            let level = level.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_stats",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(9usize);
            if let Some(v) = &completion_fields {
                query.push(("completion_fields", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &fielddata_fields {
                query.push(("fielddata_fields", v.to_string()));
            }
            if let Some(v) = &fields {
                query.push(("fields", v.to_string()));
            }
            if let Some(v) = &forbid_closed_indices {
                query.push(("forbid_closed_indices", v.to_string()));
            }
            if let Some(v) = &groups {
                query.push(("groups", v.to_string()));
            }
            if let Some(v) = &include_segment_file_sizes {
                query.push(("include_segment_file_sizes", v.to_string()));
            }
            if let Some(v) = &include_unloaded_segments {
                query.push(("include_unloaded_segments", v.to_string()));
            }
            if let Some(v) = &level {
                query.push(("level", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_stats_with_index_metric`]
    ///
    ///[`Client::indices_stats_with_index_metric`]: super::Client::indices_stats_with_index_metric
    #[derive(Debug, Clone)]
    pub struct IndicesStatsWithIndexMetric<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesStatsWithIndexMetricIndex, String>,
        metric: Result<types::IndicesStatsWithIndexMetricMetric, String>,
        completion_fields: Result<Option<Vec<String>>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        fielddata_fields: Result<Option<Vec<String>>, String>,
        fields: Result<Option<Vec<String>>, String>,
        forbid_closed_indices: Result<Option<bool>, String>,
        groups: Result<Option<Vec<String>>, String>,
        include_segment_file_sizes: Result<Option<bool>, String>,
        include_unloaded_segments: Result<Option<bool>, String>,
        level: Result<Option<types::IndiciesStatLevel>, String>,
    }

    impl<'a> IndicesStatsWithIndexMetric<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                metric: Err("metric was not initialized".to_string()),
                completion_fields: Ok(None),
                expand_wildcards: Ok(None),
                fielddata_fields: Ok(None),
                fields: Ok(None),
                forbid_closed_indices: Ok(None),
                groups: Ok(None),
                include_segment_file_sizes: Ok(None),
                include_unloaded_segments: Ok(None),
                level: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesStatsWithIndexMetricIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `IndicesStatsWithIndexMetricIndex` for index failed".to_string()
            });
            self
        }

        pub fn metric<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesStatsWithIndexMetricMetric>,
        {
            self.metric = value.try_into().map_err(|_| {
                "conversion to `IndicesStatsWithIndexMetricMetric` for metric failed".to_string()
            });
            self
        }

        pub fn completion_fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.completion_fields = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for completion_fields failed".to_string()
            });
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn fielddata_fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.fielddata_fields = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for fielddata_fields failed".to_string()
            });
            self
        }

        pub fn fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.fields = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
            self
        }

        pub fn forbid_closed_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.forbid_closed_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for forbid_closed_indices failed".to_string());
            self
        }

        pub fn groups<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.groups = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for groups failed".to_string());
            self
        }

        pub fn include_segment_file_sizes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.include_segment_file_sizes = value.try_into().map(Some).map_err(|_| {
                "conversion to `bool` for include_segment_file_sizes failed".to_string()
            });
            self
        }

        pub fn include_unloaded_segments<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.include_unloaded_segments = value.try_into().map(Some).map_err(|_| {
                "conversion to `bool` for include_unloaded_segments failed".to_string()
            });
            self
        }

        pub fn level<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndiciesStatLevel>,
        {
            self.level = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IndiciesStatLevel` for level failed".to_string());
            self
        }

        ///Sends a `GET` request to `/{index}/_stats/{metric}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                metric,
                completion_fields,
                expand_wildcards,
                fielddata_fields,
                fields,
                forbid_closed_indices,
                groups,
                include_segment_file_sizes,
                include_unloaded_segments,
                level,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let metric = metric.map_err(Error::InvalidRequest)?;
            let completion_fields = completion_fields.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let fielddata_fields = fielddata_fields.map_err(Error::InvalidRequest)?;
            let fields = fields.map_err(Error::InvalidRequest)?;
            let forbid_closed_indices = forbid_closed_indices.map_err(Error::InvalidRequest)?;
            let groups = groups.map_err(Error::InvalidRequest)?;
            let include_segment_file_sizes =
                include_segment_file_sizes.map_err(Error::InvalidRequest)?;
            let include_unloaded_segments =
                include_unloaded_segments.map_err(Error::InvalidRequest)?;
            let level = level.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_stats/{}",
                client.baseurl,
                encode_path(&index.to_string()),
                encode_path(&metric.to_string()),
            );
            let mut query = Vec::with_capacity(9usize);
            if let Some(v) = &completion_fields {
                query.push(("completion_fields", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &fielddata_fields {
                query.push(("fielddata_fields", v.to_string()));
            }
            if let Some(v) = &fields {
                query.push(("fields", v.to_string()));
            }
            if let Some(v) = &forbid_closed_indices {
                query.push(("forbid_closed_indices", v.to_string()));
            }
            if let Some(v) = &groups {
                query.push(("groups", v.to_string()));
            }
            if let Some(v) = &include_segment_file_sizes {
                query.push(("include_segment_file_sizes", v.to_string()));
            }
            if let Some(v) = &include_unloaded_segments {
                query.push(("include_unloaded_segments", v.to_string()));
            }
            if let Some(v) = &level {
                query.push(("level", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::termvectors_get`]
    ///
    ///[`Client::termvectors_get`]: super::Client::termvectors_get
    #[derive(Debug, Clone)]
    pub struct TermvectorsGet<'a> {
        client: &'a super::Client,
        index: Result<types::TermvectorsGetIndex, String>,
        field_statistics: Result<Option<bool>, String>,
        fields: Result<Option<Vec<String>>, String>,
        offsets: Result<Option<bool>, String>,
        payloads: Result<Option<bool>, String>,
        positions: Result<Option<bool>, String>,
        preference: Result<Option<String>, String>,
        realtime: Result<Option<bool>, String>,
        routing: Result<Option<String>, String>,
        term_statistics: Result<Option<bool>, String>,
        version: Result<Option<i32>, String>,
        version_type: Result<Option<types::VersionType>, String>,
    }

    impl<'a> TermvectorsGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                field_statistics: Ok(None),
                fields: Ok(None),
                offsets: Ok(None),
                payloads: Ok(None),
                positions: Ok(None),
                preference: Ok(None),
                realtime: Ok(None),
                routing: Ok(None),
                term_statistics: Ok(None),
                version: Ok(None),
                version_type: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::TermvectorsGetIndex>,
        {
            self.index = value
                .try_into()
                .map_err(|_| "conversion to `TermvectorsGetIndex` for index failed".to_string());
            self
        }

        pub fn field_statistics<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.field_statistics = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for field_statistics failed".to_string());
            self
        }

        pub fn fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.fields = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
            self
        }

        pub fn offsets<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.offsets = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for offsets failed".to_string());
            self
        }

        pub fn payloads<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.payloads = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for payloads failed".to_string());
            self
        }

        pub fn positions<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.positions = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for positions failed".to_string());
            self
        }

        pub fn preference<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.preference = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for preference failed".to_string());
            self
        }

        pub fn realtime<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.realtime = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for realtime failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for routing failed".to_string());
            self
        }

        pub fn term_statistics<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.term_statistics = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for term_statistics failed".to_string());
            self
        }

        pub fn version<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.version = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for version failed".to_string());
            self
        }

        pub fn version_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VersionType>,
        {
            self.version_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `VersionType` for version_type failed".to_string());
            self
        }

        ///Sends a `GET` request to `/{index}/_termvectors`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                field_statistics,
                fields,
                offsets,
                payloads,
                positions,
                preference,
                realtime,
                routing,
                term_statistics,
                version,
                version_type,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let field_statistics = field_statistics.map_err(Error::InvalidRequest)?;
            let fields = fields.map_err(Error::InvalidRequest)?;
            let offsets = offsets.map_err(Error::InvalidRequest)?;
            let payloads = payloads.map_err(Error::InvalidRequest)?;
            let positions = positions.map_err(Error::InvalidRequest)?;
            let preference = preference.map_err(Error::InvalidRequest)?;
            let realtime = realtime.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let term_statistics = term_statistics.map_err(Error::InvalidRequest)?;
            let version = version.map_err(Error::InvalidRequest)?;
            let version_type = version_type.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_termvectors",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(11usize);
            if let Some(v) = &field_statistics {
                query.push(("field_statistics", v.to_string()));
            }
            if let Some(v) = &fields {
                query.push(("fields", v.to_string()));
            }
            if let Some(v) = &offsets {
                query.push(("offsets", v.to_string()));
            }
            if let Some(v) = &payloads {
                query.push(("payloads", v.to_string()));
            }
            if let Some(v) = &positions {
                query.push(("positions", v.to_string()));
            }
            if let Some(v) = &preference {
                query.push(("preference", v.to_string()));
            }
            if let Some(v) = &realtime {
                query.push(("realtime", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &term_statistics {
                query.push(("term_statistics", v.to_string()));
            }
            if let Some(v) = &version {
                query.push(("version", v.to_string()));
            }
            if let Some(v) = &version_type {
                query.push(("version_type", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::termvectors_post`]
    ///
    ///[`Client::termvectors_post`]: super::Client::termvectors_post
    #[derive(Debug, Clone)]
    pub struct TermvectorsPost<'a> {
        client: &'a super::Client,
        index: Result<types::TermvectorsPostIndex, String>,
        field_statistics: Result<Option<bool>, String>,
        fields: Result<Option<Vec<String>>, String>,
        offsets: Result<Option<bool>, String>,
        payloads: Result<Option<bool>, String>,
        positions: Result<Option<bool>, String>,
        preference: Result<Option<String>, String>,
        realtime: Result<Option<bool>, String>,
        routing: Result<Option<String>, String>,
        term_statistics: Result<Option<bool>, String>,
        version: Result<Option<i32>, String>,
        version_type: Result<Option<types::VersionType>, String>,
        body: Result<types::TermvectorsBodyParams, String>,
    }

    impl<'a> TermvectorsPost<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                field_statistics: Ok(None),
                fields: Ok(None),
                offsets: Ok(None),
                payloads: Ok(None),
                positions: Ok(None),
                preference: Ok(None),
                realtime: Ok(None),
                routing: Ok(None),
                term_statistics: Ok(None),
                version: Ok(None),
                version_type: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::TermvectorsPostIndex>,
        {
            self.index = value
                .try_into()
                .map_err(|_| "conversion to `TermvectorsPostIndex` for index failed".to_string());
            self
        }

        pub fn field_statistics<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.field_statistics = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for field_statistics failed".to_string());
            self
        }

        pub fn fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.fields = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
            self
        }

        pub fn offsets<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.offsets = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for offsets failed".to_string());
            self
        }

        pub fn payloads<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.payloads = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for payloads failed".to_string());
            self
        }

        pub fn positions<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.positions = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for positions failed".to_string());
            self
        }

        pub fn preference<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.preference = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for preference failed".to_string());
            self
        }

        pub fn realtime<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.realtime = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for realtime failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for routing failed".to_string());
            self
        }

        pub fn term_statistics<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.term_statistics = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for term_statistics failed".to_string());
            self
        }

        pub fn version<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.version = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for version failed".to_string());
            self
        }

        pub fn version_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VersionType>,
        {
            self.version_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `VersionType` for version_type failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::TermvectorsBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `TermvectorsBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `POST` request to `/{index}/_termvectors`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                field_statistics,
                fields,
                offsets,
                payloads,
                positions,
                preference,
                realtime,
                routing,
                term_statistics,
                version,
                version_type,
                body,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let field_statistics = field_statistics.map_err(Error::InvalidRequest)?;
            let fields = fields.map_err(Error::InvalidRequest)?;
            let offsets = offsets.map_err(Error::InvalidRequest)?;
            let payloads = payloads.map_err(Error::InvalidRequest)?;
            let positions = positions.map_err(Error::InvalidRequest)?;
            let preference = preference.map_err(Error::InvalidRequest)?;
            let realtime = realtime.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let term_statistics = term_statistics.map_err(Error::InvalidRequest)?;
            let version = version.map_err(Error::InvalidRequest)?;
            let version_type = version_type.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_termvectors",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(11usize);
            if let Some(v) = &field_statistics {
                query.push(("field_statistics", v.to_string()));
            }
            if let Some(v) = &fields {
                query.push(("fields", v.to_string()));
            }
            if let Some(v) = &offsets {
                query.push(("offsets", v.to_string()));
            }
            if let Some(v) = &payloads {
                query.push(("payloads", v.to_string()));
            }
            if let Some(v) = &positions {
                query.push(("positions", v.to_string()));
            }
            if let Some(v) = &preference {
                query.push(("preference", v.to_string()));
            }
            if let Some(v) = &realtime {
                query.push(("realtime", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &term_statistics {
                query.push(("term_statistics", v.to_string()));
            }
            if let Some(v) = &version {
                query.push(("version", v.to_string()));
            }
            if let Some(v) = &version_type {
                query.push(("version_type", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::termvectors_get_with_id`]
    ///
    ///[`Client::termvectors_get_with_id`]: super::Client::termvectors_get_with_id
    #[derive(Debug, Clone)]
    pub struct TermvectorsGetWithId<'a> {
        client: &'a super::Client,
        index: Result<types::TermvectorsGetWithIdIndex, String>,
        id: Result<types::TermvectorsGetWithIdId, String>,
        field_statistics: Result<Option<bool>, String>,
        fields: Result<Option<Vec<String>>, String>,
        offsets: Result<Option<bool>, String>,
        payloads: Result<Option<bool>, String>,
        positions: Result<Option<bool>, String>,
        preference: Result<Option<String>, String>,
        realtime: Result<Option<bool>, String>,
        routing: Result<Option<String>, String>,
        term_statistics: Result<Option<bool>, String>,
        version: Result<Option<i32>, String>,
        version_type: Result<Option<types::VersionType>, String>,
    }

    impl<'a> TermvectorsGetWithId<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                id: Err("id was not initialized".to_string()),
                field_statistics: Ok(None),
                fields: Ok(None),
                offsets: Ok(None),
                payloads: Ok(None),
                positions: Ok(None),
                preference: Ok(None),
                realtime: Ok(None),
                routing: Ok(None),
                term_statistics: Ok(None),
                version: Ok(None),
                version_type: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::TermvectorsGetWithIdIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `TermvectorsGetWithIdIndex` for index failed".to_string()
            });
            self
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::TermvectorsGetWithIdId>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `TermvectorsGetWithIdId` for id failed".to_string());
            self
        }

        pub fn field_statistics<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.field_statistics = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for field_statistics failed".to_string());
            self
        }

        pub fn fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.fields = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
            self
        }

        pub fn offsets<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.offsets = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for offsets failed".to_string());
            self
        }

        pub fn payloads<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.payloads = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for payloads failed".to_string());
            self
        }

        pub fn positions<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.positions = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for positions failed".to_string());
            self
        }

        pub fn preference<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.preference = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for preference failed".to_string());
            self
        }

        pub fn realtime<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.realtime = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for realtime failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for routing failed".to_string());
            self
        }

        pub fn term_statistics<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.term_statistics = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for term_statistics failed".to_string());
            self
        }

        pub fn version<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.version = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for version failed".to_string());
            self
        }

        pub fn version_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VersionType>,
        {
            self.version_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `VersionType` for version_type failed".to_string());
            self
        }

        ///Sends a `GET` request to `/{index}/_termvectors/{id}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                id,
                field_statistics,
                fields,
                offsets,
                payloads,
                positions,
                preference,
                realtime,
                routing,
                term_statistics,
                version,
                version_type,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let id = id.map_err(Error::InvalidRequest)?;
            let field_statistics = field_statistics.map_err(Error::InvalidRequest)?;
            let fields = fields.map_err(Error::InvalidRequest)?;
            let offsets = offsets.map_err(Error::InvalidRequest)?;
            let payloads = payloads.map_err(Error::InvalidRequest)?;
            let positions = positions.map_err(Error::InvalidRequest)?;
            let preference = preference.map_err(Error::InvalidRequest)?;
            let realtime = realtime.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let term_statistics = term_statistics.map_err(Error::InvalidRequest)?;
            let version = version.map_err(Error::InvalidRequest)?;
            let version_type = version_type.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_termvectors/{}",
                client.baseurl,
                encode_path(&index.to_string()),
                encode_path(&id.to_string()),
            );
            let mut query = Vec::with_capacity(11usize);
            if let Some(v) = &field_statistics {
                query.push(("field_statistics", v.to_string()));
            }
            if let Some(v) = &fields {
                query.push(("fields", v.to_string()));
            }
            if let Some(v) = &offsets {
                query.push(("offsets", v.to_string()));
            }
            if let Some(v) = &payloads {
                query.push(("payloads", v.to_string()));
            }
            if let Some(v) = &positions {
                query.push(("positions", v.to_string()));
            }
            if let Some(v) = &preference {
                query.push(("preference", v.to_string()));
            }
            if let Some(v) = &realtime {
                query.push(("realtime", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &term_statistics {
                query.push(("term_statistics", v.to_string()));
            }
            if let Some(v) = &version {
                query.push(("version", v.to_string()));
            }
            if let Some(v) = &version_type {
                query.push(("version_type", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::termvectors_post_with_id`]
    ///
    ///[`Client::termvectors_post_with_id`]: super::Client::termvectors_post_with_id
    #[derive(Debug, Clone)]
    pub struct TermvectorsPostWithId<'a> {
        client: &'a super::Client,
        index: Result<types::TermvectorsPostWithIdIndex, String>,
        id: Result<types::TermvectorsPostWithIdId, String>,
        field_statistics: Result<Option<bool>, String>,
        fields: Result<Option<Vec<String>>, String>,
        offsets: Result<Option<bool>, String>,
        payloads: Result<Option<bool>, String>,
        positions: Result<Option<bool>, String>,
        preference: Result<Option<String>, String>,
        realtime: Result<Option<bool>, String>,
        routing: Result<Option<String>, String>,
        term_statistics: Result<Option<bool>, String>,
        version: Result<Option<i32>, String>,
        version_type: Result<Option<types::VersionType>, String>,
        body: Result<types::TermvectorsBodyParams, String>,
    }

    impl<'a> TermvectorsPostWithId<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                id: Err("id was not initialized".to_string()),
                field_statistics: Ok(None),
                fields: Ok(None),
                offsets: Ok(None),
                payloads: Ok(None),
                positions: Ok(None),
                preference: Ok(None),
                realtime: Ok(None),
                routing: Ok(None),
                term_statistics: Ok(None),
                version: Ok(None),
                version_type: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::TermvectorsPostWithIdIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `TermvectorsPostWithIdIndex` for index failed".to_string()
            });
            self
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::TermvectorsPostWithIdId>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `TermvectorsPostWithIdId` for id failed".to_string());
            self
        }

        pub fn field_statistics<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.field_statistics = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for field_statistics failed".to_string());
            self
        }

        pub fn fields<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.fields = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for fields failed".to_string());
            self
        }

        pub fn offsets<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.offsets = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for offsets failed".to_string());
            self
        }

        pub fn payloads<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.payloads = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for payloads failed".to_string());
            self
        }

        pub fn positions<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.positions = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for positions failed".to_string());
            self
        }

        pub fn preference<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.preference = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for preference failed".to_string());
            self
        }

        pub fn realtime<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.realtime = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for realtime failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for routing failed".to_string());
            self
        }

        pub fn term_statistics<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.term_statistics = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for term_statistics failed".to_string());
            self
        }

        pub fn version<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.version = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for version failed".to_string());
            self
        }

        pub fn version_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VersionType>,
        {
            self.version_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `VersionType` for version_type failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::TermvectorsBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `TermvectorsBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `POST` request to `/{index}/_termvectors/{id}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                id,
                field_statistics,
                fields,
                offsets,
                payloads,
                positions,
                preference,
                realtime,
                routing,
                term_statistics,
                version,
                version_type,
                body,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let id = id.map_err(Error::InvalidRequest)?;
            let field_statistics = field_statistics.map_err(Error::InvalidRequest)?;
            let fields = fields.map_err(Error::InvalidRequest)?;
            let offsets = offsets.map_err(Error::InvalidRequest)?;
            let payloads = payloads.map_err(Error::InvalidRequest)?;
            let positions = positions.map_err(Error::InvalidRequest)?;
            let preference = preference.map_err(Error::InvalidRequest)?;
            let realtime = realtime.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let term_statistics = term_statistics.map_err(Error::InvalidRequest)?;
            let version = version.map_err(Error::InvalidRequest)?;
            let version_type = version_type.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_termvectors/{}",
                client.baseurl,
                encode_path(&index.to_string()),
                encode_path(&id.to_string()),
            );
            let mut query = Vec::with_capacity(11usize);
            if let Some(v) = &field_statistics {
                query.push(("field_statistics", v.to_string()));
            }
            if let Some(v) = &fields {
                query.push(("fields", v.to_string()));
            }
            if let Some(v) = &offsets {
                query.push(("offsets", v.to_string()));
            }
            if let Some(v) = &payloads {
                query.push(("payloads", v.to_string()));
            }
            if let Some(v) = &positions {
                query.push(("positions", v.to_string()));
            }
            if let Some(v) = &preference {
                query.push(("preference", v.to_string()));
            }
            if let Some(v) = &realtime {
                query.push(("realtime", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &term_statistics {
                query.push(("term_statistics", v.to_string()));
            }
            if let Some(v) = &version {
                query.push(("version", v.to_string()));
            }
            if let Some(v) = &version_type {
                query.push(("version_type", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::update`]
    ///
    ///[`Client::update`]: super::Client::update
    #[derive(Debug, Clone)]
    pub struct Update<'a> {
        client: &'a super::Client,
        index: Result<types::UpdateIndex, String>,
        id: Result<types::UpdateId, String>,
        source: Result<Option<Vec<String>>, String>,
        source_excludes: Result<Option<Vec<String>>, String>,
        source_includes: Result<Option<Vec<String>>, String>,
        if_primary_term: Result<Option<i32>, String>,
        if_seq_no: Result<Option<i32>, String>,
        lang: Result<Option<String>, String>,
        refresh: Result<Option<types::RefreshEnum>, String>,
        require_alias: Result<Option<bool>, String>,
        retry_on_conflict: Result<Option<i32>, String>,
        routing: Result<Option<String>, String>,
        timeout: Result<Option<types::UpdateTimeout>, String>,
        wait_for_active_shards: Result<Option<String>, String>,
        body: Result<types::UpdateBodyParams, String>,
    }

    impl<'a> Update<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                id: Err("id was not initialized".to_string()),
                source: Ok(None),
                source_excludes: Ok(None),
                source_includes: Ok(None),
                if_primary_term: Ok(None),
                if_seq_no: Ok(None),
                lang: Ok(None),
                refresh: Ok(None),
                require_alias: Ok(None),
                retry_on_conflict: Ok(None),
                routing: Ok(None),
                timeout: Ok(None),
                wait_for_active_shards: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdateIndex>,
        {
            self.index = value
                .try_into()
                .map_err(|_| "conversion to `UpdateIndex` for index failed".to_string());
            self
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdateId>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `UpdateId` for id failed".to_string());
            self
        }

        pub fn source<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for source failed".to_string());
            self
        }

        pub fn source_excludes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_excludes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_excludes failed".to_string()
            });
            self
        }

        pub fn source_includes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_includes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_includes failed".to_string()
            });
            self
        }

        pub fn if_primary_term<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.if_primary_term = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for if_primary_term failed".to_string());
            self
        }

        pub fn if_seq_no<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.if_seq_no = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for if_seq_no failed".to_string());
            self
        }

        pub fn lang<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.lang = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for lang failed".to_string());
            self
        }

        pub fn refresh<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RefreshEnum>,
        {
            self.refresh = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `RefreshEnum` for refresh failed".to_string());
            self
        }

        pub fn require_alias<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.require_alias = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for require_alias failed".to_string());
            self
        }

        pub fn retry_on_conflict<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.retry_on_conflict = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for retry_on_conflict failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for routing failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdateTimeout>,
        {
            self.timeout = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `UpdateTimeout` for timeout failed".to_string());
            self
        }

        pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.wait_for_active_shards = value.try_into().map(Some).map_err(|_| {
                "conversion to `String` for wait_for_active_shards failed".to_string()
            });
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdateBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `UpdateBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `POST` request to `/{index}/_update/{id}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                id,
                source,
                source_excludes,
                source_includes,
                if_primary_term,
                if_seq_no,
                lang,
                refresh,
                require_alias,
                retry_on_conflict,
                routing,
                timeout,
                wait_for_active_shards,
                body,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let id = id.map_err(Error::InvalidRequest)?;
            let source = source.map_err(Error::InvalidRequest)?;
            let source_excludes = source_excludes.map_err(Error::InvalidRequest)?;
            let source_includes = source_includes.map_err(Error::InvalidRequest)?;
            let if_primary_term = if_primary_term.map_err(Error::InvalidRequest)?;
            let if_seq_no = if_seq_no.map_err(Error::InvalidRequest)?;
            let lang = lang.map_err(Error::InvalidRequest)?;
            let refresh = refresh.map_err(Error::InvalidRequest)?;
            let require_alias = require_alias.map_err(Error::InvalidRequest)?;
            let retry_on_conflict = retry_on_conflict.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_update/{}",
                client.baseurl,
                encode_path(&index.to_string()),
                encode_path(&id.to_string()),
            );
            let mut query = Vec::with_capacity(12usize);
            if let Some(v) = &source {
                query.push(("_source", v.to_string()));
            }
            if let Some(v) = &source_excludes {
                query.push(("_source_excludes", v.to_string()));
            }
            if let Some(v) = &source_includes {
                query.push(("_source_includes", v.to_string()));
            }
            if let Some(v) = &if_primary_term {
                query.push(("if_primary_term", v.to_string()));
            }
            if let Some(v) = &if_seq_no {
                query.push(("if_seq_no", v.to_string()));
            }
            if let Some(v) = &lang {
                query.push(("lang", v.to_string()));
            }
            if let Some(v) = &refresh {
                query.push(("refresh", v.to_string()));
            }
            if let Some(v) = &require_alias {
                query.push(("require_alias", v.to_string()));
            }
            if let Some(v) = &retry_on_conflict {
                query.push(("retry_on_conflict", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &wait_for_active_shards {
                query.push(("wait_for_active_shards", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::update_by_query`]
    ///
    ///[`Client::update_by_query`]: super::Client::update_by_query
    #[derive(Debug, Clone)]
    pub struct UpdateByQuery<'a> {
        client: &'a super::Client,
        index: Result<types::UpdateByQueryIndex, String>,
        source: Result<Option<Vec<String>>, String>,
        source_excludes: Result<Option<Vec<String>>, String>,
        source_includes: Result<Option<Vec<String>>, String>,
        allow_no_indices: Result<Option<bool>, String>,
        analyze_wildcard: Result<Option<bool>, String>,
        analyzer: Result<Option<String>, String>,
        conflicts: Result<Option<types::Conflicts>, String>,
        default_operator: Result<Option<types::DefaultOperator>, String>,
        df: Result<Option<String>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        from: Result<Option<i32>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        lenient: Result<Option<bool>, String>,
        max_docs: Result<Option<i32>, String>,
        pipeline: Result<Option<String>, String>,
        preference: Result<Option<String>, String>,
        q: Result<Option<String>, String>,
        refresh: Result<Option<bool>, String>,
        request_cache: Result<Option<bool>, String>,
        requests_per_second: Result<Option<i32>, String>,
        routing: Result<Option<Vec<String>>, String>,
        scroll: Result<Option<types::UpdateByQueryScroll>, String>,
        scroll_size: Result<Option<i32>, String>,
        search_timeout: Result<Option<types::UpdateByQuerySearchTimeout>, String>,
        search_type: Result<Option<types::SearchType>, String>,
        size: Result<Option<i32>, String>,
        slices: Result<Option<String>, String>,
        sort: Result<Option<Vec<String>>, String>,
        stats: Result<Option<Vec<String>>, String>,
        terminate_after: Result<Option<i32>, String>,
        timeout: Result<Option<types::UpdateByQueryTimeout>, String>,
        version: Result<Option<bool>, String>,
        wait_for_active_shards: Result<Option<String>, String>,
        wait_for_completion: Result<Option<bool>, String>,
        body: Result<types::UpdateByQueryBodyParams, String>,
    }

    impl<'a> UpdateByQuery<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                source: Ok(None),
                source_excludes: Ok(None),
                source_includes: Ok(None),
                allow_no_indices: Ok(None),
                analyze_wildcard: Ok(None),
                analyzer: Ok(None),
                conflicts: Ok(None),
                default_operator: Ok(None),
                df: Ok(None),
                expand_wildcards: Ok(None),
                from: Ok(None),
                ignore_unavailable: Ok(None),
                lenient: Ok(None),
                max_docs: Ok(None),
                pipeline: Ok(None),
                preference: Ok(None),
                q: Ok(None),
                refresh: Ok(None),
                request_cache: Ok(None),
                requests_per_second: Ok(None),
                routing: Ok(None),
                scroll: Ok(None),
                scroll_size: Ok(None),
                search_timeout: Ok(None),
                search_type: Ok(None),
                size: Ok(None),
                slices: Ok(None),
                sort: Ok(None),
                stats: Ok(None),
                terminate_after: Ok(None),
                timeout: Ok(None),
                version: Ok(None),
                wait_for_active_shards: Ok(None),
                wait_for_completion: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdateByQueryIndex>,
        {
            self.index = value
                .try_into()
                .map_err(|_| "conversion to `UpdateByQueryIndex` for index failed".to_string());
            self
        }

        pub fn source<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for source failed".to_string());
            self
        }

        pub fn source_excludes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_excludes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_excludes failed".to_string()
            });
            self
        }

        pub fn source_includes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.source_includes = value.try_into().map(Some).map_err(|_| {
                "conversion to `Vec < String >` for source_includes failed".to_string()
            });
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn analyze_wildcard<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.analyze_wildcard = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for analyze_wildcard failed".to_string());
            self
        }

        pub fn analyzer<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.analyzer = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for analyzer failed".to_string());
            self
        }

        pub fn conflicts<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Conflicts>,
        {
            self.conflicts = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Conflicts` for conflicts failed".to_string());
            self
        }

        pub fn default_operator<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DefaultOperator>,
        {
            self.default_operator = value.try_into().map(Some).map_err(|_| {
                "conversion to `DefaultOperator` for default_operator failed".to_string()
            });
            self
        }

        pub fn df<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.df = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for df failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn from<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.from = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for from failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn lenient<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.lenient = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for lenient failed".to_string());
            self
        }

        pub fn max_docs<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.max_docs = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for max_docs failed".to_string());
            self
        }

        pub fn pipeline<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.pipeline = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for pipeline failed".to_string());
            self
        }

        pub fn preference<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.preference = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for preference failed".to_string());
            self
        }

        pub fn q<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.q = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for q failed".to_string());
            self
        }

        pub fn refresh<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.refresh = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for refresh failed".to_string());
            self
        }

        pub fn request_cache<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.request_cache = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for request_cache failed".to_string());
            self
        }

        pub fn requests_per_second<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.requests_per_second = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for requests_per_second failed".to_string());
            self
        }

        pub fn routing<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.routing = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for routing failed".to_string());
            self
        }

        pub fn scroll<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdateByQueryScroll>,
        {
            self.scroll = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `UpdateByQueryScroll` for scroll failed".to_string());
            self
        }

        pub fn scroll_size<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.scroll_size = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for scroll_size failed".to_string());
            self
        }

        pub fn search_timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdateByQuerySearchTimeout>,
        {
            self.search_timeout = value.try_into().map(Some).map_err(|_| {
                "conversion to `UpdateByQuerySearchTimeout` for search_timeout failed".to_string()
            });
            self
        }

        pub fn search_type<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchType>,
        {
            self.search_type = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `SearchType` for search_type failed".to_string());
            self
        }

        pub fn size<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.size = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for size failed".to_string());
            self
        }

        pub fn slices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.slices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for slices failed".to_string());
            self
        }

        pub fn sort<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.sort = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for sort failed".to_string());
            self
        }

        pub fn stats<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<Vec<String>>,
        {
            self.stats = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `Vec < String >` for stats failed".to_string());
            self
        }

        pub fn terminate_after<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<i32>,
        {
            self.terminate_after = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `i32` for terminate_after failed".to_string());
            self
        }

        pub fn timeout<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdateByQueryTimeout>,
        {
            self.timeout = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `UpdateByQueryTimeout` for timeout failed".to_string());
            self
        }

        pub fn version<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.version = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for version failed".to_string());
            self
        }

        pub fn wait_for_active_shards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.wait_for_active_shards = value.try_into().map(Some).map_err(|_| {
                "conversion to `String` for wait_for_active_shards failed".to_string()
            });
            self
        }

        pub fn wait_for_completion<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.wait_for_completion = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for wait_for_completion failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdateByQueryBodyParams>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `UpdateByQueryBodyParams` for body failed".to_string());
            self
        }

        ///Sends a `POST` request to `/{index}/_update_by_query`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                source,
                source_excludes,
                source_includes,
                allow_no_indices,
                analyze_wildcard,
                analyzer,
                conflicts,
                default_operator,
                df,
                expand_wildcards,
                from,
                ignore_unavailable,
                lenient,
                max_docs,
                pipeline,
                preference,
                q,
                refresh,
                request_cache,
                requests_per_second,
                routing,
                scroll,
                scroll_size,
                search_timeout,
                search_type,
                size,
                slices,
                sort,
                stats,
                terminate_after,
                timeout,
                version,
                wait_for_active_shards,
                wait_for_completion,
                body,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let source = source.map_err(Error::InvalidRequest)?;
            let source_excludes = source_excludes.map_err(Error::InvalidRequest)?;
            let source_includes = source_includes.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let analyze_wildcard = analyze_wildcard.map_err(Error::InvalidRequest)?;
            let analyzer = analyzer.map_err(Error::InvalidRequest)?;
            let conflicts = conflicts.map_err(Error::InvalidRequest)?;
            let default_operator = default_operator.map_err(Error::InvalidRequest)?;
            let df = df.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let from = from.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let lenient = lenient.map_err(Error::InvalidRequest)?;
            let max_docs = max_docs.map_err(Error::InvalidRequest)?;
            let pipeline = pipeline.map_err(Error::InvalidRequest)?;
            let preference = preference.map_err(Error::InvalidRequest)?;
            let q = q.map_err(Error::InvalidRequest)?;
            let refresh = refresh.map_err(Error::InvalidRequest)?;
            let request_cache = request_cache.map_err(Error::InvalidRequest)?;
            let requests_per_second = requests_per_second.map_err(Error::InvalidRequest)?;
            let routing = routing.map_err(Error::InvalidRequest)?;
            let scroll = scroll.map_err(Error::InvalidRequest)?;
            let scroll_size = scroll_size.map_err(Error::InvalidRequest)?;
            let search_timeout = search_timeout.map_err(Error::InvalidRequest)?;
            let search_type = search_type.map_err(Error::InvalidRequest)?;
            let size = size.map_err(Error::InvalidRequest)?;
            let slices = slices.map_err(Error::InvalidRequest)?;
            let sort = sort.map_err(Error::InvalidRequest)?;
            let stats = stats.map_err(Error::InvalidRequest)?;
            let terminate_after = terminate_after.map_err(Error::InvalidRequest)?;
            let timeout = timeout.map_err(Error::InvalidRequest)?;
            let version = version.map_err(Error::InvalidRequest)?;
            let wait_for_active_shards = wait_for_active_shards.map_err(Error::InvalidRequest)?;
            let wait_for_completion = wait_for_completion.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_update_by_query",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(34usize);
            if let Some(v) = &source {
                query.push(("_source", v.to_string()));
            }
            if let Some(v) = &source_excludes {
                query.push(("_source_excludes", v.to_string()));
            }
            if let Some(v) = &source_includes {
                query.push(("_source_includes", v.to_string()));
            }
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &analyze_wildcard {
                query.push(("analyze_wildcard", v.to_string()));
            }
            if let Some(v) = &analyzer {
                query.push(("analyzer", v.to_string()));
            }
            if let Some(v) = &conflicts {
                query.push(("conflicts", v.to_string()));
            }
            if let Some(v) = &default_operator {
                query.push(("default_operator", v.to_string()));
            }
            if let Some(v) = &df {
                query.push(("df", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &from {
                query.push(("from", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &lenient {
                query.push(("lenient", v.to_string()));
            }
            if let Some(v) = &max_docs {
                query.push(("max_docs", v.to_string()));
            }
            if let Some(v) = &pipeline {
                query.push(("pipeline", v.to_string()));
            }
            if let Some(v) = &preference {
                query.push(("preference", v.to_string()));
            }
            if let Some(v) = &q {
                query.push(("q", v.to_string()));
            }
            if let Some(v) = &refresh {
                query.push(("refresh", v.to_string()));
            }
            if let Some(v) = &request_cache {
                query.push(("request_cache", v.to_string()));
            }
            if let Some(v) = &requests_per_second {
                query.push(("requests_per_second", v.to_string()));
            }
            if let Some(v) = &routing {
                query.push(("routing", v.to_string()));
            }
            if let Some(v) = &scroll {
                query.push(("scroll", v.to_string()));
            }
            if let Some(v) = &scroll_size {
                query.push(("scroll_size", v.to_string()));
            }
            if let Some(v) = &search_timeout {
                query.push(("search_timeout", v.to_string()));
            }
            if let Some(v) = &search_type {
                query.push(("search_type", v.to_string()));
            }
            if let Some(v) = &size {
                query.push(("size", v.to_string()));
            }
            if let Some(v) = &slices {
                query.push(("slices", v.to_string()));
            }
            if let Some(v) = &sort {
                query.push(("sort", v.to_string()));
            }
            if let Some(v) = &stats {
                query.push(("stats", v.to_string()));
            }
            if let Some(v) = &terminate_after {
                query.push(("terminate_after", v.to_string()));
            }
            if let Some(v) = &timeout {
                query.push(("timeout", v.to_string()));
            }
            if let Some(v) = &version {
                query.push(("version", v.to_string()));
            }
            if let Some(v) = &wait_for_active_shards {
                query.push(("wait_for_active_shards", v.to_string()));
            }
            if let Some(v) = &wait_for_completion {
                query.push(("wait_for_completion", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_get_upgrade_with_index`]
    ///
    ///[`Client::indices_get_upgrade_with_index`]: super::Client::indices_get_upgrade_with_index
    #[derive(Debug, Clone)]
    pub struct IndicesGetUpgradeWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesGetUpgradeWithIndexIndex, String>,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
    }

    impl<'a> IndicesGetUpgradeWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                ignore_unavailable: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesGetUpgradeWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `IndicesGetUpgradeWithIndexIndex` for index failed".to_string()
            });
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        ///Sends a `GET` request to `/{index}/_upgrade`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                allow_no_indices,
                expand_wildcards,
                ignore_unavailable,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_upgrade",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_upgrade_with_index`]
    ///
    ///[`Client::indices_upgrade_with_index`]: super::Client::indices_upgrade_with_index
    #[derive(Debug, Clone)]
    pub struct IndicesUpgradeWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesUpgradeWithIndexIndex, String>,
        allow_no_indices: Result<Option<bool>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        only_ancient_segments: Result<Option<bool>, String>,
        wait_for_completion: Result<Option<bool>, String>,
    }

    impl<'a> IndicesUpgradeWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                allow_no_indices: Ok(None),
                expand_wildcards: Ok(None),
                ignore_unavailable: Ok(None),
                only_ancient_segments: Ok(None),
                wait_for_completion: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesUpgradeWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `IndicesUpgradeWithIndexIndex` for index failed".to_string()
            });
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn only_ancient_segments<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.only_ancient_segments = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for only_ancient_segments failed".to_string());
            self
        }

        pub fn wait_for_completion<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.wait_for_completion = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for wait_for_completion failed".to_string());
            self
        }

        ///Sends a `POST` request to `/{index}/_upgrade`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                allow_no_indices,
                expand_wildcards,
                ignore_unavailable,
                only_ancient_segments,
                wait_for_completion,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let only_ancient_segments = only_ancient_segments.map_err(Error::InvalidRequest)?;
            let wait_for_completion = wait_for_completion.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_upgrade",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &only_ancient_segments {
                query.push(("only_ancient_segments", v.to_string()));
            }
            if let Some(v) = &wait_for_completion {
                query.push(("wait_for_completion", v.to_string()));
            }
            let request = client.client.post(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_validate_query_get_with_index`]
    ///
    ///[`Client::indices_validate_query_get_with_index`]: super::Client::indices_validate_query_get_with_index
    #[derive(Debug, Clone)]
    pub struct IndicesValidateQueryGetWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesValidateQueryGetWithIndexIndex, String>,
        all_shards: Result<Option<bool>, String>,
        allow_no_indices: Result<Option<bool>, String>,
        analyze_wildcard: Result<Option<bool>, String>,
        analyzer: Result<Option<String>, String>,
        default_operator: Result<Option<types::DefaultOperator>, String>,
        df: Result<Option<String>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        explain: Result<Option<bool>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        lenient: Result<Option<bool>, String>,
        q: Result<Option<String>, String>,
        rewrite: Result<Option<bool>, String>,
    }

    impl<'a> IndicesValidateQueryGetWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                all_shards: Ok(None),
                allow_no_indices: Ok(None),
                analyze_wildcard: Ok(None),
                analyzer: Ok(None),
                default_operator: Ok(None),
                df: Ok(None),
                expand_wildcards: Ok(None),
                explain: Ok(None),
                ignore_unavailable: Ok(None),
                lenient: Ok(None),
                q: Ok(None),
                rewrite: Ok(None),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesValidateQueryGetWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `IndicesValidateQueryGetWithIndexIndex` for index failed".to_string()
            });
            self
        }

        pub fn all_shards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.all_shards = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for all_shards failed".to_string());
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn analyze_wildcard<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.analyze_wildcard = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for analyze_wildcard failed".to_string());
            self
        }

        pub fn analyzer<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.analyzer = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for analyzer failed".to_string());
            self
        }

        pub fn default_operator<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DefaultOperator>,
        {
            self.default_operator = value.try_into().map(Some).map_err(|_| {
                "conversion to `DefaultOperator` for default_operator failed".to_string()
            });
            self
        }

        pub fn df<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.df = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for df failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn explain<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.explain = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for explain failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn lenient<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.lenient = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for lenient failed".to_string());
            self
        }

        pub fn q<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.q = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for q failed".to_string());
            self
        }

        pub fn rewrite<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.rewrite = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for rewrite failed".to_string());
            self
        }

        ///Sends a `GET` request to `/{index}/_validate/query`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                all_shards,
                allow_no_indices,
                analyze_wildcard,
                analyzer,
                default_operator,
                df,
                expand_wildcards,
                explain,
                ignore_unavailable,
                lenient,
                q,
                rewrite,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let all_shards = all_shards.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let analyze_wildcard = analyze_wildcard.map_err(Error::InvalidRequest)?;
            let analyzer = analyzer.map_err(Error::InvalidRequest)?;
            let default_operator = default_operator.map_err(Error::InvalidRequest)?;
            let df = df.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let explain = explain.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let lenient = lenient.map_err(Error::InvalidRequest)?;
            let q = q.map_err(Error::InvalidRequest)?;
            let rewrite = rewrite.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_validate/query",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(12usize);
            if let Some(v) = &all_shards {
                query.push(("all_shards", v.to_string()));
            }
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &analyze_wildcard {
                query.push(("analyze_wildcard", v.to_string()));
            }
            if let Some(v) = &analyzer {
                query.push(("analyzer", v.to_string()));
            }
            if let Some(v) = &default_operator {
                query.push(("default_operator", v.to_string()));
            }
            if let Some(v) = &df {
                query.push(("df", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &explain {
                query.push(("explain", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &lenient {
                query.push(("lenient", v.to_string()));
            }
            if let Some(v) = &q {
                query.push(("q", v.to_string()));
            }
            if let Some(v) = &rewrite {
                query.push(("rewrite", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    ///Builder for [`Client::indices_validate_query_post_with_index`]
    ///
    ///[`Client::indices_validate_query_post_with_index`]: super::Client::indices_validate_query_post_with_index
    #[derive(Debug, Clone)]
    pub struct IndicesValidateQueryPostWithIndex<'a> {
        client: &'a super::Client,
        index: Result<types::IndicesValidateQueryPostWithIndexIndex, String>,
        all_shards: Result<Option<bool>, String>,
        allow_no_indices: Result<Option<bool>, String>,
        analyze_wildcard: Result<Option<bool>, String>,
        analyzer: Result<Option<String>, String>,
        default_operator: Result<Option<types::DefaultOperator>, String>,
        df: Result<Option<String>, String>,
        expand_wildcards: Result<Option<types::ExpandWildcards>, String>,
        explain: Result<Option<bool>, String>,
        ignore_unavailable: Result<Option<bool>, String>,
        lenient: Result<Option<bool>, String>,
        q: Result<Option<String>, String>,
        rewrite: Result<Option<bool>, String>,
        body: Result<types::IndicesValidateQueryBodyParams, String>,
    }

    impl<'a> IndicesValidateQueryPostWithIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                index: Err("index was not initialized".to_string()),
                all_shards: Ok(None),
                allow_no_indices: Ok(None),
                analyze_wildcard: Ok(None),
                analyzer: Ok(None),
                default_operator: Ok(None),
                df: Ok(None),
                expand_wildcards: Ok(None),
                explain: Ok(None),
                ignore_unavailable: Ok(None),
                lenient: Ok(None),
                q: Ok(None),
                rewrite: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn index<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesValidateQueryPostWithIndexIndex>,
        {
            self.index = value.try_into().map_err(|_| {
                "conversion to `IndicesValidateQueryPostWithIndexIndex` for index failed"
                    .to_string()
            });
            self
        }

        pub fn all_shards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.all_shards = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for all_shards failed".to_string());
            self
        }

        pub fn allow_no_indices<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.allow_no_indices = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for allow_no_indices failed".to_string());
            self
        }

        pub fn analyze_wildcard<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.analyze_wildcard = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for analyze_wildcard failed".to_string());
            self
        }

        pub fn analyzer<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.analyzer = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for analyzer failed".to_string());
            self
        }

        pub fn default_operator<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DefaultOperator>,
        {
            self.default_operator = value.try_into().map(Some).map_err(|_| {
                "conversion to `DefaultOperator` for default_operator failed".to_string()
            });
            self
        }

        pub fn df<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.df = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for df failed".to_string());
            self
        }

        pub fn expand_wildcards<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ExpandWildcards>,
        {
            self.expand_wildcards = value.try_into().map(Some).map_err(|_| {
                "conversion to `ExpandWildcards` for expand_wildcards failed".to_string()
            });
            self
        }

        pub fn explain<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.explain = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for explain failed".to_string());
            self
        }

        pub fn ignore_unavailable<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.ignore_unavailable = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for ignore_unavailable failed".to_string());
            self
        }

        pub fn lenient<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.lenient = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for lenient failed".to_string());
            self
        }

        pub fn q<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.q = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for q failed".to_string());
            self
        }

        pub fn rewrite<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.rewrite = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for rewrite failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IndicesValidateQueryBodyParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `IndicesValidateQueryBodyParams` for body failed".to_string()
            });
            self
        }

        ///Sends a `POST` request to `/{index}/_validate/query`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<()>> {
            let Self {
                client,
                index,
                all_shards,
                allow_no_indices,
                analyze_wildcard,
                analyzer,
                default_operator,
                df,
                expand_wildcards,
                explain,
                ignore_unavailable,
                lenient,
                q,
                rewrite,
                body,
            } = self;
            let index = index.map_err(Error::InvalidRequest)?;
            let all_shards = all_shards.map_err(Error::InvalidRequest)?;
            let allow_no_indices = allow_no_indices.map_err(Error::InvalidRequest)?;
            let analyze_wildcard = analyze_wildcard.map_err(Error::InvalidRequest)?;
            let analyzer = analyzer.map_err(Error::InvalidRequest)?;
            let default_operator = default_operator.map_err(Error::InvalidRequest)?;
            let df = df.map_err(Error::InvalidRequest)?;
            let expand_wildcards = expand_wildcards.map_err(Error::InvalidRequest)?;
            let explain = explain.map_err(Error::InvalidRequest)?;
            let ignore_unavailable = ignore_unavailable.map_err(Error::InvalidRequest)?;
            let lenient = lenient.map_err(Error::InvalidRequest)?;
            let q = q.map_err(Error::InvalidRequest)?;
            let rewrite = rewrite.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/{}/_validate/query",
                client.baseurl,
                encode_path(&index.to_string()),
            );
            let mut query = Vec::with_capacity(12usize);
            if let Some(v) = &all_shards {
                query.push(("all_shards", v.to_string()));
            }
            if let Some(v) = &allow_no_indices {
                query.push(("allow_no_indices", v.to_string()));
            }
            if let Some(v) = &analyze_wildcard {
                query.push(("analyze_wildcard", v.to_string()));
            }
            if let Some(v) = &analyzer {
                query.push(("analyzer", v.to_string()));
            }
            if let Some(v) = &default_operator {
                query.push(("default_operator", v.to_string()));
            }
            if let Some(v) = &df {
                query.push(("df", v.to_string()));
            }
            if let Some(v) = &expand_wildcards {
                query.push(("expand_wildcards", v.to_string()));
            }
            if let Some(v) = &explain {
                query.push(("explain", v.to_string()));
            }
            if let Some(v) = &ignore_unavailable {
                query.push(("ignore_unavailable", v.to_string()));
            }
            if let Some(v) = &lenient {
                query.push(("lenient", v.to_string()));
            }
            if let Some(v) = &q {
                query.push(("q", v.to_string()));
            }
            if let Some(v) = &rewrite {
                query.push(("rewrite", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => Ok(ResponseValue::empty(response)),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
}

pub mod prelude {
    pub use self::super::Client;
}
